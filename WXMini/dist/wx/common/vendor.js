global.webpackJsonpMpvue([0],[
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// fix env
try {
  if (!global) global = {};
  global.process = global.process || {};
  global.process.env = global.process.env || {};
  global.App = global.App || App;
  global.Page = global.Page || Page;
  global.Component = global.Component || Component;
  global.getApp = global.getApp || getApp;

  if (typeof wx !== 'undefined') {
    global.mpvue = wx;
    global.mpvuePlatform = 'wx';
  } else if (typeof swan !== 'undefined') {
    global.mpvue = swan;
    global.mpvuePlatform = 'swan';
  }else if (typeof tt !== 'undefined') {
    global.mpvue = tt;
    global.mpvuePlatform = 'tt';
  }else if (typeof my !== 'undefined') {
    global.mpvue = my;
    global.mpvuePlatform = 'my';
  }
} catch (e) {}

(function (global, factory) {
	 true ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global.Vue = factory());
}(this, (function () { 'use strict';

/*  */

// these helpers produces better vm code in JS engines due to their
// explicitness and function inlining
function isUndef (v) {
  return v === undefined || v === null
}

function isDef (v) {
  return v !== undefined && v !== null
}

function isTrue (v) {
  return v === true
}

function isFalse (v) {
  return v === false
}

/**
 * Check if value is primitive
 */
function isPrimitive (value) {
  return typeof value === 'string' || typeof value === 'number'
}

/**
 * Quick object check - this is primarily used to tell
 * Objects from primitive values when we know the value
 * is a JSON-compliant type.
 */
function isObject (obj) {
  return obj !== null && typeof obj === 'object'
}

var _toString = Object.prototype.toString;

/**
 * Strict object type check. Only returns true
 * for plain JavaScript objects.
 */
function isPlainObject (obj) {
  return _toString.call(obj) === '[object Object]'
}

function isRegExp (v) {
  return _toString.call(v) === '[object RegExp]'
}

/**
 * Check if val is a valid array index.
 */
function isValidArrayIndex (val) {
  var n = parseFloat(val);
  return n >= 0 && Math.floor(n) === n && isFinite(val)
}

/**
 * Convert a value to a string that is actually rendered.
 */
function toString (val) {
  return val == null
    ? ''
    : typeof val === 'object'
      ? JSON.stringify(val, null, 2)
      : String(val)
}

/**
 * Convert a input value to a number for persistence.
 * If the conversion fails, return original string.
 */
function toNumber (val) {
  var n = parseFloat(val);
  return isNaN(n) ? val : n
}

/**
 * Make a map and return a function for checking if a key
 * is in that map.
 */
function makeMap (
  str,
  expectsLowerCase
) {
  var map = Object.create(null);
  var list = str.split(',');
  for (var i = 0; i < list.length; i++) {
    map[list[i]] = true;
  }
  return expectsLowerCase
    ? function (val) { return map[val.toLowerCase()]; }
    : function (val) { return map[val]; }
}

/**
 * Check if a tag is a built-in tag.
 */
var isBuiltInTag = makeMap('slot,component', true);

/**
 * Check if a attribute is a reserved attribute.
 */
var isReservedAttribute = makeMap('key,ref,slot,is');

/**
 * Remove an item from an array
 */
function remove (arr, item) {
  if (arr.length) {
    var index = arr.indexOf(item);
    if (index > -1) {
      return arr.splice(index, 1)
    }
  }
}

/**
 * Check whether the object has the property.
 */
var hasOwnProperty = Object.prototype.hasOwnProperty;
function hasOwn (obj, key) {
  return hasOwnProperty.call(obj, key)
}

/**
 * Create a cached version of a pure function.
 */
function cached (fn) {
  var cache = Object.create(null);
  return (function cachedFn (str) {
    var hit = cache[str];
    return hit || (cache[str] = fn(str))
  })
}

/**
 * Camelize a hyphen-delimited string.
 */
var camelizeRE = /-(\w)/g;
var camelize = cached(function (str) {
  return str.replace(camelizeRE, function (_, c) { return c ? c.toUpperCase() : ''; })
});

/**
 * Capitalize a string.
 */
var capitalize = cached(function (str) {
  return str.charAt(0).toUpperCase() + str.slice(1)
});

/**
 * Hyphenate a camelCase string.
 */
var hyphenateRE = /([^-])([A-Z])/g;
var hyphenate = cached(function (str) {
  return str
    .replace(hyphenateRE, '$1-$2')
    .replace(hyphenateRE, '$1-$2')
    .toLowerCase()
});

/**
 * Simple bind, faster than native
 */
function bind (fn, ctx) {
  function boundFn (a) {
    var l = arguments.length;
    return l
      ? l > 1
        ? fn.apply(ctx, arguments)
        : fn.call(ctx, a)
      : fn.call(ctx)
  }
  // record original fn length
  boundFn._length = fn.length;
  return boundFn
}

/**
 * Convert an Array-like object to a real Array.
 */
function toArray (list, start) {
  start = start || 0;
  var i = list.length - start;
  var ret = new Array(i);
  while (i--) {
    ret[i] = list[i + start];
  }
  return ret
}

/**
 * Mix properties into target object.
 */
function extend (to, _from) {
  for (var key in _from) {
    to[key] = _from[key];
  }
  return to
}

/**
 * Merge an Array of Objects into a single Object.
 */
function toObject (arr) {
  var res = {};
  for (var i = 0; i < arr.length; i++) {
    if (arr[i]) {
      extend(res, arr[i]);
    }
  }
  return res
}

/**
 * Perform no operation.
 * Stubbing args to make Flow happy without leaving useless transpiled code
 * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/)
 */
function noop (a, b, c) {}

/**
 * Always return false.
 */
var no = function (a, b, c) { return false; };

/**
 * Return same value
 */
var identity = function (_) { return _; };

/**
 * Generate a static keys string from compiler modules.
 */


/**
 * Check if two values are loosely equal - that is,
 * if they are plain objects, do they have the same shape?
 */
function looseEqual (a, b) {
  var isObjectA = isObject(a);
  var isObjectB = isObject(b);
  if (isObjectA && isObjectB) {
    try {
      return JSON.stringify(a) === JSON.stringify(b)
    } catch (e) {
      // possible circular reference
      return a === b
    }
  } else if (!isObjectA && !isObjectB) {
    return String(a) === String(b)
  } else {
    return false
  }
}

function looseIndexOf (arr, val) {
  for (var i = 0; i < arr.length; i++) {
    if (looseEqual(arr[i], val)) { return i }
  }
  return -1
}

/**
 * Ensure a function is called only once.
 */
function once (fn) {
  var called = false;
  return function () {
    if (!called) {
      called = true;
      fn.apply(this, arguments);
    }
  }
}

var SSR_ATTR = 'data-server-rendered';

var ASSET_TYPES = [
  'component',
  'directive',
  'filter'
];

var LIFECYCLE_HOOKS = [
  'beforeCreate',
  'created',
  'beforeMount',
  'mounted',
  'beforeUpdate',
  'updated',
  'beforeDestroy',
  'destroyed',
  'activated',
  'deactivated', 'onLaunch',
  'onLoad',
  'onShow',
  'onReady',
  'onHide',
  'onUnload',
  'onPullDownRefresh',
  'onReachBottom',
  'onShareAppMessage',
  'onPageScroll',
  'onTabItemTap',
  'attached',
  'ready',
  'moved',
  'detached'
];

/*  */

var config = ({
  /**
   * Option merge strategies (used in core/util/options)
   */
  optionMergeStrategies: Object.create(null),

  /**
   * Whether to suppress warnings.
   */
  silent: false,

  /**
   * Show production mode tip message on boot?
   */
  productionTip: "production" !== 'production',

  /**
   * Whether to enable devtools
   */
  devtools: "production" !== 'production',

  /**
   * Whether to record perf
   */
  performance: false,

  /**
   * Error handler for watcher errors
   */
  errorHandler: null,

  /**
   * Warn handler for watcher warns
   */
  warnHandler: null,

  /**
   * Ignore certain custom elements
   */
  ignoredElements: [],

  /**
   * Custom user key aliases for v-on
   */
  keyCodes: Object.create(null),

  /**
   * Check if a tag is reserved so that it cannot be registered as a
   * component. This is platform-dependent and may be overwritten.
   */
  isReservedTag: no,

  /**
   * Check if an attribute is reserved so that it cannot be used as a component
   * prop. This is platform-dependent and may be overwritten.
   */
  isReservedAttr: no,

  /**
   * Check if a tag is an unknown element.
   * Platform-dependent.
   */
  isUnknownElement: no,

  /**
   * Get the namespace of an element
   */
  getTagNamespace: noop,

  /**
   * Parse the real tag name for the specific platform.
   */
  parsePlatformTagName: identity,

  /**
   * Check if an attribute must be bound using property, e.g. value
   * Platform-dependent.
   */
  mustUseProp: no,

  /**
   * Exposed for legacy reasons
   */
  _lifecycleHooks: LIFECYCLE_HOOKS
});

/*  */

var emptyObject = Object.freeze({});

/**
 * Check if a string starts with $ or _
 */
function isReserved (str) {
  var c = (str + '').charCodeAt(0);
  return c === 0x24 || c === 0x5F
}

/**
 * Define a property.
 */
function def (obj, key, val, enumerable) {
  Object.defineProperty(obj, key, {
    value: val,
    enumerable: !!enumerable,
    writable: true,
    configurable: true
  });
}

/**
 * Parse simple path.
 */
var bailRE = /[^\w.$]/;
function parsePath (path) {
  if (bailRE.test(path)) {
    return
  }
  var segments = path.split('.');
  return function (obj) {
    for (var i = 0; i < segments.length; i++) {
      if (!obj) { return }
      obj = obj[segments[i]];
    }
    return obj
  }
}

/*  */

var warn = noop;

var formatComponentName = (null); // work around flow check

/*  */

function handleError (err, vm, info) {
  if (config.errorHandler) {
    config.errorHandler.call(null, err, vm, info);
  } else {
    if (inBrowser && typeof console !== 'undefined') {
      console.error(err);
    } else {
      throw err
    }
  }
}

/*  */

// can we use __proto__?
var hasProto = '__proto__' in {};

// Browser environment sniffing
var inBrowser = typeof window !== 'undefined';
var UA = ['mpvue-runtime'].join();
var isIE = UA && /msie|trident/.test(UA);
var isIE9 = UA && UA.indexOf('msie 9.0') > 0;
var isEdge = UA && UA.indexOf('edge/') > 0;
var isAndroid = UA && UA.indexOf('android') > 0;
var isIOS = UA && /iphone|ipad|ipod|ios/.test(UA);
var isChrome = UA && /chrome\/\d+/.test(UA) && !isEdge;

// Firefix has a "watch" function on Object.prototype...
var nativeWatch = ({}).watch;

var supportsPassive = false;
if (inBrowser) {
  try {
    var opts = {};
    Object.defineProperty(opts, 'passive', ({
      get: function get () {
        /* istanbul ignore next */
        supportsPassive = true;
      }
    })); // https://github.com/facebook/flow/issues/285
    window.addEventListener('test-passive', null, opts);
  } catch (e) {}
}

// this needs to be lazy-evaled because vue may be required before
// vue-server-renderer can set VUE_ENV
var _isServer;
var isServerRendering = function () {
  if (_isServer === undefined) {
    /* istanbul ignore if */
    if (!inBrowser && typeof global !== 'undefined') {
      // detect presence of vue-server-renderer and avoid
      // Webpack shimming the process
      _isServer = global['process'].env.VUE_ENV === 'server';
    } else {
      _isServer = false;
    }
  }
  return _isServer
};

// detect devtools
var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;

/* istanbul ignore next */
function isNative (Ctor) {
  return typeof Ctor === 'function' && /native code/.test(Ctor.toString())
}

var hasSymbol =
  typeof Symbol !== 'undefined' && isNative(Symbol) &&
  typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);

/**
 * Defer a task to execute it asynchronously.
 */
var nextTick = (function () {
  var callbacks = [];
  var pending = false;
  var timerFunc;

  function nextTickHandler () {
    pending = false;
    var copies = callbacks.slice(0);
    callbacks.length = 0;
    for (var i = 0; i < copies.length; i++) {
      copies[i]();
    }
  }

  // the nextTick behavior leverages the microtask queue, which can be accessed
  // via either native Promise.then or MutationObserver.
  // MutationObserver has wider support, however it is seriously bugged in
  // UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It
  // completely stops working after triggering a few times... so, if native
  // Promise is available, we will use it:
  /* istanbul ignore if */
  if (typeof Promise !== 'undefined' && isNative(Promise)) {
    var p = Promise.resolve();
    var logError = function (err) { console.error(err); };
    timerFunc = function () {
      p.then(nextTickHandler).catch(logError);
      // in problematic UIWebViews, Promise.then doesn't completely break, but
      // it can get stuck in a weird state where callbacks are pushed into the
      // microtask queue but the queue isn't being flushed, until the browser
      // needs to do some other work, e.g. handle a timer. Therefore we can
      // "force" the microtask queue to be flushed by adding an empty timer.
      if (isIOS) { setTimeout(noop); }
    };
  // } else if (typeof MutationObserver !== 'undefined' && (
  //   isNative(MutationObserver) ||
  //   // PhantomJS and iOS 7.x
  //   MutationObserver.toString() === '[object MutationObserverConstructor]'
  // )) {
  //   // use MutationObserver where native Promise is not available,
  //   // e.g. PhantomJS IE11, iOS7, Android 4.4
  //   var counter = 1
  //   var observer = new MutationObserver(nextTickHandler)
  //   var textNode = document.createTextNode(String(counter))
  //   observer.observe(textNode, {
  //     characterData: true
  //   })
  //   timerFunc = () => {
  //     counter = (counter + 1) % 2
  //     textNode.data = String(counter)
  //   }
  } else {
    // fallback to setTimeout
    /* istanbul ignore next */
    timerFunc = function () {
      setTimeout(nextTickHandler, 0);
    };
  }

  return function queueNextTick (cb, ctx) {
    var _resolve;
    callbacks.push(function () {
      if (cb) {
        try {
          cb.call(ctx);
        } catch (e) {
          handleError(e, ctx, 'nextTick');
        }
      } else if (_resolve) {
        _resolve(ctx);
      }
    });
    if (!pending) {
      pending = true;
      timerFunc();
    }
    if (!cb && typeof Promise !== 'undefined') {
      return new Promise(function (resolve, reject) {
        _resolve = resolve;
      })
    }
  }
})();

var _Set;
/* istanbul ignore if */
if (typeof Set !== 'undefined' && isNative(Set)) {
  // use native Set when available.
  _Set = Set;
} else {
  // a non-standard Set polyfill that only works with primitive keys.
  _Set = (function () {
    function Set () {
      this.set = Object.create(null);
    }
    Set.prototype.has = function has (key) {
      return this.set[key] === true
    };
    Set.prototype.add = function add (key) {
      this.set[key] = true;
    };
    Set.prototype.clear = function clear () {
      this.set = Object.create(null);
    };

    return Set;
  }());
}

/*  */


var uid$1 = 0;

/**
 * A dep is an observable that can have multiple
 * directives subscribing to it.
 */
var Dep = function Dep () {
  this.id = uid$1++;
  this.subs = [];
};

Dep.prototype.addSub = function addSub (sub) {
  this.subs.push(sub);
};

Dep.prototype.removeSub = function removeSub (sub) {
  remove(this.subs, sub);
};

Dep.prototype.depend = function depend () {
  if (Dep.target) {
    Dep.target.addDep(this);
  }
};

Dep.prototype.notify = function notify () {
  // stabilize the subscriber list first
  var subs = this.subs.slice();
  for (var i = 0, l = subs.length; i < l; i++) {
    subs[i].update();
  }
};

// the current target watcher being evaluated.
// this is globally unique because there could be only one
// watcher being evaluated at any time.
Dep.target = null;
var targetStack = [];

function pushTarget (_target) {
  if (Dep.target) { targetStack.push(Dep.target); }
  Dep.target = _target;
}

function popTarget () {
  Dep.target = targetStack.pop();
}

/*
 * not type checking this file because flow doesn't play well with
 * dynamically accessing methods on Array prototype
 */

var arrayProto = Array.prototype;
var arrayMethods = Object.create(arrayProto);[
  'push',
  'pop',
  'shift',
  'unshift',
  'splice',
  'sort',
  'reverse'
]
.forEach(function (method) {
  // cache original method
  var original = arrayProto[method];
  def(arrayMethods, method, function mutator () {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

    var result = original.apply(this, args);
    var ob = this.__ob__;
    var inserted;
    switch (method) {
      case 'push':
      case 'unshift':
        inserted = args;
        break
      case 'splice':
        inserted = args.slice(2);
        break
    }
    if (inserted) { ob.observeArray(inserted); }
    // notify change
    ob.dep.notify();
    return result
  });
});

/*  */

var arrayKeys = Object.getOwnPropertyNames(arrayMethods);

/**
 * By default, when a reactive property is set, the new value is
 * also converted to become reactive. However when passing down props,
 * we don't want to force conversion because the value may be a nested value
 * under a frozen data structure. Converting it would defeat the optimization.
 */
var observerState = {
  shouldConvert: true
};

/**
 * Observer class that are attached to each observed
 * object. Once attached, the observer converts target
 * object's property keys into getter/setters that
 * collect dependencies and dispatches updates.
 */
var Observer = function Observer (value, key) {
  this.value = value;
  this.dep = new Dep();
  this.vmCount = 0;
  if (key) {
    this.key = key;
  }
  def(value, '__ob__', this);
  if (Array.isArray(value)) {
    var augment = hasProto
      ? protoAugment
      : copyAugment;
    augment(value, arrayMethods, arrayKeys);
    this.observeArray(value);
  } else {
    this.walk(value);
  }
};

/**
 * Walk through each property and convert them into
 * getter/setters. This method should only be called when
 * value type is Object.
 */
Observer.prototype.walk = function walk (obj) {
  var keys = Object.keys(obj);
  for (var i = 0; i < keys.length; i++) {
    defineReactive$$1(obj, keys[i], obj[keys[i]]);
  }
};

/**
 * Observe a list of Array items.
 */
Observer.prototype.observeArray = function observeArray (items) {
  for (var i = 0, l = items.length; i < l; i++) {
    observe(items[i]);
  }
};

// helpers

/**
 * Augment an target Object or Array by intercepting
 * the prototype chain using __proto__
 */
function protoAugment (target, src, keys) {
  /* eslint-disable no-proto */
  target.__proto__ = src;
  /* eslint-enable no-proto */
}

/**
 * Augment an target Object or Array by defining
 * hidden properties.
 */
/* istanbul ignore next */
function copyAugment (target, src, keys) {
  for (var i = 0, l = keys.length; i < l; i++) {
    var key = keys[i];
    def(target, key, src[key]);
  }
}

/**
 * Attempt to create an observer instance for a value,
 * returns the new observer if successfully observed,
 * or the existing observer if the value already has one.
 */
function observe (value, asRootData, key) {
  if (!isObject(value)) {
    return
  }
  var ob;
  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
    ob = value.__ob__;
  } else if (
    observerState.shouldConvert &&
    !isServerRendering() &&
    (Array.isArray(value) || isPlainObject(value)) &&
    Object.isExtensible(value) &&
    !value._isVue
  ) {
    ob = new Observer(value, key);
  }
  if (asRootData && ob) {
    ob.vmCount++;
  }
  return ob
}

/**
 * Define a reactive property on an Object.
 */
function defineReactive$$1 (
  obj,
  key,
  val,
  customSetter,
  shallow
) {
  var dep = new Dep();

  var property = Object.getOwnPropertyDescriptor(obj, key);
  if (property && property.configurable === false) {
    return
  }

  // cater for pre-defined getter/setters
  var getter = property && property.get;
  var setter = property && property.set;

  var childOb = !shallow && observe(val, undefined, key);
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter () {
      var value = getter ? getter.call(obj) : val;
      if (Dep.target) {
        dep.depend();
        if (childOb) {
          childOb.dep.depend();
        }
        if (Array.isArray(value)) {
          dependArray(value);
        }
      }
      return value
    },
    set: function reactiveSetter (newVal) {
      var value = getter ? getter.call(obj) : val;
      /* eslint-disable no-self-compare */
      if (newVal === value || (newVal !== newVal && value !== value)) {
        return
      }

      /* eslint-enable no-self-compare */
      if (false) {
        customSetter();
      }
      if (setter) {
        setter.call(obj, newVal);
      } else {
        val = newVal;
      }
      childOb = !shallow && observe(newVal, undefined, key);
      dep.notify();

      if (!obj.__keyPath) {
        def(obj, '__keyPath', {}, false);
      }
      obj.__keyPath[key] = true;
      if (newVal instanceof Object && !(newVal instanceof Array)) {
        // 标记是否是通过this.Obj = {} 赋值印发的改动，解决少更新问题#1305
        def(newVal, '__newReference', true, false);
      }
    }
  });
}

/**
 * Set a property on an object. Adds the new property and
 * triggers change notification if the property doesn't
 * already exist.
 */
function set (target, key, val) {
  if (Array.isArray(target) && isValidArrayIndex(key)) {
    target.length = Math.max(target.length, key);
    target.splice(key, 1, val);
    return val
  }
  if (hasOwn(target, key)) {
    target[key] = val;
    return val
  }
  var ob = (target).__ob__;
  if (target._isVue || (ob && ob.vmCount)) {
    "production" !== 'production' && warn(
      'Avoid adding reactive properties to a Vue instance or its root $data ' +
      'at runtime - declare it upfront in the data option.'
    );
    return val
  }
  if (!ob) {
    target[key] = val;
    return val
  }
  defineReactive$$1(ob.value, key, val);
  // Vue.set 添加对象属性，渲染时候把 val 传给小程序渲染
  if (!target.__keyPath) {
    def(target, '__keyPath', {}, false);
  }
  target.__keyPath[key] = true;
  ob.dep.notify();
  return val
}

/**
 * Delete a property and trigger change if necessary.
 */
function del (target, key) {
  if (Array.isArray(target) && isValidArrayIndex(key)) {
    target.splice(key, 1);
    return
  }
  var ob = (target).__ob__;
  if (target._isVue || (ob && ob.vmCount)) {
    "production" !== 'production' && warn(
      'Avoid deleting properties on a Vue instance or its root $data ' +
      '- just set it to null.'
    );
    return
  }
  if (!hasOwn(target, key)) {
    return
  }
  delete target[key];
  if (!ob) {
    return
  }
  if (!target.__keyPath) {
    def(target, '__keyPath', {}, false);
  }
  // Vue.del 删除对象属性，渲染时候把这个属性设置为 undefined
  target.__keyPath[key] = 'del';
  ob.dep.notify();
}

/**
 * Collect dependencies on array elements when the array is touched, since
 * we cannot intercept array element access like property getters.
 */
function dependArray (value) {
  for (var e = (void 0), i = 0, l = value.length; i < l; i++) {
    e = value[i];
    e && e.__ob__ && e.__ob__.dep.depend();
    if (Array.isArray(e)) {
      dependArray(e);
    }
  }
}

/*  */

/**
 * Option overwriting strategies are functions that handle
 * how to merge a parent option value and a child option
 * value into the final value.
 */
var strats = config.optionMergeStrategies;

/**
 * Options with restrictions
 */
/**
 * Helper that recursively merges two data objects together.
 */
function mergeData (to, from) {
  if (!from) { return to }
  var key, toVal, fromVal;
  var keys = Object.keys(from);
  for (var i = 0; i < keys.length; i++) {
    key = keys[i];
    toVal = to[key];
    fromVal = from[key];
    if (!hasOwn(to, key)) {
      set(to, key, fromVal);
    } else if (isPlainObject(toVal) && isPlainObject(fromVal)) {
      mergeData(toVal, fromVal);
    }
  }
  return to
}

/**
 * Data
 */
function mergeDataOrFn (
  parentVal,
  childVal,
  vm
) {
  if (!vm) {
    // in a Vue.extend merge, both should be functions
    if (!childVal) {
      return parentVal
    }
    if (!parentVal) {
      return childVal
    }
    // when parentVal & childVal are both present,
    // we need to return a function that returns the
    // merged result of both functions... no need to
    // check if parentVal is a function here because
    // it has to be a function to pass previous merges.
    return function mergedDataFn () {
      return mergeData(
        typeof childVal === 'function' ? childVal.call(this) : childVal,
        parentVal.call(this)
      )
    }
  } else if (parentVal || childVal) {
    return function mergedInstanceDataFn () {
      // instance merge
      var instanceData = typeof childVal === 'function'
        ? childVal.call(vm)
        : childVal;
      var defaultData = typeof parentVal === 'function'
        ? parentVal.call(vm)
        : undefined;
      if (instanceData) {
        return mergeData(instanceData, defaultData)
      } else {
        return defaultData
      }
    }
  }
}

strats.data = function (
  parentVal,
  childVal,
  vm
) {
  if (!vm) {
    if (childVal && typeof childVal !== 'function') {
      "production" !== 'production' && warn(
        'The "data" option should be a function ' +
        'that returns a per-instance value in component ' +
        'definitions.',
        vm
      );

      return parentVal
    }
    return mergeDataOrFn.call(this, parentVal, childVal)
  }

  return mergeDataOrFn(parentVal, childVal, vm)
};

/**
 * Hooks and props are merged as arrays.
 */
function mergeHook (
  parentVal,
  childVal
) {
  return childVal
    ? parentVal
      ? parentVal.concat(childVal)
      : Array.isArray(childVal)
        ? childVal
        : [childVal]
    : parentVal
}

LIFECYCLE_HOOKS.forEach(function (hook) {
  strats[hook] = mergeHook;
});

/**
 * Assets
 *
 * When a vm is present (instance creation), we need to do
 * a three-way merge between constructor options, instance
 * options and parent options.
 */
function mergeAssets (parentVal, childVal) {
  var res = Object.create(parentVal || null);
  return childVal
    ? extend(res, childVal)
    : res
}

ASSET_TYPES.forEach(function (type) {
  strats[type + 's'] = mergeAssets;
});

/**
 * Watchers.
 *
 * Watchers hashes should not overwrite one
 * another, so we merge them as arrays.
 */
strats.watch = function (parentVal, childVal) {
  // work around Firefox's Object.prototype.watch...
  if (parentVal === nativeWatch) { parentVal = undefined; }
  if (childVal === nativeWatch) { childVal = undefined; }
  /* istanbul ignore if */
  if (!childVal) { return Object.create(parentVal || null) }
  if (!parentVal) { return childVal }
  var ret = {};
  extend(ret, parentVal);
  for (var key in childVal) {
    var parent = ret[key];
    var child = childVal[key];
    if (parent && !Array.isArray(parent)) {
      parent = [parent];
    }
    ret[key] = parent
      ? parent.concat(child)
      : Array.isArray(child) ? child : [child];
  }
  return ret
};

/**
 * Other object hashes.
 */
strats.props =
strats.methods =
strats.inject =
strats.computed = function (parentVal, childVal) {
  if (!childVal) { return Object.create(parentVal || null) }
  if (!parentVal) { return childVal }
  var ret = Object.create(null);
  extend(ret, parentVal);
  extend(ret, childVal);
  return ret
};
strats.provide = mergeDataOrFn;

/**
 * Default strategy.
 */
var defaultStrat = function (parentVal, childVal) {
  return childVal === undefined
    ? parentVal
    : childVal
};

/**
 * Ensure all props option syntax are normalized into the
 * Object-based format.
 */
function normalizeProps (options) {
  var props = options.props;
  if (!props) { return }
  var res = {};
  var i, val, name;
  if (Array.isArray(props)) {
    i = props.length;
    while (i--) {
      val = props[i];
      if (typeof val === 'string') {
        name = camelize(val);
        res[name] = { type: null };
      } else {}
    }
  } else if (isPlainObject(props)) {
    for (var key in props) {
      val = props[key];
      name = camelize(key);
      res[name] = isPlainObject(val)
        ? val
        : { type: val };
    }
  }
  options.props = res;
}

/**
 * Normalize all injections into Object-based format
 */
function normalizeInject (options) {
  var inject = options.inject;
  if (Array.isArray(inject)) {
    var normalized = options.inject = {};
    for (var i = 0; i < inject.length; i++) {
      normalized[inject[i]] = inject[i];
    }
  }
}

/**
 * Normalize raw function directives into object format.
 */
function normalizeDirectives (options) {
  var dirs = options.directives;
  if (dirs) {
    for (var key in dirs) {
      var def = dirs[key];
      if (typeof def === 'function') {
        dirs[key] = { bind: def, update: def };
      }
    }
  }
}

/**
 * Merge two option objects into a new one.
 * Core utility used in both instantiation and inheritance.
 */
function mergeOptions (
  parent,
  child,
  vm
) {
  if (typeof child === 'function') {
    child = child.options;
  }

  normalizeProps(child);
  normalizeInject(child);
  normalizeDirectives(child);
  var extendsFrom = child.extends;
  if (extendsFrom) {
    parent = mergeOptions(parent, extendsFrom, vm);
  }
  if (child.mixins) {
    for (var i = 0, l = child.mixins.length; i < l; i++) {
      parent = mergeOptions(parent, child.mixins[i], vm);
    }
  }
  var options = {};
  var key;
  for (key in parent) {
    mergeField(key);
  }
  for (key in child) {
    if (!hasOwn(parent, key)) {
      mergeField(key);
    }
  }
  function mergeField (key) {
    var strat = strats[key] || defaultStrat;
    options[key] = strat(parent[key], child[key], vm, key);
  }
  return options
}

/**
 * Resolve an asset.
 * This function is used because child instances need access
 * to assets defined in its ancestor chain.
 */
function resolveAsset (
  options,
  type,
  id,
  warnMissing
) {
  /* istanbul ignore if */
  if (typeof id !== 'string') {
    return
  }
  var assets = options[type];
  // check local registration variations first
  if (hasOwn(assets, id)) { return assets[id] }
  var camelizedId = camelize(id);
  if (hasOwn(assets, camelizedId)) { return assets[camelizedId] }
  var PascalCaseId = capitalize(camelizedId);
  if (hasOwn(assets, PascalCaseId)) { return assets[PascalCaseId] }
  // fallback to prototype chain
  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];
  if (false) {
    warn(
      'Failed to resolve ' + type.slice(0, -1) + ': ' + id,
      options
    );
  }
  return res
}

/*  */

function validateProp (
  key,
  propOptions,
  propsData,
  vm
) {
  var prop = propOptions[key];
  var absent = !hasOwn(propsData, key);
  var value = propsData[key];
  // handle boolean props
  if (isType(Boolean, prop.type)) {
    if (absent && !hasOwn(prop, 'default')) {
      value = false;
    } else if (!isType(String, prop.type) && (value === '' || value === hyphenate(key))) {
      value = true;
    }
  }
  // check default value
  if (value === undefined) {
    value = getPropDefaultValue(vm, prop, key);
    // since the default value is a fresh copy,
    // make sure to observe it.
    var prevShouldConvert = observerState.shouldConvert;
    observerState.shouldConvert = true;
    observe(value);
    observerState.shouldConvert = prevShouldConvert;
  }
  return value
}

/**
 * Get the default value of a prop.
 */
function getPropDefaultValue (vm, prop, key) {
  // no default, return undefined
  if (!hasOwn(prop, 'default')) {
    return undefined
  }
  var def = prop.default;
  // warn against non-factory defaults for Object & Array
  if (false) {
    warn(
      'Invalid default value for prop "' + key + '": ' +
      'Props with type Object/Array must use a factory function ' +
      'to return the default value.',
      vm
    );
  }
  // the raw prop value was also undefined from previous render,
  // return previous default value to avoid unnecessary watcher trigger
  if (vm && vm.$options.propsData &&
    vm.$options.propsData[key] === undefined &&
    vm._props[key] !== undefined
  ) {
    return vm._props[key]
  }
  // call factory function for non-Function types
  // a value is Function if its prototype is function even across different execution context
  return typeof def === 'function' && getType(prop.type) !== 'Function'
    ? def.call(vm)
    : def
}

/**
 * Use function string name to check built-in types,
 * because a simple equality check will fail when running
 * across different vms / iframes.
 */
function getType (fn) {
  var match = fn && fn.toString().match(/^\s*function (\w+)/);
  return match ? match[1] : ''
}

function isType (type, fn) {
  if (!Array.isArray(fn)) {
    return getType(fn) === getType(type)
  }
  for (var i = 0, len = fn.length; i < len; i++) {
    if (getType(fn[i]) === getType(type)) {
      return true
    }
  }
  /* istanbul ignore next */
  return false
}

/*  */

/* not type checking this file because flow doesn't play well with Proxy */

var mark;
var measure;

/*  */

var VNode = function VNode (
  tag,
  data,
  children,
  text,
  elm,
  context,
  componentOptions,
  asyncFactory
) {
  this.tag = tag;
  this.data = data;
  this.children = children;
  this.text = text;
  this.elm = elm;
  this.ns = undefined;
  this.context = context;
  this.functionalContext = undefined;
  this.key = data && data.key;
  this.componentOptions = componentOptions;
  this.componentInstance = undefined;
  this.parent = undefined;
  this.raw = false;
  this.isStatic = false;
  this.isRootInsert = true;
  this.isComment = false;
  this.isCloned = false;
  this.isOnce = false;
  this.asyncFactory = asyncFactory;
  this.asyncMeta = undefined;
  this.isAsyncPlaceholder = false;
};

var prototypeAccessors = { child: {} };

// DEPRECATED: alias for componentInstance for backwards compat.
/* istanbul ignore next */
prototypeAccessors.child.get = function () {
  return this.componentInstance
};

Object.defineProperties( VNode.prototype, prototypeAccessors );

var createEmptyVNode = function (text) {
  if ( text === void 0 ) text = '';

  var node = new VNode();
  node.text = text;
  node.isComment = true;
  return node
};

function createTextVNode (val) {
  return new VNode(undefined, undefined, undefined, String(val))
}

// optimized shallow clone
// used for static nodes and slot nodes because they may be reused across
// multiple renders, cloning them avoids errors when DOM manipulations rely
// on their elm reference.
function cloneVNode (vnode) {
  var cloned = new VNode(
    vnode.tag,
    vnode.data,
    vnode.children,
    vnode.text,
    vnode.elm,
    vnode.context,
    vnode.componentOptions,
    vnode.asyncFactory
  );
  cloned.ns = vnode.ns;
  cloned.isStatic = vnode.isStatic;
  cloned.key = vnode.key;
  cloned.isComment = vnode.isComment;
  cloned.isCloned = true;
  return cloned
}

function cloneVNodes (vnodes) {
  var len = vnodes.length;
  var res = new Array(len);
  for (var i = 0; i < len; i++) {
    res[i] = cloneVNode(vnodes[i]);
  }
  return res
}

/*  */

var normalizeEvent = cached(function (name) {
  var passive = name.charAt(0) === '&';
  name = passive ? name.slice(1) : name;
  var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first
  name = once$$1 ? name.slice(1) : name;
  var capture = name.charAt(0) === '!';
  name = capture ? name.slice(1) : name;
  return {
    name: name,
    once: once$$1,
    capture: capture,
    passive: passive
  }
});

function createFnInvoker (fns) {
  function invoker () {
    var arguments$1 = arguments;

    var fns = invoker.fns;
    if (Array.isArray(fns)) {
      var cloned = fns.slice();
      for (var i = 0; i < cloned.length; i++) {
        cloned[i].apply(null, arguments$1);
      }
    } else {
      // return handler return value for single handlers
      return fns.apply(null, arguments)
    }
  }
  invoker.fns = fns;
  return invoker
}

function updateListeners (
  on,
  oldOn,
  add,
  remove$$1,
  vm
) {
  var name, cur, old, event;
  for (name in on) {
    cur = on[name];
    old = oldOn[name];
    event = normalizeEvent(name);
    if (isUndef(cur)) {
      "production" !== 'production' && warn(
        "Invalid handler for event \"" + (event.name) + "\": got " + String(cur),
        vm
      );
    } else if (isUndef(old)) {
      if (isUndef(cur.fns)) {
        cur = on[name] = createFnInvoker(cur);
      }
      add(event.name, cur, event.once, event.capture, event.passive);
    } else if (cur !== old) {
      old.fns = cur;
      on[name] = old;
    }
  }
  for (name in oldOn) {
    if (isUndef(on[name])) {
      event = normalizeEvent(name);
      remove$$1(event.name, oldOn[name], event.capture);
    }
  }
}

/*  */

/*  */

function extractPropsFromVNodeData (
  data,
  Ctor,
  tag
) {
  // we are only extracting raw values here.
  // validation and default values are handled in the child
  // component itself.
  var propOptions = Ctor.options.props;
  if (isUndef(propOptions)) {
    return
  }
  var res = {};
  var attrs = data.attrs;
  var props = data.props;
  if (isDef(attrs) || isDef(props)) {
    for (var key in propOptions) {
      var altKey = hyphenate(key);
      checkProp(res, props, key, altKey, true) ||
      checkProp(res, attrs, key, altKey, false);
    }
  }
  return res
}

function checkProp (
  res,
  hash,
  key,
  altKey,
  preserve
) {
  if (isDef(hash)) {
    if (hasOwn(hash, key)) {
      res[key] = hash[key];
      if (!preserve) {
        delete hash[key];
      }
      return true
    } else if (hasOwn(hash, altKey)) {
      res[key] = hash[altKey];
      if (!preserve) {
        delete hash[altKey];
      }
      return true
    }
  }
  return false
}

/*  */

// The template compiler attempts to minimize the need for normalization by
// statically analyzing the template at compile time.
//
// For plain HTML markup, normalization can be completely skipped because the
// generated render function is guaranteed to return Array<VNode>. There are
// two cases where extra normalization is needed:

// 1. When the children contains components - because a functional component
// may return an Array instead of a single root. In this case, just a simple
// normalization is needed - if any child is an Array, we flatten the whole
// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep
// because functional components already normalize their own children.
function simpleNormalizeChildren (children) {
  for (var i = 0; i < children.length; i++) {
    if (Array.isArray(children[i])) {
      return Array.prototype.concat.apply([], children)
    }
  }
  return children
}

// 2. When the children contains constructs that always generated nested Arrays,
// e.g. <template>, <slot>, v-for, or when the children is provided by user
// with hand-written render functions / JSX. In such cases a full normalization
// is needed to cater to all possible types of children values.
function normalizeChildren (children) {
  return isPrimitive(children)
    ? [createTextVNode(children)]
    : Array.isArray(children)
      ? normalizeArrayChildren(children)
      : undefined
}

function isTextNode (node) {
  return isDef(node) && isDef(node.text) && isFalse(node.isComment)
}

function normalizeArrayChildren (children, nestedIndex) {
  var res = [];
  var i, c, last;
  for (i = 0; i < children.length; i++) {
    c = children[i];
    if (isUndef(c) || typeof c === 'boolean') { continue }
    last = res[res.length - 1];
    //  nested
    if (Array.isArray(c)) {
      res.push.apply(res, normalizeArrayChildren(c, ((nestedIndex || '') + "_" + i)));
    } else if (isPrimitive(c)) {
      if (isTextNode(last)) {
        // merge adjacent text nodes
        // this is necessary for SSR hydration because text nodes are
        // essentially merged when rendered to HTML strings
        (last).text += String(c);
      } else if (c !== '') {
        // convert primitive to vnode
        res.push(createTextVNode(c));
      }
    } else {
      if (isTextNode(c) && isTextNode(last)) {
        // merge adjacent text nodes
        res[res.length - 1] = createTextVNode(last.text + c.text);
      } else {
        // default key for nested array children (likely generated by v-for)
        if (isTrue(children._isVList) &&
          isDef(c.tag) &&
          isUndef(c.key) &&
          isDef(nestedIndex)) {
          c.key = "__vlist" + nestedIndex + "_" + i + "__";
        }
        res.push(c);
      }
    }
  }
  return res
}

/*  */

function ensureCtor (comp, base) {
  if (comp.__esModule && comp.default) {
    comp = comp.default;
  }
  return isObject(comp)
    ? base.extend(comp)
    : comp
}

function createAsyncPlaceholder (
  factory,
  data,
  context,
  children,
  tag
) {
  var node = createEmptyVNode();
  node.asyncFactory = factory;
  node.asyncMeta = { data: data, context: context, children: children, tag: tag };
  return node
}

function resolveAsyncComponent (
  factory,
  baseCtor,
  context
) {
  if (isTrue(factory.error) && isDef(factory.errorComp)) {
    return factory.errorComp
  }

  if (isDef(factory.resolved)) {
    return factory.resolved
  }

  if (isTrue(factory.loading) && isDef(factory.loadingComp)) {
    return factory.loadingComp
  }

  if (isDef(factory.contexts)) {
    // already pending
    factory.contexts.push(context);
  } else {
    var contexts = factory.contexts = [context];
    var sync = true;

    var forceRender = function () {
      for (var i = 0, l = contexts.length; i < l; i++) {
        contexts[i].$forceUpdate();
      }
    };

    var resolve = once(function (res) {
      // cache resolved
      factory.resolved = ensureCtor(res, baseCtor);
      // invoke callbacks only if this is not a synchronous resolve
      // (async resolves are shimmed as synchronous during SSR)
      if (!sync) {
        forceRender();
      }
    });

    var reject = once(function (reason) {
      "production" !== 'production' && warn(
        "Failed to resolve async component: " + (String(factory)) +
        (reason ? ("\nReason: " + reason) : '')
      );
      if (isDef(factory.errorComp)) {
        factory.error = true;
        forceRender();
      }
    });

    var res = factory(resolve, reject);

    if (isObject(res)) {
      if (typeof res.then === 'function') {
        // () => Promise
        if (isUndef(factory.resolved)) {
          res.then(resolve, reject);
        }
      } else if (isDef(res.component) && typeof res.component.then === 'function') {
        res.component.then(resolve, reject);

        if (isDef(res.error)) {
          factory.errorComp = ensureCtor(res.error, baseCtor);
        }

        if (isDef(res.loading)) {
          factory.loadingComp = ensureCtor(res.loading, baseCtor);
          if (res.delay === 0) {
            factory.loading = true;
          } else {
            setTimeout(function () {
              if (isUndef(factory.resolved) && isUndef(factory.error)) {
                factory.loading = true;
                forceRender();
              }
            }, res.delay || 200);
          }
        }

        if (isDef(res.timeout)) {
          setTimeout(function () {
            if (isUndef(factory.resolved)) {
              reject(
                null
              );
            }
          }, res.timeout);
        }
      }
    }

    sync = false;
    // return in case resolved synchronously
    return factory.loading
      ? factory.loadingComp
      : factory.resolved
  }
}

/*  */

function getFirstComponentChild (children) {
  if (Array.isArray(children)) {
    for (var i = 0; i < children.length; i++) {
      var c = children[i];
      if (isDef(c) && isDef(c.componentOptions)) {
        return c
      }
    }
  }
}

/*  */

/*  */

function initEvents (vm) {
  vm._events = Object.create(null);
  vm._hasHookEvent = false;
  // init parent attached events
  var listeners = vm.$options._parentListeners;
  if (listeners) {
    updateComponentListeners(vm, listeners);
  }
}

var target;

function add (event, fn, once$$1) {
  if (once$$1) {
    target.$once(event, fn);
  } else {
    target.$on(event, fn);
  }
}

function remove$1 (event, fn) {
  target.$off(event, fn);
}

function updateComponentListeners (
  vm,
  listeners,
  oldListeners
) {
  target = vm;
  updateListeners(listeners, oldListeners || {}, add, remove$1, vm);
}

function eventsMixin (Vue) {
  var hookRE = /^hook:/;
  Vue.prototype.$on = function (event, fn) {
    var this$1 = this;

    var vm = this;
    if (Array.isArray(event)) {
      for (var i = 0, l = event.length; i < l; i++) {
        this$1.$on(event[i], fn);
      }
    } else {
      (vm._events[event] || (vm._events[event] = [])).push(fn);
      // optimize hook:event cost by using a boolean flag marked at registration
      // instead of a hash lookup
      if (hookRE.test(event)) {
        vm._hasHookEvent = true;
      }
    }
    return vm
  };

  Vue.prototype.$once = function (event, fn) {
    var vm = this;
    function on () {
      vm.$off(event, on);
      fn.apply(vm, arguments);
    }
    on.fn = fn;
    vm.$on(event, on);
    return vm
  };

  Vue.prototype.$off = function (event, fn) {
    var this$1 = this;

    var vm = this;
    // all
    if (!arguments.length) {
      vm._events = Object.create(null);
      return vm
    }
    // array of events
    if (Array.isArray(event)) {
      for (var i$1 = 0, l = event.length; i$1 < l; i$1++) {
        this$1.$off(event[i$1], fn);
      }
      return vm
    }
    // specific event
    var cbs = vm._events[event];
    if (!cbs) {
      return vm
    }
    if (arguments.length === 1) {
      vm._events[event] = null;
      return vm
    }
    // specific handler
    var cb;
    var i = cbs.length;
    while (i--) {
      cb = cbs[i];
      if (cb === fn || cb.fn === fn) {
        cbs.splice(i, 1);
        break
      }
    }
    return vm
  };

  Vue.prototype.$emit = function (event) {
    var vm = this;
    var cbs = vm._events[event];
    if (cbs) {
      cbs = cbs.length > 1 ? toArray(cbs) : cbs;
      var args = toArray(arguments, 1);
      for (var i = 0, l = cbs.length; i < l; i++) {
        try {
          cbs[i].apply(vm, args);
        } catch (e) {
          handleError(e, vm, ("event handler for \"" + event + "\""));
        }
      }
    }
    return vm
  };
}

/*  */

/**
 * Runtime helper for resolving raw children VNodes into a slot object.
 */
function resolveSlots (
  children,
  context
) {
  var slots = {};
  if (!children) {
    return slots
  }
  var defaultSlot = [];
  for (var i = 0, l = children.length; i < l; i++) {
    var child = children[i];
    // named slots should only be respected if the vnode was rendered in the
    // same context.
    if ((child.context === context || child.functionalContext === context) &&
      child.data && child.data.slot != null
    ) {
      var name = child.data.slot;
      var slot = (slots[name] || (slots[name] = []));
      if (child.tag === 'template') {
        slot.push.apply(slot, child.children);
      } else {
        slot.push(child);
      }
    } else {
      defaultSlot.push(child);
    }
  }
  // ignore whitespace
  if (!defaultSlot.every(isWhitespace)) {
    slots.default = defaultSlot;
  }
  return slots
}

function isWhitespace (node) {
  return node.isComment || node.text === ' '
}

function resolveScopedSlots (
  fns, // see flow/vnode
  res
) {
  res = res || {};
  for (var i = 0; i < fns.length; i++) {
    if (Array.isArray(fns[i])) {
      resolveScopedSlots(fns[i], res);
    } else {
      res[fns[i].key] = fns[i].fn;
    }
  }
  return res
}

/*  */

var activeInstance = null;


function initLifecycle (vm) {
  var options = vm.$options;

  // locate first non-abstract parent
  var parent = options.parent;
  if (parent && !options.abstract) {
    while (parent.$options.abstract && parent.$parent) {
      parent = parent.$parent;
    }
    parent.$children.push(vm);
  }

  vm.$parent = parent;
  vm.$root = parent ? parent.$root : vm;

  vm.$children = [];
  vm.$refs = {};

  vm._watcher = null;
  vm._inactive = null;
  vm._directInactive = false;
  vm._isMounted = false;
  vm._isDestroyed = false;
  vm._isBeingDestroyed = false;
}

function lifecycleMixin (Vue) {
  Vue.prototype._update = function (vnode, hydrating) {
    var vm = this;
    if (vm._isMounted) {
      callHook(vm, 'beforeUpdate');
    }
    var prevEl = vm.$el;
    var prevVnode = vm._vnode;
    var prevActiveInstance = activeInstance;
    activeInstance = vm;
    vm._vnode = vnode;
    // Vue.prototype.__patch__ is injected in entry points
    // based on the rendering backend used.
    if (!prevVnode) {
      // initial render
      vm.$el = vm.__patch__(
        vm.$el, vnode, hydrating, false /* removeOnly */,
        vm.$options._parentElm,
        vm.$options._refElm
      );
      // no need for the ref nodes after initial patch
      // this prevents keeping a detached DOM tree in memory (#5851)
      vm.$options._parentElm = vm.$options._refElm = null;
    } else {
      // updates
      vm.$el = vm.__patch__(prevVnode, vnode);
    }
    activeInstance = prevActiveInstance;
    // update __vue__ reference
    if (prevEl) {
      prevEl.__vue__ = null;
    }
    if (vm.$el) {
      vm.$el.__vue__ = vm;
    }
    // if parent is an HOC, update its $el as well
    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
      vm.$parent.$el = vm.$el;
    }
    // updated hook is called by the scheduler to ensure that children are
    // updated in a parent's updated hook.
  };

  Vue.prototype.$forceUpdate = function () {
    var vm = this;
    if (vm._watcher) {
      vm._watcher.update();
    }
  };

  Vue.prototype.$destroy = function () {
    var vm = this;
    if (vm._isBeingDestroyed) {
      return
    }
    callHook(vm, 'beforeDestroy');
    vm._isBeingDestroyed = true;
    // remove self from parent
    var parent = vm.$parent;
    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
      remove(parent.$children, vm);
    }
    // teardown watchers
    if (vm._watcher) {
      vm._watcher.teardown();
    }
    var i = vm._watchers.length;
    while (i--) {
      vm._watchers[i].teardown();
    }
    // remove reference from data ob
    // frozen object may not have observer.
    if (vm._data.__ob__) {
      vm._data.__ob__.vmCount--;
    }
    // call the last hook...
    vm._isDestroyed = true;
    // invoke destroy hooks on current rendered tree
    vm.__patch__(vm._vnode, null);
    // fire destroyed hook
    callHook(vm, 'destroyed');
    // turn off all instance listeners.
    vm.$off();
    // remove __vue__ reference
    if (vm.$el) {
      vm.$el.__vue__ = null;
    }
  };
}

function mountComponent (
  vm,
  el,
  hydrating
) {
  vm.$el = el;
  if (!vm.$options.render) {
    vm.$options.render = createEmptyVNode;
    
  }
  callHook(vm, 'beforeMount');

  var updateComponent;
  /* istanbul ignore if */
  if (false) {
    updateComponent = function () {
      var name = vm._name;
      var id = vm._uid;
      var startTag = "vue-perf-start:" + id;
      var endTag = "vue-perf-end:" + id;

      mark(startTag);
      var vnode = vm._render();
      mark(endTag);
      measure((name + " render"), startTag, endTag);

      mark(startTag);
      vm._update(vnode, hydrating);
      mark(endTag);
      measure((name + " patch"), startTag, endTag);
    };
  } else {
    updateComponent = function () {
      vm._update(vm._render(), hydrating);
    };
  }

  vm._watcher = new Watcher(vm, updateComponent, noop);
  hydrating = false;

  // manually mounted instance, call mounted on self
  // mounted is called for render-created child components in its inserted hook
  if (vm.$vnode == null) {
    vm._isMounted = true;
    callHook(vm, 'mounted');
  }
  return vm
}

function updateChildComponent (
  vm,
  propsData,
  listeners,
  parentVnode,
  renderChildren
) {
  var hasChildren = !!(
    renderChildren ||               // has new static slots
    vm.$options._renderChildren ||  // has old static slots
    parentVnode.data.scopedSlots || // has new scoped slots
    vm.$scopedSlots !== emptyObject // has old scoped slots
  );

  vm.$options._parentVnode = parentVnode;
  vm.$vnode = parentVnode; // update vm's placeholder node without re-render

  if (vm._vnode) { // update child tree's parent
    vm._vnode.parent = parentVnode;
  }
  vm.$options._renderChildren = renderChildren;

  // update $attrs and $listensers hash
  // these are also reactive so they may trigger child update if the child
  // used them during render
  vm.$attrs = parentVnode.data && parentVnode.data.attrs;
  vm.$listeners = listeners;

  // update props
  if (propsData && vm.$options.props) {
    observerState.shouldConvert = false;
    var props = vm._props;
    var propKeys = vm.$options._propKeys || [];
    for (var i = 0; i < propKeys.length; i++) {
      var key = propKeys[i];
      props[key] = validateProp(key, vm.$options.props, propsData, vm);
    }
    observerState.shouldConvert = true;
    // keep a copy of raw propsData
    vm.$options.propsData = propsData;
  }

  // update listeners
  if (listeners) {
    var oldListeners = vm.$options._parentListeners;
    vm.$options._parentListeners = listeners;
    updateComponentListeners(vm, listeners, oldListeners);
  }
  // resolve slots + force update if has children
  if (hasChildren) {
    vm.$slots = resolveSlots(renderChildren, parentVnode.context);
    vm.$forceUpdate();
  }

  
}

function isInInactiveTree (vm) {
  while (vm && (vm = vm.$parent)) {
    if (vm._inactive) { return true }
  }
  return false
}

function activateChildComponent (vm, direct) {
  if (direct) {
    vm._directInactive = false;
    if (isInInactiveTree(vm)) {
      return
    }
  } else if (vm._directInactive) {
    return
  }
  if (vm._inactive || vm._inactive === null) {
    vm._inactive = false;
    for (var i = 0; i < vm.$children.length; i++) {
      activateChildComponent(vm.$children[i]);
    }
    callHook(vm, 'activated');
  }
}

function deactivateChildComponent (vm, direct) {
  if (direct) {
    vm._directInactive = true;
    if (isInInactiveTree(vm)) {
      return
    }
  }
  if (!vm._inactive) {
    vm._inactive = true;
    for (var i = 0; i < vm.$children.length; i++) {
      deactivateChildComponent(vm.$children[i]);
    }
    callHook(vm, 'deactivated');
  }
}

function callHook (vm, hook) {
  var handlers = vm.$options[hook];
  if (handlers) {
    for (var i = 0, j = handlers.length; i < j; i++) {
      try {
        handlers[i].call(vm);
      } catch (e) {
        handleError(e, vm, (hook + " hook"));
      }
    }
  }
  if (vm._hasHookEvent) {
    vm.$emit('hook:' + hook);
  }
}

/*  */


var MAX_UPDATE_COUNT = 100;

var queue = [];
var activatedChildren = [];
var has = {};
var circular = {};
var waiting = false;
var flushing = false;
var index = 0;

/**
 * Reset the scheduler's state.
 */
function resetSchedulerState () {
  index = queue.length = activatedChildren.length = 0;
  has = {};
  waiting = flushing = false;
}

/**
 * Flush both queues and run the watchers.
 */
function flushSchedulerQueue () {
  flushing = true;
  var watcher, id;

  // Sort queue before flush.
  // This ensures that:
  // 1. Components are updated from parent to child. (because parent is always
  //    created before the child)
  // 2. A component's user watchers are run before its render watcher (because
  //    user watchers are created before the render watcher)
  // 3. If a component is destroyed during a parent component's watcher run,
  //    its watchers can be skipped.
  queue.sort(function (a, b) { return a.id - b.id; });

  // do not cache length because more watchers might be pushed
  // as we run existing watchers
  for (index = 0; index < queue.length; index++) {
    watcher = queue[index];
    id = watcher.id;
    has[id] = null;
    watcher.run();
    // in dev build, check and stop circular updates.
    if (false) {
      circular[id] = (circular[id] || 0) + 1;
      if (circular[id] > MAX_UPDATE_COUNT) {
        warn(
          'You may have an infinite update loop ' + (
            watcher.user
              ? ("in watcher with expression \"" + (watcher.expression) + "\"")
              : "in a component render function."
          ),
          watcher.vm
        );
        break
      }
    }
  }

  // keep copies of post queues before resetting state
  var activatedQueue = activatedChildren.slice();
  var updatedQueue = queue.slice();

  resetSchedulerState();

  // call component updated and activated hooks
  callActivatedHooks(activatedQueue);
  callUpdatedHooks(updatedQueue);

  // devtool hook
  /* istanbul ignore if */
  if (devtools && config.devtools) {
    devtools.emit('flush');
  }
}

function callUpdatedHooks (queue) {
  var i = queue.length;
  while (i--) {
    var watcher = queue[i];
    var vm = watcher.vm;
    if (vm._watcher === watcher && vm._isMounted) {
      callHook(vm, 'updated');
    }
  }
}

/**
 * Queue a kept-alive component that was activated during patch.
 * The queue will be processed after the entire tree has been patched.
 */
function queueActivatedComponent (vm) {
  // setting _inactive to false here so that a render function can
  // rely on checking whether it's in an inactive tree (e.g. router-view)
  vm._inactive = false;
  activatedChildren.push(vm);
}

function callActivatedHooks (queue) {
  for (var i = 0; i < queue.length; i++) {
    queue[i]._inactive = true;
    activateChildComponent(queue[i], true /* true */);
  }
}

/**
 * Push a watcher into the watcher queue.
 * Jobs with duplicate IDs will be skipped unless it's
 * pushed when the queue is being flushed.
 */
function queueWatcher (watcher) {
  var id = watcher.id;
  if (has[id] == null) {
    has[id] = true;
    if (!flushing) {
      queue.push(watcher);
    } else {
      // if already flushing, splice the watcher based on its id
      // if already past its id, it will be run next immediately.
      var i = queue.length - 1;
      while (i > index && queue[i].id > watcher.id) {
        i--;
      }
      queue.splice(i + 1, 0, watcher);
    }
    // queue the flush
    if (!waiting) {
      waiting = true;
      nextTick(flushSchedulerQueue);
    }
  }
}

/*  */

var uid$2 = 0;

/**
 * A watcher parses an expression, collects dependencies,
 * and fires callback when the expression value changes.
 * This is used for both the $watch() api and directives.
 */
var Watcher = function Watcher (
  vm,
  expOrFn,
  cb,
  options
) {
  this.vm = vm;
  vm._watchers.push(this);
  // options
  if (options) {
    this.deep = !!options.deep;
    this.user = !!options.user;
    this.lazy = !!options.lazy;
    this.sync = !!options.sync;
  } else {
    this.deep = this.user = this.lazy = this.sync = false;
  }
  this.cb = cb;
  this.id = ++uid$2; // uid for batching
  this.active = true;
  this.dirty = this.lazy; // for lazy watchers
  this.deps = [];
  this.newDeps = [];
  this.depIds = new _Set();
  this.newDepIds = new _Set();
  this.expression = '';
  // parse expression for getter
  if (typeof expOrFn === 'function') {
    this.getter = expOrFn;
  } else {
    this.getter = parsePath(expOrFn);
    if (!this.getter) {
      this.getter = function () {};
      "production" !== 'production' && warn(
        "Failed watching path: \"" + expOrFn + "\" " +
        'Watcher only accepts simple dot-delimited paths. ' +
        'For full control, use a function instead.',
        vm
      );
    }
  }
  this.value = this.lazy
    ? undefined
    : this.get();
};

/**
 * Evaluate the getter, and re-collect dependencies.
 */
Watcher.prototype.get = function get () {
  pushTarget(this);
  var value;
  var vm = this.vm;
  try {
    value = this.getter.call(vm, vm);
  } catch (e) {
    if (this.user) {
      handleError(e, vm, ("getter for watcher \"" + (this.expression) + "\""));
    } else {
      throw e
    }
  } finally {
    // "touch" every property so they are all tracked as
    // dependencies for deep watching
    if (this.deep) {
      traverse(value);
    }
    popTarget();
    this.cleanupDeps();
  }
  return value
};

/**
 * Add a dependency to this directive.
 */
Watcher.prototype.addDep = function addDep (dep) {
  var id = dep.id;
  if (!this.newDepIds.has(id)) {
    this.newDepIds.add(id);
    this.newDeps.push(dep);
    if (!this.depIds.has(id)) {
      dep.addSub(this);
    }
  }
};

/**
 * Clean up for dependency collection.
 */
Watcher.prototype.cleanupDeps = function cleanupDeps () {
    var this$1 = this;

  var i = this.deps.length;
  while (i--) {
    var dep = this$1.deps[i];
    if (!this$1.newDepIds.has(dep.id)) {
      dep.removeSub(this$1);
    }
  }
  var tmp = this.depIds;
  this.depIds = this.newDepIds;
  this.newDepIds = tmp;
  this.newDepIds.clear();
  tmp = this.deps;
  this.deps = this.newDeps;
  this.newDeps = tmp;
  this.newDeps.length = 0;
};

/**
 * Subscriber interface.
 * Will be called when a dependency changes.
 */
Watcher.prototype.update = function update () {
  /* istanbul ignore else */
  if (this.lazy) {
    this.dirty = true;
  } else if (this.sync) {
    this.run();
  } else {
    queueWatcher(this);
  }
};

/**
 * Scheduler job interface.
 * Will be called by the scheduler.
 */
Watcher.prototype.run = function run () {
  if (this.active) {
    var value = this.get();
    if (
      value !== this.value ||
      // Deep watchers and watchers on Object/Arrays should fire even
      // when the value is the same, because the value may
      // have mutated.
      isObject(value) ||
      this.deep
    ) {
      // set new value
      var oldValue = this.value;
      this.value = value;
      if (this.user) {
        try {
          this.cb.call(this.vm, value, oldValue);
        } catch (e) {
          handleError(e, this.vm, ("callback for watcher \"" + (this.expression) + "\""));
        }
      } else {
        this.cb.call(this.vm, value, oldValue);
      }
    }
  }
};

/**
 * Evaluate the value of the watcher.
 * This only gets called for lazy watchers.
 */
Watcher.prototype.evaluate = function evaluate () {
  this.value = this.get();
  this.dirty = false;
};

/**
 * Depend on all deps collected by this watcher.
 */
Watcher.prototype.depend = function depend () {
    var this$1 = this;

  var i = this.deps.length;
  while (i--) {
    this$1.deps[i].depend();
  }
};

/**
 * Remove self from all dependencies' subscriber list.
 */
Watcher.prototype.teardown = function teardown () {
    var this$1 = this;

  if (this.active) {
    // remove self from vm's watcher list
    // this is a somewhat expensive operation so we skip it
    // if the vm is being destroyed.
    if (!this.vm._isBeingDestroyed) {
      remove(this.vm._watchers, this);
    }
    var i = this.deps.length;
    while (i--) {
      this$1.deps[i].removeSub(this$1);
    }
    this.active = false;
  }
};

/**
 * Recursively traverse an object to evoke all converted
 * getters, so that every nested property inside the object
 * is collected as a "deep" dependency.
 */
var seenObjects = new _Set();
function traverse (val) {
  seenObjects.clear();
  _traverse(val, seenObjects);
}

function _traverse (val, seen) {
  var i, keys;
  var isA = Array.isArray(val);
  if ((!isA && !isObject(val)) || !Object.isExtensible(val)) {
    return
  }
  if (val.__ob__) {
    var depId = val.__ob__.dep.id;
    if (seen.has(depId)) {
      return
    }
    seen.add(depId);
  }
  if (isA) {
    i = val.length;
    while (i--) { _traverse(val[i], seen); }
  } else {
    keys = Object.keys(val);
    i = keys.length;
    while (i--) { _traverse(val[keys[i]], seen); }
  }
}

/*  */

var sharedPropertyDefinition = {
  enumerable: true,
  configurable: true,
  get: noop,
  set: noop
};

function proxy (target, sourceKey, key) {
  sharedPropertyDefinition.get = function proxyGetter () {
    return this[sourceKey][key]
  };
  sharedPropertyDefinition.set = function proxySetter (val) {
    this[sourceKey][key] = val;
  };
  Object.defineProperty(target, key, sharedPropertyDefinition);
}

function initState (vm) {
  vm._watchers = [];
  var opts = vm.$options;
  if (opts.props) { initProps(vm, opts.props); }
  if (opts.methods) { initMethods(vm, opts.methods); }
  if (opts.data) {
    initData(vm);
  } else {
    observe(vm._data = {}, true /* asRootData */);
  }
  if (opts.computed) { initComputed(vm, opts.computed); }
  if (opts.watch && opts.watch !== nativeWatch) {
    initWatch(vm, opts.watch);
  }
}

function checkOptionType (vm, name) {
  var option = vm.$options[name];
  if (!isPlainObject(option)) {
    warn(
      ("component option \"" + name + "\" should be an object."),
      vm
    );
  }
}

function initProps (vm, propsOptions) {
  var propsData = vm.$options.propsData || {};
  var props = vm._props = {};
  // cache prop keys so that future props updates can iterate using Array
  // instead of dynamic object key enumeration.
  var keys = vm.$options._propKeys = [];
  var isRoot = !vm.$parent;
  // root instance props should be converted
  observerState.shouldConvert = isRoot;
  var loop = function ( key ) {
    keys.push(key);
    var value = validateProp(key, propsOptions, propsData, vm);
    /* istanbul ignore else */
    {
      defineReactive$$1(props, key, value);
    }
    // static props are already proxied on the component's prototype
    // during Vue.extend(). We only need to proxy props defined at
    // instantiation here.
    if (!(key in vm)) {
      proxy(vm, "_props", key);
    }
  };

  for (var key in propsOptions) loop( key );
  observerState.shouldConvert = true;
}

function initData (vm) {
  var data = vm.$options.data;
  data = vm._data = typeof data === 'function'
    ? getData(data, vm)
    : data || {};
  if (!isPlainObject(data)) {
    data = {};
    "production" !== 'production' && warn(
      'data functions should return an object:\n' +
      'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function',
      vm
    );
  }
  // proxy data on instance
  var keys = Object.keys(data);
  var props = vm.$options.props;
  var methods = vm.$options.methods;
  var i = keys.length;
  while (i--) {
    var key = keys[i];
    if (props && hasOwn(props, key)) {
      "production" !== 'production' && warn(
        "The data property \"" + key + "\" is already declared as a prop. " +
        "Use prop default value instead.",
        vm
      );
    } else if (!isReserved(key)) {
      proxy(vm, "_data", key);
    }
  }
  // observe data
  observe(data, true /* asRootData */);
}

function getData (data, vm) {
  try {
    return data.call(vm)
  } catch (e) {
    handleError(e, vm, "data()");
    return {}
  }
}

var computedWatcherOptions = { lazy: true };

function initComputed (vm, computed) {
  "production" !== 'production' && checkOptionType(vm, 'computed');
  var watchers = vm._computedWatchers = Object.create(null);

  for (var key in computed) {
    var userDef = computed[key];
    var getter = typeof userDef === 'function' ? userDef : userDef.get;
    watchers[key] = new Watcher(vm, getter, noop, computedWatcherOptions);

    // component-defined computed properties are already defined on the
    // component prototype. We only need to define computed properties defined
    // at instantiation here.
    if (!(key in vm)) {
      defineComputed(vm, key, userDef);
    } else {}
  }
}

function defineComputed (target, key, userDef) {
  if (typeof userDef === 'function') {
    sharedPropertyDefinition.get = createComputedGetter(key);
    sharedPropertyDefinition.set = noop;
  } else {
    sharedPropertyDefinition.get = userDef.get
      ? userDef.cache !== false
        ? createComputedGetter(key)
        : userDef.get
      : noop;
    sharedPropertyDefinition.set = userDef.set
      ? userDef.set
      : noop;
  }
  Object.defineProperty(target, key, sharedPropertyDefinition);
}

function createComputedGetter (key) {
  return function computedGetter () {
    var watcher = this._computedWatchers && this._computedWatchers[key];
    if (watcher) {
      if (watcher.dirty) {
        watcher.evaluate();
      }
      if (Dep.target) {
        watcher.depend();
      }
      return watcher.value
    }
  }
}

function initMethods (vm, methods) {
  "production" !== 'production' && checkOptionType(vm, 'methods');
  var props = vm.$options.props;
  for (var key in methods) {
    vm[key] = methods[key] == null ? noop : bind(methods[key], vm);
    
  }
}

function initWatch (vm, watch) {
  "production" !== 'production' && checkOptionType(vm, 'watch');
  for (var key in watch) {
    var handler = watch[key];
    if (Array.isArray(handler)) {
      for (var i = 0; i < handler.length; i++) {
        createWatcher(vm, key, handler[i]);
      }
    } else {
      createWatcher(vm, key, handler);
    }
  }
}

function createWatcher (
  vm,
  keyOrFn,
  handler,
  options
) {
  if (isPlainObject(handler)) {
    options = handler;
    handler = handler.handler;
  }
  if (typeof handler === 'string') {
    handler = vm[handler];
  }
  return vm.$watch(keyOrFn, handler, options)
}

function stateMixin (Vue) {
  // flow somehow has problems with directly declared definition object
  // when using Object.defineProperty, so we have to procedurally build up
  // the object here.
  var dataDef = {};
  dataDef.get = function () { return this._data };
  var propsDef = {};
  propsDef.get = function () { return this._props };
  Object.defineProperty(Vue.prototype, '$data', dataDef);
  Object.defineProperty(Vue.prototype, '$props', propsDef);

  Vue.prototype.$set = set;
  Vue.prototype.$delete = del;

  Vue.prototype.$watch = function (
    expOrFn,
    cb,
    options
  ) {
    var vm = this;
    if (isPlainObject(cb)) {
      return createWatcher(vm, expOrFn, cb, options)
    }
    options = options || {};
    options.user = true;
    var watcher = new Watcher(vm, expOrFn, cb, options);
    if (options.immediate) {
      cb.call(vm, watcher.value);
    }
    return function unwatchFn () {
      watcher.teardown();
    }
  };
}

/*  */

function initProvide (vm) {
  var provide = vm.$options.provide;
  if (provide) {
    vm._provided = typeof provide === 'function'
      ? provide.call(vm)
      : provide;
  }
}

function initInjections (vm) {
  var result = resolveInject(vm.$options.inject, vm);
  if (result) {
    observerState.shouldConvert = false;
    Object.keys(result).forEach(function (key) {
      /* istanbul ignore else */
      {
        defineReactive$$1(vm, key, result[key]);
      }
    });
    observerState.shouldConvert = true;
  }
}

function resolveInject (inject, vm) {
  if (inject) {
    // inject is :any because flow is not smart enough to figure out cached
    var result = Object.create(null);
    var keys = hasSymbol
        ? Reflect.ownKeys(inject)
        : Object.keys(inject);

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      var provideKey = inject[key];
      var source = vm;
      while (source) {
        if (source._provided && provideKey in source._provided) {
          result[key] = source._provided[provideKey];
          break
        }
        source = source.$parent;
      }
      if (false) {
        warn(("Injection \"" + key + "\" not found"), vm);
      }
    }
    return result
  }
}

/*  */

function createFunctionalComponent (
  Ctor,
  propsData,
  data,
  context,
  children
) {
  var props = {};
  var propOptions = Ctor.options.props;
  if (isDef(propOptions)) {
    for (var key in propOptions) {
      props[key] = validateProp(key, propOptions, propsData || {});
    }
  } else {
    if (isDef(data.attrs)) { mergeProps(props, data.attrs); }
    if (isDef(data.props)) { mergeProps(props, data.props); }
  }
  // ensure the createElement function in functional components
  // gets a unique context - this is necessary for correct named slot check
  var _context = Object.create(context);
  var h = function (a, b, c, d) { return createElement(_context, a, b, c, d, true); };
  var vnode = Ctor.options.render.call(null, h, {
    data: data,
    props: props,
    children: children,
    parent: context,
    listeners: data.on || {},
    injections: resolveInject(Ctor.options.inject, context),
    slots: function () { return resolveSlots(children, context); }
  });
  if (vnode instanceof VNode) {
    vnode.functionalContext = context;
    vnode.functionalOptions = Ctor.options;
    if (data.slot) {
      (vnode.data || (vnode.data = {})).slot = data.slot;
    }
  }
  return vnode
}

function mergeProps (to, from) {
  for (var key in from) {
    to[camelize(key)] = from[key];
  }
}

/*  */

// hooks to be invoked on component VNodes during patch
var componentVNodeHooks = {
  init: function init (
    vnode,
    hydrating,
    parentElm,
    refElm
  ) {
    if (!vnode.componentInstance || vnode.componentInstance._isDestroyed) {
      var child = vnode.componentInstance = createComponentInstanceForVnode(
        vnode,
        activeInstance,
        parentElm,
        refElm
      );
      child.$mount(hydrating ? vnode.elm : undefined, hydrating);
    } else if (vnode.data.keepAlive) {
      // kept-alive components, treat as a patch
      var mountedNode = vnode; // work around flow
      componentVNodeHooks.prepatch(mountedNode, mountedNode);
    }
  },

  prepatch: function prepatch (oldVnode, vnode) {
    var options = vnode.componentOptions;
    var child = vnode.componentInstance = oldVnode.componentInstance;
    updateChildComponent(
      child,
      options.propsData, // updated props
      options.listeners, // updated listeners
      vnode, // new parent vnode
      options.children // new children
    );
  },

  insert: function insert (vnode) {
    var context = vnode.context;
    var componentInstance = vnode.componentInstance;

    if (!componentInstance._isMounted) {
      componentInstance._isMounted = true;
      callHook(componentInstance, 'mounted');
    }
    if (vnode.data.keepAlive) {
      if (context._isMounted) {
        // vue-router#1212
        // During updates, a kept-alive component's child components may
        // change, so directly walking the tree here may call activated hooks
        // on incorrect children. Instead we push them into a queue which will
        // be processed after the whole patch process ended.
        queueActivatedComponent(componentInstance);
      } else {
        activateChildComponent(componentInstance, true /* direct */);
      }
    }
  },

  destroy: function destroy (vnode) {
    var componentInstance = vnode.componentInstance;
    if (!componentInstance._isDestroyed) {
      if (!vnode.data.keepAlive) {
        componentInstance.$destroy();
      } else {
        deactivateChildComponent(componentInstance, true /* direct */);
      }
    }
  }
};

var hooksToMerge = Object.keys(componentVNodeHooks);

function createComponent (
  Ctor,
  data,
  context,
  children,
  tag
) {
  if (isUndef(Ctor)) {
    return
  }

  var baseCtor = context.$options._base;

  // plain options object: turn it into a constructor
  if (isObject(Ctor)) {
    Ctor = baseCtor.extend(Ctor);
  }

  // if at this stage it's not a constructor or an async component factory,
  // reject.
  if (typeof Ctor !== 'function') {
    return
  }

  // async component
  var asyncFactory;
  if (isUndef(Ctor.cid)) {
    asyncFactory = Ctor;
    Ctor = resolveAsyncComponent(asyncFactory, baseCtor, context);
    if (Ctor === undefined) {
      // return a placeholder node for async component, which is rendered
      // as a comment node but preserves all the raw information for the node.
      // the information will be used for async server-rendering and hydration.
      return createAsyncPlaceholder(
        asyncFactory,
        data,
        context,
        children,
        tag
      )
    }
  }

  data = data || {};

  // resolve constructor options in case global mixins are applied after
  // component constructor creation
  resolveConstructorOptions(Ctor);

  // transform component v-model data into props & events
  if (isDef(data.model)) {
    transformModel(Ctor.options, data);
  }

  // extract props
  var propsData = extractPropsFromVNodeData(data, Ctor, tag);

  // functional component
  if (isTrue(Ctor.options.functional)) {
    return createFunctionalComponent(Ctor, propsData, data, context, children)
  }

  // keep listeners
  var listeners = data.on;

  if (isTrue(Ctor.options.abstract)) {
    // abstract components do not keep anything
    // other than props & listeners & slot

    // work around flow
    var slot = data.slot;
    data = {};
    if (slot) {
      data.slot = slot;
    }
  }

  // merge component management hooks onto the placeholder node
  mergeHooks(data);

  // return a placeholder vnode
  var name = Ctor.options.name || tag;
  var vnode = new VNode(
    ("vue-component-" + (Ctor.cid) + (name ? ("-" + name) : '')),
    data, undefined, undefined, undefined, context,
    { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children },
    asyncFactory
  );
  return vnode
}

function createComponentInstanceForVnode (
  vnode, // we know it's MountedComponentVNode but flow doesn't
  parent, // activeInstance in lifecycle state
  parentElm,
  refElm
) {
  var vnodeComponentOptions = vnode.componentOptions;
  var options = {
    _isComponent: true,
    parent: parent,
    propsData: vnodeComponentOptions.propsData,
    _componentTag: vnodeComponentOptions.tag,
    _parentVnode: vnode,
    _parentListeners: vnodeComponentOptions.listeners,
    _renderChildren: vnodeComponentOptions.children,
    _parentElm: parentElm || null,
    _refElm: refElm || null
  };
  // check inline-template render functions
  var inlineTemplate = vnode.data.inlineTemplate;
  if (isDef(inlineTemplate)) {
    options.render = inlineTemplate.render;
    options.staticRenderFns = inlineTemplate.staticRenderFns;
  }
  return new vnodeComponentOptions.Ctor(options)
}

function mergeHooks (data) {
  if (!data.hook) {
    data.hook = {};
  }
  for (var i = 0; i < hooksToMerge.length; i++) {
    var key = hooksToMerge[i];
    var fromParent = data.hook[key];
    var ours = componentVNodeHooks[key];
    data.hook[key] = fromParent ? mergeHook$1(ours, fromParent) : ours;
  }
}

function mergeHook$1 (one, two) {
  return function (a, b, c, d) {
    one(a, b, c, d);
    two(a, b, c, d);
  }
}

// transform component v-model info (value and callback) into
// prop and event handler respectively.
function transformModel (options, data) {
  var prop = (options.model && options.model.prop) || 'value';
  var event = (options.model && options.model.event) || 'input';(data.props || (data.props = {}))[prop] = data.model.value;
  var on = data.on || (data.on = {});
  if (isDef(on[event])) {
    on[event] = [data.model.callback].concat(on[event]);
  } else {
    on[event] = data.model.callback;
  }
}

/*  */

var SIMPLE_NORMALIZE = 1;
var ALWAYS_NORMALIZE = 2;

// wrapper function for providing a more flexible interface
// without getting yelled at by flow
function createElement (
  context,
  tag,
  data,
  children,
  normalizationType,
  alwaysNormalize
) {
  if (Array.isArray(data) || isPrimitive(data)) {
    normalizationType = children;
    children = data;
    data = undefined;
  }
  if (isTrue(alwaysNormalize)) {
    normalizationType = ALWAYS_NORMALIZE;
  }
  return _createElement(context, tag, data, children, normalizationType)
}

function _createElement (
  context,
  tag,
  data,
  children,
  normalizationType
) {
  if (isDef(data) && isDef((data).__ob__)) {
    "production" !== 'production' && warn(
      "Avoid using observed data object as vnode data: " + (JSON.stringify(data)) + "\n" +
      'Always create fresh vnode data objects in each render!',
      context
    );
    return createEmptyVNode()
  }
  // object syntax in v-bind
  if (isDef(data) && isDef(data.is)) {
    tag = data.is;
  }
  if (!tag) {
    // in case of component :is set to falsy value
    return createEmptyVNode()
  }
  // warn against non-primitive key
  if (false
  ) {
    warn(
      'Avoid using non-primitive value as key, ' +
      'use string/number value instead.',
      context
    );
  }
  // support single function children as default scoped slot
  if (Array.isArray(children) &&
    typeof children[0] === 'function'
  ) {
    data = data || {};
    data.scopedSlots = { default: children[0] };
    children.length = 0;
  }
  if (normalizationType === ALWAYS_NORMALIZE) {
    children = normalizeChildren(children);
  } else if (normalizationType === SIMPLE_NORMALIZE) {
    children = simpleNormalizeChildren(children);
  }
  var vnode, ns;
  if (typeof tag === 'string') {
    var Ctor;
    ns = config.getTagNamespace(tag);
    if (config.isReservedTag(tag)) {
      // platform built-in elements
      vnode = new VNode(
        config.parsePlatformTagName(tag), data, children,
        undefined, undefined, context
      );
    } else if (isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {
      // component
      vnode = createComponent(Ctor, data, context, children, tag);
    } else {
      // unknown or unlisted namespaced elements
      // check at runtime because it may get assigned a namespace when its
      // parent normalizes children
      vnode = new VNode(
        tag, data, children,
        undefined, undefined, context
      );
    }
  } else {
    // direct component options / constructor
    vnode = createComponent(tag, data, context, children);
  }
  if (isDef(vnode)) {
    if (ns) { applyNS(vnode, ns); }
    return vnode
  } else {
    return createEmptyVNode()
  }
}

function applyNS (vnode, ns) {
  vnode.ns = ns;
  if (vnode.tag === 'foreignObject') {
    // use default namespace inside foreignObject
    return
  }
  if (isDef(vnode.children)) {
    for (var i = 0, l = vnode.children.length; i < l; i++) {
      var child = vnode.children[i];
      if (isDef(child.tag) && isUndef(child.ns)) {
        applyNS(child, ns);
      }
    }
  }
}

/*  */

/**
 * Runtime helper for rendering v-for lists.
 */
function renderList (
  val,
  render
) {
  var ret, i, l, keys, key;
  if (Array.isArray(val) || typeof val === 'string') {
    ret = new Array(val.length);
    for (i = 0, l = val.length; i < l; i++) {
      ret[i] = render(val[i], i);
    }
  } else if (typeof val === 'number') {
    ret = new Array(val);
    for (i = 0; i < val; i++) {
      ret[i] = render(i + 1, i);
    }
  } else if (isObject(val)) {
    keys = Object.keys(val);
    ret = new Array(keys.length);
    for (i = 0, l = keys.length; i < l; i++) {
      key = keys[i];
      ret[i] = render(val[key], key, i);
    }
  }
  if (isDef(ret)) {
    (ret)._isVList = true;
  }
  return ret
}

/*  */

/**
 * Runtime helper for rendering <slot>
 */
function renderSlot (
  name,
  fallback,
  props,
  bindObject
) {
  var scopedSlotFn = this.$scopedSlots[name];
  if (scopedSlotFn) { // scoped slot
    props = props || {};
    if (bindObject) {
      props = extend(extend({}, bindObject), props);
    }
    return scopedSlotFn(props) || fallback
  } else {
    var slotNodes = this.$slots[name];
    // warn duplicate slot usage
    if (slotNodes && "production" !== 'production') {
      slotNodes._rendered && warn(
        "Duplicate presence of slot \"" + name + "\" found in the same render tree " +
        "- this will likely cause render errors.",
        this
      );
      slotNodes._rendered = true;
    }
    return slotNodes || fallback
  }
}

/*  */

/**
 * Runtime helper for resolving filters
 */
function resolveFilter (id) {
  return resolveAsset(this.$options, 'filters', id, true) || identity
}

/*  */

/**
 * Runtime helper for checking keyCodes from config.
 */
function checkKeyCodes (
  eventKeyCode,
  key,
  builtInAlias
) {
  var keyCodes = config.keyCodes[key] || builtInAlias;
  if (Array.isArray(keyCodes)) {
    return keyCodes.indexOf(eventKeyCode) === -1
  } else {
    return keyCodes !== eventKeyCode
  }
}

/*  */

/**
 * Runtime helper for merging v-bind="object" into a VNode's data.
 */
function bindObjectProps (
  data,
  tag,
  value,
  asProp,
  isSync
) {
  if (value) {
    if (!isObject(value)) {
      "production" !== 'production' && warn(
        'v-bind without argument expects an Object or Array value',
        this
      );
    } else {
      if (Array.isArray(value)) {
        value = toObject(value);
      }
      var hash;
      var loop = function ( key ) {
        if (
          key === 'class' ||
          key === 'style' ||
          isReservedAttribute(key)
        ) {
          hash = data;
        } else {
          var type = data.attrs && data.attrs.type;
          hash = asProp || config.mustUseProp(tag, type, key)
            ? data.domProps || (data.domProps = {})
            : data.attrs || (data.attrs = {});
        }
        if (!(key in hash)) {
          hash[key] = value[key];

          if (isSync) {
            var on = data.on || (data.on = {});
            on[("update:" + key)] = function ($event) {
              value[key] = $event;
            };
          }
        }
      };

      for (var key in value) loop( key );
    }
  }
  return data
}

/*  */

/**
 * Runtime helper for rendering static trees.
 */
function renderStatic (
  index,
  isInFor
) {
  var tree = this._staticTrees[index];
  // if has already-rendered static tree and not inside v-for,
  // we can reuse the same tree by doing a shallow clone.
  if (tree && !isInFor) {
    return Array.isArray(tree)
      ? cloneVNodes(tree)
      : cloneVNode(tree)
  }
  // otherwise, render a fresh tree.
  tree = this._staticTrees[index] =
    this.$options.staticRenderFns[index].call(this._renderProxy);
  markStatic(tree, ("__static__" + index), false);
  return tree
}

/**
 * Runtime helper for v-once.
 * Effectively it means marking the node as static with a unique key.
 */
function markOnce (
  tree,
  index,
  key
) {
  markStatic(tree, ("__once__" + index + (key ? ("_" + key) : "")), true);
  return tree
}

function markStatic (
  tree,
  key,
  isOnce
) {
  if (Array.isArray(tree)) {
    for (var i = 0; i < tree.length; i++) {
      if (tree[i] && typeof tree[i] !== 'string') {
        markStaticNode(tree[i], (key + "_" + i), isOnce);
      }
    }
  } else {
    markStaticNode(tree, key, isOnce);
  }
}

function markStaticNode (node, key, isOnce) {
  node.isStatic = true;
  node.key = key;
  node.isOnce = isOnce;
}

/*  */

function bindObjectListeners (data, value) {
  if (value) {
    if (!isPlainObject(value)) {
      "production" !== 'production' && warn(
        'v-on without argument expects an Object value',
        this
      );
    } else {
      var on = data.on = data.on ? extend({}, data.on) : {};
      for (var key in value) {
        var existing = on[key];
        var ours = value[key];
        on[key] = existing ? [].concat(ours, existing) : ours;
      }
    }
  }
  return data
}

/*  */

function initRender (vm) {
  vm._vnode = null; // the root of the child tree
  vm._staticTrees = null;
  var parentVnode = vm.$vnode = vm.$options._parentVnode; // the placeholder node in parent tree
  var renderContext = parentVnode && parentVnode.context;
  vm.$slots = resolveSlots(vm.$options._renderChildren, renderContext);
  vm.$scopedSlots = emptyObject;
  // bind the createElement fn to this instance
  // so that we get proper render context inside it.
  // args order: tag, data, children, normalizationType, alwaysNormalize
  // internal version is used by render functions compiled from templates
  vm._c = function (a, b, c, d) { return createElement(vm, a, b, c, d, false); };
  // normalization is always applied for the public version, used in
  // user-written render functions.
  vm.$createElement = function (a, b, c, d) { return createElement(vm, a, b, c, d, true); };

  // $attrs & $listeners are exposed for easier HOC creation.
  // they need to be reactive so that HOCs using them are always updated
  var parentData = parentVnode && parentVnode.data;
  /* istanbul ignore else */
  {
    defineReactive$$1(vm, '$attrs', parentData && parentData.attrs, null, true);
    defineReactive$$1(vm, '$listeners', parentData && parentData.on, null, true);
  }
}

function renderMixin (Vue) {
  Vue.prototype.$nextTick = function (fn) {
    return nextTick(fn, this)
  };

  Vue.prototype._render = function () {
    var vm = this;
    var ref = vm.$options;
    var render = ref.render;
    var staticRenderFns = ref.staticRenderFns;
    var _parentVnode = ref._parentVnode;

    if (vm._isMounted) {
      // clone slot nodes on re-renders
      for (var key in vm.$slots) {
        vm.$slots[key] = cloneVNodes(vm.$slots[key]);
      }
    }

    vm.$scopedSlots = (_parentVnode && _parentVnode.data.scopedSlots) || emptyObject;

    if (staticRenderFns && !vm._staticTrees) {
      vm._staticTrees = [];
    }
    // set parent vnode. this allows render functions to have access
    // to the data on the placeholder node.
    vm.$vnode = _parentVnode;
    // render self
    var vnode;
    try {
      vnode = render.call(vm._renderProxy, vm.$createElement);
    } catch (e) {
      handleError(e, vm, "render function");
      // return error render result,
      // or previous vnode to prevent render error causing blank component
      /* istanbul ignore else */
      {
        vnode = vm._vnode;
      }
    }
    // return empty vnode in case the render function errored out
    if (!(vnode instanceof VNode)) {
      if (false) {
        warn(
          'Multiple root nodes returned from render function. Render function ' +
          'should return a single root node.',
          vm
        );
      }
      vnode = createEmptyVNode();
    }
    // set parent
    vnode.parent = _parentVnode;
    return vnode
  };

  // internal render helpers.
  // these are exposed on the instance prototype to reduce generated render
  // code size.
  Vue.prototype._o = markOnce;
  Vue.prototype._n = toNumber;
  Vue.prototype._s = toString;
  Vue.prototype._l = renderList;
  Vue.prototype._t = renderSlot;
  Vue.prototype._q = looseEqual;
  Vue.prototype._i = looseIndexOf;
  Vue.prototype._m = renderStatic;
  Vue.prototype._f = resolveFilter;
  Vue.prototype._k = checkKeyCodes;
  Vue.prototype._b = bindObjectProps;
  Vue.prototype._v = createTextVNode;
  Vue.prototype._e = createEmptyVNode;
  Vue.prototype._u = resolveScopedSlots;
  Vue.prototype._g = bindObjectListeners;
}

/*  */

var uid = 0;

function initMixin (Vue) {
  Vue.prototype._init = function (options) {
    var vm = this;
    // a uid
    vm._uid = uid++;

    var startTag, endTag;
    /* istanbul ignore if */
    if (false) {
      startTag = "vue-perf-init:" + (vm._uid);
      endTag = "vue-perf-end:" + (vm._uid);
      mark(startTag);
    }

    // a flag to avoid this being observed
    vm._isVue = true;
    // merge options
    if (options && options._isComponent) {
      // optimize internal component instantiation
      // since dynamic options merging is pretty slow, and none of the
      // internal component options needs special treatment.
      initInternalComponent(vm, options);
    } else {
      vm.$options = mergeOptions(
        resolveConstructorOptions(vm.constructor),
        options || {},
        vm
      );
    }
    /* istanbul ignore else */
    {
      vm._renderProxy = vm;
    }
    // expose real self
    vm._self = vm;
    initLifecycle(vm);
    initEvents(vm);
    initRender(vm);
    callHook(vm, 'beforeCreate');
    initInjections(vm); // resolve injections before data/props
    initState(vm);
    initProvide(vm); // resolve provide after data/props
    callHook(vm, 'created');

    /* istanbul ignore if */
    if (false) {
      vm._name = formatComponentName(vm, false);
      mark(endTag);
      measure(((vm._name) + " init"), startTag, endTag);
    }

    if (vm.$options.el) {
      vm.$mount(vm.$options.el);
    }
  };
}

function initInternalComponent (vm, options) {
  var opts = vm.$options = Object.create(vm.constructor.options);
  // doing this because it's faster than dynamic enumeration.
  opts.parent = options.parent;
  opts.propsData = options.propsData;
  opts._parentVnode = options._parentVnode;
  opts._parentListeners = options._parentListeners;
  opts._renderChildren = options._renderChildren;
  opts._componentTag = options._componentTag;
  opts._parentElm = options._parentElm;
  opts._refElm = options._refElm;
  if (options.render) {
    opts.render = options.render;
    opts.staticRenderFns = options.staticRenderFns;
  }
}

function resolveConstructorOptions (Ctor) {
  var options = Ctor.options;
  if (Ctor.super) {
    var superOptions = resolveConstructorOptions(Ctor.super);
    var cachedSuperOptions = Ctor.superOptions;
    if (superOptions !== cachedSuperOptions) {
      // super option changed,
      // need to resolve new options.
      Ctor.superOptions = superOptions;
      // check if there are any late-modified/attached options (#4976)
      var modifiedOptions = resolveModifiedOptions(Ctor);
      // update base extend options
      if (modifiedOptions) {
        extend(Ctor.extendOptions, modifiedOptions);
      }
      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);
      if (options.name) {
        options.components[options.name] = Ctor;
      }
    }
  }
  return options
}

function resolveModifiedOptions (Ctor) {
  var modified;
  var latest = Ctor.options;
  var extended = Ctor.extendOptions;
  var sealed = Ctor.sealedOptions;
  for (var key in latest) {
    if (latest[key] !== sealed[key]) {
      if (!modified) { modified = {}; }
      modified[key] = dedupe(latest[key], extended[key], sealed[key]);
    }
  }
  return modified
}

function dedupe (latest, extended, sealed) {
  // compare latest and sealed to ensure lifecycle hooks won't be duplicated
  // between merges
  if (Array.isArray(latest)) {
    var res = [];
    sealed = Array.isArray(sealed) ? sealed : [sealed];
    extended = Array.isArray(extended) ? extended : [extended];
    for (var i = 0; i < latest.length; i++) {
      // push original options and not sealed options to exclude duplicated options
      if (extended.indexOf(latest[i]) >= 0 || sealed.indexOf(latest[i]) < 0) {
        res.push(latest[i]);
      }
    }
    return res
  } else {
    return latest
  }
}

function Vue$3 (options) {
  if (false
  ) {
    warn('Vue is a constructor and should be called with the `new` keyword');
  }
  this._init(options);
}

initMixin(Vue$3);
stateMixin(Vue$3);
eventsMixin(Vue$3);
lifecycleMixin(Vue$3);
renderMixin(Vue$3);

/*  */

function initUse (Vue) {
  Vue.use = function (plugin) {
    var installedPlugins = (this._installedPlugins || (this._installedPlugins = []));
    if (installedPlugins.indexOf(plugin) > -1) {
      return this
    }

    // additional parameters
    var args = toArray(arguments, 1);
    args.unshift(this);
    if (typeof plugin.install === 'function') {
      plugin.install.apply(plugin, args);
    } else if (typeof plugin === 'function') {
      plugin.apply(null, args);
    }
    installedPlugins.push(plugin);
    return this
  };
}

/*  */

function initMixin$1 (Vue) {
  Vue.mixin = function (mixin) {
    this.options = mergeOptions(this.options, mixin);
    return this
  };
}

/*  */

function initExtend (Vue) {
  /**
   * Each instance constructor, including Vue, has a unique
   * cid. This enables us to create wrapped "child
   * constructors" for prototypal inheritance and cache them.
   */
  Vue.cid = 0;
  var cid = 1;

  /**
   * Class inheritance
   */
  Vue.extend = function (extendOptions) {
    extendOptions = extendOptions || {};
    var Super = this;
    var SuperId = Super.cid;
    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});
    if (cachedCtors[SuperId]) {
      return cachedCtors[SuperId]
    }

    var name = extendOptions.name || Super.options.name;
    var Sub = function VueComponent (options) {
      this._init(options);
    };
    Sub.prototype = Object.create(Super.prototype);
    Sub.prototype.constructor = Sub;
    Sub.cid = cid++;
    Sub.options = mergeOptions(
      Super.options,
      extendOptions
    );
    Sub['super'] = Super;

    // For props and computed properties, we define the proxy getters on
    // the Vue instances at extension time, on the extended prototype. This
    // avoids Object.defineProperty calls for each instance created.
    if (Sub.options.props) {
      initProps$1(Sub);
    }
    if (Sub.options.computed) {
      initComputed$1(Sub);
    }

    // allow further extension/mixin/plugin usage
    Sub.extend = Super.extend;
    Sub.mixin = Super.mixin;
    Sub.use = Super.use;

    // create asset registers, so extended classes
    // can have their private assets too.
    ASSET_TYPES.forEach(function (type) {
      Sub[type] = Super[type];
    });
    // enable recursive self-lookup
    if (name) {
      Sub.options.components[name] = Sub;
    }

    // keep a reference to the super options at extension time.
    // later at instantiation we can check if Super's options have
    // been updated.
    Sub.superOptions = Super.options;
    Sub.extendOptions = extendOptions;
    Sub.sealedOptions = extend({}, Sub.options);

    // cache constructor
    cachedCtors[SuperId] = Sub;
    return Sub
  };
}

function initProps$1 (Comp) {
  var props = Comp.options.props;
  for (var key in props) {
    proxy(Comp.prototype, "_props", key);
  }
}

function initComputed$1 (Comp) {
  var computed = Comp.options.computed;
  for (var key in computed) {
    defineComputed(Comp.prototype, key, computed[key]);
  }
}

/*  */

function initAssetRegisters (Vue) {
  /**
   * Create asset registration methods.
   */
  ASSET_TYPES.forEach(function (type) {
    Vue[type] = function (
      id,
      definition
    ) {
      if (!definition) {
        return this.options[type + 's'][id]
      } else {
        /* istanbul ignore if */
        if (type === 'component' && isPlainObject(definition)) {
          definition.name = definition.name || id;
          definition = this.options._base.extend(definition);
        }
        if (type === 'directive' && typeof definition === 'function') {
          definition = { bind: definition, update: definition };
        }
        this.options[type + 's'][id] = definition;
        return definition
      }
    };
  });
}

/*  */

var patternTypes = [String, RegExp, Array];

function getComponentName (opts) {
  return opts && (opts.Ctor.options.name || opts.tag)
}

function matches (pattern, name) {
  if (Array.isArray(pattern)) {
    return pattern.indexOf(name) > -1
  } else if (typeof pattern === 'string') {
    return pattern.split(',').indexOf(name) > -1
  } else if (isRegExp(pattern)) {
    return pattern.test(name)
  }
  /* istanbul ignore next */
  return false
}

function pruneCache (cache, current, filter) {
  for (var key in cache) {
    var cachedNode = cache[key];
    if (cachedNode) {
      var name = getComponentName(cachedNode.componentOptions);
      if (name && !filter(name)) {
        if (cachedNode !== current) {
          pruneCacheEntry(cachedNode);
        }
        cache[key] = null;
      }
    }
  }
}

function pruneCacheEntry (vnode) {
  if (vnode) {
    vnode.componentInstance.$destroy();
  }
}

var KeepAlive = {
  name: 'keep-alive',
  abstract: true,

  props: {
    include: patternTypes,
    exclude: patternTypes
  },

  created: function created () {
    this.cache = Object.create(null);
  },

  destroyed: function destroyed () {
    var this$1 = this;

    for (var key in this$1.cache) {
      pruneCacheEntry(this$1.cache[key]);
    }
  },

  watch: {
    include: function include (val) {
      pruneCache(this.cache, this._vnode, function (name) { return matches(val, name); });
    },
    exclude: function exclude (val) {
      pruneCache(this.cache, this._vnode, function (name) { return !matches(val, name); });
    }
  },

  render: function render () {
    var vnode = getFirstComponentChild(this.$slots.default);
    var componentOptions = vnode && vnode.componentOptions;
    if (componentOptions) {
      // check pattern
      var name = getComponentName(componentOptions);
      if (name && (
        (this.include && !matches(this.include, name)) ||
        (this.exclude && matches(this.exclude, name))
      )) {
        return vnode
      }
      var key = vnode.key == null
        // same constructor may get registered as different local components
        // so cid alone is not enough (#3269)
        ? componentOptions.Ctor.cid + (componentOptions.tag ? ("::" + (componentOptions.tag)) : '')
        : vnode.key;
      if (this.cache[key]) {
        vnode.componentInstance = this.cache[key].componentInstance;
      } else {
        this.cache[key] = vnode;
      }
      vnode.data.keepAlive = true;
    }
    return vnode
  }
};

var builtInComponents = {
  KeepAlive: KeepAlive
};

/*  */

function initGlobalAPI (Vue) {
  // config
  var configDef = {};
  configDef.get = function () { return config; };
  Object.defineProperty(Vue, 'config', configDef);

  // exposed util methods.
  // NOTE: these are not considered part of the public API - avoid relying on
  // them unless you are aware of the risk.
  Vue.util = {
    warn: warn,
    extend: extend,
    mergeOptions: mergeOptions,
    defineReactive: defineReactive$$1
  };

  Vue.set = set;
  Vue.delete = del;
  Vue.nextTick = nextTick;

  Vue.options = Object.create(null);
  ASSET_TYPES.forEach(function (type) {
    Vue.options[type + 's'] = Object.create(null);
  });

  // this is used to identify the "base" constructor to extend all plain-object
  // components with in Weex's multi-instance scenarios.
  Vue.options._base = Vue;

  extend(Vue.options.components, builtInComponents);

  initUse(Vue);
  initMixin$1(Vue);
  initExtend(Vue);
  initAssetRegisters(Vue);
}

initGlobalAPI(Vue$3);

Object.defineProperty(Vue$3.prototype, '$isServer', {
  get: isServerRendering
});

Object.defineProperty(Vue$3.prototype, '$ssrContext', {
  get: function get () {
    /* istanbul ignore next */
    return this.$vnode && this.$vnode.ssrContext
  }
});

Vue$3.version = '2.4.1';
Vue$3.mpvueVersion = '2.0.6';

/* globals renderer */



var isReservedTag = makeMap(
  'template,script,style,element,content,slot,link,meta,svg,view,' +
  'a,div,img,image,text,span,richtext,input,switch,textarea,spinner,select,' +
  'slider,slider-neighbor,indicator,trisition,trisition-group,canvas,' +
  'list,cell,header,loading,loading-indicator,refresh,scrollable,scroller,' +
  'video,web,embed,tabbar,tabheader,datepicker,timepicker,marquee,countdown',
  true
);

// these are reserved for web because they are directly compiled away
// during template compilation
var isReservedAttr = makeMap('style,class');

// Elements that you can, intentionally, leave open (and which close themselves)
// more flexable than web
var canBeLeftOpenTag = makeMap(
  'web,spinner,switch,video,textarea,canvas,' +
  'indicator,marquee,countdown',
  true
);

var isUnaryTag = makeMap(
  'embed,img,image,input,link,meta',
  true
);

function mustUseProp () { /* console.log('mustUseProp') */ }
function getTagNamespace () { /* console.log('getTagNamespace') */ }
function isUnknownElement () { /* console.log('isUnknownElement') */ }



function getComKey (vm) {
  return vm && vm.$attrs ? vm.$attrs['mpcomid'] : '0'
}

// 用于小程序的 event type 到 web 的 event
var eventTypeMap = {
  tap: ['tap', 'click'],
  touchstart: ['touchstart'],
  touchmove: ['touchmove'],
  touchcancel: ['touchcancel'],
  touchend: ['touchend'],
  longtap: ['longtap'],
  input: ['input'],
  blur: ['change', 'blur'],
  submit: ['submit'],
  focus: ['focus'],
  scrolltoupper: ['scrolltoupper'],
  scrolltolower: ['scrolltolower'],
  scroll: ['scroll']
};

/*  */

// import { namespaceMap } from 'mp/util/index'

var obj = {};

function createElement$1 (tagName, vnode) {
  return obj
}

function createElementNS (namespace, tagName) {
  return obj
}

function createTextNode (text) {
  return obj
}

function createComment (text) {
  return obj
}

function insertBefore (parentNode, newNode, referenceNode) {}

function removeChild (node, child) {}

function appendChild (node, child) {}

function parentNode (node) {
  return obj
}

function nextSibling (node) {
  return obj
}

function tagName (node) {
  return 'div'
}

function setTextContent (node, text) {
  return obj
}

function setAttribute (node, key, val) {
  return obj
}


var nodeOps = Object.freeze({
	createElement: createElement$1,
	createElementNS: createElementNS,
	createTextNode: createTextNode,
	createComment: createComment,
	insertBefore: insertBefore,
	removeChild: removeChild,
	appendChild: appendChild,
	parentNode: parentNode,
	nextSibling: nextSibling,
	tagName: tagName,
	setTextContent: setTextContent,
	setAttribute: setAttribute
});

/*  */

var ref = {
  create: function create (_, vnode) {
    registerRef(vnode);
  },
  update: function update (oldVnode, vnode) {
    if (oldVnode.data.ref !== vnode.data.ref) {
      registerRef(oldVnode, true);
      registerRef(vnode);
    }
  },
  destroy: function destroy (vnode) {
    registerRef(vnode, true);
  }
};

function registerRef (vnode, isRemoval) {
  var key = vnode.data.ref;
  if (!key) { return }

  var vm = vnode.context;
  var ref = vnode.componentInstance || vnode.elm;
  var refs = vm.$refs;
  if (isRemoval) {
    if (Array.isArray(refs[key])) {
      remove(refs[key], ref);
    } else if (refs[key] === ref) {
      refs[key] = undefined;
    }
  } else {
    if (vnode.data.refInFor) {
      if (!Array.isArray(refs[key])) {
        refs[key] = [ref];
      } else if (refs[key].indexOf(ref) < 0) {
        // $flow-disable-line
        refs[key].push(ref);
      }
    } else {
      refs[key] = ref;
    }
  }
}

/**
 * Virtual DOM patching algorithm based on Snabbdom by
 * Simon Friis Vindum (@paldepind)
 * Licensed under the MIT License
 * https://github.com/paldepind/snabbdom/blob/master/LICENSE
 *
 * modified by Evan You (@yyx990803)
 *

/*
 * Not type-checking this because this file is perf-critical and the cost
 * of making flow understand it is not worth it.
 */

var emptyNode = new VNode('', {}, []);

var hooks = ['create', 'activate', 'update', 'remove', 'destroy'];

function sameVnode (a, b) {
  return (
    a.key === b.key && (
      (
        a.tag === b.tag &&
        a.isComment === b.isComment &&
        isDef(a.data) === isDef(b.data) &&
        sameInputType(a, b)
      ) || (
        isTrue(a.isAsyncPlaceholder) &&
        a.asyncFactory === b.asyncFactory &&
        isUndef(b.asyncFactory.error)
      )
    )
  )
}

// Some browsers do not support dynamically changing type for <input>
// so they need to be treated as different nodes
function sameInputType (a, b) {
  if (a.tag !== 'input') { return true }
  var i;
  var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;
  var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;
  return typeA === typeB
}

function createKeyToOldIdx (children, beginIdx, endIdx) {
  var i, key;
  var map = {};
  for (i = beginIdx; i <= endIdx; ++i) {
    key = children[i].key;
    if (isDef(key)) { map[key] = i; }
  }
  return map
}

function createPatchFunction (backend) {
  var i, j;
  var cbs = {};

  var modules = backend.modules;
  var nodeOps = backend.nodeOps;

  for (i = 0; i < hooks.length; ++i) {
    cbs[hooks[i]] = [];
    for (j = 0; j < modules.length; ++j) {
      if (isDef(modules[j][hooks[i]])) {
        cbs[hooks[i]].push(modules[j][hooks[i]]);
      }
    }
  }

  function emptyNodeAt (elm) {
    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm)
  }

  function createRmCb (childElm, listeners) {
    function remove$$1 () {
      if (--remove$$1.listeners === 0) {
        removeNode(childElm);
      }
    }
    remove$$1.listeners = listeners;
    return remove$$1
  }

  function removeNode (el) {
    var parent = nodeOps.parentNode(el);
    // element may have already been removed due to v-html / v-text
    if (isDef(parent)) {
      nodeOps.removeChild(parent, el);
    }
  }

  var inPre = 0;
  function createElm (vnode, insertedVnodeQueue, parentElm, refElm, nested) {
    vnode.isRootInsert = !nested; // for transition enter check
    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {
      return
    }

    var data = vnode.data;
    var children = vnode.children;
    var tag = vnode.tag;
    if (isDef(tag)) {
      vnode.elm = vnode.ns
        ? nodeOps.createElementNS(vnode.ns, tag)
        : nodeOps.createElement(tag, vnode);
      setScope(vnode);

      /* istanbul ignore if */
      {
        createChildren(vnode, children, insertedVnodeQueue);
        if (isDef(data)) {
          invokeCreateHooks(vnode, insertedVnodeQueue);
        }
        insert(parentElm, vnode.elm, refElm);
      }

      if (false) {
        inPre--;
      }
    } else if (isTrue(vnode.isComment)) {
      vnode.elm = nodeOps.createComment(vnode.text);
      insert(parentElm, vnode.elm, refElm);
    } else {
      vnode.elm = nodeOps.createTextNode(vnode.text);
      insert(parentElm, vnode.elm, refElm);
    }
  }

  function createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {
    var i = vnode.data;
    if (isDef(i)) {
      var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;
      if (isDef(i = i.hook) && isDef(i = i.init)) {
        i(vnode, false /* hydrating */, parentElm, refElm);
      }
      // after calling the init hook, if the vnode is a child component
      // it should've created a child instance and mounted it. the child
      // component also has set the placeholder vnode's elm.
      // in that case we can just return the element and be done.
      if (isDef(vnode.componentInstance)) {
        initComponent(vnode, insertedVnodeQueue);
        if (isTrue(isReactivated)) {
          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);
        }
        return true
      }
    }
  }

  function initComponent (vnode, insertedVnodeQueue) {
    if (isDef(vnode.data.pendingInsert)) {
      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);
      vnode.data.pendingInsert = null;
    }
    vnode.elm = vnode.componentInstance.$el;
    if (isPatchable(vnode)) {
      invokeCreateHooks(vnode, insertedVnodeQueue);
      setScope(vnode);
    } else {
      // empty component root.
      // skip all element-related modules except for ref (#3455)
      registerRef(vnode);
      // make sure to invoke the insert hook
      insertedVnodeQueue.push(vnode);
    }
  }

  function reactivateComponent (vnode, insertedVnodeQueue, parentElm, refElm) {
    var i;
    // hack for #4339: a reactivated component with inner transition
    // does not trigger because the inner node's created hooks are not called
    // again. It's not ideal to involve module-specific logic in here but
    // there doesn't seem to be a better way to do it.
    var innerNode = vnode;
    while (innerNode.componentInstance) {
      innerNode = innerNode.componentInstance._vnode;
      if (isDef(i = innerNode.data) && isDef(i = i.transition)) {
        for (i = 0; i < cbs.activate.length; ++i) {
          cbs.activate[i](emptyNode, innerNode);
        }
        insertedVnodeQueue.push(innerNode);
        break
      }
    }
    // unlike a newly created component,
    // a reactivated keep-alive component doesn't insert itself
    insert(parentElm, vnode.elm, refElm);
  }

  function insert (parent, elm, ref$$1) {
    if (isDef(parent)) {
      if (isDef(ref$$1)) {
        if (ref$$1.parentNode === parent) {
          nodeOps.insertBefore(parent, elm, ref$$1);
        }
      } else {
        nodeOps.appendChild(parent, elm);
      }
    }
  }

  function createChildren (vnode, children, insertedVnodeQueue) {
    if (Array.isArray(children)) {
      for (var i = 0; i < children.length; ++i) {
        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true);
      }
    } else if (isPrimitive(vnode.text)) {
      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(vnode.text));
    }
  }

  function isPatchable (vnode) {
    while (vnode.componentInstance) {
      vnode = vnode.componentInstance._vnode;
    }
    return isDef(vnode.tag)
  }

  function invokeCreateHooks (vnode, insertedVnodeQueue) {
    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
      cbs.create[i$1](emptyNode, vnode);
    }
    i = vnode.data.hook; // Reuse variable
    if (isDef(i)) {
      if (isDef(i.create)) { i.create(emptyNode, vnode); }
      if (isDef(i.insert)) { insertedVnodeQueue.push(vnode); }
    }
  }

  // set scope id attribute for scoped CSS.
  // this is implemented as a special case to avoid the overhead
  // of going through the normal attribute patching process.
  function setScope (vnode) {
    var i;
    var ancestor = vnode;
    while (ancestor) {
      if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {
        nodeOps.setAttribute(vnode.elm, i, '');
      }
      ancestor = ancestor.parent;
    }
    // for slot content they should also get the scopeId from the host instance.
    if (isDef(i = activeInstance) &&
      i !== vnode.context &&
      isDef(i = i.$options._scopeId)
    ) {
      nodeOps.setAttribute(vnode.elm, i, '');
    }
  }

  function addVnodes (parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {
    for (; startIdx <= endIdx; ++startIdx) {
      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm);
    }
  }

  function invokeDestroyHook (vnode) {
    var i, j;
    var data = vnode.data;
    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.destroy)) { i(vnode); }
      for (i = 0; i < cbs.destroy.length; ++i) { cbs.destroy[i](vnode); }
    }
    if (isDef(i = vnode.children)) {
      for (j = 0; j < vnode.children.length; ++j) {
        invokeDestroyHook(vnode.children[j]);
      }
    }
  }

  function removeVnodes (parentElm, vnodes, startIdx, endIdx) {
    for (; startIdx <= endIdx; ++startIdx) {
      var ch = vnodes[startIdx];
      if (isDef(ch)) {
        if (isDef(ch.tag)) {
          removeAndInvokeRemoveHook(ch);
          invokeDestroyHook(ch);
        } else { // Text node
          removeNode(ch.elm);
        }
      }
    }
  }

  function removeAndInvokeRemoveHook (vnode, rm) {
    if (isDef(rm) || isDef(vnode.data)) {
      var i;
      var listeners = cbs.remove.length + 1;
      if (isDef(rm)) {
        // we have a recursively passed down rm callback
        // increase the listeners count
        rm.listeners += listeners;
      } else {
        // directly removing
        rm = createRmCb(vnode.elm, listeners);
      }
      // recursively invoke hooks on child component root node
      if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {
        removeAndInvokeRemoveHook(i, rm);
      }
      for (i = 0; i < cbs.remove.length; ++i) {
        cbs.remove[i](vnode, rm);
      }
      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {
        i(vnode, rm);
      } else {
        rm();
      }
    } else {
      removeNode(vnode.elm);
    }
  }

  function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {
    var oldStartIdx = 0;
    var newStartIdx = 0;
    var oldEndIdx = oldCh.length - 1;
    var oldStartVnode = oldCh[0];
    var oldEndVnode = oldCh[oldEndIdx];
    var newEndIdx = newCh.length - 1;
    var newStartVnode = newCh[0];
    var newEndVnode = newCh[newEndIdx];
    var oldKeyToIdx, idxInOld, elmToMove, refElm;

    // removeOnly is a special flag used only by <transition-group>
    // to ensure removed elements stay in correct relative positions
    // during leaving transitions
    var canMove = !removeOnly;

    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
      if (isUndef(oldStartVnode)) {
        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left
      } else if (isUndef(oldEndVnode)) {
        oldEndVnode = oldCh[--oldEndIdx];
      } else if (sameVnode(oldStartVnode, newStartVnode)) {
        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);
        oldStartVnode = oldCh[++oldStartIdx];
        newStartVnode = newCh[++newStartIdx];
      } else if (sameVnode(oldEndVnode, newEndVnode)) {
        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);
        oldEndVnode = oldCh[--oldEndIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right
        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);
        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));
        oldStartVnode = oldCh[++oldStartIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left
        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);
        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
        oldEndVnode = oldCh[--oldEndIdx];
        newStartVnode = newCh[++newStartIdx];
      } else {
        if (isUndef(oldKeyToIdx)) { oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx); }
        idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : null;
        if (isUndef(idxInOld)) { // New element
          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);
          newStartVnode = newCh[++newStartIdx];
        } else {
          elmToMove = oldCh[idxInOld];
          /* istanbul ignore if */
          if (false) {
            warn(
              'It seems there are duplicate keys that is causing an update error. ' +
              'Make sure each v-for item has a unique key.'
            );
          }
          if (sameVnode(elmToMove, newStartVnode)) {
            patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);
            oldCh[idxInOld] = undefined;
            canMove && nodeOps.insertBefore(parentElm, elmToMove.elm, oldStartVnode.elm);
            newStartVnode = newCh[++newStartIdx];
          } else {
            // same key but different element. treat as new element
            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);
            newStartVnode = newCh[++newStartIdx];
          }
        }
      }
    }
    if (oldStartIdx > oldEndIdx) {
      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;
      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
    } else if (newStartIdx > newEndIdx) {
      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
    }
  }

  function patchVnode (oldVnode, vnode, insertedVnodeQueue, removeOnly) {
    if (oldVnode === vnode) {
      return
    }

    var elm = vnode.elm = oldVnode.elm;

    if (isTrue(oldVnode.isAsyncPlaceholder)) {
      if (isDef(vnode.asyncFactory.resolved)) {
        hydrate(oldVnode.elm, vnode, insertedVnodeQueue);
      } else {
        vnode.isAsyncPlaceholder = true;
      }
      return
    }

    // reuse element for static trees.
    // note we only do this if the vnode is cloned -
    // if the new node is not cloned it means the render functions have been
    // reset by the hot-reload-api and we need to do a proper re-render.
    if (isTrue(vnode.isStatic) &&
      isTrue(oldVnode.isStatic) &&
      vnode.key === oldVnode.key &&
      (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))
    ) {
      vnode.componentInstance = oldVnode.componentInstance;
      return
    }

    var i;
    var data = vnode.data;
    if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {
      i(oldVnode, vnode);
    }

    var oldCh = oldVnode.children;
    var ch = vnode.children;
    if (isDef(data) && isPatchable(vnode)) {
      for (i = 0; i < cbs.update.length; ++i) { cbs.update[i](oldVnode, vnode); }
      if (isDef(i = data.hook) && isDef(i = i.update)) { i(oldVnode, vnode); }
    }
    if (isUndef(vnode.text)) {
      if (isDef(oldCh) && isDef(ch)) {
        if (oldCh !== ch) { updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly); }
      } else if (isDef(ch)) {
        if (isDef(oldVnode.text)) { nodeOps.setTextContent(elm, ''); }
        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
      } else if (isDef(oldCh)) {
        removeVnodes(elm, oldCh, 0, oldCh.length - 1);
      } else if (isDef(oldVnode.text)) {
        nodeOps.setTextContent(elm, '');
      }
    } else if (oldVnode.text !== vnode.text) {
      nodeOps.setTextContent(elm, vnode.text);
    }
    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.postpatch)) { i(oldVnode, vnode); }
    }
  }

  function invokeInsertHook (vnode, queue, initial) {
    // delay insert hooks for component root nodes, invoke them after the
    // element is really inserted
    if (isTrue(initial) && isDef(vnode.parent)) {
      vnode.parent.data.pendingInsert = queue;
    } else {
      for (var i = 0; i < queue.length; ++i) {
        queue[i].data.hook.insert(queue[i]);
      }
    }
  }

  var bailed = false;
  // list of modules that can skip create hook during hydration because they
  // are already rendered on the client or has no need for initialization
  var isRenderedModule = makeMap('attrs,style,class,staticClass,staticStyle,key');

  // Note: this is a browser-only function so we can assume elms are DOM nodes.
  function hydrate (elm, vnode, insertedVnodeQueue) {
    if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {
      vnode.elm = elm;
      vnode.isAsyncPlaceholder = true;
      return true
    }
    vnode.elm = elm;
    var tag = vnode.tag;
    var data = vnode.data;
    var children = vnode.children;
    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.init)) { i(vnode, true /* hydrating */); }
      if (isDef(i = vnode.componentInstance)) {
        // child component. it should have hydrated its own tree.
        initComponent(vnode, insertedVnodeQueue);
        return true
      }
    }
    if (isDef(tag)) {
      if (isDef(children)) {
        // empty element, allow client to pick up and populate children
        if (!elm.hasChildNodes()) {
          createChildren(vnode, children, insertedVnodeQueue);
        } else {
          var childrenMatch = true;
          var childNode = elm.firstChild;
          for (var i$1 = 0; i$1 < children.length; i$1++) {
            if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue)) {
              childrenMatch = false;
              break
            }
            childNode = childNode.nextSibling;
          }
          // if childNode is not null, it means the actual childNodes list is
          // longer than the virtual children list.
          if (!childrenMatch || childNode) {
            if (false
            ) {
              bailed = true;
              console.warn('Parent: ', elm);
              console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);
            }
            return false
          }
        }
      }
      if (isDef(data)) {
        for (var key in data) {
          if (!isRenderedModule(key)) {
            invokeCreateHooks(vnode, insertedVnodeQueue);
            break
          }
        }
      }
    } else if (elm.data !== vnode.text) {
      elm.data = vnode.text;
    }
    return true
  }

  return function patch (oldVnode, vnode, hydrating, removeOnly, parentElm, refElm) {
    if (isUndef(vnode)) {
      if (isDef(oldVnode)) { invokeDestroyHook(oldVnode); }
      return
    }

    var isInitialPatch = false;
    var insertedVnodeQueue = [];

    if (isUndef(oldVnode)) {
      // empty mount (likely as component), create new root element
      isInitialPatch = true;
      createElm(vnode, insertedVnodeQueue, parentElm, refElm);
    } else {
      var isRealElement = isDef(oldVnode.nodeType);
      if (!isRealElement && sameVnode(oldVnode, vnode)) {
        // patch existing root node
        patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly);
      } else {
        if (isRealElement) {
          // mounting to a real element
          // check if this is server-rendered content and if we can perform
          // a successful hydration.
          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {
            oldVnode.removeAttribute(SSR_ATTR);
            hydrating = true;
          }
          if (isTrue(hydrating)) {
            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {
              invokeInsertHook(vnode, insertedVnodeQueue, true);
              return oldVnode
            } else {}
          }
          // either not server-rendered, or hydration failed.
          // create an empty node and replace it
          oldVnode = emptyNodeAt(oldVnode);
        }
        // replacing existing element
        var oldElm = oldVnode.elm;
        var parentElm$1 = nodeOps.parentNode(oldElm);
        createElm(
          vnode,
          insertedVnodeQueue,
          // extremely rare edge case: do not insert if old element is in a
          // leaving transition. Only happens when combining transition +
          // keep-alive + HOCs. (#4590)
          oldElm._leaveCb ? null : parentElm$1,
          nodeOps.nextSibling(oldElm)
        );

        if (isDef(vnode.parent)) {
          // component root element replaced.
          // update parent placeholder node element, recursively
          var ancestor = vnode.parent;
          while (ancestor) {
            ancestor.elm = vnode.elm;
            ancestor = ancestor.parent;
          }
          if (isPatchable(vnode)) {
            for (var i = 0; i < cbs.create.length; ++i) {
              cbs.create[i](emptyNode, vnode.parent);
            }
          }
        }

        if (isDef(parentElm$1)) {
          removeVnodes(parentElm$1, [oldVnode], 0, 0);
        } else if (isDef(oldVnode.tag)) {
          invokeDestroyHook(oldVnode);
        }
      }
    }

    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);
    return vnode.elm
  }
}

/*  */

// import baseModules from 'core/vdom/modules/index'
// const platformModules = []
// import platformModules from 'web/runtime/modules/index'

// the directive module should be applied last, after all
// built-in modules have been applied.
// const modules = platformModules.concat(baseModules)
var modules = [ref];

var corePatch = createPatchFunction({ nodeOps: nodeOps, modules: modules });

function patch () {
  corePatch.apply(this, arguments);
  this.$updateDataToMP();
}

function callHook$1 (vm, hook, params) {
  var handlers = vm.$options[hook];
  if (hook === 'onError' && handlers) {
    handlers = [handlers];
  } else if (hook === 'onPageNotFound' && handlers) {
    handlers = [handlers];
  }

  var ret;
  if (handlers) {
    for (var i = 0, j = handlers.length; i < j; i++) {
      try {
        ret = handlers[i].call(vm, params);
      } catch (e) {
        handleError(e, vm, (hook + " hook"));
      }
    }
  }
  if (vm._hasHookEvent) {
    vm.$emit('hook:' + hook);
  }

  // for child
  if (vm.$children.length) {
    vm.$children.forEach(function (v) { return callHook$1(v, hook, params); });
  }

  return ret
}

// mpType 小程序实例的类型，可能的值是 'app', 'page'
// rootVueVM 是 vue 的根组件实例，子组件中访问 this.$root 可得
function getGlobalData (app, rootVueVM) {
  var mp = rootVueVM.$mp;
  if (app && app.globalData) {
    mp.appOptions = app.globalData.appOptions;
  }
}

// 格式化 properties 属性，并给每个属性加上 observer 方法

// properties 的 一些类型 https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/component.html
// properties: {
//   paramA: Number,
//   myProperty: { // 属性名
//     type: String, // 类型（必填），目前接受的类型包括：String, Number, Boolean, Object, Array, null（表示任意类型）
//     value: '', // 属性初始值（可选），如果未指定则会根据类型选择一个
//     observer: function(newVal, oldVal, changedPath) {
//        // 属性被改变时执行的函数（可选），也可以写成在methods段中定义的方法名字符串, 如：'_propertyChange'
//        // 通常 newVal 就是新设置的数据， oldVal 是旧数据
//     }
//   },
// }

// props 的一些类型 https://cn.vuejs.org/v2/guide/components-props.html#ad
// props: {
//   // 基础的类型检查 (`null` 匹配任何类型)
//   propA: Number,
//   // 多个可能的类型
//   propB: [String, Number],
//   // 必填的字符串
//   propC: {
//     type: String,
//     required: true
//   },
//   // 带有默认值的数字
//   propD: {
//     type: Number,
//     default: 100
//   },
//   // 带有默认值的对象
//   propE: {
//     type: Object,
//     // 对象或数组且一定会从一个工厂函数返回默认值
//     default: function () {
//       return { message: 'hello' }
//     }
//   },
//   // 自定义验证函数
//   propF: {
//     validator: function (value) {
//       // 这个值必须匹配下列字符串中的一个
//       return ['success', 'warning', 'danger'].indexOf(value) !== -1
//     }
//   }
// }

// core/util/options
function normalizeProps$1 (props, res, vm) {
  if (!props) { return }
  var i, val, name;
  if (Array.isArray(props)) {
    i = props.length;
    while (i--) {
      val = props[i];
      if (typeof val === 'string') {
        name = camelize(val);
        res[name] = { type: null };
      } else {}
    }
  } else if (isPlainObject(props)) {
    for (var key in props) {
      val = props[key];
      name = camelize(key);
      res[name] = isPlainObject(val)
        ? val
        : { type: val };
    }
  }

  // fix vueProps to properties
  for (var key$1 in res) {
    if (res.hasOwnProperty(key$1)) {
      var item = res[key$1];
      if (item.default) {
        item.value = item.default;
      }
      var oldObserver = item.observer;
      item.observer = function (newVal, oldVal) {
        vm[name] = newVal;
        // 先修改值再触发原始的 observer，跟 watch 行为保持一致
        if (typeof oldObserver === 'function') {
          oldObserver.call(vm, newVal, oldVal);
        }
      };
    }
  }

  return res
}

function normalizeProperties (vm) {
  var properties = vm.$options.properties;
  var vueProps = vm.$options.props;
  var res = {};

  normalizeProps$1(properties, res, vm);
  normalizeProps$1(vueProps, res, vm);

  return res
}

/**
 * 把 properties 中的属性 proxy 到 vm 上
 */
function initMpProps (vm) {
  var mpProps = vm._mpProps = {};
  var keys = Object.keys(vm.$options.properties || {});
  keys.forEach(function (key) {
    if (!(key in vm)) {
      proxy(vm, '_mpProps', key);
      mpProps[key] = undefined; // for observe
    }
  });
  observe(mpProps, true);
}

function initMP (mpType, next) {
  var rootVueVM = this.$root;
  if (!rootVueVM.$mp) {
    rootVueVM.$mp = {};
  }

  var mp = rootVueVM.$mp;

  // Please do not register multiple Pages
  // if (mp.registered) {
  if (mp.status) {
    // 处理子组件的小程序生命周期
    if (mpType === 'app') {
      callHook$1(this, 'onLaunch', mp.appOptions);
    } else {
      callHook$1(this, 'onLoad', mp.query);
      callHook$1(this, 'onReady');
    }
    return next()
  }
  // mp.registered = true

  mp.mpType = mpType;
  mp.status = 'register';

  if (mpType === 'app') {
    global.App({
      // 页面的初始数据
      globalData: {
        appOptions: {}
      },

      handleProxy: function handleProxy (e) {
        return rootVueVM.$handleProxyWithVue(e)
      },

      // Do something initial when launch.
      onLaunch: function onLaunch (options) {
        if ( options === void 0 ) options = {};

        mp.app = this;
        mp.status = 'launch';
        this.globalData.appOptions = mp.appOptions = options;
        callHook$1(rootVueVM, 'onLaunch', options);
        next();
      },

      // Do something when app show.
      onShow: function onShow (options) {
        if ( options === void 0 ) options = {};

        mp.status = 'show';
        this.globalData.appOptions = mp.appOptions = options;
        callHook$1(rootVueVM, 'onShow', options);
      },

      // Do something when app hide.
      onHide: function onHide () {
        mp.status = 'hide';
        callHook$1(rootVueVM, 'onHide');
      },

      onError: function onError (err) {
        callHook$1(rootVueVM, 'onError', err);
      },

      onPageNotFound: function onPageNotFound (err) {
        callHook$1(rootVueVM, 'onPageNotFound', err);
      }
    });
  } else if (mpType === 'component') {
    initMpProps(rootVueVM);

    global.Component({
      // 小程序原生的组件属性
      properties: normalizeProperties(rootVueVM),
      // 页面的初始数据
      data: {
        $root: {}
      },
      methods: {
        handleProxy: function handleProxy (e) {
          return rootVueVM.$handleProxyWithVue(e)
        }
      },
      // mp lifecycle for vue
      // 组件生命周期函数，在组件实例进入页面节点树时执行，注意此时不能调用 setData
      created: function created () {
        mp.status = 'created';
        mp.page = this;
      },
      // 组件生命周期函数，在组件实例进入页面节点树时执行
      attached: function attached () {
        mp.status = 'attached';
        callHook$1(rootVueVM, 'attached');
      },
      // 组件生命周期函数，在组件布局完成后执行，此时可以获取节点信息（使用 SelectorQuery ）
      ready: function ready () {
        mp.status = 'ready';

        callHook$1(rootVueVM, 'ready');
        next();

        // 只有页面需要 setData
        rootVueVM.$nextTick(function () {
          rootVueVM._initDataToMP();
        });
      },
      // 组件生命周期函数，在组件实例被移动到节点树另一个位置时执行
      moved: function moved () {
        callHook$1(rootVueVM, 'moved');
      },
      // 组件生命周期函数，在组件实例被从页面节点树移除时执行
      detached: function detached () {
        mp.status = 'detached';
        callHook$1(rootVueVM, 'detached');
      }
    });
  } else {
    var app = global.getApp();
    global.Page({
      // 页面的初始数据
      data: {
        $root: {}
      },

      handleProxy: function handleProxy (e) {
        return rootVueVM.$handleProxyWithVue(e)
      },

      // mp lifecycle for vue
      // 生命周期函数--监听页面加载
      onLoad: function onLoad (query) {
        mp.page = this;
        mp.query = query;
        mp.status = 'load';
        getGlobalData(app, rootVueVM);
        callHook$1(rootVueVM, 'onLoad', query);
      },

      // 生命周期函数--监听页面显示
      onShow: function onShow () {
        mp.page = this;
        mp.status = 'show';
        callHook$1(rootVueVM, 'onShow');

        // 只有页面需要 setData
        rootVueVM.$nextTick(function () {
          rootVueVM._initDataToMP();
        });
      },

      // 生命周期函数--监听页面初次渲染完成
      onReady: function onReady () {
        mp.status = 'ready';

        callHook$1(rootVueVM, 'onReady');
        next();
      },

      // 生命周期函数--监听页面隐藏
      onHide: function onHide () {
        mp.status = 'hide';
        callHook$1(rootVueVM, 'onHide');
        mp.page = null;
      },

      // 生命周期函数--监听页面卸载
      onUnload: function onUnload () {
        mp.status = 'unload';
        callHook$1(rootVueVM, 'onUnload');
        mp.page = null;
      },

      // 页面相关事件处理函数--监听用户下拉动作
      onPullDownRefresh: function onPullDownRefresh () {
        callHook$1(rootVueVM, 'onPullDownRefresh');
      },

      // 页面上拉触底事件的处理函数
      onReachBottom: function onReachBottom () {
        callHook$1(rootVueVM, 'onReachBottom');
      },

      // 用户点击右上角分享
      onShareAppMessage: rootVueVM.$options.onShareAppMessage
        ? function (options) { return callHook$1(rootVueVM, 'onShareAppMessage', options); } : null,

      // Do something when page scroll
      onPageScroll: function onPageScroll (options) {
        callHook$1(rootVueVM, 'onPageScroll', options);
      },

      // 当前是 tab 页时，点击 tab 时触发
      onTabItemTap: function onTabItemTap (options) {
        callHook$1(rootVueVM, 'onTabItemTap', options);
      }
    });
  }
}

var updateDataTotal = 0; // 总共更新的数据量
function diffLog (updateData) {
  updateData = JSON.stringify(updateData);
  if (!Vue$3._mpvueTraceTimer) {
    Vue$3._mpvueTraceTimer = setTimeout(function () {
      clearTimeout(Vue$3._mpvueTraceTimer);
      updateDataTotal = (updateDataTotal / 1024).toFixed(1);
      console.log('这次操作引发500ms内数据更新量:' + updateDataTotal + 'kb');
      Vue$3._mpvueTraceTimer = 0;
      updateDataTotal = 0;
    }, 500);
  } else if (Vue$3._mpvueTraceTimer) {
    updateData = updateData.replace(/[^\u0000-\u00ff]/g, 'aa'); // 中文占2字节，中文替换成两个字母计算占用空间
    updateDataTotal += updateData.length;
  }
}

var KEY_SEP$1 = '_';

function getDeepData (keyList, viewData) {
  if (keyList.length > 1) {
    var _key = keyList.splice(0, 1);
    var _viewData = viewData[_key];
    if (_viewData) {
      return getDeepData(keyList, _viewData)
    } else {
      return null
    }
  } else {
    if (viewData[keyList[0]]) {
      return viewData[keyList[0]]
    } else {
      return null
    }
  }
}

function compareAndSetDeepData (key, newData, vm, data, forceUpdate) {
  // 比较引用类型数据
  try {
    var keyList = key.split('.');
    // page.__viewData__老版小程序不存在，使用mpvue里绑的data比对
    var oldData = getDeepData(keyList, vm.$root.$mp.page.data);
    if (oldData === null || JSON.stringify(oldData) !== JSON.stringify(newData) || forceUpdate) {
      data[key] = newData;
    } else {
      var keys = Object.keys(oldData);
      keys.forEach(function (_key) {
        var properties = Object.getOwnPropertyDescriptor(oldData, _key);
        if (!properties['get'] && !properties['set']) {
          data[key + '.' + _key] = newData[_key];
        }
      });
    }
  } catch (e) {
    console.log(e, key, newData, vm);
  }
}

function cleanKeyPath (vm) {
  if (vm.__mpKeyPath) {
    Object.keys(vm.__mpKeyPath).forEach(function (_key) {
      delete vm.__mpKeyPath[_key]['__keyPath'];
    });
  }
}

function minifyDeepData (rootKey, originKey, vmData, data, _mpValueSet, vm) {
  try {
    if (vmData instanceof Array) {
       // 数组
      compareAndSetDeepData(rootKey + '.' + originKey, vmData, vm, data, true);
    } else {
      // Object
      var _keyPathOnThis = {}; // 存储这层对象的keyPath
      if (vmData.__keyPath && !vmData.__newReference) {
        // 有更新列表 ，按照更新列表更新
        _keyPathOnThis = vmData.__keyPath;
        Object.keys(vmData).forEach(function (_key) {
          if (vmData[_key] instanceof Object) {
            // 引用类型 递归
            if (_key === '__keyPath') {
              return
            }
            minifyDeepData(rootKey + '.' + originKey, _key, vmData[_key], data, null, vm);
          } else {
            // 更新列表中的 加入data
            if (_keyPathOnThis[_key] === true) {
              if (originKey) {
                data[rootKey + '.' + originKey + '.' + _key] = vmData[_key];
              } else {
                data[rootKey + '.' + _key] = vmData[_key];
              }
            }
          }
        });
         // 根节点可能有父子引用同一个引用类型数据，依赖树都遍历完后清理
        vm['__mpKeyPath'] = vm['__mpKeyPath'] || {};
        vm['__mpKeyPath'][vmData.__ob__.dep.id] = vmData;
      } else {
        // 没有更新列表
        compareAndSetDeepData(rootKey + '.' + originKey, vmData, vm, data);
      }
      // 标记是否是通过this.Obj = {} 赋值印发的改动，解决少更新问题#1305
      def(vmData, '__newReference', false, false);
    }
  } catch (e) {
    console.log(e, rootKey, originKey, vmData, data);
  }
}

function getRootKey (vm, rootKey) {
  if (!vm.$parent.$attrs) {
    rootKey = '$root.0' + KEY_SEP$1 + rootKey;
    return rootKey
  } else {
    rootKey = vm.$parent.$attrs.mpcomid + KEY_SEP$1 + rootKey;
    return getRootKey(vm.$parent, rootKey)
  }
}

function diffData (vm, data) {
  var vmData = vm._data || {};
  var vmProps = vm._props || {};
  var rootKey = '';
  if (!vm.$attrs) {
    rootKey = '$root.0';
  } else {
    rootKey = getRootKey(vm, vm.$attrs.mpcomid);
  }
  Vue$3.nextTick(function () {
    cleanKeyPath(vm);
  });
  // console.log(rootKey)

  // 值类型变量不考虑优化，还是直接更新
  var __keyPathOnThis = vmData.__keyPath || vm.__keyPath || {};
  delete vm.__keyPath;
  delete vmData.__keyPath;
  delete vmProps.__keyPath;
  if (vm._mpValueSet === 'done') {
    // 第二次赋值才进行缩减操作
    Object.keys(vmData).forEach(function (vmDataItemKey) {
      if (vmData[vmDataItemKey] instanceof Object) {
        // 引用类型
        minifyDeepData(rootKey, vmDataItemKey, vmData[vmDataItemKey], data, vm._mpValueSet, vm);
      } else if (vmData[vmDataItemKey] !== undefined) {
        // _data上的值属性只有要更新的时候才赋值
        if (__keyPathOnThis[vmDataItemKey] === true) {
          data[rootKey + '.' + vmDataItemKey] = vmData[vmDataItemKey];
        }
      }
    });

    Object.keys(vmProps).forEach(function (vmPropsItemKey) {
      if (vmProps[vmPropsItemKey] instanceof Object) {
        // 引用类型
        minifyDeepData(rootKey, vmPropsItemKey, vmProps[vmPropsItemKey], data, vm._mpValueSet, vm);
      } else if (vmProps[vmPropsItemKey] !== undefined) {
        data[rootKey + '.' + vmPropsItemKey] = vmProps[vmPropsItemKey];
      }
      // _props上的值属性只有要更新的时候才赋值
    });

    // 检查完data和props,最后补上_mpProps & _computedWatchers
    var vmMpProps = vm._mpProps || {};
    var vmComputedWatchers = vm._computedWatchers || {};
    Object.keys(vmMpProps).forEach(function (mpItemKey) {
      data[rootKey + '.' + mpItemKey] = vm[mpItemKey];
    });
    Object.keys(vmComputedWatchers).forEach(function (computedItemKey) {
      data[rootKey + '.' + computedItemKey] = vm[computedItemKey];
    });
    // 更新的时候要删除$root.0:{},否则会覆盖原正确数据
    delete data[rootKey];
  }
  if (vm._mpValueSet === undefined) {
    // 第一次设置数据成功后，标记位置true,再更新到这个节点如果没有keyPath数组认为不需要更新
    vm._mpValueSet = 'done';
  }
  if (Vue$3.config._mpTrace) {
    // console.log('更新VM节点', vm)
    // console.log('实际传到Page.setData数据', data)
    diffLog(data);
  }
}

// 节流方法，性能优化
// 全局的命名约定，为了节省编译的包大小一律采取形象的缩写，说明如下。
// $c === $child
// $k === $comKey

// 新型的被拍平的数据结构
// {
//   $root: {
//     '1-1'{
//       // ... data
//     },
//     '1.2-1': {
//       // ... data1
//     },
//     '1.2-2': {
//       // ... data2
//     }
//   }
// }

var KEY_SEP = '_';

function getVmData (vm) {
  // 确保当前 vm 所有数据被同步
  var dataKeys = [].concat(
    Object.keys(vm._data || {}),
    Object.keys(vm._props || {}),
    Object.keys(vm._mpProps || {}),
    Object.keys(vm._computedWatchers || {})
  );
  return dataKeys.reduce(function (res, key) {
    res[key] = vm[key];
    return res
  }, {})
}

function getParentComKey (vm, res) {
  if ( res === void 0 ) res = [];

  var ref = vm || {};
  var $parent = ref.$parent;
  if (!$parent) { return res }
  res.unshift(getComKey($parent));
  if ($parent.$parent) {
    return getParentComKey($parent, res)
  }
  return res
}

function formatVmData (vm) {
  var $p = getParentComKey(vm).join(KEY_SEP);
  var $k = $p + ($p ? KEY_SEP : '') + getComKey(vm);

  // getVmData 这儿获取当前组件内的所有数据，包含 props、computed 的数据
  // 改动 vue.runtime 所获的的核心能力
  var data = Object.assign(getVmData(vm), { $k: $k, $kk: ("" + $k + KEY_SEP), $p: $p });
  var key = '$root.' + $k;
  var res = {};
  res[key] = data;
  return res
}

function collectVmData (vm, res) {
  if ( res === void 0 ) res = {};

  var vms = vm.$children;
  if (vms && vms.length) {
    vms.forEach(function (v) { return collectVmData(v, res); });
  }
  return Object.assign(res, formatVmData(vm))
}

/**
 * 频率控制 返回函数连续调用时，func 执行频率限定为 次 / wait
 * 自动合并 data
 *
 * @param  {function}   func      传入函数
 * @param  {number}     wait      表示时间窗口的间隔
 * @param  {object}     options   如果想忽略开始边界上的调用，传入{leading: false}。
 *                                如果想忽略结尾边界上的调用，传入{trailing: false}
 * @return {function}             返回客户调用函数
 */
function throttle (func, wait, options) {
  var context, args, result;
  var timeout = null;
  // 上次执行时间点
  var previous = 0;
  if (!options) { options = {}; }
  // 延迟执行函数
  function later () {
    // 若设定了开始边界不执行选项，上次执行时间始终为0
    previous = options.leading === false ? 0 : Date.now();
    timeout = null;
    result = func.apply(context, args);
    if (!timeout) { context = args = null; }
  }
  return function (handle, data) {
    var now = Date.now();
    // 首次执行时，如果设定了开始边界不执行选项，将上次执行时间设定为当前时间。
    if (!previous && options.leading === false) { previous = now; }
    // 延迟执行时间间隔
    var remaining = wait - (now - previous);
    context = this;
    args = args ? [handle, Object.assign(args[1], data)] : [handle, data];
    // 延迟时间间隔remaining小于等于0，表示上次执行至此所间隔时间已经超过一个时间窗口
    // remaining大于时间窗口wait，表示客户端系统时间被调整过
    if (remaining <= 0 || remaining > wait) {
      clearTimeout(timeout);
      timeout = null;
      previous = now;
      result = func.apply(context, args);
      if (!timeout) { context = args = null; }
    // 如果延迟执行不存在，且没有设定结尾边界不执行选项
    } else if (!timeout && options.trailing !== false) {
      timeout = setTimeout(later, remaining);
    }
    return result
  }
}

// 优化频繁的 setData: https://mp.weixin.qq.com/debug/wxadoc/dev/framework/performance/tips.html
var throttleSetData = throttle(function (handle, data) {
  handle(data);
}, 50);

function getPage (vm) {
  var rootVueVM = vm.$root;
  var ref = rootVueVM.$mp || {};
  var mpType = ref.mpType; if ( mpType === void 0 ) mpType = '';
  var page = ref.page;

  // 优化后台态页面进行 setData: https://mp.weixin.qq.com/debug/wxadoc/dev/framework/performance/tips.html
  if (mpType === 'app' || !page || typeof page.setData !== 'function') {
    return
  }
  return page
}

// 优化js变量动态变化时候引起全量更新
// 优化每次 setData 都传递大量新数据
function updateDataToMP () {
  var page = getPage(this);
  if (!page) {
    return
  }

  var data = formatVmData(this);
  diffData(this, data);
  throttleSetData(page.setData.bind(page), data);
}

function initDataToMP () {
  var page = getPage(this);
  if (!page) {
    return
  }

  var data = collectVmData(this.$root);
  page.setData(data);
}

// 虚拟dom的compid与真实dom的comkey匹配，多层嵌套的先补齐虚拟dom的compid直到完全匹配为止
function isVmKeyMatchedCompkey (k, comkey) {
  if (!k || !comkey) {
    return false
  }
  // 完全匹配 comkey = '1_0_1', k = '1_0_1'
  // 部分匹配 comkey = '1_0_10_1', k = '1_0_10'
  // k + KEY_SEP防止k = '1_0_1'误匹配comkey = '1_0_10_1'
  return comkey === k || comkey.indexOf(k + KEY_SEP$2) === 0
}

function getVM (vm, comkeys) {
  if ( comkeys === void 0 ) comkeys = [];

  var keys = comkeys.slice(1);
  if (!keys.length) { return vm }

  // bugfix #1375: 虚拟dom的compid和真实dom的comkey在组件嵌套时匹配出错，comid会丢失前缀，需要从父节点补充
  var comkey = keys.join(KEY_SEP$2);
  var comidPrefix = '';
  return keys.reduce(function (res, key) {
    var len = res.$children.length;
    for (var i = 0; i < len; i++) {
      var v = res.$children[i];
      var k = getComKey(v);
      if (comidPrefix) {
        k = comidPrefix + KEY_SEP$2 + k;
      }
      // 找到匹配的父节点
      if (isVmKeyMatchedCompkey(k, comkey)) {
        comidPrefix = k;
        res = v;
        return res
      }
    }
    return res
  }, vm)
}

function getHandle (vnode, eventid, eventTypes) {
  if ( eventTypes === void 0 ) eventTypes = [];

  var res = [];
  if (!vnode || !vnode.tag) {
    return res
  }

  var ref = vnode || {};
  var data = ref.data; if ( data === void 0 ) data = {};
  var children = ref.children; if ( children === void 0 ) children = [];
  var componentInstance = ref.componentInstance;
  if (componentInstance) {
    // 增加 slot 情况的处理
    // Object.values 会多增加几行编译后的代码
    Object.keys(componentInstance.$slots).forEach(function (slotKey) {
      var slot = componentInstance.$slots[slotKey];
      var slots = Array.isArray(slot) ? slot : [slot];
      slots.forEach(function (node) {
        res = res.concat(getHandle(node, eventid, eventTypes));
      });
    });
  } else {
    // 避免遍历超出当前组件的 vm
    children.forEach(function (node) {
      res = res.concat(getHandle(node, eventid, eventTypes));
    });
  }

  var attrs = data.attrs;
  var on = data.on;
  if (attrs && on && attrs['eventid'] === eventid) {
    eventTypes.forEach(function (et) {
      var h = on[et];
      if (typeof h === 'function') {
        res.push(h);
      } else if (Array.isArray(h)) {
        res = res.concat(h);
      }
    });
    return res
  }

  return res
}

function getWebEventByMP (e) {
  var type = e.type;
  var timeStamp = e.timeStamp;
  var touches = e.touches;
  var detail = e.detail; if ( detail === void 0 ) detail = {};
  var target = e.target; if ( target === void 0 ) target = {};
  var currentTarget = e.currentTarget; if ( currentTarget === void 0 ) currentTarget = {};
  var x = detail.x;
  var y = detail.y;
  var event = {
    mp: e,
    type: type,
    timeStamp: timeStamp,
    x: x,
    y: y,
    target: Object.assign({}, target, detail),
    currentTarget: currentTarget,
    stopPropagation: noop,
    preventDefault: noop
  };

  if (touches && touches.length) {
    Object.assign(event, touches[0]);
    event.touches = touches;
  }
  return event
}

var KEY_SEP$2 = '_';
function handleProxyWithVue (e) {
  var rootVueVM = this.$root;
  var type = e.type;
  var target = e.target; if ( target === void 0 ) target = {};
  var currentTarget = e.currentTarget;
  var ref = currentTarget || target;
  var dataset = ref.dataset; if ( dataset === void 0 ) dataset = {};
  var comkey = dataset.comkey; if ( comkey === void 0 ) comkey = '';
  var eventid = dataset.eventid;
  var vm = getVM(rootVueVM, comkey.split(KEY_SEP$2));

  if (!vm) {
    return
  }

  var webEventTypes = eventTypeMap[type] || [type];
  var handles = getHandle(vm._vnode, eventid, webEventTypes);

  // TODO, enevt 还需要处理更多
  // https://developer.mozilla.org/zh-CN/docs/Web/API/Event
  if (handles.length) {
    var event = getWebEventByMP(e);
    if (handles.length === 1) {
      var result = handles[0](event);
      return result
    }
    handles.forEach(function (h) { return h(event); });
  }
}

// for platforms
// import config from 'core/config'
// install platform specific utils
Vue$3.config.mustUseProp = mustUseProp;
Vue$3.config.isReservedTag = isReservedTag;
Vue$3.config.isReservedAttr = isReservedAttr;
Vue$3.config.getTagNamespace = getTagNamespace;
Vue$3.config.isUnknownElement = isUnknownElement;

// install platform patch function
Vue$3.prototype.__patch__ = patch;

// public mount method
Vue$3.prototype.$mount = function (el, hydrating) {
  var this$1 = this;

  // el = el && inBrowser ? query(el) : undefined
  // return mountComponent(this, el, hydrating)

  // 初始化小程序生命周期相关
  var options = this.$options;

  if (options && (options.render || options.mpType)) {
    var mpType = options.mpType; if ( mpType === void 0 ) mpType = 'page';
    return this._initMP(mpType, function () {
      return mountComponent(this$1, undefined, undefined)
    })
  } else {
    return mountComponent(this, undefined, undefined)
  }
};

// for mp
Vue$3.prototype._initMP = initMP;

Vue$3.prototype.$updateDataToMP = updateDataToMP;
Vue$3.prototype._initDataToMP = initDataToMP;

Vue$3.prototype.$handleProxyWithVue = handleProxyWithVue;

/*  */

return Vue$3;

})));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26)))

/***/ }),
/* 1 */
/***/ (function(module, exports) {

/* globals __VUE_SSR_CONTEXT__ */

// this module is a runtime utility for cleaner component module output and will
// be included in the final webpack user bundle

module.exports = function normalizeComponent (
  rawScriptExports,
  compiledTemplate,
  injectStyles,
  scopeId,
  moduleIdentifier /* server only */
) {
  var esModule
  var scriptExports = rawScriptExports = rawScriptExports || {}

  // ES6 modules interop
  var type = typeof rawScriptExports.default
  if (type === 'object' || type === 'function') {
    esModule = rawScriptExports
    scriptExports = rawScriptExports.default
  }

  // Vue.extend constructor export interop
  var options = typeof scriptExports === 'function'
    ? scriptExports.options
    : scriptExports

  // render functions
  if (compiledTemplate) {
    options.render = compiledTemplate.render
    options.staticRenderFns = compiledTemplate.staticRenderFns
  }

  // scopedId
  if (scopeId) {
    options._scopeId = scopeId
  }

  var hook
  if (moduleIdentifier) { // server build
    hook = function (context) {
      // 2.3 injection
      context =
        context || // cached call
        (this.$vnode && this.$vnode.ssrContext) || // stateful
        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional
      // 2.2 with runInNewContext: true
      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
        context = __VUE_SSR_CONTEXT__
      }
      // inject component styles
      if (injectStyles) {
        injectStyles.call(this, context)
      }
      // register component module identifier for async chunk inferrence
      if (context && context._registeredComponents) {
        context._registeredComponents.add(moduleIdentifier)
      }
    }
    // used by ssr in case component is cached and beforeCreate
    // never gets called
    options._ssrRegister = hook
  } else if (injectStyles) {
    hook = injectStyles
  }

  if (hook) {
    var functional = options.functional
    var existing = functional
      ? options.render
      : options.beforeCreate
    if (!functional) {
      // inject component registration as beforeCreate hook
      options.beforeCreate = existing
        ? [].concat(existing, hook)
        : [hook]
    } else {
      // register for functioal component in vue file
      options.render = function renderWithStyleInjection (h, context) {
        hook.call(context)
        return existing(h, context)
      }
    }
  }

  return {
    esModule: esModule,
    exports: scriptExports,
    options: options
  }
}


/***/ }),
/* 2 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/* unused harmony export Store */
/* unused harmony export install */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return mapState; });
/* unused harmony export mapMutations */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return mapGetters; });
/* unused harmony export mapActions */
/* unused harmony export createNamespacedHelpers */
/**
 * vuex v3.1.3
 * (c) 2020 Evan You
 * @license MIT
 */
function applyMixin (Vue) {
  var version = Number(Vue.version.split('.')[0]);

  if (version >= 2) {
    Vue.mixin({ beforeCreate: vuexInit });
  } else {
    // override init and inject vuex init procedure
    // for 1.x backwards compatibility.
    var _init = Vue.prototype._init;
    Vue.prototype._init = function (options) {
      if ( options === void 0 ) options = {};

      options.init = options.init
        ? [vuexInit].concat(options.init)
        : vuexInit;
      _init.call(this, options);
    };
  }

  /**
   * Vuex init hook, injected into each instances init hooks list.
   */

  function vuexInit () {
    var options = this.$options;
    // store injection
    if (options.store) {
      this.$store = typeof options.store === 'function'
        ? options.store()
        : options.store;
    } else if (options.parent && options.parent.$store) {
      this.$store = options.parent.$store;
    }
  }
}

var target = typeof window !== 'undefined'
  ? window
  : typeof global !== 'undefined'
    ? global
    : {};
var devtoolHook = target.__VUE_DEVTOOLS_GLOBAL_HOOK__;

function devtoolPlugin (store) {
  if (!devtoolHook) { return }

  store._devtoolHook = devtoolHook;

  devtoolHook.emit('vuex:init', store);

  devtoolHook.on('vuex:travel-to-state', function (targetState) {
    store.replaceState(targetState);
  });

  store.subscribe(function (mutation, state) {
    devtoolHook.emit('vuex:mutation', mutation, state);
  });
}

/**
 * Get the first item that pass the test
 * by second argument function
 *
 * @param {Array} list
 * @param {Function} f
 * @return {*}
 */

/**
 * forEach for object
 */
function forEachValue (obj, fn) {
  Object.keys(obj).forEach(function (key) { return fn(obj[key], key); });
}

function isObject (obj) {
  return obj !== null && typeof obj === 'object'
}

function isPromise (val) {
  return val && typeof val.then === 'function'
}

function assert (condition, msg) {
  if (!condition) { throw new Error(("[vuex] " + msg)) }
}

function partial (fn, arg) {
  return function () {
    return fn(arg)
  }
}

// Base data struct for store's module, package with some attribute and method
var Module = function Module (rawModule, runtime) {
  this.runtime = runtime;
  // Store some children item
  this._children = Object.create(null);
  // Store the origin module object which passed by programmer
  this._rawModule = rawModule;
  var rawState = rawModule.state;

  // Store the origin module's state
  this.state = (typeof rawState === 'function' ? rawState() : rawState) || {};
};

var prototypeAccessors = { namespaced: { configurable: true } };

prototypeAccessors.namespaced.get = function () {
  return !!this._rawModule.namespaced
};

Module.prototype.addChild = function addChild (key, module) {
  this._children[key] = module;
};

Module.prototype.removeChild = function removeChild (key) {
  delete this._children[key];
};

Module.prototype.getChild = function getChild (key) {
  return this._children[key]
};

Module.prototype.update = function update (rawModule) {
  this._rawModule.namespaced = rawModule.namespaced;
  if (rawModule.actions) {
    this._rawModule.actions = rawModule.actions;
  }
  if (rawModule.mutations) {
    this._rawModule.mutations = rawModule.mutations;
  }
  if (rawModule.getters) {
    this._rawModule.getters = rawModule.getters;
  }
};

Module.prototype.forEachChild = function forEachChild (fn) {
  forEachValue(this._children, fn);
};

Module.prototype.forEachGetter = function forEachGetter (fn) {
  if (this._rawModule.getters) {
    forEachValue(this._rawModule.getters, fn);
  }
};

Module.prototype.forEachAction = function forEachAction (fn) {
  if (this._rawModule.actions) {
    forEachValue(this._rawModule.actions, fn);
  }
};

Module.prototype.forEachMutation = function forEachMutation (fn) {
  if (this._rawModule.mutations) {
    forEachValue(this._rawModule.mutations, fn);
  }
};

Object.defineProperties( Module.prototype, prototypeAccessors );

var ModuleCollection = function ModuleCollection (rawRootModule) {
  // register root module (Vuex.Store options)
  this.register([], rawRootModule, false);
};

ModuleCollection.prototype.get = function get (path) {
  return path.reduce(function (module, key) {
    return module.getChild(key)
  }, this.root)
};

ModuleCollection.prototype.getNamespace = function getNamespace (path) {
  var module = this.root;
  return path.reduce(function (namespace, key) {
    module = module.getChild(key);
    return namespace + (module.namespaced ? key + '/' : '')
  }, '')
};

ModuleCollection.prototype.update = function update$1 (rawRootModule) {
  update([], this.root, rawRootModule);
};

ModuleCollection.prototype.register = function register (path, rawModule, runtime) {
    var this$1 = this;
    if ( runtime === void 0 ) runtime = true;

  if (true) {
    assertRawModule(path, rawModule);
  }

  var newModule = new Module(rawModule, runtime);
  if (path.length === 0) {
    this.root = newModule;
  } else {
    var parent = this.get(path.slice(0, -1));
    parent.addChild(path[path.length - 1], newModule);
  }

  // register nested modules
  if (rawModule.modules) {
    forEachValue(rawModule.modules, function (rawChildModule, key) {
      this$1.register(path.concat(key), rawChildModule, runtime);
    });
  }
};

ModuleCollection.prototype.unregister = function unregister (path) {
  var parent = this.get(path.slice(0, -1));
  var key = path[path.length - 1];
  if (!parent.getChild(key).runtime) { return }

  parent.removeChild(key);
};

function update (path, targetModule, newModule) {
  if (true) {
    assertRawModule(path, newModule);
  }

  // update target module
  targetModule.update(newModule);

  // update nested modules
  if (newModule.modules) {
    for (var key in newModule.modules) {
      if (!targetModule.getChild(key)) {
        if (true) {
          console.warn(
            "[vuex] trying to add a new module '" + key + "' on hot reloading, " +
            'manual reload is needed'
          );
        }
        return
      }
      update(
        path.concat(key),
        targetModule.getChild(key),
        newModule.modules[key]
      );
    }
  }
}

var functionAssert = {
  assert: function (value) { return typeof value === 'function'; },
  expected: 'function'
};

var objectAssert = {
  assert: function (value) { return typeof value === 'function' ||
    (typeof value === 'object' && typeof value.handler === 'function'); },
  expected: 'function or object with "handler" function'
};

var assertTypes = {
  getters: functionAssert,
  mutations: functionAssert,
  actions: objectAssert
};

function assertRawModule (path, rawModule) {
  Object.keys(assertTypes).forEach(function (key) {
    if (!rawModule[key]) { return }

    var assertOptions = assertTypes[key];

    forEachValue(rawModule[key], function (value, type) {
      assert(
        assertOptions.assert(value),
        makeAssertionMessage(path, key, type, value, assertOptions.expected)
      );
    });
  });
}

function makeAssertionMessage (path, key, type, value, expected) {
  var buf = key + " should be " + expected + " but \"" + key + "." + type + "\"";
  if (path.length > 0) {
    buf += " in module \"" + (path.join('.')) + "\"";
  }
  buf += " is " + (JSON.stringify(value)) + ".";
  return buf
}

var Vue; // bind on install

var Store = function Store (options) {
  var this$1 = this;
  if ( options === void 0 ) options = {};

  // Auto install if it is not done yet and `window` has `Vue`.
  // To allow users to avoid auto-installation in some cases,
  // this code should be placed here. See #731
  if (!Vue && typeof window !== 'undefined' && window.Vue) {
    install(window.Vue);
  }

  if (true) {
    assert(Vue, "must call Vue.use(Vuex) before creating a store instance.");
    assert(typeof Promise !== 'undefined', "vuex requires a Promise polyfill in this browser.");
    assert(this instanceof Store, "store must be called with the new operator.");
  }

  var plugins = options.plugins; if ( plugins === void 0 ) plugins = [];
  var strict = options.strict; if ( strict === void 0 ) strict = false;

  // store internal state
  this._committing = false;
  this._actions = Object.create(null);
  this._actionSubscribers = [];
  this._mutations = Object.create(null);
  this._wrappedGetters = Object.create(null);
  this._modules = new ModuleCollection(options);
  this._modulesNamespaceMap = Object.create(null);
  this._subscribers = [];
  this._watcherVM = new Vue();
  this._makeLocalGettersCache = Object.create(null);

  // bind commit and dispatch to self
  var store = this;
  var ref = this;
  var dispatch = ref.dispatch;
  var commit = ref.commit;
  this.dispatch = function boundDispatch (type, payload) {
    return dispatch.call(store, type, payload)
  };
  this.commit = function boundCommit (type, payload, options) {
    return commit.call(store, type, payload, options)
  };

  // strict mode
  this.strict = strict;

  var state = this._modules.root.state;

  // init root module.
  // this also recursively registers all sub-modules
  // and collects all module getters inside this._wrappedGetters
  installModule(this, state, [], this._modules.root);

  // initialize the store vm, which is responsible for the reactivity
  // (also registers _wrappedGetters as computed properties)
  resetStoreVM(this, state);

  // apply plugins
  plugins.forEach(function (plugin) { return plugin(this$1); });

  var useDevtools = options.devtools !== undefined ? options.devtools : Vue.config.devtools;
  if (useDevtools) {
    devtoolPlugin(this);
  }
};

var prototypeAccessors$1 = { state: { configurable: true } };

prototypeAccessors$1.state.get = function () {
  return this._vm._data.$$state
};

prototypeAccessors$1.state.set = function (v) {
  if (true) {
    assert(false, "use store.replaceState() to explicit replace store state.");
  }
};

Store.prototype.commit = function commit (_type, _payload, _options) {
    var this$1 = this;

  // check object-style commit
  var ref = unifyObjectStyle(_type, _payload, _options);
    var type = ref.type;
    var payload = ref.payload;
    var options = ref.options;

  var mutation = { type: type, payload: payload };
  var entry = this._mutations[type];
  if (!entry) {
    if (true) {
      console.error(("[vuex] unknown mutation type: " + type));
    }
    return
  }
  this._withCommit(function () {
    entry.forEach(function commitIterator (handler) {
      handler(payload);
    });
  });

  this._subscribers
    .slice() // shallow copy to prevent iterator invalidation if subscriber synchronously calls unsubscribe
    .forEach(function (sub) { return sub(mutation, this$1.state); });

  if (
    "development" !== 'production' &&
    options && options.silent
  ) {
    console.warn(
      "[vuex] mutation type: " + type + ". Silent option has been removed. " +
      'Use the filter functionality in the vue-devtools'
    );
  }
};

Store.prototype.dispatch = function dispatch (_type, _payload) {
    var this$1 = this;

  // check object-style dispatch
  var ref = unifyObjectStyle(_type, _payload);
    var type = ref.type;
    var payload = ref.payload;

  var action = { type: type, payload: payload };
  var entry = this._actions[type];
  if (!entry) {
    if (true) {
      console.error(("[vuex] unknown action type: " + type));
    }
    return
  }

  try {
    this._actionSubscribers
      .slice() // shallow copy to prevent iterator invalidation if subscriber synchronously calls unsubscribe
      .filter(function (sub) { return sub.before; })
      .forEach(function (sub) { return sub.before(action, this$1.state); });
  } catch (e) {
    if (true) {
      console.warn("[vuex] error in before action subscribers: ");
      console.error(e);
    }
  }

  var result = entry.length > 1
    ? Promise.all(entry.map(function (handler) { return handler(payload); }))
    : entry[0](payload);

  return result.then(function (res) {
    try {
      this$1._actionSubscribers
        .filter(function (sub) { return sub.after; })
        .forEach(function (sub) { return sub.after(action, this$1.state); });
    } catch (e) {
      if (true) {
        console.warn("[vuex] error in after action subscribers: ");
        console.error(e);
      }
    }
    return res
  })
};

Store.prototype.subscribe = function subscribe (fn) {
  return genericSubscribe(fn, this._subscribers)
};

Store.prototype.subscribeAction = function subscribeAction (fn) {
  var subs = typeof fn === 'function' ? { before: fn } : fn;
  return genericSubscribe(subs, this._actionSubscribers)
};

Store.prototype.watch = function watch (getter, cb, options) {
    var this$1 = this;

  if (true) {
    assert(typeof getter === 'function', "store.watch only accepts a function.");
  }
  return this._watcherVM.$watch(function () { return getter(this$1.state, this$1.getters); }, cb, options)
};

Store.prototype.replaceState = function replaceState (state) {
    var this$1 = this;

  this._withCommit(function () {
    this$1._vm._data.$$state = state;
  });
};

Store.prototype.registerModule = function registerModule (path, rawModule, options) {
    if ( options === void 0 ) options = {};

  if (typeof path === 'string') { path = [path]; }

  if (true) {
    assert(Array.isArray(path), "module path must be a string or an Array.");
    assert(path.length > 0, 'cannot register the root module by using registerModule.');
  }

  this._modules.register(path, rawModule);
  installModule(this, this.state, path, this._modules.get(path), options.preserveState);
  // reset store to update getters...
  resetStoreVM(this, this.state);
};

Store.prototype.unregisterModule = function unregisterModule (path) {
    var this$1 = this;

  if (typeof path === 'string') { path = [path]; }

  if (true) {
    assert(Array.isArray(path), "module path must be a string or an Array.");
  }

  this._modules.unregister(path);
  this._withCommit(function () {
    var parentState = getNestedState(this$1.state, path.slice(0, -1));
    Vue.delete(parentState, path[path.length - 1]);
  });
  resetStore(this);
};

Store.prototype.hotUpdate = function hotUpdate (newOptions) {
  this._modules.update(newOptions);
  resetStore(this, true);
};

Store.prototype._withCommit = function _withCommit (fn) {
  var committing = this._committing;
  this._committing = true;
  fn();
  this._committing = committing;
};

Object.defineProperties( Store.prototype, prototypeAccessors$1 );

function genericSubscribe (fn, subs) {
  if (subs.indexOf(fn) < 0) {
    subs.push(fn);
  }
  return function () {
    var i = subs.indexOf(fn);
    if (i > -1) {
      subs.splice(i, 1);
    }
  }
}

function resetStore (store, hot) {
  store._actions = Object.create(null);
  store._mutations = Object.create(null);
  store._wrappedGetters = Object.create(null);
  store._modulesNamespaceMap = Object.create(null);
  var state = store.state;
  // init all modules
  installModule(store, state, [], store._modules.root, true);
  // reset vm
  resetStoreVM(store, state, hot);
}

function resetStoreVM (store, state, hot) {
  var oldVm = store._vm;

  // bind store public getters
  store.getters = {};
  // reset local getters cache
  store._makeLocalGettersCache = Object.create(null);
  var wrappedGetters = store._wrappedGetters;
  var computed = {};
  forEachValue(wrappedGetters, function (fn, key) {
    // use computed to leverage its lazy-caching mechanism
    // direct inline function use will lead to closure preserving oldVm.
    // using partial to return function with only arguments preserved in closure environment.
    computed[key] = partial(fn, store);
    Object.defineProperty(store.getters, key, {
      get: function () { return store._vm[key]; },
      enumerable: true // for local getters
    });
  });

  // use a Vue instance to store the state tree
  // suppress warnings just in case the user has added
  // some funky global mixins
  var silent = Vue.config.silent;
  Vue.config.silent = true;
  store._vm = new Vue({
    data: {
      $$state: state
    },
    computed: computed
  });
  Vue.config.silent = silent;

  // enable strict mode for new vm
  if (store.strict) {
    enableStrictMode(store);
  }

  if (oldVm) {
    if (hot) {
      // dispatch changes in all subscribed watchers
      // to force getter re-evaluation for hot reloading.
      store._withCommit(function () {
        oldVm._data.$$state = null;
      });
    }
    Vue.nextTick(function () { return oldVm.$destroy(); });
  }
}

function installModule (store, rootState, path, module, hot) {
  var isRoot = !path.length;
  var namespace = store._modules.getNamespace(path);

  // register in namespace map
  if (module.namespaced) {
    if (store._modulesNamespaceMap[namespace] && "development" !== 'production') {
      console.error(("[vuex] duplicate namespace " + namespace + " for the namespaced module " + (path.join('/'))));
    }
    store._modulesNamespaceMap[namespace] = module;
  }

  // set state
  if (!isRoot && !hot) {
    var parentState = getNestedState(rootState, path.slice(0, -1));
    var moduleName = path[path.length - 1];
    store._withCommit(function () {
      if (true) {
        if (moduleName in parentState) {
          console.warn(
            ("[vuex] state field \"" + moduleName + "\" was overridden by a module with the same name at \"" + (path.join('.')) + "\"")
          );
        }
      }
      Vue.set(parentState, moduleName, module.state);
    });
  }

  var local = module.context = makeLocalContext(store, namespace, path);

  module.forEachMutation(function (mutation, key) {
    var namespacedType = namespace + key;
    registerMutation(store, namespacedType, mutation, local);
  });

  module.forEachAction(function (action, key) {
    var type = action.root ? key : namespace + key;
    var handler = action.handler || action;
    registerAction(store, type, handler, local);
  });

  module.forEachGetter(function (getter, key) {
    var namespacedType = namespace + key;
    registerGetter(store, namespacedType, getter, local);
  });

  module.forEachChild(function (child, key) {
    installModule(store, rootState, path.concat(key), child, hot);
  });
}

/**
 * make localized dispatch, commit, getters and state
 * if there is no namespace, just use root ones
 */
function makeLocalContext (store, namespace, path) {
  var noNamespace = namespace === '';

  var local = {
    dispatch: noNamespace ? store.dispatch : function (_type, _payload, _options) {
      var args = unifyObjectStyle(_type, _payload, _options);
      var payload = args.payload;
      var options = args.options;
      var type = args.type;

      if (!options || !options.root) {
        type = namespace + type;
        if ("development" !== 'production' && !store._actions[type]) {
          console.error(("[vuex] unknown local action type: " + (args.type) + ", global type: " + type));
          return
        }
      }

      return store.dispatch(type, payload)
    },

    commit: noNamespace ? store.commit : function (_type, _payload, _options) {
      var args = unifyObjectStyle(_type, _payload, _options);
      var payload = args.payload;
      var options = args.options;
      var type = args.type;

      if (!options || !options.root) {
        type = namespace + type;
        if ("development" !== 'production' && !store._mutations[type]) {
          console.error(("[vuex] unknown local mutation type: " + (args.type) + ", global type: " + type));
          return
        }
      }

      store.commit(type, payload, options);
    }
  };

  // getters and state object must be gotten lazily
  // because they will be changed by vm update
  Object.defineProperties(local, {
    getters: {
      get: noNamespace
        ? function () { return store.getters; }
        : function () { return makeLocalGetters(store, namespace); }
    },
    state: {
      get: function () { return getNestedState(store.state, path); }
    }
  });

  return local
}

function makeLocalGetters (store, namespace) {
  if (!store._makeLocalGettersCache[namespace]) {
    var gettersProxy = {};
    var splitPos = namespace.length;
    Object.keys(store.getters).forEach(function (type) {
      // skip if the target getter is not match this namespace
      if (type.slice(0, splitPos) !== namespace) { return }

      // extract local getter type
      var localType = type.slice(splitPos);

      // Add a port to the getters proxy.
      // Define as getter property because
      // we do not want to evaluate the getters in this time.
      Object.defineProperty(gettersProxy, localType, {
        get: function () { return store.getters[type]; },
        enumerable: true
      });
    });
    store._makeLocalGettersCache[namespace] = gettersProxy;
  }

  return store._makeLocalGettersCache[namespace]
}

function registerMutation (store, type, handler, local) {
  var entry = store._mutations[type] || (store._mutations[type] = []);
  entry.push(function wrappedMutationHandler (payload) {
    handler.call(store, local.state, payload);
  });
}

function registerAction (store, type, handler, local) {
  var entry = store._actions[type] || (store._actions[type] = []);
  entry.push(function wrappedActionHandler (payload) {
    var res = handler.call(store, {
      dispatch: local.dispatch,
      commit: local.commit,
      getters: local.getters,
      state: local.state,
      rootGetters: store.getters,
      rootState: store.state
    }, payload);
    if (!isPromise(res)) {
      res = Promise.resolve(res);
    }
    if (store._devtoolHook) {
      return res.catch(function (err) {
        store._devtoolHook.emit('vuex:error', err);
        throw err
      })
    } else {
      return res
    }
  });
}

function registerGetter (store, type, rawGetter, local) {
  if (store._wrappedGetters[type]) {
    if (true) {
      console.error(("[vuex] duplicate getter key: " + type));
    }
    return
  }
  store._wrappedGetters[type] = function wrappedGetter (store) {
    return rawGetter(
      local.state, // local state
      local.getters, // local getters
      store.state, // root state
      store.getters // root getters
    )
  };
}

function enableStrictMode (store) {
  store._vm.$watch(function () { return this._data.$$state }, function () {
    if (true) {
      assert(store._committing, "do not mutate vuex store state outside mutation handlers.");
    }
  }, { deep: true, sync: true });
}

function getNestedState (state, path) {
  return path.reduce(function (state, key) { return state[key]; }, state)
}

function unifyObjectStyle (type, payload, options) {
  if (isObject(type) && type.type) {
    options = payload;
    payload = type;
    type = type.type;
  }

  if (true) {
    assert(typeof type === 'string', ("expects string as the type, but found " + (typeof type) + "."));
  }

  return { type: type, payload: payload, options: options }
}

function install (_Vue) {
  if (Vue && _Vue === Vue) {
    if (true) {
      console.error(
        '[vuex] already installed. Vue.use(Vuex) should be called only once.'
      );
    }
    return
  }
  Vue = _Vue;
  applyMixin(Vue);
}

/**
 * Reduce the code which written in Vue.js for getting the state.
 * @param {String} [namespace] - Module's namespace
 * @param {Object|Array} states # Object's item can be a function which accept state and getters for param, you can do something for state and getters in it.
 * @param {Object}
 */
var mapState = normalizeNamespace(function (namespace, states) {
  var res = {};
  if ("development" !== 'production' && !isValidMap(states)) {
    console.error('[vuex] mapState: mapper parameter must be either an Array or an Object');
  }
  normalizeMap(states).forEach(function (ref) {
    var key = ref.key;
    var val = ref.val;

    res[key] = function mappedState () {
      var state = this.$store.state;
      var getters = this.$store.getters;
      if (namespace) {
        var module = getModuleByNamespace(this.$store, 'mapState', namespace);
        if (!module) {
          return
        }
        state = module.context.state;
        getters = module.context.getters;
      }
      return typeof val === 'function'
        ? val.call(this, state, getters)
        : state[val]
    };
    // mark vuex getter for devtools
    res[key].vuex = true;
  });
  return res
});

/**
 * Reduce the code which written in Vue.js for committing the mutation
 * @param {String} [namespace] - Module's namespace
 * @param {Object|Array} mutations # Object's item can be a function which accept `commit` function as the first param, it can accept anthor params. You can commit mutation and do any other things in this function. specially, You need to pass anthor params from the mapped function.
 * @return {Object}
 */
var mapMutations = normalizeNamespace(function (namespace, mutations) {
  var res = {};
  if ("development" !== 'production' && !isValidMap(mutations)) {
    console.error('[vuex] mapMutations: mapper parameter must be either an Array or an Object');
  }
  normalizeMap(mutations).forEach(function (ref) {
    var key = ref.key;
    var val = ref.val;

    res[key] = function mappedMutation () {
      var args = [], len = arguments.length;
      while ( len-- ) args[ len ] = arguments[ len ];

      // Get the commit method from store
      var commit = this.$store.commit;
      if (namespace) {
        var module = getModuleByNamespace(this.$store, 'mapMutations', namespace);
        if (!module) {
          return
        }
        commit = module.context.commit;
      }
      return typeof val === 'function'
        ? val.apply(this, [commit].concat(args))
        : commit.apply(this.$store, [val].concat(args))
    };
  });
  return res
});

/**
 * Reduce the code which written in Vue.js for getting the getters
 * @param {String} [namespace] - Module's namespace
 * @param {Object|Array} getters
 * @return {Object}
 */
var mapGetters = normalizeNamespace(function (namespace, getters) {
  var res = {};
  if ("development" !== 'production' && !isValidMap(getters)) {
    console.error('[vuex] mapGetters: mapper parameter must be either an Array or an Object');
  }
  normalizeMap(getters).forEach(function (ref) {
    var key = ref.key;
    var val = ref.val;

    // The namespace has been mutated by normalizeNamespace
    val = namespace + val;
    res[key] = function mappedGetter () {
      if (namespace && !getModuleByNamespace(this.$store, 'mapGetters', namespace)) {
        return
      }
      if ("development" !== 'production' && !(val in this.$store.getters)) {
        console.error(("[vuex] unknown getter: " + val));
        return
      }
      return this.$store.getters[val]
    };
    // mark vuex getter for devtools
    res[key].vuex = true;
  });
  return res
});

/**
 * Reduce the code which written in Vue.js for dispatch the action
 * @param {String} [namespace] - Module's namespace
 * @param {Object|Array} actions # Object's item can be a function which accept `dispatch` function as the first param, it can accept anthor params. You can dispatch action and do any other things in this function. specially, You need to pass anthor params from the mapped function.
 * @return {Object}
 */
var mapActions = normalizeNamespace(function (namespace, actions) {
  var res = {};
  if ("development" !== 'production' && !isValidMap(actions)) {
    console.error('[vuex] mapActions: mapper parameter must be either an Array or an Object');
  }
  normalizeMap(actions).forEach(function (ref) {
    var key = ref.key;
    var val = ref.val;

    res[key] = function mappedAction () {
      var args = [], len = arguments.length;
      while ( len-- ) args[ len ] = arguments[ len ];

      // get dispatch function from store
      var dispatch = this.$store.dispatch;
      if (namespace) {
        var module = getModuleByNamespace(this.$store, 'mapActions', namespace);
        if (!module) {
          return
        }
        dispatch = module.context.dispatch;
      }
      return typeof val === 'function'
        ? val.apply(this, [dispatch].concat(args))
        : dispatch.apply(this.$store, [val].concat(args))
    };
  });
  return res
});

/**
 * Rebinding namespace param for mapXXX function in special scoped, and return them by simple object
 * @param {String} namespace
 * @return {Object}
 */
var createNamespacedHelpers = function (namespace) { return ({
  mapState: mapState.bind(null, namespace),
  mapGetters: mapGetters.bind(null, namespace),
  mapMutations: mapMutations.bind(null, namespace),
  mapActions: mapActions.bind(null, namespace)
}); };

/**
 * Normalize the map
 * normalizeMap([1, 2, 3]) => [ { key: 1, val: 1 }, { key: 2, val: 2 }, { key: 3, val: 3 } ]
 * normalizeMap({a: 1, b: 2, c: 3}) => [ { key: 'a', val: 1 }, { key: 'b', val: 2 }, { key: 'c', val: 3 } ]
 * @param {Array|Object} map
 * @return {Object}
 */
function normalizeMap (map) {
  if (!isValidMap(map)) {
    return []
  }
  return Array.isArray(map)
    ? map.map(function (key) { return ({ key: key, val: key }); })
    : Object.keys(map).map(function (key) { return ({ key: key, val: map[key] }); })
}

/**
 * Validate whether given map is valid or not
 * @param {*} map
 * @return {Boolean}
 */
function isValidMap (map) {
  return Array.isArray(map) || isObject(map)
}

/**
 * Return a function expect two param contains namespace and map. it will normalize the namespace and then the param's function will handle the new namespace and the map.
 * @param {Function} fn
 * @return {Function}
 */
function normalizeNamespace (fn) {
  return function (namespace, map) {
    if (typeof namespace !== 'string') {
      map = namespace;
      namespace = '';
    } else if (namespace.charAt(namespace.length - 1) !== '/') {
      namespace += '/';
    }
    return fn(namespace, map)
  }
}

/**
 * Search a special module from store by namespace. if module not exist, print error message.
 * @param {Object} store
 * @param {String} helper
 * @param {String} namespace
 * @return {Object}
 */
function getModuleByNamespace (store, helper, namespace) {
  var module = store._modulesNamespaceMap[namespace];
  if ("development" !== 'production' && !module) {
    console.error(("[vuex] module namespace not found in " + helper + "(): " + namespace));
  }
  return module
}

var index_esm = {
  Store: Store,
  install: install,
  version: '3.1.3',
  mapState: mapState,
  mapMutations: mapMutations,
  mapGetters: mapGetters,
  mapActions: mapActions,
  createNamespacedHelpers: createNamespacedHelpers
};

/* harmony default export */ __webpack_exports__["a"] = (index_esm);


/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(26)))

/***/ }),
/* 3 */
/***/ (function(module, exports) {

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self
  // eslint-disable-next-line no-new-func
  : Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _assign = __webpack_require__(76);

var _assign2 = _interopRequireDefault(_assign);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _assign2.default || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

var store = __webpack_require__(42)('wks');
var uid = __webpack_require__(30);
var Symbol = __webpack_require__(3).Symbol;
var USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function (name) {
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;


/***/ }),
/* 6 */
/***/ (function(module, exports) {

var core = module.exports = { version: '2.6.11' };
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(3);
var core = __webpack_require__(6);
var ctx = __webpack_require__(11);
var hide = __webpack_require__(12);
var has = __webpack_require__(14);
var PROTOTYPE = 'prototype';

var $export = function (type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var IS_WRAP = type & $export.W;
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE];
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE];
  var key, own, out;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    if (own && has(exports, key)) continue;
    // export native or passed
    out = own ? target[key] : source[key];
    // prevent global pollution for namespaces
    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
    // bind timers to global for call from export context
    : IS_BIND && own ? ctx(out, global)
    // wrap global constructors for prevent change them in library
    : IS_WRAP && target[key] == out ? (function (C) {
      var F = function (a, b, c) {
        if (this instanceof C) {
          switch (arguments.length) {
            case 0: return new C();
            case 1: return new C(a);
            case 2: return new C(a, b);
          } return new C(a, b, c);
        } return C.apply(this, arguments);
      };
      F[PROTOTYPE] = C[PROTOTYPE];
      return F;
    // make static versions for prototype methods
    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
    if (IS_PROTO) {
      (exports.virtual || (exports.virtual = {}))[key] = out;
      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
      if (type & $export.R && expProto && !expProto[key]) hide(expProto, key, out);
    }
  }
};
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library`
module.exports = $export;


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(13);
var IE8_DOM_DEFINE = __webpack_require__(57);
var toPrimitive = __webpack_require__(38);
var dP = Object.defineProperty;

exports.f = __webpack_require__(10) ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};


/***/ }),
/* 9 */
/***/ (function(module, exports) {

module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};


/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

// Thank's IE8 for his funny defineProperty
module.exports = !__webpack_require__(15)(function () {
  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

// optional / simple context binding
var aFunction = __webpack_require__(19);
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(8);
var createDesc = __webpack_require__(20);
module.exports = __webpack_require__(10) ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};


/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(9);
module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};


/***/ }),
/* 14 */
/***/ (function(module, exports) {

var hasOwnProperty = {}.hasOwnProperty;
module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};


/***/ }),
/* 15 */
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = __webpack_require__(40);
var defined = __webpack_require__(35);
module.exports = function (it) {
  return IObject(defined(it));
};


/***/ }),
/* 17 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = formatTime;
/* unused harmony export getDate */
/* unused harmony export getTime */
/* unused harmony export getFullDate */
/* unused harmony export isToday */
/* harmony export (immutable) */ __webpack_exports__["e"] = throttle;
/* harmony export (immutable) */ __webpack_exports__["a"] = formatDuration;
/* harmony export (immutable) */ __webpack_exports__["d"] = pinyin;
/* harmony export (immutable) */ __webpack_exports__["c"] = isJSON;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_typeof__ = __webpack_require__(104);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_typeof___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_typeof__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__dict_js__ = __webpack_require__(115);



function formatNumber(n) {
  var str = n.toString();
  return str[1] ? str : '0' + str;
}

function formatTime(date) {
  if (isToday(date)) {
    return wx.dayjs(date).format('A HH:mm').replace('PM', '下午').replace('AM', '上午');
  }
  return getDate(date);
}

function getDate(date) {
  var splitor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '/';

  var year = date.getFullYear();
  var month = date.getMonth() + 1;
  var day = date.getDate();
  return '' + year + splitor + addZeroPrefix(month) + splitor + addZeroPrefix(day);
}

/**
 * 返回时分秒/时分
 * @export
 * @param {*} date
 * @param {boolean} [withSecond=false]
 * @returns
 */
function getTime(date) {
  var withSecond = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  var hour = date.getHours();
  var minute = date.getMinutes();
  var second = date.getSeconds();
  return withSecond ? addZeroPrefix(hour) + ':' + addZeroPrefix(minute) + ':' + addZeroPrefix(second) : hour + ':' + addZeroPrefix(minute);
}

function getFullDate(date) {
  return getDate(date) + ' ' + getTime(date);
}

function isToday(date) {
  return date.toDateString() === new Date().toDateString();
}

/**
 * 个位数，加0前缀
 * @param {*} number
 * @returns
 */
function addZeroPrefix(number) {
  return number < 10 ? '0' + number : number;
}

function throttle(func, wait) {
  var timeout = void 0;
  return function () {
    var that = this;
    var args = arguments;

    if (!timeout) {
      timeout = setTimeout(function () {
        timeout = null;
        func.apply(that, args);
      }, wait);
    }
  };
}
function formatDuration(time) {
  var interval = time;
  var continued = '';
  if (interval > 3600) {
    var hour = Math.floor(interval / 3600);
    continued += hour + '小时';
    interval -= hour * 3600;
  }
  if (interval > 60 && interval < 3600) {
    var min = Math.floor(interval / 60);
    continued += min + '分';
    interval -= min * 60;
  }
  if (interval < 60) {
    continued += Math.floor(interval) + '秒';
  }
  return continued;
}

// 获取中文字符首字母拼音
function pinyin(raw) {
  var str = '' + raw;
  if (!str || /^ +$/g.test(str)) {
    return '';
  }
  var result = [];
  for (var i = 0; i < str.length; i++) {
    var unicode = str.charCodeAt(i);
    var char = str.charAt(i);
    if (unicode >= 19968 && unicode <= 40869) {
      char = __WEBPACK_IMPORTED_MODULE_1__dict_js__["a" /* default */].charAt(unicode - 19968);
    }
    result.push(char);
  }
  return result.join('');
}
// 判断是否是json string
function isJSON(str) {
  if (typeof str === 'string') {
    try {
      var obj = JSON.parse(str);
      return !!((typeof obj === 'undefined' ? 'undefined' : __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_typeof___default()(obj)) === 'object' && obj);
    } catch (e) {
      return false;
    }
  }
}

/* unused harmony default export */ var _unused_webpack_default_export = ({
  formatNumber: formatNumber,
  formatTime: formatTime,
  throttle: throttle,
  formatDuration: formatDuration,
  pinyin: pinyin,
  isJSON: isJSON
});

/***/ }),
/* 18 */
/***/ (function(module, exports) {

module.exports = true;


/***/ }),
/* 19 */
/***/ (function(module, exports) {

module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};


/***/ }),
/* 20 */
/***/ (function(module, exports) {

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};


/***/ }),
/* 21 */
/***/ (function(module, exports) {

module.exports = {};


/***/ }),
/* 22 */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};


/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

var def = __webpack_require__(8).f;
var has = __webpack_require__(14);
var TAG = __webpack_require__(5)('toStringTag');

module.exports = function (it, tag, stat) {
  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
};


/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.13 ToObject(argument)
var defined = __webpack_require__(35);
module.exports = function (it) {
  return Object(defined(it));
};


/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

var ctx = __webpack_require__(11);
var call = __webpack_require__(62);
var isArrayIter = __webpack_require__(63);
var anObject = __webpack_require__(13);
var toLength = __webpack_require__(29);
var getIterFn = __webpack_require__(64);
var BREAK = {};
var RETURN = {};
var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
  var iterFn = ITERATOR ? function () { return iterable; } : getIterFn(iterable);
  var f = ctx(fn, that, entries ? 2 : 1);
  var index = 0;
  var length, step, iterator, result;
  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');
  // fast case for arrays with default iterator
  if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {
    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
    if (result === BREAK || result === RETURN) return result;
  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
    result = call(iterator, f, step.value, entries);
    if (result === BREAK || result === RETURN) return result;
  }
};
exports.BREAK = BREAK;
exports.RETURN = RETURN;


/***/ }),
/* 26 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() { return typeof global !== 'undefined' ? global : this; })();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $at = __webpack_require__(86)(true);

// 21.1.3.27 String.prototype[@@iterator]()
__webpack_require__(36)(String, 'String', function (iterated) {
  this._t = String(iterated); // target
  this._i = 0;                // next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var index = this._i;
  var point;
  if (index >= O.length) return { value: undefined, done: true };
  point = $at(O, index);
  this._i += point.length;
  return { value: point, done: false };
});


/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys = __webpack_require__(59);
var enumBugKeys = __webpack_require__(43);

module.exports = Object.keys || function keys(O) {
  return $keys(O, enumBugKeys);
};


/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.15 ToLength
var toInteger = __webpack_require__(34);
var min = Math.min;
module.exports = function (it) {
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};


/***/ }),
/* 30 */
/***/ (function(module, exports) {

var id = 0;
var px = Math.random();
module.exports = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};


/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _from = __webpack_require__(100);

var _from2 = _interopRequireDefault(_from);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  } else {
    return (0, _from2.default)(arr);
  }
};

/***/ }),
/* 32 */
/***/ (function(module, exports) {

exports.f = {}.propertyIsEnumerable;


/***/ }),
/* 33 */
/***/ (function(module, exports) {



/***/ }),
/* 34 */
/***/ (function(module, exports) {

// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;
module.exports = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};


/***/ }),
/* 35 */
/***/ (function(module, exports) {

// 7.2.1 RequireObjectCoercible(argument)
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};


/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var LIBRARY = __webpack_require__(18);
var $export = __webpack_require__(7);
var redefine = __webpack_require__(58);
var hide = __webpack_require__(12);
var Iterators = __webpack_require__(21);
var $iterCreate = __webpack_require__(87);
var setToStringTag = __webpack_require__(23);
var getPrototypeOf = __webpack_require__(91);
var ITERATOR = __webpack_require__(5)('iterator');
var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function () { return this; };

module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  $iterCreate(Constructor, NAME, next);
  var getMethod = function (kind) {
    if (!BUGGY && kind in proto) return proto[kind];
    switch (kind) {
      case KEYS: return function keys() { return new Constructor(this, kind); };
      case VALUES: return function values() { return new Constructor(this, kind); };
    } return function entries() { return new Constructor(this, kind); };
  };
  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = $native || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype;
  // Fix native
  if ($anyNative) {
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != 'function') hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEF_VALUES && $native && $native.name !== VALUES) {
    VALUES_BUG = true;
    $default = function values() { return $native.call(this); };
  }
  // Define iterator
  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG] = returnThis;
  if (DEFAULT) {
    methods = {
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries
    };
    if (FORCED) for (key in methods) {
      if (!(key in proto)) redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};


/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(9);
var document = __webpack_require__(3).document;
// typeof document.createElement is 'object' in old IE
var is = isObject(document) && isObject(document.createElement);
module.exports = function (it) {
  return is ? document.createElement(it) : {};
};


/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = __webpack_require__(9);
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};


/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject = __webpack_require__(13);
var dPs = __webpack_require__(88);
var enumBugKeys = __webpack_require__(43);
var IE_PROTO = __webpack_require__(41)('IE_PROTO');
var Empty = function () { /* empty */ };
var PROTOTYPE = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = __webpack_require__(37)('iframe');
  var i = enumBugKeys.length;
  var lt = '<';
  var gt = '>';
  var iframeDocument;
  iframe.style.display = 'none';
  __webpack_require__(60).appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty();
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};


/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = __webpack_require__(22);
// eslint-disable-next-line no-prototype-builtins
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return cof(it) == 'String' ? it.split('') : Object(it);
};


/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

var shared = __webpack_require__(42)('keys');
var uid = __webpack_require__(30);
module.exports = function (key) {
  return shared[key] || (shared[key] = uid(key));
};


/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

var core = __webpack_require__(6);
var global = __webpack_require__(3);
var SHARED = '__core-js_shared__';
var store = global[SHARED] || (global[SHARED] = {});

(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: core.version,
  mode: __webpack_require__(18) ? 'pure' : 'global',
  copyright: '© 2019 Denis Pushkarev (zloirock.ru)'
});


/***/ }),
/* 43 */
/***/ (function(module, exports) {

// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');


/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(92);
var global = __webpack_require__(3);
var hide = __webpack_require__(12);
var Iterators = __webpack_require__(21);
var TO_STRING_TAG = __webpack_require__(5)('toStringTag');

var DOMIterables = ('CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,' +
  'DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,' +
  'MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,' +
  'SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,' +
  'TextTrackList,TouchList').split(',');

for (var i = 0; i < DOMIterables.length; i++) {
  var NAME = DOMIterables[i];
  var Collection = global[NAME];
  var proto = Collection && Collection.prototype;
  if (proto && !proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
  Iterators[NAME] = Iterators.Array;
}


/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = __webpack_require__(22);
var TAG = __webpack_require__(5)('toStringTag');
// ES3 wrong here
var ARG = cof(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (e) { /* empty */ }
};

module.exports = function (it) {
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
    // builtinTag case
    : ARG ? cof(O)
    // ES3 arguments fallback
    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};


/***/ }),
/* 46 */
/***/ (function(module, exports) {

module.exports = function (it, Constructor, name, forbiddenField) {
  if (!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)) {
    throw TypeError(name + ': incorrect invocation!');
  } return it;
};


/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 25.4.1.5 NewPromiseCapability(C)
var aFunction = __webpack_require__(19);

function PromiseCapability(C) {
  var resolve, reject;
  this.promise = new C(function ($$resolve, $$reject) {
    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
    resolve = $$resolve;
    reject = $$reject;
  });
  this.resolve = aFunction(resolve);
  this.reject = aFunction(reject);
}

module.exports.f = function (C) {
  return new PromiseCapability(C);
};


/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

var hide = __webpack_require__(12);
module.exports = function (target, src, safe) {
  for (var key in src) {
    if (safe && target[key]) target[key] = src[key];
    else hide(target, key, src[key]);
  } return target;
};


/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

exports.f = __webpack_require__(5);


/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

var META = __webpack_require__(30)('meta');
var isObject = __webpack_require__(9);
var has = __webpack_require__(14);
var setDesc = __webpack_require__(8).f;
var id = 0;
var isExtensible = Object.isExtensible || function () {
  return true;
};
var FREEZE = !__webpack_require__(15)(function () {
  return isExtensible(Object.preventExtensions({}));
});
var setMeta = function (it) {
  setDesc(it, META, { value: {
    i: 'O' + ++id, // object ID
    w: {}          // weak collections IDs
  } });
};
var fastKey = function (it, create) {
  // return primitive with prefix
  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return 'F';
    // not necessary to add metadata
    if (!create) return 'E';
    // add missing metadata
    setMeta(it);
  // return object ID
  } return it[META].i;
};
var getWeak = function (it, create) {
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return true;
    // not necessary to add metadata
    if (!create) return false;
    // add missing metadata
    setMeta(it);
  // return hash weak collections IDs
  } return it[META].w;
};
// add metadata on freeze-family methods calling
var onFreeze = function (it) {
  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
  return it;
};
var meta = module.exports = {
  KEY: META,
  NEED: false,
  fastKey: fastKey,
  getWeak: getWeak,
  onFreeze: onFreeze
};


/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(3);
var core = __webpack_require__(6);
var LIBRARY = __webpack_require__(18);
var wksExt = __webpack_require__(49);
var defineProperty = __webpack_require__(8).f;
module.exports = function (name) {
  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, { value: wksExt.f(name) });
};


/***/ }),
/* 52 */
/***/ (function(module, exports) {

exports.f = Object.getOwnPropertySymbols;


/***/ }),
/* 53 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return _SDKAPPID; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return genTestUserSig; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__lib_generate_test_usersig_es_min_js__ = __webpack_require__(122);
/*eslint-disable*/


const _SDKAPPID = 0;
const _SECRETKEY = '';
/*
 * Module:   GenerateTestUserSig
 *
 * Function: 用于生成测试用的 UserSig，UserSig 是腾讯云为其云服务设计的一种安全保护签名。
 *           其计算方法是对 SDKAppID、UserID 和 EXPIRETIME 进行加密，加密算法为 HMAC-SHA256。
 *
 * Attention: 请不要将如下代码发布到您的线上正式版本的 App 中，原因如下：
 *
 *            本文件中的代码虽然能够正确计算出 UserSig，但仅适合快速调通 SDK 的基本功能，不适合线上产品，
 *            这是因为客户端代码中的 SECRETKEY 很容易被反编译逆向破解，尤其是 Web 端的代码被破解的难度几乎为零。
 *            一旦您的密钥泄露，攻击者就可以计算出正确的 UserSig 来盗用您的腾讯云流量。
 *
 *            正确的做法是将 UserSig 的计算代码和加密密钥放在您的业务服务器上，然后由 App 按需向您的服务器获取实时算出的 UserSig。
 *            由于破解服务器的成本要高于破解客户端 App，所以服务器计算的方案能够更好地保护您的加密密钥。
 *
 * Reference：https://cloud.tencent.com/document/product/647/17275#Server
 */
function genTestUserSig(userID) {
  /**
   * 腾讯云 SDKAppId，需要替换为您自己账号下的 SDKAppId。
   *
   * 进入腾讯云实时音视频[控制台](https://console.cloud.tencent.com/rav ) 创建应用，即可看到 SDKAppId，
   * 它是腾讯云用于区分客户的唯一标识。
   */
  var SDKAPPID = _SDKAPPID;

  /**
   * 签名过期时间，建议不要设置的过短
   * <p>
   * 时间单位：秒
   * 默认时间：7 x 24 x 60 x 60 = 604800 = 7 天
   */
  var EXPIRETIME = 604800;


  /**
   * 计算签名用的加密密钥，获取步骤如下：
   *
   * step1. 进入腾讯云实时音视频[控制台](https://console.cloud.tencent.com/rav )，如果还没有应用就创建一个，
   * step2. 单击“应用配置”进入基础配置页面，并进一步找到“帐号体系集成”部分。
   * step3. 点击“查看密钥”按钮，就可以看到计算 UserSig 使用的加密的密钥了，请将其拷贝并复制到如下的变量中
   *
   * 注意：该方案仅适用于调试Demo，正式上线前请将 UserSig 计算代码和密钥迁移到您的后台服务器上，以避免加密密钥泄露导致的流量盗用。
   * 文档：https://cloud.tencent.com/document/product/647/17275#Server
   */
  var SECRETKEY = _SECRETKEY;
  
  var generator = new __WEBPACK_IMPORTED_MODULE_0__lib_generate_test_usersig_es_min_js__["a" /* default */](SDKAPPID, SECRETKEY, EXPIRETIME);
  var userSig = generator.genTestUserSig(userID);
  return {
    sdkappid: SDKAPPID,
    userSig: userSig
  };
}




/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(135), __esModule: true };

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {(function (global, factory) {
   true ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global = global || self, global.TIM = factory());
}(this, (function () { 'use strict';

  var version = "2.6.0";

  /**
   * 接入侧需要监听处理的事件列表，详细如下：
   * @memberof SDK
   * @exports EVENT
   * @module EVENT
   */
  var TIM_OUTER_EVENT = {
    /**
     * @description SDK 进入 ready 状态时触发，接入侧监听此事件，然后可调用 SDK 发送消息等api，使用 SDK 的各项功能
     * @memberOf module:EVENT
     * @example
     * let onSdkReady = function(event) {
     *   let message = tim.createTextMessage({ to: 'user1', conversationType: 'C2C', payload: { text: 'Hello world!' }});
     *   tim.sendMessage(message);
     * };
     * tim.on(TIM.EVENT.SDK_READY, onSdkReady);
     */
    SDK_READY: 'sdkStateReady',

    /**
     * @description SDK 进入 not ready 状态时触发，此时接入侧将无法使用 SDK 发送消息等功能。<br/>
     * 如果想恢复使用，接入侧需调用 login 接口，驱动 SDK 进入 ready 状态
     * @memberOf module:EVENT
     * @example
     * let onSdkNotReady = function(event) {
     *   // 如果想使用发送消息等功能，接入侧需驱动 SDK 进入 ready 状态，重新调用 login 接口即可，如下所示：
     *   // tim.login({userID: 'your userID', userSig: 'your userSig'});
     * };
     * tim.on(TIM.EVENT.SDK_NOT_READY, onSdkNotReady);
     */
    SDK_NOT_READY: 'sdkStateNotReady',

    /**
     * @description 销毁时触发，TIM SDK实例工厂将删除SDKAppID对应的sdk实例。接入侧不需要侦听处理此事件
     * @memberOf module:EVENT
     * @private
     */
    SDK_DESTROY: 'sdkDestroy',
    // 消息相关事件

    /**
     * @description SDK 收到推送的单聊、群聊、群提示、群系统通知的新消息，可通过遍历 event.data 获取消息列表数据并渲染到页面
     * @memberof module:EVENT
     * @example
     * let onMessageReceived = function(event) {
     *   // event.data - 存储 Message 对象的数组 - [Message]
     * };
     * tim.on(TIM.EVENT.MESSAGE_RECEIVED, onMessageReceived);
     */
    MESSAGE_RECEIVED: 'onMessageReceived',

    /**
     * @description SDK 收到消息被撤回的通知，可通过遍历 event.data 获取被撤回的消息列表数据并渲染到页面，如单聊会话内可展示为 "对方撤回了一条消息"；群聊会话内可展示为 "XXX撤回了一条消息"。
     * >注意：使用前需要将SDK版本升级至v2.4.0或以上。
     * @memberof module:EVENT
     * @example
     * let onMessageRevoked = function(event) {
     *   // event.data - 存储 Message 对象的数组 - [Message] - 每个 Message 对象的 isRevoked 属性值为 true
     * };
     * tim.on(TIM.EVENT.MESSAGE_REVOKED, onMessageRevoked);
     */
    MESSAGE_REVOKED: 'onMessageRevoked',
    // 会话相关

    /**
     * @description 会话列表更新，event.data 是包含 Conversation 对象的数组
     * @memberof module:EVENT
     * @example
     * let onConversationListUpdated = function(event) {
     *   console.log(event.data); // 包含 {@link Conversation} 实例的数组
     * };
     * tim.on(TIM.EVENT.CONVERSATION_LIST_UPDATED, onConversationListUpdated);
     */
    CONVERSATION_LIST_UPDATED: 'onConversationListUpdated',
    // 群组相关

    /**
     * @description SDK 群组列表更新时触发，可通过遍历 event.data 获取群组列表数据并渲染到页面
     * @memberof module:EVENT
     * @example
     * let onGroupListUpdated = function(event) {
     *    console.log(event.data);// 包含 {@link Group} 实例的数组
     * };
     * tim.on(TIM.EVENT.GROUP_LIST_UPDATED, onGroupListUpdated);
     */
    GROUP_LIST_UPDATED: 'onGroupListUpdated',

    /**
     * @deprecated ！！！v2.6.0起弃用，为了更好的体验，请在 MESSAGE_RECEIVED 事件回调内接收处理群系统通知。
     * @description SDK 收到新的群系统通知时触发。
     * @see {@link module:TYPES.GROUP_SYSTEM_NOTICE_TYPES 群系统通知类型常量及含义}
     * @see {@link Message.GroupSystemNoticePayload 群系统通知 payload 结构描述}
     * @memberof module:EVENT
     * @example
     * let onGroupSystemNoticeReceived = function(event) {
     *   const type = event.data.type; // 群系统通知的类型，详见 {@link module:TYPES.GROUP_SYSTEM_NOTICE_TYPES 群系统通知类型常量及含义}
     *   const message = event.data.message; // 群系统通知的消息实例，详见 {@link Message}
     *   console.log(message.payload); // 消息内容. {@link Message.GroupSystemNoticePayload 群系统通知 payload 结构描述}
     * };
     * tim.on(TIM.EVENT.GROUP_SYSTEM_NOTICE_RECEIVED, onGroupSystemNoticeReceived);
     */
    GROUP_SYSTEM_NOTICE_RECEIVED: 'receiveGroupSystemNotice',

    /**
     * @description 自己或好友的资料发生变更时触发，event.data 是包含 Profile 对象的数组
     * @memberof module:EVENT
     * @example
     * let onProfileUpdated = function(event) {
     *   console.log(event.data); // 包含 Profile 对象的数组
     * };
     * tim.on(TIM.EVENT.PROFILE_UPDATED, onProfileUpdated);
     */
    PROFILE_UPDATED: 'onProfileUpdated',
    // 好友相关

    /**
     * @description SDK 黑名单列表更新时触发
     * @memberof module:EVENT
     * @example
     * let onBlacklistUpdated = function(event) {
     *   console.log(event.data); // 我的黑名单列表，结构为包含用户 userID 的数组
     * };
     * tim.on(TIM.EVENT.BLACKLIST_UPDATED, onBlacklistUpdated);
     */
    BLACKLIST_UPDATED: 'blacklistUpdated',

    /**
     * @description 用户被踢下线时触发
     * @memberof module:EVENT
     * @example
     * let onKickedOut = function(event) {
     *   console.log(event.data.type);
     *   // TIM.TYPES.KICKED_OUT_MULT_ACCOUNT(Web端，同一账号，多页面登录被踢)
     *   // TIM.TYPES.KICKED_OUT_MULT_DEVICE(同一账号，多端登录被踢)
     *   // TIM.TYPES.KICKED_OUT_USERSIG_EXPIRED(签名过期。使用前需要将SDK版本升级至v2.4.0或以上)
     * };
     * tim.on(TIM.EVENT.KICKED_OUT, onKickedOut);
     */
    KICKED_OUT: 'kickedOut',

    /**
     * @description SDK 遇到错误时触发
     * @memberof module:EVENT
     * @example
     * let onError = function(event) {
     *   // event.data.code - 错误码
     *   // event.data.message - 错误信息
     * };
     * tim.on(TIM.EVENT.ERROR, onError);
     */
    ERROR: 'error',
    // 给 SDK 外部处理的error事件

    /**
     * @description 网络状态发生改变
     * @memberof module:EVENT
     * @example
     * let onNetStateChange = function(event) {
     *   // v2.5.0 起支持
     *   // event.data.state 当前网络状态，枚举值及说明如下：
     *   // TIM.TYPES.NET_STATE_CONNECTED - 已接入网络
     *   // TIM.TYPES.NET_STATE_CONNECTING - 连接中。很可能遇到网络抖动，SDK 在重试。接入侧可根据此状态提示“当前网络不稳定”或“连接中”
     *   // TIM.TYPES.NET_STATE_DISCONNECTED - 未接入网络。接入侧可根据此状态提示“当前网络不可用”。SDK 仍会继续重试，若用户网络恢复，SDK 会自动同步消息
     * }
     */
    NET_STATE_CHANGE: 'netStateChange'
  };

  /**
   * 类型常量， 消息类型、会话类型...
   *
   */

  /**
   * SDK 中的类型常量。为了代码简洁、方便阅读，部分常量使用常见的英文单词缩写描述，具体如下：<br/>
   * | 缩写 | 全称 |
   * | :--- | :---- |
   * | CONV | CONVERSATION（会话）|
   * | GRP | GROUP（群组）|
   * | MSG | MESSAGE（消息）|
   * | SYS | SYSTEM（系统）|
   * | MBR | MEMBER（成员）|
   * | ACPT | ACCEPT（接受）|
   * | NOTE | NOTIFY（通知）|
   * | MULT | MULTIPLE（多重的）|
   * @memberof SDK
   * @exports TYPES
   * @module TYPES
   * @example
   * // 判断消息类型
   * const isTextMessage = message.type === TIM.TYPES.MSG_TEXT // 是否是文本消息类型
   * // 判断会话类型
   * const isGroupConversation = conversation.type === TIM.TYPES.CONV_GROUP // 是否是群组会话
   */
  var TYPES = {
    /**
     * @description 消息类型：文本消息
     * @memberof module:TYPES
     */
    MSG_TEXT: 'TIMTextElem',

    /**
     * @description 消息类型：图片消息
     * @memberof module:TYPES
     */
    MSG_IMAGE: 'TIMImageElem',

    /**
     * @description 消息类型：音频消息
     * > 注意：已废弃，请使用 MSG_AUDIO
     * @memberof module:TYPES
     */
    MSG_SOUND: 'TIMSoundElem',

    /**
     * @description 消息类型：音频消息
     * @memberof module:TYPES
     */
    MSG_AUDIO: 'TIMSoundElem',

    /**
     * @description 消息类型：文件消息
     * @memberof module:TYPES
     */
    MSG_FILE: 'TIMFileElem',

    /**
     * @private
     * @description 消息类型：表情消息
     * @memberof module:TYPES
     */
    MSG_FACE: 'TIMFaceElem',

    /**
     * @description 消息类型：视频消息
     * @memberof module:TYPES
     */
    MSG_VIDEO: 'TIMVideoFileElem',

    /**
     * @description 消息类型：位置消息
     * @memberof module:TYPES
     */
    MSG_GEO: 'TIMLocationElem',

    /**
     * @description 消息类型：群提示消息
     * @memberof module:TYPES
     */
    MSG_GRP_TIP: 'TIMGroupTipElem',

    /**
     * @description 消息类型：群系统通知消息
     * @memberof module:TYPES
     */
    MSG_GRP_SYS_NOTICE: 'TIMGroupSystemNoticeElem',

    /**
     * @description 消息类型：自定义消息
     * @memberof module:TYPES
     */
    MSG_CUSTOM: 'TIMCustomElem',

    /**
     * @description 群消息高优先级。建议选择该优先级的消息类型：红包消息和礼物消息
     * @memberof module:TYPES
     */
    MSG_PRIORITY_HIGH: 'High',

    /**
     * @description 群消息普通优先级。建议选择该优先级的消息类型：普通文本消息
     * @memberof module:TYPES
     */
    MSG_PRIORITY_NORMAL: 'Normal',

    /**
     * @description 群消息低优先级。建议选择该优先级的消息类型：点赞消息
     * @memberof module:TYPES
     */
    MSG_PRIORITY_LOW: 'Low',

    /**
     * @description 群消息最低优先级。建议选择该优先级的消息类型：最不重要的消息
     * @memberof module:TYPES
     */
    MSG_PRIORITY_LOWEST: 'Lowest',

    /**
     * @description 会话类型：C2C(Client to Client, 端到端) 会话
     * @memberof module:TYPES
     */
    CONV_C2C: 'C2C',

    /**
     * @description 会话类型：GROUP(群组) 会话
     * @memberof module:TYPES
     */
    CONV_GROUP: 'GROUP',

    /**
     * @description 会话类型：SYSTEM(系统) 会话
     * @memberof module:TYPES
     */
    CONV_SYSTEM: '@TIM#SYSTEM',

    /**
     * @description 群组类型：私有群
     * @memberof module:TYPES
     */
    GRP_PRIVATE: 'Private',

    /**
     * @description 群组类型：公开群
     * @memberof module:TYPES
     */
    GRP_PUBLIC: 'Public',

    /**
     * @description 群组类型：聊天室
     * @memberof module:TYPES
     */
    GRP_CHATROOM: 'ChatRoom',

    /**
     * @description 群组类型：音视频聊天室
     * @memberof module:TYPES
     */
    GRP_AVCHATROOM: 'AVChatRoom',

    /**
     * @description 群成员角色：群主
     * @memberof module:TYPES
     */
    GRP_MBR_ROLE_OWNER: 'Owner',

    /**
     * @description 群成员角色：管理员
     * @memberof module:TYPES
     */
    GRP_MBR_ROLE_ADMIN: 'Admin',

    /**
     * @description 群成员角色：普通群成员
     * @memberof module:TYPES
     */
    GRP_MBR_ROLE_MEMBER: 'Member',

    /**
     * @description 群提示：有成员加群
     * @memberof module:TYPES
     */
    GRP_TIP_MBR_JOIN: 1,

    /**
     * @description 群提示：有群成员退群
     * @memberof module:TYPES
     */
    GRP_TIP_MBR_QUIT: 2,

    /**
     * @description 群提示：有群成员被踢出群
     * @memberof module:TYPES
     */
    GRP_TIP_MBR_KICKED_OUT: 3,

    /**
     * @description 群提示：有群成员被设为管理员
     * @memberof module:TYPES
     */
    GRP_TIP_MBR_SET_ADMIN: 4,
    // 被设置为管理员

    /**
     * @description 群提示：有群成员被撤销管理员
     * @memberof module:TYPES
     */
    GRP_TIP_MBR_CANCELED_ADMIN: 5,
    // 被取消管理员

    /**
     * @description 群提示：群组资料变更
     * @memberof module:TYPES
     */
    GRP_TIP_GRP_PROFILE_UPDATED: 6,
    // 修改群资料，转让群组为该类型，msgBody.msgGroupNewInfo.ownerAccount表示新群主的ID

    /**
     * @description 群提示：群成员资料变更
     * @memberof module:TYPES
     */
    GRP_TIP_MBR_PROFILE_UPDATED: 7,
    // 修改群成员信息

    /**
     * @description 群消息提示类型：SDK 接收消息并通知接入侧，接入侧做提示
     * @memberof module:TYPES
     */
    MSG_REMIND_ACPT_AND_NOTE: 'AcceptAndNotify',

    /**
     * @description 群消息提示类型：SDK 接收消息并通知接入侧，接入侧不做提示
     * @memberof module:TYPES
     */
    MSG_REMIND_ACPT_NOT_NOTE: 'AcceptNotNotify',

    /**
     * @description 群消息提示类型：SDK 拒收消息
     * @memberof module:TYPES
     */
    MSG_REMIND_DISCARD: 'Discard',

    /**
     * @description 性别：未设置性别
     * @memberOf module:TYPES
     */
    GENDER_UNKNOWN: 'Gender_Type_Unknown',

    /**
     * @description 性别：女性
     * @memberOf module:TYPES
     */
    GENDER_FEMALE: 'Gender_Type_Female',

    /**
     * @description 性别：男性
     * @memberOf module:TYPES
     */
    GENDER_MALE: 'Gender_Type_Male',

    /**
     * @description 被踢类型：多账号登录被踢
     * @memberOf module:TYPES
     */
    KICKED_OUT_MULT_ACCOUNT: 'multipleAccount',

    /**
     * @description 被踢类型：多终端登录被踢
     * @memberOf module:TYPES
     */
    KICKED_OUT_MULT_DEVICE: 'multipleDevice',

    /**
     * @description 被踢类型：签名过期
     * @memberOf module:TYPES
     */
    KICKED_OUT_USERSIG_EXPIRED: 'userSigExpired',

    /**
     * @description 当被人加好友时：允许任何人添加自己为好友
     * @memberOf module:TYPES
     */
    ALLOW_TYPE_ALLOW_ANY: 'AllowType_Type_AllowAny',

    /**
     * @description 当被人加好友时：需要经过自己确认才能添加自己为好友
     * @memberOf module:TYPES
     */
    ALLOW_TYPE_NEED_CONFIRM: 'AllowType_Type_NeedConfirm',

    /**
     * @description 当被人加好友时：不允许任何人添加自己为好友
     * @memberOf module:TYPES
     */
    ALLOW_TYPE_DENY_ANY: 'AllowType_Type_DenyAny',

    /**
     * @description 管理员禁止加好友标识：默认值，允许加好友
     * @memberOf module:TYPES
     */
    FORBID_TYPE_NONE: 'AdminForbid_Type_None',

    /**
     * @description 管理员禁止加好友标识：禁止该用户发起加好友请求
     * @memberOf module:TYPES
     */
    FORBID_TYPE_SEND_OUT: 'AdminForbid_Type_SendOut',

    /**
     * @description 加群选项：自由加入
     * @memberOf module:TYPES
     */
    JOIN_OPTIONS_FREE_ACCESS: 'FreeAccess',

    /**
     * @description 加群选项：需要管理员同意
     * @memberOf module:TYPES
     */
    JOIN_OPTIONS_NEED_PERMISSION: 'NeedPermission',

    /**
     * @description 加群选项：不允许加群
     * @memberOf module:TYPES
     */
    JOIN_OPTIONS_DISABLE_APPLY: 'DisableApply',

    /**
     * @description 加群申请状态：加群成功
     * @memberOf module:TYPES
     */
    JOIN_STATUS_SUCCESS: 'JoinedSuccess',

    /**
     * @description 加群申请状态：已在群中
     * @memberOf module:TYPES
     */
    JOIN_STATUS_ALREADY_IN_GROUP: 'AlreadyInGroup',

    /**
     * @description 加群申请状态：等待管理员同意
     * @memberOf module:TYPES
     */
    JOIN_STATUS_WAIT_APPROVAL: 'WaitAdminApproval',

    /**
     * @description 群资料：群主 ID
     * @memberOf module:TYPES
     */
    GRP_PROFILE_OWNER_ID: 'ownerID',

    /**
     * @description 群资料：群创建时间
     * @memberOf module:TYPES
     */
    GRP_PROFILE_CREATE_TIME: 'createTime',

    /**
     * @description 群资料：最后一次群资料变更时间
     * @memberOf module:TYPES
     */
    GRP_PROFILE_LAST_INFO_TIME: 'lastInfoTime',

    /**
     * @description 群资料：当前群组的群成员数量
     * @memberOf module:TYPES
     */
    GRP_PROFILE_MEMBER_NUM: 'memberNum',

    /**
     * @description 群资料：当前群组的最大群成员数量
     * @memberOf module:TYPES
     */
    GRP_PROFILE_MAX_MEMBER_NUM: 'maxMemberNum',

    /**
     * @description 群资料：申请加群选项
     * @memberOf module:TYPES
     */
    GRP_PROFILE_JOIN_OPTION: 'joinOption',

    /**
     * @description 群资料：群介绍
     * @memberOf module:TYPES
     */
    GRP_PROFILE_INTRODUCTION: 'introduction',

    /**
     * @description 群资料：群公告
     * @memberOf module:TYPES
     */
    GRP_PROFILE_NOTIFICATION: 'notification',

    /**
     * @description 网络状态：已接入网络。v2.5.0 起支持。
     * @memberOf module:TYPES
     */
    NET_STATE_CONNECTED: 'connected',

    /**
     * @description 网络状态：连接中。v2.5.0 起支持。
     * @memberOf module:TYPES
     */
    NET_STATE_CONNECTING: 'connecting',

    /**
     * @description 网络状态：未接入网络。v2.5.0 起支持。
     * @memberOf module:TYPES
     */
    NET_STATE_DISCONNECTED: 'disconnected'
  };

  function _typeof(obj) {
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function (obj) {
        return typeof obj;
      };
    } else {
      _typeof = function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof(obj);
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);

    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly) symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
      keys.push.apply(keys, symbols);
    }

    return keys;
  }

  function _objectSpread2(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};

      if (i % 2) {
        ownKeys(Object(source), true).forEach(function (key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys(Object(source)).forEach(function (key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }

    return target;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }

  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  function isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _construct(Parent, args, Class) {
    if (isNativeReflectConstruct()) {
      _construct = Reflect.construct;
    } else {
      _construct = function _construct(Parent, args, Class) {
        var a = [null];
        a.push.apply(a, args);
        var Constructor = Function.bind.apply(Parent, a);
        var instance = new Constructor();
        if (Class) _setPrototypeOf(instance, Class.prototype);
        return instance;
      };
    }

    return _construct.apply(null, arguments);
  }

  function _isNativeFunction(fn) {
    return Function.toString.call(fn).indexOf("[native code]") !== -1;
  }

  function _wrapNativeSuper(Class) {
    var _cache = typeof Map === "function" ? new Map() : undefined;

    _wrapNativeSuper = function _wrapNativeSuper(Class) {
      if (Class === null || !_isNativeFunction(Class)) return Class;

      if (typeof Class !== "function") {
        throw new TypeError("Super expression must either be null or a function");
      }

      if (typeof _cache !== "undefined") {
        if (_cache.has(Class)) return _cache.get(Class);

        _cache.set(Class, Wrapper);
      }

      function Wrapper() {
        return _construct(Class, arguments, _getPrototypeOf(this).constructor);
      }

      Wrapper.prototype = Object.create(Class.prototype, {
        constructor: {
          value: Wrapper,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      return _setPrototypeOf(Wrapper, Class);
    };

    return _wrapNativeSuper(Class);
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized(self);
  }

  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
  }

  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
  }

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

      return arr2;
    }
  }

  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  function _iterableToArray(iter) {
    if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
  }

  function _iterableToArrayLimit(arr, i) {
    if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) {
      return;
    }

    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance");
  }

  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance");
  }

  var Middleware =
  /*#__PURE__*/
  function () {
    function Middleware() {
      _classCallCheck(this, Middleware);

      this.cache = [];
      this.options = null; // 缓存options
    }

    _createClass(Middleware, [{
      key: "use",
      value: function use(fn) {
        if (typeof fn !== 'function') {
          // eslint-disable-next-line no-throw-literal
          throw 'middleware must be a function';
        }

        this.cache.push(fn);
        return this;
      }
    }, {
      key: "next",
      value: function next(fn) {
        if (this.middlewares && this.middlewares.length > 0) {
          var ware = this.middlewares.shift();
          return ware.call(this, this.options, this.next.bind(this)); // 需要返回中间件函数运行多结果
        }
      }
      /**
       * @param options 数据的入口
       * @param next
       */

    }, {
      key: "run",
      value: function run(options) {
        this.middlewares = this.cache.map(function (fn) {
          return fn;
        });
        this.options = options; // 缓存数据

        return this.next();
      }
    }]);

    return Middleware;
  }();

  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  function createCommonjsModule(fn, module) {
  	return module = { exports: {} }, fn(module, module.exports), module.exports;
  }

  var typeDetect = createCommonjsModule(function (module, exports) {
  (function (global, factory) {
  	 module.exports = factory() ;
  }(commonjsGlobal, (function () {
  /* !
   * type-detect
   * Copyright(c) 2013 jake luer <jake@alogicalparadox.com>
   * MIT Licensed
   */
  var promiseExists = typeof Promise === 'function';

  /* eslint-disable no-undef */
  var globalObject = typeof self === 'object' ? self : commonjsGlobal; // eslint-disable-line id-blacklist

  var symbolExists = typeof Symbol !== 'undefined';
  var mapExists = typeof Map !== 'undefined';
  var setExists = typeof Set !== 'undefined';
  var weakMapExists = typeof WeakMap !== 'undefined';
  var weakSetExists = typeof WeakSet !== 'undefined';
  var dataViewExists = typeof DataView !== 'undefined';
  var symbolIteratorExists = symbolExists && typeof Symbol.iterator !== 'undefined';
  var symbolToStringTagExists = symbolExists && typeof Symbol.toStringTag !== 'undefined';
  var setEntriesExists = setExists && typeof Set.prototype.entries === 'function';
  var mapEntriesExists = mapExists && typeof Map.prototype.entries === 'function';
  var setIteratorPrototype = setEntriesExists && Object.getPrototypeOf(new Set().entries());
  var mapIteratorPrototype = mapEntriesExists && Object.getPrototypeOf(new Map().entries());
  var arrayIteratorExists = symbolIteratorExists && typeof Array.prototype[Symbol.iterator] === 'function';
  var arrayIteratorPrototype = arrayIteratorExists && Object.getPrototypeOf([][Symbol.iterator]());
  var stringIteratorExists = symbolIteratorExists && typeof String.prototype[Symbol.iterator] === 'function';
  var stringIteratorPrototype = stringIteratorExists && Object.getPrototypeOf(''[Symbol.iterator]());
  var toStringLeftSliceLength = 8;
  var toStringRightSliceLength = -1;
  /**
   * ### typeOf (obj)
   *
   * Uses `Object.prototype.toString` to determine the type of an object,
   * normalising behaviour across engine versions & well optimised.
   *
   * @param {Mixed} object
   * @return {String} object type
   * @api public
   */
  function typeDetect(obj) {
    /* ! Speed optimisation
     * Pre:
     *   string literal     x 3,039,035 ops/sec ±1.62% (78 runs sampled)
     *   boolean literal    x 1,424,138 ops/sec ±4.54% (75 runs sampled)
     *   number literal     x 1,653,153 ops/sec ±1.91% (82 runs sampled)
     *   undefined          x 9,978,660 ops/sec ±1.92% (75 runs sampled)
     *   function           x 2,556,769 ops/sec ±1.73% (77 runs sampled)
     * Post:
     *   string literal     x 38,564,796 ops/sec ±1.15% (79 runs sampled)
     *   boolean literal    x 31,148,940 ops/sec ±1.10% (79 runs sampled)
     *   number literal     x 32,679,330 ops/sec ±1.90% (78 runs sampled)
     *   undefined          x 32,363,368 ops/sec ±1.07% (82 runs sampled)
     *   function           x 31,296,870 ops/sec ±0.96% (83 runs sampled)
     */
    var typeofObj = typeof obj;
    if (typeofObj !== 'object') {
      return typeofObj;
    }

    /* ! Speed optimisation
     * Pre:
     *   null               x 28,645,765 ops/sec ±1.17% (82 runs sampled)
     * Post:
     *   null               x 36,428,962 ops/sec ±1.37% (84 runs sampled)
     */
    if (obj === null) {
      return 'null';
    }

    /* ! Spec Conformance
     * Test: `Object.prototype.toString.call(window)``
     *  - Node === "[object global]"
     *  - Chrome === "[object global]"
     *  - Firefox === "[object Window]"
     *  - PhantomJS === "[object Window]"
     *  - Safari === "[object Window]"
     *  - IE 11 === "[object Window]"
     *  - IE Edge === "[object Window]"
     * Test: `Object.prototype.toString.call(this)``
     *  - Chrome Worker === "[object global]"
     *  - Firefox Worker === "[object DedicatedWorkerGlobalScope]"
     *  - Safari Worker === "[object DedicatedWorkerGlobalScope]"
     *  - IE 11 Worker === "[object WorkerGlobalScope]"
     *  - IE Edge Worker === "[object WorkerGlobalScope]"
     */
    if (obj === globalObject) {
      return 'global';
    }

    /* ! Speed optimisation
     * Pre:
     *   array literal      x 2,888,352 ops/sec ±0.67% (82 runs sampled)
     * Post:
     *   array literal      x 22,479,650 ops/sec ±0.96% (81 runs sampled)
     */
    if (
      Array.isArray(obj) &&
      (symbolToStringTagExists === false || !(Symbol.toStringTag in obj))
    ) {
      return 'Array';
    }

    // Not caching existence of `window` and related properties due to potential
    // for `window` to be unset before tests in quasi-browser environments.
    if (typeof window === 'object' && window !== null) {
      /* ! Spec Conformance
       * (https://html.spec.whatwg.org/multipage/browsers.html#location)
       * WhatWG HTML$7.7.3 - The `Location` interface
       * Test: `Object.prototype.toString.call(window.location)``
       *  - IE <=11 === "[object Object]"
       *  - IE Edge <=13 === "[object Object]"
       */
      if (typeof window.location === 'object' && obj === window.location) {
        return 'Location';
      }

      /* ! Spec Conformance
       * (https://html.spec.whatwg.org/#document)
       * WhatWG HTML$3.1.1 - The `Document` object
       * Note: Most browsers currently adher to the W3C DOM Level 2 spec
       *       (https://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-26809268)
       *       which suggests that browsers should use HTMLTableCellElement for
       *       both TD and TH elements. WhatWG separates these.
       *       WhatWG HTML states:
       *         > For historical reasons, Window objects must also have a
       *         > writable, configurable, non-enumerable property named
       *         > HTMLDocument whose value is the Document interface object.
       * Test: `Object.prototype.toString.call(document)``
       *  - Chrome === "[object HTMLDocument]"
       *  - Firefox === "[object HTMLDocument]"
       *  - Safari === "[object HTMLDocument]"
       *  - IE <=10 === "[object Document]"
       *  - IE 11 === "[object HTMLDocument]"
       *  - IE Edge <=13 === "[object HTMLDocument]"
       */
      if (typeof window.document === 'object' && obj === window.document) {
        return 'Document';
      }

      if (typeof window.navigator === 'object') {
        /* ! Spec Conformance
         * (https://html.spec.whatwg.org/multipage/webappapis.html#mimetypearray)
         * WhatWG HTML$8.6.1.5 - Plugins - Interface MimeTypeArray
         * Test: `Object.prototype.toString.call(navigator.mimeTypes)``
         *  - IE <=10 === "[object MSMimeTypesCollection]"
         */
        if (typeof window.navigator.mimeTypes === 'object' &&
            obj === window.navigator.mimeTypes) {
          return 'MimeTypeArray';
        }

        /* ! Spec Conformance
         * (https://html.spec.whatwg.org/multipage/webappapis.html#pluginarray)
         * WhatWG HTML$8.6.1.5 - Plugins - Interface PluginArray
         * Test: `Object.prototype.toString.call(navigator.plugins)``
         *  - IE <=10 === "[object MSPluginsCollection]"
         */
        if (typeof window.navigator.plugins === 'object' &&
            obj === window.navigator.plugins) {
          return 'PluginArray';
        }
      }

      if ((typeof window.HTMLElement === 'function' ||
          typeof window.HTMLElement === 'object') &&
          obj instanceof window.HTMLElement) {
        /* ! Spec Conformance
        * (https://html.spec.whatwg.org/multipage/webappapis.html#pluginarray)
        * WhatWG HTML$4.4.4 - The `blockquote` element - Interface `HTMLQuoteElement`
        * Test: `Object.prototype.toString.call(document.createElement('blockquote'))``
        *  - IE <=10 === "[object HTMLBlockElement]"
        */
        if (obj.tagName === 'BLOCKQUOTE') {
          return 'HTMLQuoteElement';
        }

        /* ! Spec Conformance
         * (https://html.spec.whatwg.org/#htmltabledatacellelement)
         * WhatWG HTML$4.9.9 - The `td` element - Interface `HTMLTableDataCellElement`
         * Note: Most browsers currently adher to the W3C DOM Level 2 spec
         *       (https://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-82915075)
         *       which suggests that browsers should use HTMLTableCellElement for
         *       both TD and TH elements. WhatWG separates these.
         * Test: Object.prototype.toString.call(document.createElement('td'))
         *  - Chrome === "[object HTMLTableCellElement]"
         *  - Firefox === "[object HTMLTableCellElement]"
         *  - Safari === "[object HTMLTableCellElement]"
         */
        if (obj.tagName === 'TD') {
          return 'HTMLTableDataCellElement';
        }

        /* ! Spec Conformance
         * (https://html.spec.whatwg.org/#htmltableheadercellelement)
         * WhatWG HTML$4.9.9 - The `td` element - Interface `HTMLTableHeaderCellElement`
         * Note: Most browsers currently adher to the W3C DOM Level 2 spec
         *       (https://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-82915075)
         *       which suggests that browsers should use HTMLTableCellElement for
         *       both TD and TH elements. WhatWG separates these.
         * Test: Object.prototype.toString.call(document.createElement('th'))
         *  - Chrome === "[object HTMLTableCellElement]"
         *  - Firefox === "[object HTMLTableCellElement]"
         *  - Safari === "[object HTMLTableCellElement]"
         */
        if (obj.tagName === 'TH') {
          return 'HTMLTableHeaderCellElement';
        }
      }
    }

    /* ! Speed optimisation
    * Pre:
    *   Float64Array       x 625,644 ops/sec ±1.58% (80 runs sampled)
    *   Float32Array       x 1,279,852 ops/sec ±2.91% (77 runs sampled)
    *   Uint32Array        x 1,178,185 ops/sec ±1.95% (83 runs sampled)
    *   Uint16Array        x 1,008,380 ops/sec ±2.25% (80 runs sampled)
    *   Uint8Array         x 1,128,040 ops/sec ±2.11% (81 runs sampled)
    *   Int32Array         x 1,170,119 ops/sec ±2.88% (80 runs sampled)
    *   Int16Array         x 1,176,348 ops/sec ±5.79% (86 runs sampled)
    *   Int8Array          x 1,058,707 ops/sec ±4.94% (77 runs sampled)
    *   Uint8ClampedArray  x 1,110,633 ops/sec ±4.20% (80 runs sampled)
    * Post:
    *   Float64Array       x 7,105,671 ops/sec ±13.47% (64 runs sampled)
    *   Float32Array       x 5,887,912 ops/sec ±1.46% (82 runs sampled)
    *   Uint32Array        x 6,491,661 ops/sec ±1.76% (79 runs sampled)
    *   Uint16Array        x 6,559,795 ops/sec ±1.67% (82 runs sampled)
    *   Uint8Array         x 6,463,966 ops/sec ±1.43% (85 runs sampled)
    *   Int32Array         x 5,641,841 ops/sec ±3.49% (81 runs sampled)
    *   Int16Array         x 6,583,511 ops/sec ±1.98% (80 runs sampled)
    *   Int8Array          x 6,606,078 ops/sec ±1.74% (81 runs sampled)
    *   Uint8ClampedArray  x 6,602,224 ops/sec ±1.77% (83 runs sampled)
    */
    var stringTag = (symbolToStringTagExists && obj[Symbol.toStringTag]);
    if (typeof stringTag === 'string') {
      return stringTag;
    }

    var objPrototype = Object.getPrototypeOf(obj);
    /* ! Speed optimisation
    * Pre:
    *   regex literal      x 1,772,385 ops/sec ±1.85% (77 runs sampled)
    *   regex constructor  x 2,143,634 ops/sec ±2.46% (78 runs sampled)
    * Post:
    *   regex literal      x 3,928,009 ops/sec ±0.65% (78 runs sampled)
    *   regex constructor  x 3,931,108 ops/sec ±0.58% (84 runs sampled)
    */
    if (objPrototype === RegExp.prototype) {
      return 'RegExp';
    }

    /* ! Speed optimisation
    * Pre:
    *   date               x 2,130,074 ops/sec ±4.42% (68 runs sampled)
    * Post:
    *   date               x 3,953,779 ops/sec ±1.35% (77 runs sampled)
    */
    if (objPrototype === Date.prototype) {
      return 'Date';
    }

    /* ! Spec Conformance
     * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-promise.prototype-@@tostringtag)
     * ES6$25.4.5.4 - Promise.prototype[@@toStringTag] should be "Promise":
     * Test: `Object.prototype.toString.call(Promise.resolve())``
     *  - Chrome <=47 === "[object Object]"
     *  - Edge <=20 === "[object Object]"
     *  - Firefox 29-Latest === "[object Promise]"
     *  - Safari 7.1-Latest === "[object Promise]"
     */
    if (promiseExists && objPrototype === Promise.prototype) {
      return 'Promise';
    }

    /* ! Speed optimisation
    * Pre:
    *   set                x 2,222,186 ops/sec ±1.31% (82 runs sampled)
    * Post:
    *   set                x 4,545,879 ops/sec ±1.13% (83 runs sampled)
    */
    if (setExists && objPrototype === Set.prototype) {
      return 'Set';
    }

    /* ! Speed optimisation
    * Pre:
    *   map                x 2,396,842 ops/sec ±1.59% (81 runs sampled)
    * Post:
    *   map                x 4,183,945 ops/sec ±6.59% (82 runs sampled)
    */
    if (mapExists && objPrototype === Map.prototype) {
      return 'Map';
    }

    /* ! Speed optimisation
    * Pre:
    *   weakset            x 1,323,220 ops/sec ±2.17% (76 runs sampled)
    * Post:
    *   weakset            x 4,237,510 ops/sec ±2.01% (77 runs sampled)
    */
    if (weakSetExists && objPrototype === WeakSet.prototype) {
      return 'WeakSet';
    }

    /* ! Speed optimisation
    * Pre:
    *   weakmap            x 1,500,260 ops/sec ±2.02% (78 runs sampled)
    * Post:
    *   weakmap            x 3,881,384 ops/sec ±1.45% (82 runs sampled)
    */
    if (weakMapExists && objPrototype === WeakMap.prototype) {
      return 'WeakMap';
    }

    /* ! Spec Conformance
     * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-dataview.prototype-@@tostringtag)
     * ES6$24.2.4.21 - DataView.prototype[@@toStringTag] should be "DataView":
     * Test: `Object.prototype.toString.call(new DataView(new ArrayBuffer(1)))``
     *  - Edge <=13 === "[object Object]"
     */
    if (dataViewExists && objPrototype === DataView.prototype) {
      return 'DataView';
    }

    /* ! Spec Conformance
     * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%mapiteratorprototype%-@@tostringtag)
     * ES6$23.1.5.2.2 - %MapIteratorPrototype%[@@toStringTag] should be "Map Iterator":
     * Test: `Object.prototype.toString.call(new Map().entries())``
     *  - Edge <=13 === "[object Object]"
     */
    if (mapExists && objPrototype === mapIteratorPrototype) {
      return 'Map Iterator';
    }

    /* ! Spec Conformance
     * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%setiteratorprototype%-@@tostringtag)
     * ES6$23.2.5.2.2 - %SetIteratorPrototype%[@@toStringTag] should be "Set Iterator":
     * Test: `Object.prototype.toString.call(new Set().entries())``
     *  - Edge <=13 === "[object Object]"
     */
    if (setExists && objPrototype === setIteratorPrototype) {
      return 'Set Iterator';
    }

    /* ! Spec Conformance
     * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%arrayiteratorprototype%-@@tostringtag)
     * ES6$22.1.5.2.2 - %ArrayIteratorPrototype%[@@toStringTag] should be "Array Iterator":
     * Test: `Object.prototype.toString.call([][Symbol.iterator]())``
     *  - Edge <=13 === "[object Object]"
     */
    if (arrayIteratorExists && objPrototype === arrayIteratorPrototype) {
      return 'Array Iterator';
    }

    /* ! Spec Conformance
     * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%stringiteratorprototype%-@@tostringtag)
     * ES6$21.1.5.2.2 - %StringIteratorPrototype%[@@toStringTag] should be "String Iterator":
     * Test: `Object.prototype.toString.call(''[Symbol.iterator]())``
     *  - Edge <=13 === "[object Object]"
     */
    if (stringIteratorExists && objPrototype === stringIteratorPrototype) {
      return 'String Iterator';
    }

    /* ! Speed optimisation
    * Pre:
    *   object from null   x 2,424,320 ops/sec ±1.67% (76 runs sampled)
    * Post:
    *   object from null   x 5,838,000 ops/sec ±0.99% (84 runs sampled)
    */
    if (objPrototype === null) {
      return 'Object';
    }

    return Object
      .prototype
      .toString
      .call(obj)
      .slice(toStringLeftSliceLength, toStringRightSliceLength);
  }

  return typeDetect;

  })));
  });

  /**
   * @file env.js
   * @module env
   */
  var IN_BROWSER = typeof window !== 'undefined'; // 请勿在这里引用common-utlils的isFunction，避免模块循环引用
  // 作为小程序插件使用时，wx.canIUse 是 undefined，这个接口在sdk内已经不再用了，干脆去掉

  var IN_WX_MINI_APP = typeof wx !== 'undefined' && typeof wx.getSystemInfoSync === 'function';
  var USER_AGENT = IN_BROWSER && window.navigator && window.navigator.userAgent || '';
  var webkitVersionMap = /AppleWebKit\/([\d.]+)/i.exec(USER_AGENT);
  var appleWebkitVersion = webkitVersionMap ? parseFloat(webkitVersionMap.pop()) : null;
  /*
   * Device is an iPhone
   *
   * @type {Boolean}
   * @constant
   * @private
   */

  var IS_IPAD = /iPad/i.test(USER_AGENT); // The Facebook app's UIWebView identifies as both an iPhone and iPad, so
  // to identify iPhones, we need to exclude iPads.
  // http://artsy.github.io/blog/2012/10/18/the-perils-of-ios-user-agent-sniffing/

  var IS_IPHONE = /iPhone/i.test(USER_AGENT) && !IS_IPAD;
  var IS_IPOD = /iPod/i.test(USER_AGENT);
  var IOS_VERSION = function () {
    var match = USER_AGENT.match(/OS (\d+)_/i);

    if (match && match[1]) {
      return match[1];
    }

    return null;
  }();
  var IS_ANDROID = /Android/i.test(USER_AGENT);
  var ANDROID_VERSION = function () {
    // This matches Android Major.Minor.Patch versions
    // ANDROID_VERSION is Major.Minor as a Number, if Minor isn't available, then only Major is returned
    var match = USER_AGENT.match(/Android (\d+)(?:\.(\d+))?(?:\.(\d+))*/i);

    if (!match) {
      return null;
    }

    var major = match[1] && parseFloat(match[1]);
    var minor = match[2] && parseFloat(match[2]);

    if (major && minor) {
      return parseFloat(match[1] + '.' + match[2]);
    }

    if (major) {
      return major;
    }

    return null;
  }(); // Old Android is defined as Version older than 2.3, and requiring a webkit version of the android browser

  var IS_OLD_ANDROID = IS_ANDROID && /webkit/i.test(USER_AGENT) && ANDROID_VERSION < 2.3;
  var IS_FIREFOX = /Firefox/i.test(USER_AGENT);
  var IS_EDGE = /Edge/i.test(USER_AGENT);
  var IS_CHROME = !IS_EDGE && /Chrome/i.test(USER_AGENT);
  var CHROME_VERSION = function () {
    var match = USER_AGENT.match(/Chrome\/(\d+)/);

    if (match && match[1]) {
      return parseFloat(match[1]);
    }

    return null;
  }(); // IE

  var IS_IE = /MSIE/.test(USER_AGENT); // 是否为IE浏览器

  var IS_IE8 = /MSIE\s8\.0/.test(USER_AGENT);
  var IE_VERSION = function () {
    var result = /MSIE\s(\d+)\.\d/.exec(USER_AGENT);
    var version = result && parseFloat(result[1]);

    if (!version && /Trident\/7.0/i.test(USER_AGENT) && /rv:11.0/.test(USER_AGENT)) {
      // IE 11 has a different user agent string than other IE versions
      version = 11.0;
    }

    return version;
  }(); // Safari

  var IS_SAFARI = /Safari/i.test(USER_AGENT) && !IS_CHROME && !IS_ANDROID && !IS_EDGE;
  var IS_TBS = /TBS\/\d+/i.test(USER_AGENT); // 仅X5内核，QQ浏览器默认x5内核，但是agent没有TBS

  var TBS_VERSION = function () {
    var match = USER_AGENT.match(/TBS\/(\d+)/i);

    if (match && match[1]) {
      return match[1];
    }
  }(); // X5内核版本

  var IS_MQQB = !IS_TBS && /MQQBrowser\/\d+/i.test(USER_AGENT); // 移动端QQ浏览器

  var IS_QQB = !IS_TBS && / QQBrowser\/\d+/i.test(USER_AGENT); // pc端QQ浏览器

  var IS_WECHAT = /(micromessenger|webbrowser)/i.test(USER_AGENT);
  var IS_WIN = /Windows/i.test(USER_AGENT); // window系统

  var IS_MAC = /MAC OS X/i.test(USER_AGENT); // MAC系统，先检查IOS

  var IS_WX = /MicroMessenger/i.test(USER_AGENT); // 是否为微信环境

  var global$1 = (typeof global !== "undefined" ? global :
              typeof self !== "undefined" ? self :
              typeof window !== "undefined" ? window : {});

  var _console;

  var method;

  if (typeof console !== 'undefined') {
    _console = console;
  } else if (typeof global$1 !== 'undefined' && global$1.console) {
    _console = global$1.console;
  } else if (typeof window !== 'undefined' && window.console) {
    _console = window.console;
  } else {
    _console = {};
  }

  var noop = function noop() {};

  var methods = ['assert', 'clear', 'count', 'debug', 'dir', 'dirxml', 'error', 'exception', 'group', 'groupCollapsed', 'groupEnd', 'info', 'log', 'markTimeline', 'profile', 'profileEnd', 'table', 'time', 'timeEnd', 'timeStamp', 'trace', 'warn'];
  var length = methods.length;

  while (length--) {
    method = methods[length];

    if (!console[method]) {
      _console[method] = noop;
    }
  }

  _console.methods = methods;
  var console$1 = _console;

  var LOGLEVEL_DEBUG = -1;
  var LOGLEVEL_LOG = 0;
  var LOGLEVEL_INFO = 1;
  var LOGLEVEL_WARN = 2;
  var LOGLEVEL_ERROR = 3;
  var LOGLEVEL_NON_LOGGING = 4; // 无日志记录级别，sdk将不打印任何日志

  var MAX_LOG_LENGTH = 1000;
  var globalLevel = LOGLEVEL_LOG; // 暂停使用 wx.getLogManager，没发现它能起到什么作用
  var timerMap = new Map();
  /**
   * 对齐毫秒字符串
   * @param {*} ms 毫秒
   * @returns {String} 对齐后的毫秒时间字符串
   */

  function padMs(ms) {
    var len = ms.toString().length;
    var ret;

    switch (len) {
      case 1:
        ret = '00' + ms;
        break;

      case 2:
        ret = '0' + ms;
        break;

      default:
        ret = ms;
        break;
    }

    return ret;
  }
  /**
   * log前缀
   * @returns {String} 日志前缀
   */


  function getPrefix() {
    var date = new Date();
    return 'TIM ' + date.toLocaleTimeString('en-US', {
      hour12: false
    }) + '.' + padMs(date.getMilliseconds()) + ':';
  }
  /**
   * wx LogManager是否可用
   * @returns {Boolean} true->I can use LogManager
   */
  // function canIUseWxLog() {
  //   if (IN_WX_MINI_APP) {
  //     // 必须是微信小程序环境，百度小程序目前还只能用console
  //     const version = wx.getSystemInfoSync().SDKVersion;
  //     // HBuilder等工具会在window对象下挂自己模拟的wx对象，但是又没抄好，做个防御
  //     if (typeof version === 'undefined' ||
  //       typeof wx.getLogManager === 'undefined') {
  //       return false;
  //     }
  //     if (compareVersion(version, '2.1.0') >= 0) {
  //       wx.getLogManager().log('I can use wx log. SDKVersion=' + version);
  //       return true;
  //     }
  //   }
  //   return false;
  // }

  /**
   * 比较wx SDKVersion
   * @param {String} v1 版本字符串
   * @param {String} v2 版本字符串
   * @returns {Number} v1>v2，返回1；v1<v2，返回-1；v1==v2，返回0
   */
  // function compareVersion(v1, v2) {
  //   v1 = v1.split('.');
  //   v2 = v2.split('.');
  //   const len = Math.max(v1.length, v2.length);
  //   while (v1.length < len) {
  //     v1.push('0');
  //   }
  //   while (v2.length < len) {
  //     v2.push('0');
  //   }
  //   for (let i = 0; i < len; i++) {
  //     const num1 = parseInt(v1[i]);
  //     const num2 = parseInt(v2[i]);
  //     if (num1 > num2) {
  //       return 1;
  //     }
  //     if (num1 < num2) {
  //       return -1;
  //     }
  //   }
  //   return 0;
  // }


  var logger = {
    _data: [],
    _length: 0,
    _visible: false,
    // 将函数参数拼成字符串
    arguments2String: function arguments2String(args) {
      var s;

      if (args.length === 1) {
        s = getPrefix() + args[0];
      } else {
        s = getPrefix();

        for (var i = 0, length = args.length; i < length; i++) {
          if (isArrayOrObject(args[i])) {
            if (isInstanceOfError(args[i])) {
              s += stringifyError(args[i]);
            } else {
              s += JSON.stringify(args[i]);
            }
          } else {
            s += args[i];
          }

          s += ' ';
        }
      }

      return s;
    },

    /**
     * 打印调试日志
     */
    debug: function debug() {
      if (globalLevel <= LOGLEVEL_DEBUG) {
        // 对参数使用slice会阻止某些JavaScript引擎中的优化 (比如 V8 - 更多信息)
        // see:https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#3-managing-arguments
        var s = this.arguments2String(arguments);
        logger.record(s, 'debug');
        console$1.debug(s);
      }
    },

    /**
     * 打印普通日志
     */
    log: function log() {
      if (globalLevel <= LOGLEVEL_LOG) {
        var s = this.arguments2String(arguments);
        logger.record(s, 'log');
        console$1.log(s);
      }
    },

    /**
     * 打印release日志
     */
    info: function info() {
      if (globalLevel <= LOGLEVEL_INFO) {
        var s = this.arguments2String(arguments);
        logger.record(s, 'info');
        console$1.info(s);
      }
    },

    /**
     * 打印告警日志
     */
    warn: function warn() {
      if (globalLevel <= LOGLEVEL_WARN) {
        var s = this.arguments2String(arguments);
        logger.record(s, 'warn');
        console$1.warn(s);
      }
    },

    /**
     * 打印错误日志
     */
    error: function error() {
      if (globalLevel <= LOGLEVEL_ERROR) {
        var s = this.arguments2String(arguments);
        logger.record(s, 'error');
        console$1.error(s); // 微信写不了error日志，就用warn代替了
      }
    },
    time: function time(label) {
      timerMap.set(label, TimeUtil.now());
    },
    timeEnd: function timeEnd(label) {
      if (timerMap.has(label)) {
        var cost = TimeUtil.now() - timerMap.get(label);
        timerMap["delete"](label);
        return cost;
      }

      console$1.warn("\u672A\u627E\u5230\u5BF9\u5E94label: ".concat(label, ", \u8BF7\u5728\u8C03\u7528 logger.timeEnd \u524D\uFF0C\u8C03\u7528 logger.time"));
      return 0;
    },
    setLevel: function setLevel(newLevel) {
      if (newLevel < LOGLEVEL_NON_LOGGING) {
        console$1.log(getPrefix() + 'set level from ' + globalLevel + ' to ' + newLevel);
      }

      globalLevel = newLevel;
    },
    record: function record(s, type) {

      if (logger._length === MAX_LOG_LENGTH + 100) {
        logger._data.splice(0, 100);

        logger._length = MAX_LOG_LENGTH;
      }

      logger._length++;

      logger._data.push("".concat(s, " [").concat(type, "] \n"));
    },
    getLog: function getLog() {
      return logger._data;
    }
  };

  /**
   * 检测input类型是否为Map
   * @param {*} input 任意类型的输入
   * @returns {Boolean} true->map / false->not a map
   */

  var isMap = function isMap(input) {
    return getType(input) === 'map';
  };
  /**
   * 检测input类型是否为Set
   * @param {*} input 任意类型的输入
   * @returns {Boolean} true->set / false->not a set
   */

  var isSet = function isSet(input) {
    return getType(input) === 'set';
  };
  /**
   * 检测input类型是否为File
   * @param {*} input 任意类型的输入
   * @returns {Boolean} true->file / false->not a file
   */

  var isFile = function isFile(input) {
    return getType(input) === 'file';
  };
  /**
   * 检测input类型是否为number
   * @param {*} input 任意类型的输入
   * @returns {Boolean} true->number / false->not a number
   */

  var isNumber = function isNumber(input) {
    return input !== null && (typeof input === 'number' && !isNaN(input - 0) || _typeof(input) === 'object' && input.constructor === Number);
  };
  /**
   * 检测input类型是否为string
   * @param {*} input 任意类型的输入
   * @returns {Boolean} true->string / false->not a string
   */

  var isString = function isString(input) {
    return typeof input === 'string';
  };
  var isObject = function isObject(input) {
    // null is object, hence the extra check
    return input !== null && _typeof(input) === 'object';
  };
  /**
   * Checks to see if a value is an object and only an object
   * plain object: 没有标准定义，一般认为通过 {} 或者 new Object() 或者 Object.create(null) 方式创建的对象是纯粹对象
   * @param {*} input 任意类型的输入
   * @returns {Boolean} true->an object and only an object
   */

  var isPlainObject = function isPlainObject(input) {
    // 注意不能使用以下方式判断，因为IE9/IE10下，对象的__proto__是undefined
    // return isObject(input) && input.__proto__ === Object.prototype;
    if (_typeof(input) !== 'object' || input === null) {
      return false;
    }

    var proto = Object.getPrototypeOf(input);

    if (proto === null) {
      // edge case Object.create(null)
      return true;
    }

    var baseProto = proto;

    while (Object.getPrototypeOf(baseProto) !== null) {
      baseProto = Object.getPrototypeOf(baseProto);
    } // 2. 原型链第一个和最后一个比较


    return proto === baseProto;
  };
  /**
   * 检测input类型是否为数组
   * @param {*} input 任意类型的输入
   * @returns {Boolean} true->array / false->not an array
   */

  var isArray = function isArray(input) {
    if (typeof Array.isArray === 'function') {
      return Array.isArray(input);
    }

    return getType(input) === 'array';
  };
  /**
   * Checks to see if a value is undefined
   * @param {*} input 任意类型的输入
   * @returns {Boolean} true->input value is undefined
   */

  var isUndefined = function isUndefined(input) {
    return typeof input === 'undefined';
  };
  /**
   * 检测input类型是否为数组或者object
   * @param {*} input 任意类型的输入
   * @returns {Boolean} true->input is an array or an object
   */

  var isArrayOrObject = function isArrayOrObject(input) {
    return isArray(input) || isObject(input);
  };
  /**
   * 检测input类型是否为function
   * @param {*} input 任意类型的输入
   * @returns {Boolean} true->input is a function
   */

  var isFunction = function isFunction(input) {
    return typeof input === 'function';
  };
  /**
   * 检测input是否为Error的实例
   * @param {*} input 任意类型的输入
   * @returns {Boolean} true->input is an instance of Error
   */

  var isInstanceOfError = function isInstanceOfError(input) {
    return input instanceof Error;
  };
  /**
   * Get the object type string
   * @param {*} input 任意类型的输入
   * @returns {String} the object type string
   */

  var getType = function getType(input) {
    return Object.prototype.toString.call(input).match(/^\[object (.*)\]$/)[1].toLowerCase();
  };
  /**
   * ### 用于 request 参数 key 名称的合法性验证。
   * > 不合法的 key 有:
   *  - 非 string 类型的 key ；
   *  - 非字母和数字开头的 key ；
   * @param {string} key - 参数 key
   * @returns {boolean}
   *  - true : 合法；
   *  - false: 非法；
  */

  var isValidRequestKey = function isValidRequestKey(key) {
    // 非 string 类型的 key
    if (typeof key !== 'string') {
      return false;
    }

    var firstCharactor = key[0]; // 非字母和数字开头的 key

    if (/[^a-zA-Z0-9]/.test(firstCharactor)) {
      return false;
    }

    return true;
  }; // -----------------获取时间工具函数，计算耗时用-----------------

  var baseTime = 0;

  if (!Date.now) {
    Date.now = function now() {
      return new Date().getTime();
    };
  }

  var TimeUtil = {
    now: function now() {
      if (baseTime === 0) {
        baseTime = Date.now() - 1;
      }

      var diff = Date.now() - baseTime;

      if (diff > 0xffffffff) {
        baseTime += 0xffffffff;
        return Date.now() - baseTime;
      }

      return diff;
    },
    utc: function utc() {
      return Math.round(Date.now() / 1000);
    }
  }; // -----------------深度合并工具函数-----------------

  /**
   * 深度 merge 两个对象。merge source to target.
   * @param {Object|Object[]} target 目标对象
   * @param {Object|Object[]} source 来源对象
   * @param {String[]} [keysIgnore] 要忽略的 keys。命中的 key 会在merge时被忽略
   * @param {*[]} [valuesIgnore] 要忽略的 values。命中的 value 会在merge时被忽略
   * @returns {Number} merge的次数（只有key相同value不同的时候才会merge），如果target和source既不是数组也不是object，则返回0
   */

  var deepMerge = function deepMerge(target, source, keysIgnore, valuesIgnore) {
    // 1. 非 Array 或 Object 类型则直接 return
    if (!(isArrayOrObject(target) && isArrayOrObject(source))) {
      return 0;
    }

    var mergedCount = 0;
    var keys = Object.keys(source);
    var tmpKey;

    for (var i = 0, len = keys.length; i < len; i++) {
      tmpKey = keys[i];

      if (isUndefined(source[tmpKey]) || keysIgnore && keysIgnore.includes(tmpKey)) {
        continue;
      }

      if (isArrayOrObject(target[tmpKey]) && isArrayOrObject(source[tmpKey])) {
        // 递归merge
        mergedCount += deepMerge(target[tmpKey], source[tmpKey], keysIgnore, valuesIgnore);
      } else {
        if (valuesIgnore && valuesIgnore.includes(source[tmpKey])) {
          continue;
        }

        if (target[tmpKey] !== source[tmpKey]) {
          target[tmpKey] = source[tmpKey];
          mergedCount += 1;
        }
      }
    }

    return mergedCount;
  }; // 简单的深拷贝实现

  /**
   * 序列化Error实例，只序列化Error实例的message和code属性（如果有的话）
   * @param {Error} error Error实例
   * @returns {String} 序列化后的内容
   */

  var stringifyError = function stringifyError(error) {
    return JSON.stringify(error, ['message', 'code']);
  };
  /**
   * 返回一个 ISO（ISO 8601 Extended Format）格式的字符串，如"2019-11-15T18:45:06.000+0800"，用于记录sso上报时的时间
   * @returns {String}
   */

  var date2ISOString = function date2ISOString() {
    var date = new Date(); // YYYY-MM-DDTHH:mm:ss.sssZ。时区总是UTC（协调世界时），加一个后缀“Z”标识。

    var tempISOString = date.toISOString(); // 返回协调世界时（UTC）相对于当前时区的时间差值，单位为分钟。
    // 如果本地时区晚于协调世界时，则该差值为正值，如果早于协调世界时则为负值

    var timezoneOffset = date.getTimezoneOffset();
    var currentTimeZoneInHour = timezoneOffset / 60;
    var replaceString = '';

    if (currentTimeZoneInHour < 0) {
      // 东区
      if (currentTimeZoneInHour > -10) {
        replaceString = '+0' + Math.abs(currentTimeZoneInHour * 100);
      } else {
        replaceString = '+' + Math.abs(currentTimeZoneInHour * 100);
      }
    } else {
      // 西区
      if (currentTimeZoneInHour >= 10) {
        replaceString = '-' + currentTimeZoneInHour * 100;
      } else {
        replaceString = '-0' + currentTimeZoneInHour * 100;
      }
    } // 不需要 encodeURIComponent 把 + 转成 %2B，kibana能识别


    return tempISOString.replace('Z', replaceString);
  };
  /**
   * 获取字符串占用的字节数
   * @param {String} string - 字符串
   * @returns {Number} 字符串的长度
   */

  var stringSize = function stringSize(string) {
    if (string.length === 0) {
      return 0;
    }

    var i = 0;
    var _char = '';
    var len = 0;
    var sizeStep = 1;

    var charSet = function () {
      if (typeof document !== 'undefined' && typeof document.characterSet !== 'undefined') {
        return document.characterSet;
      }

      return 'UTF-8';
    }();

    while (typeof string[i] !== 'undefined') {
      _char = string[i++];

      if (_char.charCodeAt[i] <= 255) {
        sizeStep = 1;
      } else {
        sizeStep = charSet === 'UTF-8' >= 0 ? 3 : 2;
      }

      len += sizeStep;
    }

    return len;
  };
  /**
   *  用于生成随机整数
   * @param {Number} level - 整数的级别 例如： 99, 999 , 9999 等
   * @returns {Number} 随机数字
   */

  var randomInt = function randomInt(level) {
    var lv = level || 99999999;
    return Math.round(Math.random() * lv);
  };
  var CHARS = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
  var CHARS_LENGTH = CHARS.length;
  /**
   * 获取[0,9],[a-z],[A,Z]拼成的随机字符串，长度32
   * @returns {String} 长度为32的随机字符串
   */

  var randomString = function randomString() {
    var result = '';

    for (var i = 32; i > 0; --i) {
      result += CHARS[Math.floor(Math.random() * CHARS_LENGTH)];
    }

    return result;
  }; // 判断传入的枚举值是否有效

  var isValidType = function isValidType(obj, type) {
    for (var k in obj) {
      if (obj[k] === type) {
        return true;
      }
    }

    return false;
  };
  var AIIList = {};
  var autoincrementIndex = function autoincrementIndex(key) {
    if (!key) {
      logger.error("autoincrementIndex(string: key) need key parameter");
      return false;
    }

    if (typeof AIIList[key] === 'undefined') {
      var dateInstance = new Date();
      var hoursString = "3".concat(dateInstance.getHours()).slice(-2); // 小时数，用3占位，因为一天中不会出现30小时

      var minuteString = "0".concat(dateInstance.getMinutes()).slice(-2);
      var secondString = "0".concat(dateInstance.getSeconds()).slice(-2);
      AIIList[key] = parseInt([hoursString, minuteString, secondString, '0001'].join(''));
      hoursString = null;
      minuteString = null;
      secondString = null;
      logger.warn("utils.autoincrementIndex() create new sequence : ".concat(key, " = ").concat(AIIList[key]));
    }

    return AIIList[key]++;
  };
  var getPageProtocol = function getPageProtocol() {
    if (IN_WX_MINI_APP) {
      return 'https:';
    }

    var preFix = window.location.protocol;

    if (['http:', 'https:'].indexOf(preFix) < 0) {
      preFix = 'http:';
    }

    return preFix;
  }; // 统一用HTTPS

  var uniformHTTPS = function uniformHTTPS(url) {
    if (url.indexOf('http://') === -1 || url.indexOf('https://') === -1) {
      return 'https://' + url;
    }

    return url.replace(/https|http/, 'https');
  };
  /**
   * 深度克隆
   * @param {Object} data 要克隆的对象
   * @returns {Object} 克隆后的对象
   */

  var clone = function clone(data) {
    if (Object.getOwnPropertyNames(data).length === 0) {
      return Object.create(null);
    }

    var newObject = Array.isArray(data) ? [] : Object.create(null);
    var type = ''; // eslint-disable-next-line guard-for-in

    for (var key in data) {
      // null 是一个特殊的对象，优先处理掉
      if (data[key] === null) {
        newObject[key] = null;
        continue;
      } // undefined 也优先处理掉


      if (data[key] === undefined) {
        newObject[key] = undefined;
        continue;
      }

      type = _typeof(data[key]);

      if (['string', 'number', 'function', 'boolean'].indexOf(type) >= 0) {
        newObject[key] = data[key];
        continue;
      } // 只剩对象，递归


      newObject[key] = clone(data[key]);
    }

    return newObject;
  };
  /**
   * 更新自定义字段，如资料自定义字段，群组自定义字段，群成员自定义字段
   * @param {Object[]} target 待更新的自定义字段数组 [{key,value}, {key,value}, ...]
   * @param {Object[]} source 最新的自定义字段数组 [{key,value}, {key,value}, ...]
   */

  function updateCustomField(target, source) {
    if (!isArray(target) || !isArray(source)) {
      logger.warn('updateCustomField target 或 source 不是数组，忽略此次更新。');
      return;
    }

    source.forEach(function (_ref) {
      var key = _ref.key,
          value = _ref.value;
      var customField = target.find(function (item) {
        return item.key === key;
      });

      if (customField) {
        customField.value = value;
      } else {
        target.push({
          key: key,
          value: value
        });
      }
    });
  } // -----------------群组类型判断工具函数-----------------
  var isPublic = function isPublic(type) {
    return type === TYPES.GRP_PUBLIC;
  };
  var isChatRoom = function isChatRoom(type) {
    return type === TYPES.GRP_CHATROOM;
  };
  var isAVChatRoom = function isAVChatRoom(type) {
    return type === TYPES.GRP_AVCHATROOM;
  }; // -----------------根据会话 ID 判断会话类型-----------------

  var isC2CConversation = function isC2CConversation(conversationID) {
    return isString(conversationID) && conversationID.slice(0, 3) === TYPES.CONV_C2C;
  };
  var isGroupConversation = function isGroupConversation(conversationID) {
    return isString(conversationID) && conversationID.slice(0, 5) === TYPES.CONV_GROUP;
  };
  var isSystemConversation = function isSystemConversation(conversationID) {
    return isString(conversationID) && conversationID === TYPES.CONV_SYSTEM;
  };
  /**
   * 类似 lodash.mapKeys 功能，并具备过滤 keys 的功能
   * @export
   * @param {*} obj
   * @param {*} iteratee
   */

  function filterMapKeys(obj, iteratee) {
    var newObj = Object.create(null);
    Object.keys(obj).forEach(function (key) {
      var nextKey = iteratee(obj[key], key); // 回调返回 false 则过滤 key

      if (nextKey) {
        newObj[nextKey] = obj[key];
      }
    });
    return newObj;
  } // -----------------类lodash.mapKeys函数-----------------

  function mapKeys(obj, iteratee) {
    var newObj = {};
    Object.keys(obj).forEach(function (key) {
      newObj[iteratee(obj[key], key)] = obj[key];
    });
    return newObj;
  } // -----------------类lodash.mapValues函数-----------------

  function mapValues(obj, iteratee) {
    var newObj = {};
    Object.keys(obj).forEach(function (key) {
      newObj[key] = iteratee(obj[key], key);
    });
    return newObj;
  } // -----------------探测函数-----------------

  /**
   * 探测图片文件的宽和高
   * @param {*} imageURL 图片地址
   * @returns {Promise}
   */

  function probeImageWidthHeight(imageURL) {
    // h5不能用FileReader，因为FileReader处理后，input选择的file对象会被释放掉，导致无法用cos上传
    // 用createObjectURL(file)生成url，不能立即赋值给image.src，因为触发onload事件后，file对象也会被释放掉，导致无法用cos上传
    // 用createObjectURL(file)生成url，然后用cos上传，cos上传后file对象被释放掉，此时将url赋值给image.src，在onload回调里就能探测到宽高
    if (!IN_WX_MINI_APP) {
      // IE9就不探测了，填0
      if (IS_IE && IE_VERSION === 9) {
        return Promise.resolve({
          width: 0,
          height: 0
        });
      }

      return new Promise(function (resolve, reject) {
        var image = new Image();

        image.onload = function () {
          resolve({
            width: this.width,
            height: this.height
          });
          image = null;
        };

        image.onerror = function () {
          resolve({
            width: 0,
            height: 0
          });
          image = null;
        };

        image.src = imageURL;
      });
    } // 小程序用wx.getImageInfo探测


    return new Promise(function (resolve, reject) {
      wx.getImageInfo({
        src: imageURL,
        success: function success(res) {
          resolve({
            width: res.width,
            height: res.height
          });
        },
        fail: function fail() {
          resolve({
            width: 0,
            height: 0
          });
        }
      });
    });
  }

  /**
   * Has own property.
   *
   * @type {Function}
   */

  var hasOwnProperty = Object.prototype.hasOwnProperty;
  /**
   * Test whether a value is "empty".
   *
   * @param {Mixed} val
   * @returns {Boolean}
   */

  function isEmpty(val) {
    // Null and Undefined...
    if (val === null || typeof val === 'undefined') return true; // Booleans...

    if ('boolean' === typeof val) return false; // Numbers...

    if ('number' === typeof val) return val === 0; // Strings...

    if ('string' === typeof val) return val.length === 0; // Functions...

    if ('function' === typeof val) return val.length === 0; // Arrays...

    if (Array.isArray(val)) return val.length === 0; // Errors...

    if (val instanceof Error) return val.message === ''; // plain object

    if (isPlainObject(val)) {
      for (var key in val) {
        if (hasOwnProperty.call(val, key)) {
          return false;
        }
      }

      return true;
    } // map or set or file


    if (isMap(val) || isSet(val) || isFile(val)) {
      return val.size === 0;
    } // Anything else...


    return false;
  }

  /**
   *
   * @param {*} obj
   */
  // function getType(obj) {
  //   return Reflect.apply(Object.prototype.toString, obj, [])
  //     .replace(/^\[object\s(\w+)\]$/, '$1')
  //     .toLowerCase();
  // }

  /**
   *
   * @param {*} options
   * @param {*} validateConfig
   */

  function validateParams(args, validateConfig, functionName) {
    // console.log('TIM validateParams', functionName, args, validateConfig); //  typeof options, validateConfig,
    // 没有传入对应的参数校验配置
    if (validateConfig === undefined) {
      return true;
    } // args 为 arguments 转数组


    var valid = true; // 需要以 validateConfig 为基准进行遍历判断

    if (typeDetect(validateConfig).toLowerCase() === 'object') {
      // 检查单个对象参数的情况
      Object.keys(validateConfig).forEach(function (key) {
        var params = args.length === 1 ? args[0][key] : undefined; // 只要返回一次false，结果就是false

        valid = _validateParams(params, validateConfig[key], functionName, key) ? valid : false;
      });
    } else if (typeDetect(validateConfig).toLowerCase() === 'array') {
      // 检查多个参数的情况
      for (var i = 0; i < validateConfig.length; i++) {
        valid = _validateParams(args[i], validateConfig[i], functionName, validateConfig[i].name) ? valid : false;
      }
    }

    if (valid) {
      return valid; // 通过验证
    }

    throw new Error('Params validate failed.'); // 验证不通过，中断同步函数执行
  }
  /**
   *
   * @param {*} param
   * @param {*} validateConfig
   */

  function _validateParams(param, validateConfig, functionName, paramName) {
    if (validateConfig === undefined) {
      return true;
    }

    var valid = true;

    if (validateConfig.required && isEmpty(param)) {
      console$1.error("TIM [".concat(functionName, "] Missing required params: \"").concat(paramName, "\"."));
      valid = false;
    } // 检查基本数据类型


    if (!isEmpty(param) && typeDetect(param).toLowerCase() !== validateConfig.type.toLowerCase()) {
      console$1.error("TIM [".concat(functionName, "] Invalid params: type check failed for \"").concat(paramName, "\".Expected ").concat(validateConfig.type, "."));
      valid = false;
    } // 自定义检测逻辑


    if (validateConfig.validator && !validateConfig.validator(param)) {
      console$1.error("TIM [".concat(functionName, "] Invalid params: custom validator check failed for params."));
      valid = false;
    }

    return valid;
  }

  /**
   * 状态码，
   */

  /**
   * 一些常用的状态
   */
  var COMMON_STATUS = {
    SUCCESS: 'OK',
    FAIL: 'FAIL'
  };
  /**
   * 网络请求状态
   */

  var REQUEST_STATUS = {
    SUCCESS: 0
  };
  /**
   * 沙盒状态
   */

  var ACCESS_LAYER = {
    PRODUCTION: 0,
    TEST: 1
  };
  var LOGIN = {
    IS_LOGIN: 1,
    IS_NOT_LOGIN: 0
  };
  /**
   * 消息同步状态
   */

  var SYNC_MESSAGE = {
    SYNCHRONIZATION_START: 0,
    // 开始同步
    SYNCHRONIZING: 1,
    // 同步中
    SYNCHRONIZED: 2 // 同步完成

  };
  var MESSAGE_STATUS = {
    UNSEND: 'unSend',
    SUCCESS: 'success',
    FAIL: 'fail'
  };
  /**
   * 获取大量历史消息时需要继拉，用来表示续拉的状态
   */

  var GET_HISTORY_MESSAGE_STATUS = {
    C2C_IS_FINISHED: 1,
    C2C_IS_NOT_FINISHED: 0,
    GROUP_IS_FINISHED: 1,
    GROUP_IS_NOT_FINISHED: 0
  };
  /**
   * 账号在线状态
   */

  var ACCOUNT_STATUS = {
    SIGN_IN: true,
    SIGN_OUT: false
  };
  /**
   * 消息通道在线状态
   */

  var CHANNEL_STATUS = {
    ONLINE: true,
    OFFLINE: false
  };
  var JOIN_GROUP_STATUS = {
    SUCCESS: 'JoinedSuccess',
    WAIT_APPROVAL: 'WaitAdminApproval'
  };
  var UPLOAD_STATUS = {
    FINISHED: 1,
    // 上传完成
    UPLOADING: 0 // 上传中

  };
  var PAGING_CONVERSATION = {
    NOT_START: 'notStart',
    // 未开始，未登录时的状态
    PENDING: 'pengding',
    // 正在分页同步会话列表，登录后分页正在进行的状态
    RESOLVED: 'resolved',
    // 分页同步完成
    REJECTED: 'rejected' // 分页同步失败

  };
  var TIM_STATUS = {
    COMMON: COMMON_STATUS,
    REQUEST: REQUEST_STATUS,
    ACCESS_LAYER: ACCESS_LAYER,
    LOGIN: LOGIN,
    SYNC_MESSAGE: SYNC_MESSAGE,
    MESSAGE_STATUS: MESSAGE_STATUS,
    GET_HISTORY_MESSAGE_STATUS: GET_HISTORY_MESSAGE_STATUS,
    ACCOUNT_STATUS: ACCOUNT_STATUS,
    CHANNEL_STATUS: CHANNEL_STATUS,
    JOIN_GROUP_STATUS: JOIN_GROUP_STATUS,
    UPLOAD: UPLOAD_STATUS,
    PAGING_CONVERSATION: PAGING_CONVERSATION
  };

  /**
   * @class TextElement
   * @param { Object } options  - 配置参数
   * @example
   * let textElement = new TIM.TextElement({text:'text'});
   *
   */

  var TextElement =
  /*#__PURE__*/
  function () {
    /**
     *
     * @param {Object} options - 初始化参数
     * @param {String} options.text - 文本类型，参数。不排队以后会有富文本类型。
     */
    function TextElement(options) {
      _classCallCheck(this, TextElement);

      // request form data
      // {
      //     MsgType: "TIMTextElem",
      //     MsgContent: {
      //         Text: "12"
      //     }
      // }
      this.type = TYPES.MSG_TEXT;
      this.content = {
        text: options.text || ''
      };
    }

    _createClass(TextElement, [{
      key: "setText",
      value: function setText(text) {
        this.content.text = text;
      }
    }, {
      key: "sendable",
      value: function sendable() {
        if (this.content.text.length === 0) {
          return false;
        }

        return true;
      }
    }]);

    return TextElement;
  }();

  /**
   * sdk 内部使用的类型枚举值集合
   */
  // 消息的相关状态
  var MESSAGE = {
    // 使用JSON格式, 时使用的状态配置
    JSON: {
      // 主类型
      TYPE: {
        C2C: {
          NOTICE: 1,
          // 新的c2c消息通知
          COMMON: 9,
          // 新的c2c消息
          EVENT: 10 // TODO:未知

        },
        GROUP: {
          COMMON: 3,
          // 新的群消息
          TIP: 4,
          // 新的群提示消息
          SYSTEM: 5,
          // 新的群系统消息
          TIP2: 6 // 新的群提示消息2

        },
        FRIEND: {
          NOTICE: 7 // 好友系统通知

        },
        PROFILE: {
          NOTICE: 8 // 资料系统通知

        }
      },
      // 子类型
      SUBTYPE: {
        C2C: {
          COMMON: 0,
          // 普通消息
          READED: 92,
          // 已读消息同步
          KICKEDOUT: 96 // TODO: 未知, 看相关老代码，是被踢下线的事件 webim.js 5327行

        },
        GROUP: {
          COMMON: 0,
          // 普通消息
          LOVEMESSAGE: 1,
          // 点赞消息
          TIP: 2,
          // 提示消息
          REDPACKET: 3 // 红包消息

        }
      },
      // 操作提示类型
      OPTIONS: {
        GROUP: {
          JOIN: 1,
          // 加入群组
          QUIT: 2,
          // 退出群组
          KICK: 3,
          // 被踢出群组
          SET_ADMIN: 4,
          // 被设置为管理员
          CANCEL_ADMIN: 5,
          // 被取消管理员
          MODIFY_GROUP_INFO: 6,
          // 修改群资料
          MODIFY_MEMBER_INFO: 7 // 修改群成员信息

        }
      }
    },
    // 使用PROTOBUF协议时，使用的状态配置
    PROTOBUF: {},
    IMAGE_TYPES: {
      ORIGIN: 1,
      // 原图
      LARGE: 2,
      // 缩略大图
      SMALL: 3 // 缩略小图

    },
    IMAGE_FORMAT: {
      JPG: 1,
      JPEG: 1,
      GIF: 2,
      PNG: 3,
      BMP: 4,
      UNKNOWN: 255
    }
  };
  var GROUP_SYSTEM_NOTICE_TYPES = {
    JOIN_GROUP_REQUEST: 1,
    // 申请加群请求（只有管理员会收到）
    JOIN_GROUP_ACCEPT: 2,
    // 申请加群被同意（只有申请人能够收到）
    JOIN_GROUP_REFUSE: 3,
    // 申请加群被拒绝（只有申请人能够收到）
    KICKED_OUT: 4,
    // 被管理员踢出群(只有被踢者接收到)
    GROUP_DISMISSED: 5,
    // 群被解散(全员接收)
    GROUP_CREATED: 6,
    // 创建群(创建者接收, 不展示)
    INVITED_JOIN_GROUP_REQUEST: 7,
    // 邀请加群(被邀请者接收)。
    QUIT: 8,
    // 主动退群(主动退出者接收, 不展示)
    SET_ADMIN: 9,
    // 设置管理员(被设置者接收)
    CANCELED_ADMIN: 10,
    // 取消管理员(被取消者接收)
    REVOKE: 11,
    // 群已被回收(全员接收, 不展示)
    INVITED_JOIN_GROUP_REQUEST_AGREE: 12,
    // 邀请加群(被邀请者需同意)
    READED: 15,
    // 群消息已读同步
    CUSTOM: 255 // 用户自定义通知(默认全员接收)

  };
  var RUNLOOP_TYPES = {
    AUTO: 0,
    SOCKET: 1,
    XHR: 2
  };
  var LOGOUT_TYPES = {
    ALL: 0,
    LONG_POLL: 1
  };
  var STANDARD_IM_PROFILE = {
    NICK: 'Tag_Profile_IM_Nick',
    GENDER: 'Tag_Profile_IM_Gender',
    BIRTHDAY: 'Tag_Profile_IM_BirthDay',
    LOCATION: 'Tag_Profile_IM_Location',
    SELFSIGNATURE: 'Tag_Profile_IM_SelfSignature',
    ALLOWTYPE: 'Tag_Profile_IM_AllowType',
    LANGUAGE: 'Tag_Profile_IM_Language',
    AVATAR: 'Tag_Profile_IM_Image',
    MESSAGESETTINGS: 'Tag_Profile_IM_MsgSettings',
    ADMINFORBIDTYPE: 'Tag_Profile_IM_AdminForbidType',
    LEVEL: 'Tag_Profile_IM_Level',
    ROLE: 'Tag_Profile_IM_Role'
  };
  /**
   * 用户性别枚举值
   */

  var GENDER_TYPES = {
    UNKNOWN: 'Gender_Type_Unknown',
    // 没设置性别
    FEMALE: 'Gender_Type_Female',
    // 女性
    MALE: 'Gender_Type_Male' // 男性

  };
  /**
   * 管理员禁止加好友标识
   */

  var FORBID_TYPES = {
    NONE: 'AdminForbid_Type_None',
    // 默认值，允许加好友
    SEND_OUT: 'AdminForbid_Type_SendOut' // 禁止该用户发起加好友请求

  };
  /**
   * 被加好友时的控制选项
   */

  var ALLOW_TYPES = {
    NEED_CONFIRM: 'AllowType_Type_NeedConfirm',
    // 需要经过自己确认才能添加自己为好友
    ALLOW_ANY: 'AllowType_Type_AllowAny',
    // 允许任何人添加自己为好友
    DENY_ANY: 'AllowType_Type_DenyAny' // 不允许任何人添加自己为好友

  };

  /**
   * @class ImageElement
   * @param { Object } options  - 配置参数
   * @param {String} options.uuid 图片唯一标识
   * @param {String} options.imageFormat 图片格式类型 参考 TIM_TYPES.MESSAGE.IMAGE_FORMAT
   * @param {Array} options.imageInfoArray 图片描述对象数组, 对象包含属性 {type:'', size:'', width:'', height:'', url:'' }
   * @param {HTMLFileElement} options.file - 如果传入file 实例，而会把 file 读取为 base64 编码
   * @example
   * let options = {
   *  uuid:'',
   *  imageFormat:'',
   *  imageInfoArray:[],
   * }
   * let imageElement = new ImageElement(options);
   */
  // request form data
  // {
  //     "MsgType": "TIMImageElem",
  //     "MsgContent": {
  //         "ImageFormat": 255,
  //         "UUID": "959129_87EB4A03E2159F904C3B4A8F4318AF6A",
  //         "ImageInfoArray": [{
  //             "Type": 3,
  //             "Size": 19606,
  //             "Width": 298,
  //             "Height": 184,
  //             "URL": "http://p.qpic.cn/opensdk_im/0/10153358846003601680_0_87EB4A03E2159F904C3B4A8F4318AF6A/198"
  //         }, {
  //             "Type": 2,
  //             "Size": 19606,
  //             "Width": 298,
  //             "Height": 184,
  //             "URL": "http://p.qpic.cn/opensdk_im/0/10153358846003601680_0_87EB4A03E2159F904C3B4A8F4318AF6A/720"
  //         }, {
  //             "Type": 1,
  //             "Size": 959129,
  //              "Width": 298,
  //             "Height": 184,
  //             "URL": "http://p.qpic.cn/opensdk_im/0/10153358846003601680_0_87EB4A03E2159F904C3B4A8F4318AF6A/0"
  //         }]
  //     }
  // }

  var ImageElement =
  /*#__PURE__*/
  function () {
    function ImageElement(options) {
      _classCallCheck(this, ImageElement);

      this._imageMemoryURL = '';
      this._file = options.file; // 暂存File实例，重发的时候用
      // 如果传入了 file 实例，则读取出 blob 的访问地址

      if (!IN_WX_MINI_APP) {
        this.createImageDataASURLInWeb(options.file);
      } else {
        this.createImageDataASURLInWXMiniApp(options.file);
      }

      this._initImageInfoModel();

      this.type = TYPES.MSG_IMAGE;
      this._percent = 0;
      this.content = {
        imageFormat: MESSAGE.IMAGE_FORMAT[options.imageFormat] || MESSAGE.IMAGE_FORMAT['UNKNOWN'],
        uuid: options.uuid,
        // sdk生成的uuid，和终端互通用
        imageInfoArray: []
      };
      this.initImageInfoArray(options.imageInfoArray);
      this._defaultImage = 'http://imgcache.qq.com/open/qcloud/video/act/webim-images/default.jpg'; // 默认图片地址

      this._autoFixUrl();
    }
    /**
     * 初始化 imageInfo 模型
     */


    _createClass(ImageElement, [{
      key: "_initImageInfoModel",
      value: function _initImageInfoModel() {
        var father = this; // const urlList = {};

        this._ImageInfoModel = function (options) {
          this.instanceID = randomInt(9999999);
          this.sizeType = options.type || 0;
          this.size = options.size || 0;
          this.width = options.width || 0;
          this.height = options.height || 0;
          this.imageUrl = options.url || '';
          this.url = options.url || father._imageMemoryURL || father._defaultImage; // 默认图片地址
          // urlList[this.instanceID] = options.url || father._imageMemoryURL || father._defaultImage; // 默认图片地址
        };

        this._ImageInfoModel.prototype = {
          setSizeType: function setSizeType(value) {
            this.sizeType = value;
          },
          setImageUrl: function setImageUrl(newUrl) {
            if (newUrl) {
              this.imageUrl = newUrl;
            }
          },
          getImageUrl: function getImageUrl() {
            return this.imageUrl;
          }
        };
      }
      /**
       * @description 初始化图片消息数组
       * @param {array} infoArray - 图片信息数组
       */

    }, {
      key: "initImageInfoArray",
      value: function initImageInfoArray(infoArray) {
        var i = 2;
        var imageInfo = null;
        var infoOptions = null;

        while (i >= 0) {
          typeof infoArray === 'undefined' || typeof infoArray[i] === 'undefined' ? infoOptions = {
            type: 0,
            size: 0,
            width: 0,
            height: 0,
            url: ''
          } : infoOptions = infoArray[i];
          imageInfo = new this._ImageInfoModel(infoOptions);
          imageInfo.setSizeType(i + 1);
          this.addImageInfo(imageInfo); // this.replaceImageInfo(imageInfo,i);

          i--;
        }
      }
      /**
       * @description 更新图片信息数组
       * @param {*} options - 更新参数
       * @param {Number} options.size - 图片大小
       * @param {String} options.url - 图片URL
       * @param {Number} options.width - 图片宽度
       * @param {Number} options.height - 图片高度
       */

    }, {
      key: "updateImageInfoArray",
      value: function updateImageInfoArray(options) {
        var len = this.content.imageInfoArray.length;
        var imageInfo;

        for (var i = 0; i < len; i++) {
          imageInfo = this.content.imageInfoArray[i];

          if (options.size) {
            imageInfo.size = options.size;
          }

          if (options.url) {
            imageInfo.setImageUrl(options.url);
          }

          if (options.width) {
            imageInfo.width = options.width;
          }

          if (options.height) {
            imageInfo.height = options.height;
          }
        }
      }
      /**
       * 强制修正一下URL,因为后端存储的URL是不带有 http/https 前缀的，万一用户在file协议下使用SDK就会出现 "//xxx/image" 被自动替换为“file://xxx/image” ，导致图片无法访问。
       * @private
       */

    }, {
      key: "_autoFixUrl",
      value: function _autoFixUrl() {
        var len = this.content.imageInfoArray.length;
        var onlyUrl = '';
        var preFix = '';
        var accessPrefix = ['http', 'https'];
        var info = null;

        for (var i = 0; i < len; i++) {
          if (!this.content.imageInfoArray[i].url) {
            continue;
          }

          info = this.content.imageInfoArray[i];

          if (info.imageUrl === '') {
            continue;
          }

          preFix = info.imageUrl.slice(0, info.imageUrl.indexOf('://') + 1);
          onlyUrl = info.imageUrl.slice(info.imageUrl.indexOf('://') + 1);

          if (accessPrefix.indexOf(preFix) < 0) {
            preFix = 'https:';
          }

          this.content.imageInfoArray[i].setImageUrl([preFix, onlyUrl].join(''));
        }
      }
      /**
       * 更新百分比数据
       * @param {Number} newValue - 百分比数值
       */

    }, {
      key: "updatePercent",
      value: function updatePercent(newValue) {
        this._percent = newValue;

        if (this._percent > 1) {
          this._percent = 1;
        }
      }
      /**
       * @description 更新文件格式信息
       * @param {String} format - 图片格式
       */

    }, {
      key: "updateImageFormat",
      value: function updateImageFormat(format) {
        this.content.imageFormat = format;
      }
      /**
       * 以blob形式读取图片，并生成URL
       * @param {File} file - 文件对象
       */

    }, {
      key: "createImageDataASURLInWeb",
      value: function createImageDataASURLInWeb(file) {
        // 限制读取一个，不允许传多个文件
        if (typeof file !== 'undefined' && file.files.length > 0) {
          this._imageMemoryURL = window.URL.createObjectURL(file.files[0]);
        }
      }
      /**
       * 小程序环境，直接获取 tempFilePaths
       * @param {File} file - 文件对象
       */

    }, {
      key: "createImageDataASURLInWXMiniApp",
      value: function createImageDataASURLInWXMiniApp(file) {
        // createImageMessage 接口已经做了限制
        if (file && file.url) {
          this._imageMemoryURL = file.url;
        }
      }
      /**
       *
       * @param {*} infoInstance - 图片信息实例
       * @param {*} index - 索引ID
       */

    }, {
      key: "replaceImageInfo",
      value: function replaceImageInfo(infoInstance, index) {
        var oldInfo = this.content.imageInfoArray[index];

        if (oldInfo instanceof this._ImageInfoModel) {
          return;
        }

        this.content.imageInfoArray[index] = infoInstance;
      }
      /**
       * @description 设置文件消息元素
       * @param {Object} options 图片描述对象
       * @param {String} options.sizeType - 图片尺寸的类型，
       * @param {String} options.width - 图片宽度，单位为px
       * @param {String} options.height - 图片高度，单位为px
       * @param {String} options.url - 图片图片地址
       * @example
       * // 可以添加3组图片描述对象，小缩略图、大缩略图、原图
       * let imageElement = new ImageElement({uuid:'', imageFormat:''});
       * imageElement.addImageInfo({ type:'', size:'', width:'', height:'', url:'' });
       */

    }, {
      key: "addImageInfo",
      value: function addImageInfo(options) {
        if (this.content.imageInfoArray.length >= 3) {
          return;
        }

        this.content.imageInfoArray.push(options);
      }
    }, {
      key: "sendable",
      value: function sendable() {
        if (this.content.imageInfoArray.length === 0) {
          return false;
        }

        if (this.content.imageInfoArray[0].imageUrl === '') {
          return false;
        }

        if (this.content.imageInfoArray[0].size === 0) {
          return false;
        }

        return true;
      }
    }]);

    return ImageElement;
  }();

  var FaceElement =
  /*#__PURE__*/
  function () {
    function FaceElement(options) {
      _classCallCheck(this, FaceElement);

      this.type = TYPES.MSG_FACE;
      this.content = options || null;
    }

    _createClass(FaceElement, [{
      key: "sendable",
      value: function sendable() {
        if (this.content === null) {
          return false;
        }

        return true;
      }
    }]);

    return FaceElement;
  }();

  /**
   * @class
   * @author saxongao
   */

  var AudioElement =
  /*#__PURE__*/
  function () {
    /**
     * @param {*} options
     * @param {String} options.second  - 音频文件的时长，单位: 秒
     * @param {String} options.size  - 音频文件的大小
     * @param {String} options.url  - 音频文件的地址，接入侧调用 createAudioMessage 接口创建消息实例时，url对应的是本地文件地址
     * @param {String} options.downloadFlag - 下载标志位，表示使用后端返回的url下载文件
     * @param {String} options.remoteAudioUrl - 上传cos成功后的远端地址
     * @param {String} options.uuid - sdk生成的uuid，和终端互通用
     * @private
     * @constructor
     */
    function AudioElement(options) {
      _classCallCheck(this, AudioElement);

      this.type = TYPES.MSG_AUDIO;
      this._percent = 0;
      this.content = {
        downloadFlag: 2,
        second: options.second,
        size: options.size,
        url: options.url,
        remoteAudioUrl: '',
        uuid: options.uuid
      };
    }
    /**
     * 更新百分比数据
     * @param {Number} newValue
     */


    _createClass(AudioElement, [{
      key: "updatePercent",
      value: function updatePercent(newValue) {
        this._percent = newValue;

        if (this._percent > 1) {
          this._percent = 1;
        }
      }
      /**
       * 录音文件上传成功后，更新remoteAudioUrl，发送的时候将remoteAudioUrl的值作为音频消息url的值
       * 详细见 package-config/c2c-message.js package-config/group-message.js 的keyMaps配置
       * 注意！url的值不要更新，更新后播放自己发送的语音消息会触发下载，体验不好
       * @param {String} newUrl cos返回的url
       */

    }, {
      key: "updateAudioUrl",
      value: function updateAudioUrl(newUrl) {
        this.content.remoteAudioUrl = newUrl;
      }
    }, {
      key: "sendable",
      value: function sendable() {
        if (this.content.remoteAudioUrl === '') {
          return false;
        }

        return true;
      }
    }]);

    return AudioElement;
  }();

  var legalGroupProfileKeys = {
    from: true,
    groupID: true,
    groupName: true,
    to: true
  };
  /**
   * @class
   * @param {String} type 元素类型
   * @param {Object} content 元素内容
   * @param {Number} content.operationType 操作类型
   * @param {String} content.operatorID 执行该操作的用户 ID
   * @param {Number} content.memberNum 群成员数量
   * @param {String[]} content.userIDList 相关的 userID 列表
   * @param {Object} content.newGroupProfile 若是群资料变更，该字段存放变更的群资料 {@link Group}
   * @param {Object[]} content.newGroupProfile.groupCustomField 若是群自定义字段变更，该字段存放变更的群自定义字段键值对（v2.6.0起支持）。
   * @param {Object[]} content.memberList 当群成员被禁言时，可在改字段中拿到相关信息
   * @param {String} content.memberList.userID 被禁言的 userID
   * @param {Number} content.memberList.muteTime 被禁言的时长，单位：秒
   */

  var GroupTipElement =
  /*#__PURE__*/
  function () {
    function GroupTipElement(options) {
      _classCallCheck(this, GroupTipElement);

      this.type = TYPES.MSG_GRP_TIP;
      this.content = {};

      this._initContent(options);
    }

    _createClass(GroupTipElement, [{
      key: "_initContent",
      value: function _initContent(options) {
        var _this = this;

        Object.keys(options).forEach(function (key) {
          switch (key) {
            case 'remarkInfo':
              // TODO: 含义还不明确，先不放上去
              break;

            case 'groupProfile':
              _this.content.groupProfile = {};

              _this._initGroupProfile(options[key]);

              break;

            case 'operatorInfo':
              break;

            case 'memberInfoList':
              break;

            case 'msgMemberInfo':
              _this.content.memberList = options[key];
              Object.defineProperty(_this.content, 'msgMemberInfo', {
                get: function get() {
                  logger.warn('!!! 禁言的群提示消息中的 payload.msgMemberInfo 属性即将废弃，请使用 payload.memberList 属性替代。 \n', 'msgMemberInfo 中的 shutupTime 属性对应更改为 memberList 中的 muteTime 属性，表示禁言时长。 \n', '参考：群提示消息 https://imsdk-1252463788.file.myqcloud.com/IM_DOC/Web/Message.html#.GroupTipPayload');
                  return _this.content.memberList.map(function (item) {
                    return {
                      userID: item.userID,
                      shutupTime: item.muteTime
                    };
                  });
                }
              });
              break;

            default:
              _this.content[key] = options[key];
          }
        }); // 有的ev4 无userIDList返回，此时手动赋值。

        if (!this.content.userIDList) {
          this.content.userIDList = [this.content.operatorID];
        }
      }
    }, {
      key: "_initGroupProfile",
      value: function _initGroupProfile(options) {
        var keys = Object.keys(options);

        for (var i = 0; i < keys.length; i++) {
          var key = keys[i];

          if (!legalGroupProfileKeys[key]) {
            continue;
          }

          this.content.groupProfile[key] = options[key];
        }
      }
    }]);

    return GroupTipElement;
  }();

  var legalGroupProfileKeys$1 = {
    from: true,
    groupID: true,
    name: true,
    to: true
  };
  /**
   * @class GroupSystemNoticeElement
   * @param {String} type 元素类型
   * @param {Object} content 元素内容
   * @param {Number} content.operationType 操作类型
   * @param {String} content.operatorID 执行该操作的用户 ID
   * @param {String} content.authentication 删除消息时需使用该字段
   * @param {Number} content.messageKey 删除消息时需使用该字段
   * @param {Object} content.groupProfile 相关群组信息
   * @param {String} content.handleMessage 操作人的附言
   */

  var GroupSystemNoticeElement =
  /*#__PURE__*/
  function () {
    function GroupSystemNoticeElement(options) {
      _classCallCheck(this, GroupSystemNoticeElement);

      this.type = TYPES.MSG_GRP_SYS_NOTICE;
      this.content = {};

      this._initContent(options);
    }

    _createClass(GroupSystemNoticeElement, [{
      key: "_initContent",
      value: function _initContent(options) {
        var _this = this;

        Object.keys(options).forEach(function (key) {
          switch (key) {
            case 'memberInfoList':
              break;

            case 'remarkInfo':
              _this.content['handleMessage'] = options[key];
              break;

            case 'groupProfile':
              _this.content.groupProfile = {};

              _this._initGroupProfile(options[key]);

              break;

            default:
              _this.content[key] = options[key];
          }
        });
      }
    }, {
      key: "_initGroupProfile",
      value: function _initGroupProfile(options) {
        var keys = Object.keys(options);

        for (var i = 0; i < keys.length; i++) {
          var key = keys[i];

          if (!legalGroupProfileKeys$1[key]) {
            continue;
          }

          this.content.groupProfile[key] = options[key];
        }
      }
    }]);

    return GroupSystemNoticeElement;
  }();

  /**
   * 常见错误的code与中文message对照
   * 账号错误码：https://cloud.tencent.com/document/product/269/1671#.E5.B8.90.E5.8F.B7.E9.94.99.E8.AF.AF.E7.A0.812
   * 消息错误码：https://cloud.tencent.com/document/product/269/1671#.E6.B6.88.E6.81.AF.E9.94.99.E8.AF.AF.E7.A0.812
   * 群组错误码: https://cloud.tencent.com/document/product/269/1671#.E7.BE.A4.E7.BB.84.E9.94.99.E8.AF.AF.E7.A0.812
   */
  var IMSERVER_ERROR = {
    // 账号错误码
    70001: "UserSig \u5DF2\u8FC7\u671F\uFF0C\u8BF7\u91CD\u65B0\u751F\u6210\u3002\u5EFA\u8BAE UserSig \u6709\u6548\u671F\u8BBE\u7F6E\u4E0D\u5C0F\u4E8E24\u5C0F\u65F6\u3002",
    70002: "UserSig \u957F\u5EA6\u4E3A0\uFF0C\u8BF7\u68C0\u67E5\u4F20\u5165\u7684 UserSig \u662F\u5426\u6B63\u786E\u3002",
    70003: "UserSig \u975E\u6CD5\uFF0C\u8BF7\u4F7F\u7528\u5B98\u7F51\u63D0\u4F9B\u7684 API \u91CD\u65B0\u751F\u6210 UserSig(https://cloud.tencent.com/document/product/269/32688)\u3002",
    70005: "UserSig \u975E\u6CD5\uFF0C\u8BF7\u4F7F\u7528\u5B98\u7F51\u63D0\u4F9B\u7684 API \u91CD\u65B0\u751F\u6210 UserSig(https://cloud.tencent.com/document/product/269/32688)\u3002",
    70009: "UserSig \u9A8C\u8BC1\u5931\u8D25\uFF0C\u53EF\u80FD\u56E0\u4E3A\u751F\u6210 UserSig \u65F6\u6DF7\u7528\u4E86\u5176\u4ED6 SDKAppID \u7684\u79C1\u94A5\u6216\u5BC6\u94A5\u5BFC\u81F4\uFF0C\u8BF7\u4F7F\u7528\u5BF9\u5E94 SDKAppID \u4E0B\u7684\u79C1\u94A5\u6216\u5BC6\u94A5\u91CD\u65B0\u751F\u6210 UserSig(https://cloud.tencent.com/document/product/269/32688)\u3002",
    70013: "\u8BF7\u6C42\u4E2D\u7684 UserID \u4E0E\u751F\u6210 UserSig \u65F6\u4F7F\u7528\u7684 UserID \u4E0D\u5339\u914D\uFF0C\u60A8\u53EF\u4EE5\u5728\u5373\u65F6\u901A\u4FE1 IM \u63A7\u5236\u53F0\u7684\u3010\u5F00\u53D1\u8F85\u52A9\u5DE5\u5177(https://console.cloud.tencent.com/im-detail/tool-usersig)\u3011\u9875\u9762\u6821\u9A8C UserSig\u3002",
    70014: "\u8BF7\u6C42\u4E2D\u7684 SDKAppID \u4E0E\u751F\u6210 UserSig \u65F6\u4F7F\u7528\u7684 SDKAppID \u4E0D\u5339\u914D\uFF0C\u60A8\u53EF\u4EE5\u5728\u5373\u65F6\u901A\u4FE1 IM \u63A7\u5236\u53F0\u7684\u3010\u5F00\u53D1\u8F85\u52A9\u5DE5\u5177(https://console.cloud.tencent.com/im-detail/tool-usersig)\u3011\u9875\u9762\u6821\u9A8C UserSig\u3002",
    70016: "\u5BC6\u94A5\u4E0D\u5B58\u5728\uFF0CUserSig \u9A8C\u8BC1\u5931\u8D25\uFF0C\u8BF7\u5728\u5373\u65F6\u901A\u4FE1 IM \u63A7\u5236\u53F0\u83B7\u53D6\u5BC6\u94A5(https://cloud.tencent.com/document/product/269/32578#.E8.8E.B7.E5.8F.96.E5.AF.86.E9.92.A5)\u3002",
    70020: "SDKAppID \u672A\u627E\u5230\uFF0C\u8BF7\u5728\u5373\u65F6\u901A\u4FE1 IM \u63A7\u5236\u53F0\u786E\u8BA4\u5E94\u7528\u4FE1\u606F\u3002",
    70050: "UserSig \u9A8C\u8BC1\u6B21\u6570\u8FC7\u4E8E\u9891\u7E41\u3002\u8BF7\u68C0\u67E5 UserSig \u662F\u5426\u6B63\u786E\uFF0C\u5E76\u4E8E1\u5206\u949F\u540E\u91CD\u65B0\u9A8C\u8BC1\u3002\u60A8\u53EF\u4EE5\u5728\u5373\u65F6\u901A\u4FE1 IM \u63A7\u5236\u53F0\u7684\u3010\u5F00\u53D1\u8F85\u52A9\u5DE5\u5177(https://console.cloud.tencent.com/im-detail/tool-usersig)\u3011\u9875\u9762\u6821\u9A8C UserSig\u3002",
    70051: "\u5E10\u53F7\u88AB\u62C9\u5165\u9ED1\u540D\u5355\u3002",
    70052: "UserSig \u5DF2\u7ECF\u5931\u6548\uFF0C\u8BF7\u91CD\u65B0\u751F\u6210\uFF0C\u518D\u6B21\u5C1D\u8BD5\u3002",
    70107: "\u56E0\u5B89\u5168\u539F\u56E0\u88AB\u9650\u5236\u767B\u5F55\uFF0C\u8BF7\u4E0D\u8981\u9891\u7E41\u767B\u5F55\u3002",
    70169: "\u8BF7\u6C42\u7684\u7528\u6237\u5E10\u53F7\u4E0D\u5B58\u5728\u3002",
    70114: "\u670D\u52A1\u7AEF\u5185\u90E8\u8D85\u65F6\uFF0C\u8BF7\u7A0D\u540E\u91CD\u8BD5\u3002",
    70202: "\u670D\u52A1\u7AEF\u5185\u90E8\u8D85\u65F6\uFF0C\u8BF7\u7A0D\u540E\u91CD\u8BD5\u3002",
    70206: "\u8BF7\u6C42\u4E2D\u6279\u91CF\u6570\u91CF\u4E0D\u5408\u6CD5\u3002",
    70402: "\u53C2\u6570\u975E\u6CD5\uFF0C\u8BF7\u68C0\u67E5\u5FC5\u586B\u5B57\u6BB5\u662F\u5426\u586B\u5145\uFF0C\u6216\u8005\u5B57\u6BB5\u7684\u586B\u5145\u662F\u5426\u6EE1\u8DB3\u534F\u8BAE\u8981\u6C42\u3002",
    70403: "\u8BF7\u6C42\u5931\u8D25\uFF0C\u9700\u8981 App \u7BA1\u7406\u5458\u6743\u9650\u3002",
    70398: "\u5E10\u53F7\u6570\u8D85\u9650\u3002\u5982\u9700\u521B\u5EFA\u591A\u4E8E100\u4E2A\u5E10\u53F7\uFF0C\u8BF7\u5C06\u5E94\u7528\u5347\u7EA7\u4E3A\u4E13\u4E1A\u7248\uFF0C\u5177\u4F53\u64CD\u4F5C\u6307\u5F15\u8BF7\u53C2\u89C1\u8D2D\u4E70\u6307\u5F15(https://cloud.tencent.com/document/product/269/32458)\u3002",
    70500: "\u670D\u52A1\u7AEF\u5185\u90E8\u9519\u8BEF\uFF0C\u8BF7\u7A0D\u540E\u91CD\u8BD5\u3002",
    71000: "\u5220\u9664\u5E10\u53F7\u5931\u8D25\u3002\u4EC5\u652F\u6301\u5220\u9664\u4F53\u9A8C\u7248\u5E10\u53F7\uFF0C\u60A8\u5F53\u524D\u5E94\u7528\u4E3A\u4E13\u4E1A\u7248\uFF0C\u6682\u4E0D\u652F\u6301\u5E10\u53F7\u5220\u9664\u3002",
    // 消息错误码
    20001: "\u8BF7\u6C42\u5305\u975E\u6CD5\u3002",
    20002: "UserSig \u6216 A2 \u5931\u6548\u3002",
    20003: "\u6D88\u606F\u53D1\u9001\u65B9\u6216\u63A5\u6536\u65B9 UserID \u65E0\u6548\u6216\u4E0D\u5B58\u5728\uFF0C\u8BF7\u68C0\u67E5 UserID \u662F\u5426\u5DF2\u5BFC\u5165\u5373\u65F6\u901A\u4FE1 IM\u3002",
    20004: "\u7F51\u7EDC\u5F02\u5E38\uFF0C\u8BF7\u91CD\u8BD5\u3002",
    20005: "\u670D\u52A1\u7AEF\u5185\u90E8\u9519\u8BEF\uFF0C\u8BF7\u91CD\u8BD5\u3002",
    20006: "\u89E6\u53D1\u53D1\u9001\u5355\u804A\u6D88\u606F\u4E4B\u524D\u56DE\u8C03\uFF0CApp \u540E\u53F0\u8FD4\u56DE\u7981\u6B62\u4E0B\u53D1\u8BE5\u6D88\u606F\u3002",
    20007: "\u53D1\u9001\u5355\u804A\u6D88\u606F\uFF0C\u88AB\u5BF9\u65B9\u62C9\u9ED1\uFF0C\u7981\u6B62\u53D1\u9001\u3002\u6D88\u606F\u53D1\u9001\u72B6\u6001\u9ED8\u8BA4\u5C55\u793A\u4E3A\u5931\u8D25\uFF0C\u60A8\u53EF\u4EE5\u767B\u5F55\u63A7\u5236\u53F0\u4FEE\u6539\u8BE5\u573A\u666F\u4E0B\u7684\u6D88\u606F\u53D1\u9001\u72B6\u6001\u5C55\u793A\u7ED3\u679C\uFF0C\u5177\u4F53\u64CD\u4F5C\u8BF7\u53C2\u89C1\u6D88\u606F\u4FDD\u7559\u8BBE\u7F6E(https://cloud.tencent.com/document/product/269/38656)\u3002",
    20009: "\u6D88\u606F\u53D1\u9001\u53CC\u65B9\u4E92\u76F8\u4E0D\u662F\u597D\u53CB\uFF0C\u7981\u6B62\u53D1\u9001\uFF08\u914D\u7F6E\u5355\u804A\u6D88\u606F\u6821\u9A8C\u597D\u53CB\u5173\u7CFB\u624D\u4F1A\u51FA\u73B0\uFF09\u3002",
    20010: "\u53D1\u9001\u5355\u804A\u6D88\u606F\uFF0C\u81EA\u5DF1\u4E0D\u662F\u5BF9\u65B9\u7684\u597D\u53CB\uFF08\u5355\u5411\u5173\u7CFB\uFF09\uFF0C\u7981\u6B62\u53D1\u9001\u3002",
    20011: "\u53D1\u9001\u5355\u804A\u6D88\u606F\uFF0C\u5BF9\u65B9\u4E0D\u662F\u81EA\u5DF1\u7684\u597D\u53CB\uFF08\u5355\u5411\u5173\u7CFB\uFF09\uFF0C\u7981\u6B62\u53D1\u9001\u3002",
    20012: "\u53D1\u9001\u65B9\u88AB\u7981\u8A00\uFF0C\u8BE5\u6761\u6D88\u606F\u88AB\u7981\u6B62\u53D1\u9001\u3002",
    20016: "\u6D88\u606F\u64A4\u56DE\u8D85\u8FC7\u4E86\u65F6\u95F4\u9650\u5236\uFF08\u9ED8\u8BA42\u5206\u949F\uFF09\u3002",
    20018: "\u5220\u9664\u6F2B\u6E38\u5185\u90E8\u9519\u8BEF\u3002",
    90001: "JSON \u683C\u5F0F\u89E3\u6790\u5931\u8D25\uFF0C\u8BF7\u68C0\u67E5\u8BF7\u6C42\u5305\u662F\u5426\u7B26\u5408 JSON \u89C4\u8303\u3002",
    90002: "JSON \u683C\u5F0F\u8BF7\u6C42\u5305\u4E2D MsgBody \u4E0D\u7B26\u5408\u6D88\u606F\u683C\u5F0F\u63CF\u8FF0\uFF0C\u6216\u8005 MsgBody \u4E0D\u662F Array \u7C7B\u578B\uFF0C\u8BF7\u53C2\u8003 TIMMsgElement \u5BF9\u8C61\u7684\u5B9A\u4E49(https://cloud.tencent.com/document/product/269/2720#.E6.B6.88.E6.81.AF.E5.85.83.E7.B4.A0-timmsgelement)\u3002",
    90003: "JSON \u683C\u5F0F\u8BF7\u6C42\u5305\u4F53\u4E2D\u7F3A\u5C11 To_Account \u5B57\u6BB5\u6216\u8005 To_Account \u5E10\u53F7\u4E0D\u5B58\u5728\u3002",
    90005: "JSON \u683C\u5F0F\u8BF7\u6C42\u5305\u4F53\u4E2D\u7F3A\u5C11 MsgRandom \u5B57\u6BB5\u6216\u8005 MsgRandom \u5B57\u6BB5\u4E0D\u662F Integer \u7C7B\u578B\u3002",
    90006: "JSON \u683C\u5F0F\u8BF7\u6C42\u5305\u4F53\u4E2D\u7F3A\u5C11 MsgTimeStamp \u5B57\u6BB5\u6216\u8005 MsgTimeStamp \u5B57\u6BB5\u4E0D\u662F Integer \u7C7B\u578B\u3002",
    90007: "JSON \u683C\u5F0F\u8BF7\u6C42\u5305\u4F53\u4E2D MsgBody \u7C7B\u578B\u4E0D\u662F Array \u7C7B\u578B\uFF0C\u8BF7\u5C06\u5176\u4FEE\u6539\u4E3A Array \u7C7B\u578B\u3002",
    90008: "JSON \u683C\u5F0F\u8BF7\u6C42\u5305\u4F53\u4E2D\u7F3A\u5C11 From_Account \u5B57\u6BB5\u6216\u8005 From_Account \u5E10\u53F7\u4E0D\u5B58\u5728\u3002",
    90009: "\u8BF7\u6C42\u9700\u8981 App \u7BA1\u7406\u5458\u6743\u9650\u3002",
    90010: "JSON \u683C\u5F0F\u8BF7\u6C42\u5305\u4E0D\u7B26\u5408\u6D88\u606F\u683C\u5F0F\u63CF\u8FF0\uFF0C\u8BF7\u53C2\u8003 TIMMsgElement \u5BF9\u8C61\u7684\u5B9A\u4E49(https://cloud.tencent.com/document/product/269/2720#.E6.B6.88.E6.81.AF.E5.85.83.E7.B4.A0-timmsgelement)\u3002",
    90011: "\u6279\u91CF\u53D1\u6D88\u606F\u76EE\u6807\u5E10\u53F7\u8D85\u8FC7500\uFF0C\u8BF7\u51CF\u5C11 To_Account \u4E2D\u76EE\u6807\u5E10\u53F7\u6570\u91CF\u3002",
    90012: "To_Account \u6CA1\u6709\u6CE8\u518C\u6216\u4E0D\u5B58\u5728\uFF0C\u8BF7\u786E\u8BA4 To_Account \u662F\u5426\u5BFC\u5165\u5373\u65F6\u901A\u4FE1 IM \u6216\u8005\u662F\u5426\u62FC\u5199\u9519\u8BEF\u3002",
    90026: "\u6D88\u606F\u79BB\u7EBF\u5B58\u50A8\u65F6\u95F4\u9519\u8BEF\uFF08\u6700\u591A\u4E0D\u80FD\u8D85\u8FC77\u5929\uFF09\u3002",
    90031: "JSON \u683C\u5F0F\u8BF7\u6C42\u5305\u4F53\u4E2D SyncOtherMachine \u5B57\u6BB5\u4E0D\u662F Integer \u7C7B\u578B\u3002",
    90044: "JSON \u683C\u5F0F\u8BF7\u6C42\u5305\u4F53\u4E2D MsgLifeTime \u5B57\u6BB5\u4E0D\u662F Integer \u7C7B\u578B\u3002",
    90048: "\u8BF7\u6C42\u7684\u7528\u6237\u5E10\u53F7\u4E0D\u5B58\u5728\u3002",
    90054: "\u64A4\u56DE\u8BF7\u6C42\u4E2D\u7684 MsgKey \u4E0D\u5408\u6CD5\u3002",
    90994: "\u670D\u52A1\u5185\u90E8\u9519\u8BEF\uFF0C\u8BF7\u91CD\u8BD5\u3002",
    90995: "\u670D\u52A1\u5185\u90E8\u9519\u8BEF\uFF0C\u8BF7\u91CD\u8BD5\u3002",
    91000: "\u670D\u52A1\u5185\u90E8\u9519\u8BEF\uFF0C\u8BF7\u91CD\u8BD5\u3002",
    90992: "\u670D\u52A1\u5185\u90E8\u9519\u8BEF\uFF0C\u8BF7\u91CD\u8BD5\uFF1B\u5982\u679C\u6240\u6709\u8BF7\u6C42\u90FD\u8FD4\u56DE\u8BE5\u9519\u8BEF\u7801\uFF0C\u4E14 App \u914D\u7F6E\u4E86\u7B2C\u4E09\u65B9\u56DE\u8C03\uFF0C\u8BF7\u68C0\u67E5 App \u670D\u52A1\u7AEF\u662F\u5426\u6B63\u5E38\u5411\u5373\u65F6\u901A\u4FE1 IM \u540E\u53F0\u670D\u52A1\u7AEF\u8FD4\u56DE\u56DE\u8C03\u7ED3\u679C\u3002",
    93000: "JSON \u6570\u636E\u5305\u8D85\u957F\uFF0C\u6D88\u606F\u5305\u4F53\u8BF7\u4E0D\u8981\u8D85\u8FC78k\u3002",
    91101: "Web \u7AEF\u957F\u8F6E\u8BE2\u88AB\u8E22\uFF08Web \u7AEF\u540C\u65F6\u5728\u7EBF\u5B9E\u4F8B\u4E2A\u6570\u8D85\u51FA\u9650\u5236\uFF09\u3002",
    // 群组错误码
    10002: "\u670D\u52A1\u7AEF\u5185\u90E8\u9519\u8BEF\uFF0C\u8BF7\u91CD\u8BD5\u3002",
    10003: "\u8BF7\u6C42\u4E2D\u7684\u63A5\u53E3\u540D\u79F0\u9519\u8BEF\uFF0C\u8BF7\u6838\u5BF9\u63A5\u53E3\u540D\u79F0\u5E76\u91CD\u8BD5\u3002",
    10004: "\u53C2\u6570\u975E\u6CD5\uFF0C\u8BF7\u6839\u636E\u9519\u8BEF\u63CF\u8FF0\u68C0\u67E5\u8BF7\u6C42\u662F\u5426\u6B63\u786E\u3002",
    10005: "\u8BF7\u6C42\u5305\u4F53\u4E2D\u643A\u5E26\u7684\u5E10\u53F7\u6570\u91CF\u8FC7\u591A\u3002",
    10006: "\u64CD\u4F5C\u9891\u7387\u9650\u5236\uFF0C\u8BF7\u5C1D\u8BD5\u964D\u4F4E\u8C03\u7528\u7684\u9891\u7387\u3002",
    10007: "\u64CD\u4F5C\u6743\u9650\u4E0D\u8DB3\uFF0C\u4F8B\u5982 Public \u7FA4\u7EC4\u4E2D\u666E\u901A\u6210\u5458\u5C1D\u8BD5\u6267\u884C\u8E22\u4EBA\u64CD\u4F5C\uFF0C\u4F46\u53EA\u6709 App \u7BA1\u7406\u5458\u624D\u6709\u6743\u9650\u3002",
    10008: "\u8BF7\u6C42\u975E\u6CD5\uFF0C\u53EF\u80FD\u662F\u8BF7\u6C42\u4E2D\u643A\u5E26\u7684\u7B7E\u540D\u4FE1\u606F\u9A8C\u8BC1\u4E0D\u6B63\u786E\uFF0C\u8BF7\u518D\u6B21\u5C1D\u8BD5\u3002",
    10009: "\u8BE5\u7FA4\u4E0D\u5141\u8BB8\u7FA4\u4E3B\u4E3B\u52A8\u9000\u51FA\u3002",
    10010: "\u7FA4\u7EC4\u4E0D\u5B58\u5728\uFF0C\u6216\u8005\u66FE\u7ECF\u5B58\u5728\u8FC7\uFF0C\u4F46\u662F\u76EE\u524D\u5DF2\u7ECF\u88AB\u89E3\u6563\u3002",
    10011: "\u89E3\u6790 JSON \u5305\u4F53\u5931\u8D25\uFF0C\u8BF7\u68C0\u67E5\u5305\u4F53\u7684\u683C\u5F0F\u662F\u5426\u7B26\u5408 JSON \u683C\u5F0F\u3002",
    10012: "\u53D1\u8D77\u64CD\u4F5C\u7684 UserID \u975E\u6CD5\uFF0C\u8BF7\u68C0\u67E5\u53D1\u8D77\u64CD\u4F5C\u7684\u7528\u6237 UserID \u662F\u5426\u586B\u5199\u6B63\u786E\u3002",
    10013: "\u88AB\u9080\u8BF7\u52A0\u5165\u7684\u7528\u6237\u5DF2\u7ECF\u662F\u7FA4\u6210\u5458\u3002",
    10014: "\u7FA4\u5DF2\u6EE1\u5458\uFF0C\u65E0\u6CD5\u5C06\u8BF7\u6C42\u4E2D\u7684\u7528\u6237\u52A0\u5165\u7FA4\u7EC4\uFF0C\u5982\u679C\u662F\u6279\u91CF\u52A0\u4EBA\uFF0C\u53EF\u4EE5\u5C1D\u8BD5\u51CF\u5C11\u52A0\u5165\u7528\u6237\u7684\u6570\u91CF\u3002",
    10015: "\u627E\u4E0D\u5230\u6307\u5B9A ID \u7684\u7FA4\u7EC4\u3002",
    10016: "App \u540E\u53F0\u901A\u8FC7\u7B2C\u4E09\u65B9\u56DE\u8C03\u62D2\u7EDD\u672C\u6B21\u64CD\u4F5C\u3002",
    10017: "\u56E0\u88AB\u7981\u8A00\u800C\u4E0D\u80FD\u53D1\u9001\u6D88\u606F\uFF0C\u8BF7\u68C0\u67E5\u53D1\u9001\u8005\u662F\u5426\u88AB\u8BBE\u7F6E\u7981\u8A00\u3002",
    10018: "\u5E94\u7B54\u5305\u957F\u5EA6\u8D85\u8FC7\u6700\u5927\u5305\u957F\uFF081MB\uFF09\uFF0C\u8BF7\u6C42\u7684\u5185\u5BB9\u8FC7\u591A\uFF0C\u8BF7\u5C1D\u8BD5\u51CF\u5C11\u5355\u6B21\u8BF7\u6C42\u7684\u6570\u636E\u91CF\u3002",
    10019: "\u8BF7\u6C42\u7684\u7528\u6237\u5E10\u53F7\u4E0D\u5B58\u5728\u3002",
    10021: "\u7FA4\u7EC4 ID \u5DF2\u88AB\u4F7F\u7528\uFF0C\u8BF7\u9009\u62E9\u5176\u4ED6\u7684\u7FA4\u7EC4 ID\u3002",
    10023: "\u53D1\u6D88\u606F\u7684\u9891\u7387\u8D85\u9650\uFF0C\u8BF7\u5EF6\u957F\u4E24\u6B21\u53D1\u6D88\u606F\u65F6\u95F4\u7684\u95F4\u9694\u3002",
    10024: "\u6B64\u9080\u8BF7\u6216\u8005\u7533\u8BF7\u8BF7\u6C42\u5DF2\u7ECF\u88AB\u5904\u7406\u3002",
    10025: "\u7FA4\u7EC4 ID \u5DF2\u88AB\u4F7F\u7528\uFF0C\u5E76\u4E14\u64CD\u4F5C\u8005\u4E3A\u7FA4\u4E3B\uFF0C\u53EF\u4EE5\u76F4\u63A5\u4F7F\u7528\u3002",
    10026: "\u8BE5 SDKAppID \u8BF7\u6C42\u7684\u547D\u4EE4\u5B57\u5DF2\u88AB\u7981\u7528\u3002",
    10030: "\u8BF7\u6C42\u64A4\u56DE\u7684\u6D88\u606F\u4E0D\u5B58\u5728\u3002",
    10031: "\u6D88\u606F\u64A4\u56DE\u8D85\u8FC7\u4E86\u65F6\u95F4\u9650\u5236\uFF08\u9ED8\u8BA42\u5206\u949F\uFF09\u3002",
    10032: "\u8BF7\u6C42\u64A4\u56DE\u7684\u6D88\u606F\u4E0D\u652F\u6301\u64A4\u56DE\u64CD\u4F5C\u3002",
    10033: "\u7FA4\u7EC4\u7C7B\u578B\u4E0D\u652F\u6301\u6D88\u606F\u64A4\u56DE\u64CD\u4F5C\u3002",
    10034: "\u8BE5\u6D88\u606F\u7C7B\u578B\u4E0D\u652F\u6301\u5220\u9664\u64CD\u4F5C\u3002",
    10035: "\u97F3\u89C6\u9891\u804A\u5929\u5BA4\u548C\u5728\u7EBF\u6210\u5458\u5E7F\u64AD\u5927\u7FA4\u4E0D\u652F\u6301\u5220\u9664\u6D88\u606F\u3002",
    10036: "\u97F3\u89C6\u9891\u804A\u5929\u5BA4\u521B\u5EFA\u6570\u91CF\u8D85\u8FC7\u4E86\u9650\u5236\uFF0C\u8BF7\u53C2\u8003\u4EF7\u683C\u8BF4\u660E(https://cloud.tencent.com/document/product/269/11673)\u8D2D\u4E70\u9884\u4ED8\u8D39\u5957\u9910\u201CIM\u97F3\u89C6\u9891\u804A\u5929\u5BA4\u201D\u3002",
    10037: "\u5355\u4E2A\u7528\u6237\u53EF\u521B\u5EFA\u548C\u52A0\u5165\u7684\u7FA4\u7EC4\u6570\u91CF\u8D85\u8FC7\u4E86\u9650\u5236\uFF0C\u8BF7\u53C2\u8003\u4EF7\u683C\u8BF4\u660E(https://cloud.tencent.com/document/product/269/11673)\u8D2D\u4E70\u6216\u5347\u7EA7\u9884\u4ED8\u8D39\u5957\u9910\u201C\u5355\u4EBA\u53EF\u521B\u5EFA\u4E0E\u52A0\u5165\u7FA4\u7EC4\u6570\u201D\u3002",
    10038: "\u7FA4\u6210\u5458\u6570\u91CF\u8D85\u8FC7\u9650\u5236\uFF0C\u8BF7\u53C2\u8003\u4EF7\u683C\u8BF4\u660E(https://cloud.tencent.com/document/product/269/11673)\u8D2D\u4E70\u6216\u5347\u7EA7\u9884\u4ED8\u8D39\u5957\u9910\u201C\u6269\u5C55\u7FA4\u4EBA\u6570\u4E0A\u9650\u201D\u3002",
    10041: "\u8BE5\u5E94\u7528\uFF08SDKAppID\uFF09\u5DF2\u914D\u7F6E\u4E0D\u652F\u6301\u7FA4\u6D88\u606F\u64A4\u56DE\u3002"
  };

  var IMError =
  /*#__PURE__*/
  function (_Error) {
    _inherits(IMError, _Error);

    function IMError(options) {
      var _this;

      _classCallCheck(this, IMError);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(IMError).call(this));
      _this.code = options.code;
      _this.message = IMSERVER_ERROR[options.code] || options.message;
      _this.data = options.data || {};
      return _this;
    }

    return IMError;
  }(_wrapNativeSuper(Error));

  /**
   * @typedef 错误码对照表
   * @description SDK 错误码对照表
   * | 错误码 | 说明 |
   * | :--- | :---- |
   * | 2000 | 无 SDKAppID  |
   * | 2001 | 无 accountType |
   * | 2002 | 无 userID |
   * | 2003 | 无 userSig |
   * | 2022 | 无 tinyID  |
   * | 2023 | 无 a2key  |
   * | 2040 | 未检测到 COS 上传插件 |
   * | 2100 | 消息发送失败 |
   * | 2105 | 需要 Message 的实例 |
   * | 2106 | Message.conversationType 只能为 "C2C" 或 "GROUP" |
   * | 2108 | 无法发送空文件 |
   * | 2109 | 回调函数运行时遇到错误，请检查接入侧代码 |
   * | 2110 | 消息撤回失败 |
   * | 2251 | 请先选择一个图片 |
   * | 2252 | 只允许上传 jpg png jpeg gif 格式的图片 |
   * | 2253 | 图片大小超过20M，无法发送 |
   * | 2300 | 语音上传失败 |
   * | 2301 | 语音大小超过20M，无法发送 |
   * | 2350 | 视频上传失败 |
   * | 2351 | 视频大小超过20M，无法发送 |
   * | 2352 | 只允许上传 mp4 格式的视频 |
   * | 2400 | 文件上传失败 |
   * | 2401 | 请先选择一个文件 |
   * | 2402 | 文件大小超过100M，无法发送 |
   * | 2403 | 缺少必要的参数文件 URL |
   * | 2500 | 没有找到相应的会话，请检查传入参数 |
   * | 2501 | 没有找到相应的用户或群主，请检查传入参数 |
   * | 2502 | 未记录的会话类型 |
   * | 2600 | 非法的群类型，请检查传入参数 |
   * | 2601 | 不能加入 Private 类型的群组 |
   * | 2620 | AVChatRoom 类型的群组不能转让群主 |
   * | 2621 | 不能把群主转让给自己 |
   * | 2622 | 不能解散 Private 类型的群组 |
   * | 2660 | 加群失败，请检查传入参数或重试 |
   * | 2661 | AVChatRoom 类型的群不支持邀请群成员 |
   * | 2662 | 非 AVChatRoom 类型的群组不允许匿名加群，请先登录后再加群 |
   * | 2680 | 不能在 AVChatRoom 类型的群组踢人 |
   * | 2681 | 你不是群主，只有群主才有权限操作 |
   * | 2682 | 不能在 Private / AVChatRoom 类型的群中设置群成员身份 |
   * | 2683 | 不合法的群成员身份，请检查传入参数 |
   * | 2684 | 不能设置自己的群成员身份，请检查传入参数 |
   * | 2685 | 不能将自己禁言，请检查传入参数 |
   * | 2700 | 传入 deleteFriend 接口的参数无效 |
   * | 2721 | 传入 updateMyProfile 接口的参数无效 |
   * | 2722 | updateMyProfile 无标配资料字段或自定义资料字段 |
   * | 2740 | 传入 addToBlacklist 接口的参数无效 |
   * | 2741 | 传入 removeFromBlacklist 接口的参数无效 |
   * | 2742 | 不能拉黑自己 |
   * | 2800 | 网络错误 |
   * | 2801 | 请求超时 |
   * | 2805 | 未连接到网络 |
   * | 2901 | 意料外的通知条件 |
   * | 2902 | _syncOffset 丢失 |
   * | 2903 | 未经明确定义的错误 |
   * | 2904 | 获取 longpolling id 失败 |
   * | 2999 | 接口调用时机不合理，等待 SDK 处于 ready 状态后再调用（监听 TIM.EVENT.SDK_READY 事件）|
   *
   * [服务端错误码](https://cloud.tencent.com/document/product/269/1671?!preview&!editLang=zh#.EF.BC.88.E4.BA.8C.EF.BC.89.E6.9C.8D.E5.8A.A1.E7.AB.AF.E7.9A.84.E9.94.99.E8.AF.AF.E7.A0.81)
   */
  var ERROR_CODE = {
    // REQ_XXX_FAILED 指的是response.data.errorCode != 0
    // --[2000-2099] 初始化、登录、插件注册使用、登录状态变更等
    // ----[2000-2019] 初始化
    NO_SDKAPPID: 2000,
    NO_ACCOUNT_TYPE: 2001,
    NO_IDENTIFIER: 2002,
    NO_USERSIG: 2003,
    // ----[2020-2039] 登录相关
    NO_TINYID: 2022,
    NO_A2KEY: 2023,
    // ----[2040-2059] 插件注册使用相关
    COS_UNDETECTED: 2040,
    // ----[2060-2079] 登录态变更，如被踢下线，a2key 失效等
    // --[2100-2499] 消息收发相关
    MESSAGE_SEND_FAIL: 2100,
    MESSAGE_LIST_CONSTRUCTOR_NEED_OPTIONS: 2103,
    MESSAGE_SEND_NEED_MESSAGE_INSTANCE: 2105,
    MESSAGE_SEND_INVALID_CONVERSATION_TYPE: 2106,
    MESSAGE_FILE_IS_EMPTY: 2108,
    MESSAGE_ONPROGRESS_FUNCTION_ERROR: 2109,
    MESSAGE_REVOKE_FAIL: 2110,
    // ----[2150-2199] 拉取、同步、重发消息相关
    // ----[2200-2249] 文本消息收发相关
    // ----[2250-2299] 图片消息收发相关
    MESSAGE_IMAGE_SELECT_FILE_FIRST: 2251,
    MESSAGE_IMAGE_TYPES_LIMIT: 2252,
    MESSAGE_IMAGE_SIZE_LIMIT: 2253,
    // ----[2300-2349] 语音消息收发相关
    MESSAGE_AUDIO_UPLOAD_FAIL: 2300,
    MESSAGE_AUDIO_SIZE_LIMIT: 2301,
    // ----[2350-2399] 视频消息收发相关
    MESSAGE_VIDEO_UPLOAD_FAIL: 2350,
    MESSAGE_VIDEO_SIZE_LIMIT: 2351,
    MESSAGE_VIDEO_TYPES_LIMIT: 2352,
    // ----[2400-2449] 文件消息收发相关
    MESSAGE_FILE_UPLOAD_FAIL: 2400,
    MESSAGE_FILE_SELECT_FILE_FIRST: 2401,
    MESSAGE_FILE_SIZE_LIMIT: 2402,
    MESSAGE_FILE_URL_IS_EMPTY: 2403,
    // ----[2450-2499] 自定义消息收发相关
    // --[2500-2599] 会话相关
    // ----[2500-2519] 拉取、同步会话列表，搜索会话列表相关
    CONVERSATION_NOT_FOUND: 2500,
    USER_OR_GROUP_NOT_FOUND: 2501,
    CONVERSATION_UN_RECORDED_TYPE: 2502,
    // ----[2520-2539] 删除会话、获取会话信息相关
    // ----[2530-2549] C2C 会话相关
    // ----[2550-2569] 群组会话相关
    // --[2600-2699] 群组相关
    // ----[2600-2619] 拉取、同步、搜索群组列表相关
    ILLEGAL_GROUP_TYPE: 2600,
    CANNOT_JOIN_PRIVATE: 2601,
    // ----[2620-2639] 创建、解散、退出、转让群组相关
    CANNOT_CHANGE_OWNER_IN_AVCHATROOM: 2620,
    CANNOT_CHANGE_OWNER_TO_SELF: 2621,
    CANNOT_DISMISS_PRIVATE: 2622,
    // 不能解散 Private 类型群组
    // ----[2640-2659] 查询、修改群组资料相关
    // ----[2660-2679] 邀人入群、申请加群与处理申请相关
    JOIN_GROUP_FAIL: 2660,
    CANNOT_ADD_MEMBER_IN_AVCHATROOM: 2661,
    CANNOT_JOIN_NON_AVCHATROOM_WITHOUT_LOGIN: 2662,
    // ----[2680-2699] 控群相关，如设置禁言时间，设置群成员名片，踢人等
    CANNOT_KICK_MEMBER_IN_AVCHATROOM: 2680,
    NOT_OWNER: 2681,
    CANNOT_SET_MEMBER_ROLE_IN_PRIVATE_AND_AVCHATROOM: 2682,
    INVALID_MEMBER_ROLE: 2683,
    CANNOT_SET_SELF_MEMBER_ROLE: 2684,
    CANNOT_MUTE_SELF: 2685,
    // --[2700-2799] 关系链相关
    // ----[2700-2719] 拉取、同步好友列表、删除好友相关
    DEL_FRIEND_INVALID_PARAM: 2700,
    // ----[2720-2739] 资料相关
    UPDATE_PROFILE_INVALID_PARAM: 2721,
    UPDATE_PROFILE_NO_KEY: 2722,
    // ----[2740-2759] 黑名单相关
    ADD_BLACKLIST_INVALID_PARAM: 2740,
    DEL_BLACKLIST_INVALID_PARAM: 2741,
    CANNOT_ADD_SELF_TO_BLACKLIST: 2742,
    // ----[2760-2779] 申请加好友与处理申请相关
    // --[2800-2849] 网络相关
    NETWORK_ERROR: 2800,
    NETWORK_TIMEOUT: 2801,
    NETWORK_BASE_OPTIONS_NO_URL: 2802,
    NETWORK_UNDEFINED_SERVER_NAME: 2803,
    NETWORK_PACKAGE_UNDEFINED: 2804,
    NO_NETWORK: 2805,
    // ----[2850-2869] websocket相关，如连接断开、心跳超时等
    // --[2870-2899] 宿主环境相关
    // ----[2870-2879] 小程序环境相关
    // ----[2880-2889] PC/Mac 浏览器环境相关
    // ----[2890-2899] 移动端浏览器环境相关
    // --[2900-2999] 其它
    CONVERTOR_IRREGULAR_PARAMS: 2900,
    // --runLoop 相关
    NOTICE_RUNLOOP_UNEXPECTED_CONDITION: 2901,
    NOTICE_RUNLOOP_OFFSET_LOST: 2902,
    // --未捕获的错误，需要引起注意
    UNCAUGHT_ERROR: 2903,
    GET_LONGPOLL_ID_FAILED: 2904,
    SDK_IS_NOT_READY: 2999,
    // --[3000 - 3020]SSO 日志相关错误，SDK 内部使用
    // --服务端错误码
    LONG_POLL_KICK_OUT: 91101,
    MESSAGE_A2KEY_EXPIRED: 20002,
    // 来自消息系统的 A2key 过期
    ACCOUNT_A2KEY_EXPIRED: 70001,
    // 来自账号系统的 A2key 过期
    LONG_POLL_API_PARAM_ERROR: 90001
  };
  var ERROR_MESSAGE = {
    // --初始化、登录、插件注册使用、登录状态变更等
    // ----初始化
    NO_SDKAPPID: '无 SDKAppID',
    NO_ACCOUNT_TYPE: '无 accountType',
    NO_IDENTIFIER: '无 userID',
    NO_USERSIG: '无 userSig',
    // ----登录
    NO_TINYID: '无 tinyID',
    NO_A2KEY: '无 a2key',
    // ----插件注册使用相关
    COS_UNDETECTED: '未检测到 COS 上传插件',
    // ----登录态变更，如被踢下线，a2key 失效等
    // --消息收发
    MESSAGE_SEND_FAIL: '消息发送失败',
    MESSAGE_LIST_CONSTRUCTOR_NEED_OPTIONS: 'MessageController.constructor() 需要参数 options',
    MESSAGE_SEND_NEED_MESSAGE_INSTANCE: '需要 Message 的实例',
    MESSAGE_SEND_INVALID_CONVERSATION_TYPE: 'Message.conversationType 只能为 "C2C" 或 "GROUP"',
    MESSAGE_FILE_IS_EMPTY: '无法发送空文件',
    MESSAGE_ONPROGRESS_FUNCTION_ERROR: '回调函数运行时遇到错误，请检查接入侧代码',
    MESSAGE_REVOKE_FAIL: '消息撤回失败',
    // ----拉取、同步、重发消息相关
    // ----文本消息收发相关
    // ----图片消息收发相关
    MESSAGE_IMAGE_SELECT_FILE_FIRST: '请先选择一个图片',
    MESSAGE_IMAGE_TYPES_LIMIT: '只允许上传 jpg png jpeg gif 格式的图片',
    MESSAGE_IMAGE_SIZE_LIMIT: '图片大小超过20M，无法发送',
    // ----语音消息收发相关
    MESSAGE_AUDIO_UPLOAD_FAIL: '语音上传失败',
    MESSAGE_AUDIO_SIZE_LIMIT: '语音大小大于20M，无法发送',
    // ----视频消息收发相关
    MESSAGE_VIDEO_UPLOAD_FAIL: '视频上传失败',
    MESSAGE_VIDEO_SIZE_LIMIT: '视频大小超过100M，无法发送',
    MESSAGE_VIDEO_TYPES_LIMIT: '只允许上传 mp4 格式的视频',
    // ----文件消息收发相关
    MESSAGE_FILE_UPLOAD_FAIL: '文件上传失败',
    MESSAGE_FILE_SELECT_FILE_FIRST: '请先选择一个文件',
    MESSAGE_FILE_SIZE_LIMIT: '文件大小超过100M，无法发送 ',
    MESSAGE_FILE_URL_IS_EMPTY: '缺少必要的参数文件 URL',
    // ----自定义消息收发相关
    // --会话相关
    // ----拉取、同步会话列表，搜索会话列表相关
    CONVERSATION_NOT_FOUND: '没有找到相应的会话，请检查传入参数',
    USER_OR_GROUP_NOT_FOUND: '没有找到相应的用户或群组，请检查传入参数',
    CONVERSATION_UN_RECORDED_TYPE: '未记录的会话类型',
    // ----删除会话、获取会话信息相关
    // ----C2C会话相关
    // ----群组会话相关
    // --群组相关
    ILLEGAL_GROUP_TYPE: '非法的群类型，请检查传入参数',
    CANNOT_JOIN_PRIVATE: '不能加入 Private 类型的群组',
    // ----拉取、同步、搜索群组列表相关
    // ----创建群组相关
    // ----解散、退出、转让群组相关
    CANNOT_CHANGE_OWNER_IN_AVCHATROOM: 'AVChatRoom 类型的群组不能转让群主',
    CANNOT_CHANGE_OWNER_TO_SELF: '不能把群主转让给自己',
    CANNOT_DISMISS_PRIVATE: '不能解散 Private 类型的群组',
    // ----查询、修改群组资料相关
    // ----邀人入群、申请加群与处理申请相关
    JOIN_GROUP_FAIL: '加群失败，请检查传入参数或重试',
    CANNOT_ADD_MEMBER_IN_AVCHATROOM: 'AVChatRoom 类型的群不支持邀请群成员',
    CANNOT_JOIN_NON_AVCHATROOM_WITHOUT_LOGIN: '非 AVChatRoom 类型的群组不允许匿名加群，请先登录后再加群',
    // ----控群相关，如设置禁言时间，设置群成员名片，踢人等
    CANNOT_KICK_MEMBER_IN_AVCHATROOM: '不能在 AVChatRoom 类型的群组踢人',
    NOT_OWNER: '你不是群主，只有群主才有权限操作',
    CANNOT_SET_MEMBER_ROLE_IN_PRIVATE_AND_AVCHATROOM: '不能在 Private / AVChatRoom 类型的群中设置群成员身份',
    INVALID_MEMBER_ROLE: '不合法的群成员身份，请检查传入参数',
    CANNOT_SET_SELF_MEMBER_ROLE: '不能设置自己的群成员身份，请检查传入参数',
    CANNOT_MUTE_SELF: '不能将自己禁言，请检查传入参数',
    // --关系链相关
    // ----拉取、同步好友列表、删除好友相关
    DEL_FRIEND_INVALID_PARAM: '传入 deleteFriend 接口的参数无效',
    // ----资料相关
    UPDATE_PROFILE_INVALID_PARAM: '传入 updateMyProfile 接口的参数无效',
    UPDATE_PROFILE_NO_KEY: 'updateMyProfile 无标配资料字段或自定义资料字段',
    // ----黑名单相关
    ADD_BLACKLIST_INVALID_PARAM: '传入 addToBlacklist 接口的参数无效',
    DEL_BLACKLIST_INVALID_PARAM: '传入 removeFromBlacklist 接口的参数无效',
    CANNOT_ADD_SELF_TO_BLACKLIST: '不能拉黑自己',
    // ----申请加好友与处理申请相关
    // --网络相关
    NETWORK_ERROR: '网络错误',
    NETWORK_TIMEOUT: '请求超时',
    NETWORK_BASE_OPTIONS_NO_URL: '网络层初始化错误，缺少 URL 参数',
    NETWORK_UNDEFINED_SERVER_NAME: '打包错误，未定义的 serverName',
    NETWORK_PACKAGE_UNDEFINED: '未定义的 packageConfig',
    NO_NETWORK: '未连接到网络',
    // ----websocket相关，如连接断开、心跳超时等
    CONVERTOR_IRREGULAR_PARAMS: '不规范的参数名称',
    // ----runLoop相关
    NOTICE_RUNLOOP_UNEXPECTED_CONDITION: '意料外的通知条件',
    NOTICE_RUNLOOP_OFFSET_LOST: '_syncOffset 丢失',
    GET_LONGPOLL_ID_FAILED: '获取 longpolling id 失败',
    // --宿主环境相关
    // ----小程序环境相关
    // ----PC/Mac浏览器环境相关
    // ----移动端浏览器环境相关
    // --其它
    // SDK_ERROR:
    UNCAUGHT_ERROR: '未经明确定义的错误',
    SDK_IS_NOT_READY: '接口需要 SDK 处于 ready 状态后才能调用',
    // 服务端错误
    LONG_POLL_KICK_OUT: '检测到多个 web 实例登录，消息通道下线',
    // --SSO 日志相关
    MESSAGE_A2KEY_EXPIRED: '消息错误码：UserSig 或 A2 失效。',
    ACCOUNT_A2KEY_EXPIRED: '帐号错误码：UserSig 已过期，请重新生成。建议 UserSig 有效期设置不小于24小时。',
    LONG_POLL_API_PARAM_ERROR: 'longPoll API parameters error'
  };

  var UPLOAD_FILE_SIZE_LIMIT = 104857600; // 上传的文件大小，限制为100M
  // @NOTE: 使用优图接口缩放时，图片大小限制为20M以及长宽小于9999px: https://cloud.tencent.com/document/product/460/6929

  var UPLOAD_IMAGE_SIZE_LIMIT = 20971520; // 上传的图片大小，限制为20M

  var UPLOAD_AUDIO_SIZE_LIMIT = 20971520; // 上传的音频大小，限制为20M

  var UPLOAD_VIDEO_SIZE_LIMIT = 104857600; // 上传的视频大小，限制为100M

  var UPLOAD_IMAGE_TYPES_LIMIT = ['jpg', 'jpeg', 'gif', 'png']; // 上传图片的类型限制

  var UPLOAD_VIDEO_TYPES_LIMIT = ['mp4']; // 上传视频的类型限制

  /**
   * 用户昵称长度限制，单位为bytes ，注意：用String.length只能取得字符串中的字符个数，并不能取得字节数
   * @private
   */

  var NICK_NAME_LENGTH_LIMIT = 500;

  /**
   * 文件类型元素
   * @class FileElement
   * @author saxongao
   */

  var FileElement =
  /*#__PURE__*/
  function () {
    function FileElement(options) {
      _classCallCheck(this, FileElement);

      var checkResult = this._check(options);

      if (checkResult instanceof IMError) {
        throw checkResult;
      }

      this.type = TYPES.MSG_FILE;
      this._percent = 0;

      var fileInfo = this._getFileInfo(options);

      this.content = {
        downloadFlag: 2,
        fileUrl: options.url || '',
        uuid: options.uuid,
        // sdk生成的uuid，和终端互通用
        fileName: fileInfo.name || '',
        fileSize: fileInfo.size || 0
      }; // this.content = options.content || null;
    }
    /**
     * @description 获取文件信息
     * @param {Object} options
     */


    _createClass(FileElement, [{
      key: "_getFileInfo",
      value: function _getFileInfo(options) {
        if (options.fileName && options.fileSize) {
          return {
            size: options.fileSize,
            name: options.fileName
          };
        }

        if (IN_WX_MINI_APP) {
          return {};
        }

        var file = options.file.files[0];
        return {
          size: file.size,
          name: file.name,
          type: file.type.slice(file.type.lastIndexOf('/') + 1).toLowerCase()
        };
      }
      /**
       * 更新百分比数据
       * @param {Number} newValue
       */

    }, {
      key: "updatePercent",
      value: function updatePercent(newValue) {
        this._percent = newValue;

        if (this._percent > 1) {
          this._percent = 1;
        }
      }
    }, {
      key: "updateFileUrl",
      value: function updateFileUrl(newUrl) {
        this.content.fileUrl = newUrl;
      }
    }, {
      key: "_check",
      value: function _check(options) {
        if (options.size > UPLOAD_FILE_SIZE_LIMIT) {
          return new IMError({
            code: ERROR_CODE.MESSAGE_FILE_SIZE_LIMIT,
            message: "".concat(ERROR_MESSAGE.MESSAGE_FILE_SIZE_LIMIT, ": ").concat(UPLOAD_FILE_SIZE_LIMIT, " bytes")
          });
        }
      }
    }, {
      key: "sendable",
      value: function sendable() {
        // 如果 url 为空， 视为空
        if (this.content.fileUrl === '') {
          return false;
        } // 如果 fileName 为空， 视为空


        if (this.content.fileName === '') {
          return false;
        } // 如果 fileSize 为空， 视为空


        if (this.content.fileSize === 0) {
          return false;
        }

        return true;
      }
    }]);

    return FileElement;
  }();

  var CustomElement =
  /*#__PURE__*/
  function () {
    /**
    * @class TextElement
    * @param { Object } options - 配置参数
    * @param {*} options.data - 自定义数据
    * @param {*} options.description - 自定义描述
    * @param {*} options.extension - 自定义扩展
    * @example
    * let customElement = new TIM.CustomElement({data:'', description:'', extension:''});
    *
    */
    function CustomElement(options) {
      _classCallCheck(this, CustomElement);

      // request form data
      // {
      //     MsgType: "TIMTextElem",
      //     MsgContent: {
      //         Data: "",
      //         Desc: "",
      //         Ext: ""
      //     }
      // }
      this.type = TYPES.MSG_CUSTOM;
      this.content = {
        data: options.data || '',
        description: options.description || '',
        extension: options.extension || ''
      };
    }

    _createClass(CustomElement, [{
      key: "setData",
      value: function setData(text) {
        this.content.data = text;
        return this;
      }
    }, {
      key: "setDescription",
      value: function setDescription(text) {
        this.content.description = text;
        return this;
      }
    }, {
      key: "setExtension",
      value: function setExtension(text) {
        this.content.extension = text;
        return this;
      }
    }, {
      key: "sendable",
      value: function sendable() {
        if (this.content.data.length === 0 && this.content.description.length === 0 && this.content.extension.length === 0) {
          return false;
        }

        return true;
      }
    }]);

    return CustomElement;
  }();

  /**
   * 用于描述消息中视频元素的结构
   * @class VideoElement
   */

  var VideoElement =
  /*#__PURE__*/
  function () {
    /**
     * @param {*} options - 初始化配置参数
     * @param {String} options.videoFormat - 视频文件的格式，往往是"mp4"
     * @param {Number} options.videoSecond - 视频文件的时长，单位秒，必须为整数
     * @param {Number} options.videoSize - 视频文件大小，单位：Byte
     * @param {String} options.videoUrl  - 视频文件的地址
     * @param {String} options.remoteVideoUrl - 视频文件在上传之后，cos 的上传成功地址，不更新本地地址
     * @param {Number} options.videoDownloadFlag - 视频下载标志位，往往是2，不提供给接入侧
     * @param {String} options.videoUUID - videoUUID 只有老版本使用大数据通道发送的文件，才会有videoUUID, 新版本web sdk 使用cos上传文件，且videoUUID使用 SDKAppID-identifier-随机字符串 的格式，不提供给接入侧
     * @param {String} options.thumbUUID - thumbUUID 只有老版本使用大数据通道发送的文件，才会有thumbUUID, 新版本web sdk 使用cos上传文件，且thumbUUID使用 SDKAppID-identifier-随机字符串 的格式，不提供给接入侧
     * @param {Number} options.thumbSize - 缩略图大小，单位：Byte
     * @param {Number} options.thumbWidth - 缩略图宽度
     * @param {Number} options.thumbHeight - 缩略图高度
     * @param {Number} options.thumbDownloadFlag - 缩略图下载标志位，往往是2，不提供给接入侧
     * @param {String} options.thumbUrl - 缩略图地址
     * @private
     * @constructor
     */
    function VideoElement(options) {
      _classCallCheck(this, VideoElement);

      this.type = TYPES.MSG_VIDEO;
      this._percent = 0;
      this.content = {
        remoteVideoUrl: options.remoteVideoUrl,
        videoFormat: options.videoFormat,
        videoSecond: parseInt(options.videoSecond, 10),
        // parseInt 参数不是一个字符串，则将其转换为字符串，radix为进制数值
        videoSize: options.videoSize,
        videoUrl: options.videoUrl,
        videoDownloadFlag: 2,
        videoUUID: options.videoUUID,
        thumbUUID: options.thumbUUID,
        thumbFormat: options.thumbFormat,
        thumbWidth: options.thumbWidth,
        thumbHeight: options.thumbHeight,
        thumbSize: options.thumbSize,
        thumbDownloadFlag: 2,
        thumbUrl: options.thumbUrl
      };
    }
    /**
     * 更新百分比数据
     * @param {Number} newValue
     */


    _createClass(VideoElement, [{
      key: "updatePercent",
      value: function updatePercent(newValue) {
        this._percent = newValue;

        if (this._percent > 1) {
          this._percent = 1;
        }
      }
    }, {
      key: "updateVideoUrl",
      value: function updateVideoUrl(videoUrl) {
        if (videoUrl) {
          this.content.remoteVideoUrl = videoUrl;
        }
      }
    }, {
      key: "sendable",
      value: function sendable() {
        if (this.content.remoteVideoUrl === '') {
          return false;
        }

        return true;
      }
    }]);

    return VideoElement;
  }();

  /**
   * @property {String} type 类型。值为：TIMLocationElem
   * @property {String} description 相关描述信息
   * @property {Number} latitude 纬度
   * @property {Number} longitude 经度
   * @class GeoElemnt
   */

  var GeoElemnt =
  /**
   * Creates an instance of GeoElemnt.
   * @param {Object} options 参数
   * @param {String} options.description 相关描述信息
   * @param {Number} options.latitude 纬度
   * @param {Number} options.longitude 经度
   * @memberof GeoElemnt
   */
  function GeoElemnt(options) {
    _classCallCheck(this, GeoElemnt);

    this.type = TYPES.MSG_GEO;
    this.content = options;
  };

  /**
   * 文本消息的 payload 结构
   * @typedef TextPayload
   * @property {String} text 文本消息内容
   * @memberof Message
   */

  /**
   * 图片消息的 payload 结构
   * @typedef ImagePayload
   * @property {String} uuid 图片唯一标识
   * @property {String} imageFormat 图片格式类型
   * @property {Object[]} imageInfoArray 图片信息
   * @property {Number} imageInfoArray.width 宽度
   * @property {Number} imageInfoArray.height 高度
   * @property {String} imageInfoArray.url 图片地址，可用于渲染
   * @property {Number} imageInfoArray.size 图片大小，单位：Byte
   * @property {Number} imageInfoArray.sizeType 图片大小类型。值为 1 时表示原图，数值越大表示压缩比率越高。
   * @memberof Message
   */

  /**
   * 音频消息的 payload 结构
   * @typedef AudioPayload
   * @property {String} uuid 唯一标识
   * @property {String} url 音频地址，可用于播放
   * @property {Number} size 文件大小，单位：Byte
   * @property {Number} second 音频时长，单位：秒
   * @memberof Message
   */

  /**
   * 视频消息的 payload 结构
   * @typedef VideoPayload
   * @property {String} videoFormat  - 视频文件的格式
   * @property {Number} videoSecond - 视频文件的时长，单位秒，整型
   * @property {Number} videoSize - 视频文件大小，单位：Byte
   * @property {String} videoUrl  - 视频文件的地址，可用于播放
   * @property {String} videoUUID  - video 唯一标识
   * @property {String} thumbUUID  - thumb 唯一标识
   * @property {Number} thumbSize - 缩略图大小，单位：Byte
   * @property {Number} thumbWidth - 缩略图宽度
   * @property {Number} thumbHeight - 缩略图高度
   * @property {String} thumbUrl - 缩略图地址，可用于渲染
   * @memberof Message
   */

  /**
   * 文件消息的 payload 结构
   * @typedef FilePayload
   * @property {String} uuid 唯一标识
   * @property {String} fileName 文件名
   * @property {String} fileUrl 文件地址
   * @property {Number} fileSize 文件大小，单位：Byte
   * @memberof Message
   */

  /**
   * 自定义消息的 payload 结构
   * @typedef CustomPayload
   * @property {String} data 自定义消息的 data 字段
   * @property {String} description 自定义消息的 description 字段
   * @property {String} extension 自定义消息的 extension 字段
   * @memberof Message
   */

  /**
    * 位置消息的 payload 结构
    * @typedef GeoPayload
    * @property {String} description 相关描述信息
    * @property {Number} latitude 纬度
    * @property {Number} longitude 经度
    * @memberof Message
    */

  /**
   * 群提示消息的 payload 结构。系统会在恰当的时机，向全体群成员发出群提示消息。例如：有群成员退群/进群，系统会给所有群成员发对应的群提示消息。
   * @typedef GroupTipPayload
   * @property {String} operatorID 执行该操作的用户 ID
   * @property {Number} operationType 操作类型，具体如下:<br/>
   * | 操作类型 | 值 | 含义 |
   * | :--- | :---- | :---- |
   * | TIM.TYPES.GRP_TIP_MBR_JOIN | 1 | 有成员加群
   * | TIM.TYPES.GRP_TIP_MBR_QUIT | 2 | 有群成员退群
   * | TIM.TYPES.GRP_TIP_MBR_KICKED_OUT | 3 | 有群成员被踢出群
   * | TIM.TYPES.GRP_TIP_MBR_SET_ADMIN | 4 | 有群成员被设为管理员
   * | TIM.TYPES.GRP_TIP_MBR_CANCELED_ADMIN | 5 | 有群成员被撤销管理员
   * | TIM.TYPES.GRP_TIP_GRP_PROFILE_UPDATED | 6 | 群组资料变更
   * | TIM.TYPES.GRP_TIP_MBR_PROFILE_UPDATED | 7 | 群成员资料变更，例如：群成员被禁言
   * @property {String[]} userIDList 相关的 userID 列表
   * @property {Object} newGroupProfile 若是群资料变更，该字段存放变更的群资料
   * @property {Object[]} newGroupProfile.groupCustomField 若是[群自定义字段](https://cloud.tencent.com/document/product/269/1502#.E8.87.AA.E5.AE.9A.E4.B9.89.E5.AD.97.E6.AE.B5)变更，该字段存放变更的群自定义字段键值对（v2.6.0起支持）
   * @property {Object[]} memberList 当群成员被禁言时，可在该字段中拿到相关信息
   * @property {String} memberList.userID
   * @property {Number} memberList.muteTime 被禁言的时长，单位：秒
   * @memberof Message
   */

  /**
   * @description 群系统通知的 payload 结构。系统会在恰当的时机，向特定用户发出群系统通知。例如：user1 被踢出群组，系统会给 user1 发送对应的群系统消息。
   * @typedef GroupSystemNoticePayload
   * @property {String} operatorID 执行该操作的用户 ID
   * @property {Number} operationType 操作类型，具体如下：<br/>
   * | 值 | 描述 | 接收对象 |
   * | :--- | :--------------------------------- | :---|
   * | 1 | 有用户申请加群 | 群管理员/群主接收 |
   * | 2 | 申请加群被同意 | 申请加群的用户接收 |
   * | 3 | 申请加群被拒绝 | 申请加群的用户接收 |
   * | 4 | 被踢出群组 | 被踢出的用户接收 |
   * | 5 | 群组被解散 | 全体群成员接收 |
   * | 6 | 创建群组 | 创建者接收 |
   * | 7 | 邀请加群 | 被邀请者接收 |
   * | 8 | 退群 | 退群者接收 |
   * | 9 | 设置管理员 | 被设置方接收 |
   * | 10 | 取消管理员 | 被取消方接收 |
   * | 255 | 用户自定义通知 | 默认全员接收 |
   * @property {Object} groupProfile 相关的群组资料
   * @property {String} userDefinedField 用户自定义字段。使用 {@link https://cloud.tencent.com/document/product/269/1630 RestAPI 发送自定义通知}时，可在该属性值中拿到自定义通知的内容。
   * @property {Object} handleMessage 处理的附言。例如：user1 申请加入 group1 时，若进群需要验证，且 user1 填写了申请加群的附言。则 group1 的管理员会在相应群系统通知中看到该字段。
   * @memberof Message
   */
  // 暂不展示
  // * | 11 | 群已被回收。全员接收, 不展示
  // * | 12 | 邀请人加群。被邀请者需同意
  // * | 15 | 群消息已读同步

  /**
   * 消息优先级与枚举值对应表。（这个对应表有点反直觉）
   * 注意！sdk 设置 priority 时，传入的是字符串 'high' 'Normal'等，IM后台把字符串翻译成对应的整型。
   * 拉取群消息漫游时，MsgPriority 的值是整型，构建 Message model 时需要将整型翻译成对应的字符串。
   * @private
   */

  var MESSAGE_PRIORITY_MAP = {
    '1': TYPES.MSG_PRIORITY_HIGH,
    '2': TYPES.MSG_PRIORITY_NORMAL,
    '3': TYPES.MSG_PRIORITY_LOW,
    '4': TYPES.MSG_PRIORITY_LOWEST
  };

  var Message =
  /*#__PURE__*/
  function () {
    // eslint-disable-next-line valid-jsdoc

    /**
     * @description 消息对象，用于描述一条消息具有的属性，如类型、消息的内容、所属的会话 ID 等。
     * @property {String}  ID - 消息 ID
     * @property {String}  type - 消息类型，具体如下：<br/>
     * | 类型 | 含义 |
     * | :--- | :---- |
     * | TIM.TYPES.MSG_TEXT | 文本消息 |
     * | TIM.TYPES.MSG_IMAGE | 图片消息 |
     * | TIM.TYPES.MSG_SOUND | 音频消息（已废弃，请使用 TIM.TYPES.MSG_AUDIO ） |
     * | TIM.TYPES.MSG_AUDIO | 音频消息 |
     * | TIM.TYPES.MSG_VIDEO | 视频消息 |
     * | TIM.TYPES.MSG_FILE | 文件消息 |
     * | TIM.TYPES.MSG_CUSTOM | 自定义消息 |
     * | TIM.TYPES.MSG_GEO | 位置消息 |
     * | TIM.TYPES.MSG_GRP_TIP | 群提示消息 |
     * | TIM.TYPES.MSG_GRP_SYS_NOTICE | 群系统通知消息 |
     * @property {Object}  payload - 消息的内容，具体如下：<br/>
     * - {@link Message.TextPayload 文本}
     * - {@link Message.ImagePayload 图片}
     * - {@link Message.AudioPayload 音频}
     * - {@link Message.VideoPayload 视频}
     * - {@link Message.FilePayload 文件}
     * - {@link Message.CustomPayload 自定义}
     * - {@link Message.GeoPayload 位置}
     * - {@link Message.GroupTipPayload 群提示消息}
     * - {@link Message.GroupSystemNoticePayload 群系统通知}
     * @property {String}  conversationID - 消息所属的会话 ID
     * @property {String}  conversationType - 消息所属会话的类型，具体如下：<br/>
     * | 类型 | 含义 |
     * | :--- | :---- |
     * | TIM.TYPES.CONV_C2C | C2C(Client to Client, 端到端) 会话 |
     * | TIM.TYPES.CONV_GROUP | GROUP(群组) 会话 |
     * | TIM.TYPES.CONV_SYSTEM | SYSTEM(系统) 会话 |
     * @property {String}  to - 接收方的 userID
     * @property {String}  from - 发送方的 userID，在消息发送时，会默认设置为当前登录的用户
     * @property {String}  flow - 消息的流向<br/>
     * - in 为收到的消息
     * - out 为发出的消息
     * @property {Number}  time - 消息时间戳。单位：秒
     * @property {String}  status - 消息状态。
     * - unSend(未发送)
     * - success(发送成功)
     * - fail(发送失败)
     * @property {Boolean} isRevoked=false - 是否被撤回的消息，true 标识被撤回的消息（v2.4.0起支持）。
     * @property {String} priority=TIM.TYPES.MSG_PRIORITY_NORMAL - 消息优先级，用于群聊（v2.4.2起支持）。
     * @property {String} nick 消息发送者的昵称（v2.6.0起，在 AVChatRoom 内支持，需提前调用 [updateMyProfile](https://imsdk-1252463788.file.myqcloud.com/IM_DOC/Web/SDK.html#updateMyProfile) 设置）
     * @property {String} avatar 消息发送者的头像地址（v2.6.0起，在 AVChatRoom 内支持，需提前调用 [updateMyProfile](https://imsdk-1252463788.file.myqcloud.com/IM_DOC/Web/SDK.html#updateMyProfile) 设置）
     */
    function Message(options) {
      _classCallCheck(this, Message);

      this.ID = ''; // 消息ID

      this.conversationID = options.conversationID || null; // 这里的赋值是为了方便重建消息对象，不需要传入
      // eslint-disable-next-line max-len

      this.conversationType = options.conversationType || TYPES.CONV_C2C;
      this.conversationSubType = options.conversationSubType;
      this.time = options.time || Math.ceil(Date.now() / 1000);
      this.sequence = options.sequence || 0; // 服务端的 sequence

      this.clientSequence = options.clientSequence || options.sequence || 0; // clinet 端的 sequence

      this.random = options.random || randomInt();
      this.priority = this._computePriority(options.priority);
      this.nick = '';
      this.avatar = ''; // this.nameCard = ''; // 这个字段的 QQ 味道太浓了，目前没什么人用，先不提供

      /**
       * 用于存储消息元素
       * @member {Object[]}
       * @private
       * @example
       *
       * // 文本元素
       * message.elements = [
       *  {
       *    type: 'TIMTextElem',
       *    content: '你好~'
       *  }
       * ];
       * // 图片元素
       * message.elements = [
       *  {
       *    type: 'TIMImageElem'
       *    content: {
       *       imageFormat: 1, // 图片格式类型 JPG: 1, JPEG: 1, GIF: 2, PNG: 3, BMP: 4, UNKNOWN: 255
       *       uuid: 'xxxxxx', // 图片唯一标识
       *       imageInfoArray: [
       *        {type:3, size:9689, width:198, height:198, url:'http://xxxx' }, // 缩略小图 type:3
       *        {type:2, size:16828, width:720, height:720, url:'http://xxxx' }, // 缩略大图 type:2
       *        {type:1, size:21712, width:1920, height:1080, url:'http://xxxx' }  // 原图 type:r31
       *       ]
       *    }
       *  }
       * ];
       * // 自定义元素
       * message.elements = [
       *  {
       *    type: 'TIMCustomElem',
       *    content: {
       *     data: '', // 自定义数据
       *     description: '', // 自定义描述
       *     extension: '' // 自定义扩展
       *    }
       *  }
       * ];
       */

      this._elements = []; // 消息元素数组
      // 是否为占位消息，有些消息被撤回、被删除了、漫游过期了，或者因为其他原因导致不能展示出来，后台会塞一个空消息进去，以保证群消息的sequence是连续的。
      // 0-正常消息 1-空消息 2-被撤回的消息

      this.isPlaceMessage = options.isPlaceMessage || 0; // 是否被撤回了的消息，暴露给接入侧
      // isPlaceMessage 为2标识被撤回的群聊消息；msgFlagBits 为8标识被撤回的单聊消息

      this.isRevoked = options.isPlaceMessage === 2 || options.msgFlagBits === 8;
      this.geo = {}; // 地理位置消息内容

      this.from = options.from || null; // 消息的发送方

      this.to = options.to || null; // 消息接收方
      // this.groupID = options.groupID || null; // 群组ID

      this.flow = ''; // in || out 用来表示消息的流向

      this.isSystemMessage = options.isSystemMessage || false; // 标记这条消息是否为系统发送的消息，但对于群历史和 notice channel 下来的Event 为  4 的 GroupTips 而言，这个字段有歧义：群历史有，但notice channel 没有；使用时请注意这一点。

      this.protocol = options.protocol || 'JSON'; // 此消息使用的协议

      this.isResend = false; // 是否为重发的消息

      this.isRead = false; // 是否已读

      this.status = options.status || TIM_STATUS.MESSAGE_STATUS.SUCCESS; // 仅对 flow out 的消息

      this.reInitialize(options.currentUser);
      this.extractGroupInfo(options.groupProfile || null); // 提取出消息包体中的群组信息：成员头像地址和群名片
    } // TODO: 下一大版本删除


    _createClass(Message, [{
      key: "getElements",

      /**
       * SDK 内部访问 _elements 请调用此方法
       * @returns {Array}
       * @private
       */
      value: function getElements() {
        return this._elements;
      }
      /**
       * 提取出群组信息的 nick 和 avatar
       * @param {object} groupProfile - 消息包体中的群组信息对象
       * @private
       */

    }, {
      key: "extractGroupInfo",
      value: function extractGroupInfo(groupProfile) {
        if (groupProfile === null) {
          return;
        } // 昵称


        if (isString(groupProfile.fromAccountNick)) {
          this.nick = groupProfile.fromAccountNick;
        } // 头像


        if (isString(groupProfile.fromAccountHeadurl)) {
          this.avatar = groupProfile.fromAccountHeadurl;
        } // 群名片
        // const { messageFromAccountExtraInformation } = groupProfile;
        // if (isObject(messageFromAccountExtraInformation) &&
        //   isString(messageFromAccountExtraInformation.nameCard)) {
        //   this.nameCard = messageFromAccountExtraInformation.nameCard;
        // }

      }
      /**
       * 初始化 type 和 content 属性，用于拍平消息结构，同时保留 elements
       * @private
       */

    }, {
      key: "_initProxy",
      value: function _initProxy() {
        this.payload = this._elements[0].content;
        this.type = this._elements[0].type;
      }
      /**
       * 重初始化
       * @param {String} [currentUser] - 当前用户，发消息时要传入
       * @private
       */

    }, {
      key: "reInitialize",
      value: function reInitialize(currentUser) {
        if (currentUser) {
          this.status = this.from ? TIM_STATUS.MESSAGE_STATUS.SUCCESS : TIM_STATUS.MESSAGE_STATUS.UNSEND;
          !this.from ? this.from = currentUser : null;
        } // this._initTo();


        this._initFlow(currentUser);

        this._initielizeSequence(currentUser); // this.offlinePushInfo = ''; // 离线推送相关，先注释掉


        this._concactConversationID(currentUser);

        this.generateMessageID(currentUser);
      }
      /**
       * 判断本消息实例是否已经可以发送
       * @returns {boolean}
       * @private
       */

    }, {
      key: "isSendable",
      value: function isSendable() {
        if (this._elements.length === 0) {
          return false;
        }

        if (typeof this._elements[0].sendable !== 'function') {
          logger.warn("".concat(this._elements[0].type, " need \"boolean : sendable()\" method"));
          return false;
        }

        return this._elements[0].sendable();
      }
    }, {
      key: "_initTo",
      value: function _initTo(options) {
        if (this.conversationType === TYPES.CONV_GROUP) {
          this.to = options.groupID;
        }
      }
      /**
       * @description 生成 sequence, 只有在发消息时执行
       * @param {string} currentUser - 当前用户
       * @private
       */

    }, {
      key: "_initielizeSequence",
      value: function _initielizeSequence(currentUser) {
        if (this.clientSequence === 0 && currentUser) {
          this.clientSequence = autoincrementIndex(currentUser);
        }

        if (this.sequence === 0 && this.conversationType === TYPES.CONV_C2C) {
          this.sequence = this.clientSequence;
        }
      }
      /**
       * @description 生成消息 ID
       * @param {string} currentUser - 当前用户
       * @private
       */

    }, {
      key: "generateMessageID",
      value: function generateMessageID(currentUser) {
        var isMySendedMessage = currentUser === this.from ? 1 : 0; // 是否为我自己发送的消息
        // const sequence = this.clientSequence > 0
        //   ? this.clientSequence
        //   : this.sequence;

        var sequence = this.sequence > 0 ? this.sequence : this.clientSequence; // 不加random可能和自己发过的消息ID撞车(详见sequence的生成规则)，加上random做规避
        // eslint-disable-next-line max-len

        this.ID = "".concat(this.conversationID, "-").concat(sequence, "-").concat(this.random, "-").concat(isMySendedMessage);
      }
      /**
       * @description 初始化消息的流向 flow
       * @param {string} currentUser - 当前用户
       * @private
       */

    }, {
      key: "_initFlow",
      value: function _initFlow(currentUser) {
        if (currentUser === '') {
          return;
        }

        if (currentUser === this.from) {
          this.flow = 'out';
          this.isRead = true; // 自己发的消息默认是已读，收到其他人发的消息默认未读
        } else {
          this.flow = 'in';
        }
      }
      /**
       * @description 拼装出 会话ID `conversationID`
       * @param {string} currentUser - 当前用户
       * @private
       */

    }, {
      key: "_concactConversationID",
      value: function _concactConversationID(currentUser) {
        var to = this.to;
        var target = '';
        var type = this.conversationType; // 如果是系统消息，conversationID直接设置为系统类型的值

        if (type === TYPES.CONV_SYSTEM) {
          this.conversationID = TYPES.CONV_SYSTEM;
          return;
        }

        if (type === TYPES.CONV_C2C) {
          target = currentUser === this.from ? to : this.from;
        } else {
          target = this.to;
        }

        this.conversationID = "".concat(type).concat(target);
      }
    }, {
      key: "isElement",
      value: function isElement(element) {
        return element instanceof TextElement || element instanceof ImageElement || element instanceof FaceElement || element instanceof AudioElement || element instanceof FileElement || element instanceof VideoElement || element instanceof GroupTipElement || element instanceof GroupSystemNoticeElement || element instanceof CustomElement || element instanceof GeoElemnt;
      }
      /**
       * @description 设置消息元素, 如果content过于复杂这里需要优化
       * @param {Element | Object} options 标准Element对象，或者数据对象字面量
       * @private
       */

    }, {
      key: "setElement",
      value: function setElement(options) {
        var _this = this;

        // 支持 options 直接传 elements
        if (this.isElement(options)) {
          this._elements = [options];

          this._initProxy();

          return;
        }

        var setElementItem = function setElementItem(options) {
          // 支持 options 非标准 element 类型， 但必须有type 和content 属性
          switch (options.type) {
            case TYPES.MSG_TEXT:
              _this.setTextElement(options.content);

              break;

            case TYPES.MSG_IMAGE:
              _this.setImageElement(options.content);

              break;

            case TYPES.MSG_AUDIO:
              _this.setAudioElement(options.content);

              break;

            case TYPES.MSG_FILE:
              _this.setFileElement(options.content);

              break;

            case TYPES.MSG_VIDEO:
              _this.setVideoElement(options.content);

              break;

            case TYPES.MSG_CUSTOM:
              _this.setCustomElement(options.content);

              break;

            case TYPES.MSG_GEO:
              _this.setGEOElement(options.content);

              break;

            case TYPES.MSG_GRP_TIP:
              _this.setGroupTipElement(options.content);

              break;

            case TYPES.MSG_GRP_SYS_NOTICE:
              _this.setGroupSystemNoticeElement(options.content);

              break;

            case TYPES.MSG_FACE:
              _this.setFaceElement(options.content);

              break;

            default:
              logger.warn(options.type, options.content, 'no operation......');
          }
        };

        if (Array.isArray(options)) {
          for (var i = 0; i < options.length; i++) {
            setElementItem(options[i]);
          }
        } else {
          setElementItem(options);
        }

        this._initProxy();
      }
      /**
       * @description 设置文件消息元素
       * @param {String | Object} options 文本消息内容，或者包含文本消息的对象 eg. options = 'text content' , options = {text: 'text content'}
       * @private
       */

    }, {
      key: "setTextElement",
      value: function setTextElement(options) {
        var text = typeof options === 'string' ? options : options.text;
        var textElement = new TextElement({
          text: text
        });

        this._elements.push(textElement);
      }
      /**
       * @description 设置图片消息元素
       * @param {Object} options options = {type: '', uuid: '', imageInfoArray: []}
       * @param {String} options.uuid 图片唯一标识
       * @param {String} options.imageFormat 图片格式类型
       * @param {Array} options.imageInfoArray 图片描述对象数组, 对象包含属性 {type:'', size:'', width:'', height:'', url:'' }
       * @private
       */

    }, {
      key: "setImageElement",
      value: function setImageElement(options) {
        var imageElement = new ImageElement(options);

        this._elements.push(imageElement);
      }
      /**
       * @description 设置语音消息元素
       * @param {Object} options - 语音元素参数对象
       * @private
       */

    }, {
      key: "setAudioElement",
      value: function setAudioElement(options) {
        var audioElement = new AudioElement(options);

        this._elements.push(audioElement);
      }
      /**
       * @description 设置文件消息元素
       * @param {Object} options - 文件元素参数对象
       * @private
       */

    }, {
      key: "setFileElement",
      value: function setFileElement(options) {
        var fileElement = new FileElement(options);

        this._elements.push(fileElement);
      }
      /**
       * 设置视频消息元素
       * @param {Object} options - 视频元素参数对象
       * @private
       */

    }, {
      key: "setVideoElement",
      value: function setVideoElement(options) {
        var videoElement = new VideoElement(options);

        this._elements.push(videoElement);
      }
      /**
       * @description 设置地理定位消息元素
       * @param {Object} options - 地理定位元素参数对象
       * @private
       */

    }, {
      key: "setGEOElement",
      value: function setGEOElement(options) {
        var geoElement = new GeoElemnt(options);

        this._elements.push(geoElement);
      }
      /**
       * @description 设置自定义消息元素
       * @param {Object} options - 参数对象
       * @param {*} options.data - 自定义数据
       * @param {*} options.description - 自定义描述
       * @param {*} options.extension - 自定义扩展
       * @private
       */

    }, {
      key: "setCustomElement",
      value: function setCustomElement(options) {
        var customElement = new CustomElement(options);

        this._elements.push(customElement);
      }
      /**
       * 设置 Event 4 的群消息
       * @param {*} options - 参数对象
       * @private
       */

    }, {
      key: "setGroupTipElement",
      value: function setGroupTipElement(options) {
        // 从进群、退群等的群提示消息中提取 nick 和 avatar
        if (options.operatorInfo) {
          var _options$operatorInfo = options.operatorInfo,
              nick = _options$operatorInfo.nick,
              avatar = _options$operatorInfo.avatar;

          if (isString(nick)) {
            this.nick = nick;
          }

          if (isString(avatar)) {
            this.avatar = avatar;
          }
        }

        var groupTipElement = new GroupTipElement(options);

        this._elements.push(groupTipElement);
      }
      /**
       * 设置 Event 5 的群系统通知
       * @param {*} options - 参数对象
       * @private
       */

    }, {
      key: "setGroupSystemNoticeElement",
      value: function setGroupSystemNoticeElement(options) {
        var groupSystemNotice = new GroupSystemNoticeElement(options);

        this._elements.push(groupSystemNotice);
      }
      /**
       * 设置 TIMFaceElem 元素
       * @param {object} options - 参数对象
       * @private
       */

    }, {
      key: "setFaceElement",
      value: function setFaceElement(options) {
        var faceElement = new FaceElement(options);

        this._elements.push(faceElement);
      }
      /**
       * 设置 isRead
       * @param {Boolean} isRead 是否已读
       * @private
       */

    }, {
      key: "setIsRead",
      value: function setIsRead(isRead) {
        this.isRead = isRead;
      }
      /**
       * 计算消息优先级
       * @param {*} priority 接入侧或者IM后台返回的消息优先级
       * @private
       * @returns {String}
       */

    }, {
      key: "_computePriority",
      value: function _computePriority(priority) {
        // 默认 Normal 级别
        if (isUndefined(priority)) {
          return TYPES.MSG_PRIORITY_NORMAL;
        } // 接入侧设置的字符串，校验下


        if (isString(priority)) {
          if (Object.values(MESSAGE_PRIORITY_MAP).indexOf(priority) !== -1) {
            return priority;
          }
        } // IM后台返回的值


        if (isNumber(priority)) {
          var tmpKey = '' + priority;

          if (Object.keys(MESSAGE_PRIORITY_MAP).indexOf(tmpKey) !== -1) {
            return MESSAGE_PRIORITY_MAP[tmpKey];
          }
        }

        return TYPES.MSG_PRIORITY_NORMAL;
      }
    }, {
      key: "elements",
      get: function get() {
        logger.warn('！！！Message 实例的 elements 属性即将废弃，请尽快修改。使用 type 和 payload 属性处理单条消息，兼容组合消息使用 _elements 属性！！！');
        return this._elements;
      }
    }]);

    return Message;
  }();

  /**
   * API 接口参数校验的配置
   * {
   *   // 多个参数传参，例如 func(args1, args2, ...)
   *   'API名称': [
   *     {
   *       name: '', // 参数名称
   *       type: 'Number',  // 支持 String Number Array Object Boolean Map 等基本类型
   *       required: true // 是否必选
   *     }
   *     ...
   *   ],
   *   // 对象类型的参数配置，有且只有一个参数，例如 func(options)
   *   API名称: {
   *     参数名称: {
   *       type: 'String',
   *       required: true
   *     },
   *     ...
   *     参数名称1: {
   *       type: 'Array',
   *       required: false
   *     }
   *   }
   * }
   */

  /**
  * 检测是否有合法的会话 ID
  * @param {String} conversationID 会话 ID
  * @returns {Boolean} true 合法；false 不合法
  */

  var isValidConversationID = function isValidConversationID(conversationID) {
    if (!conversationID) {
      return false;
    }

    if (isC2CConversation(conversationID) || isGroupConversation(conversationID) || isSystemConversation(conversationID)) {
      return true;
    }

    console.warn("\u975E\u6CD5\u7684\u4F1A\u8BDD ID:".concat(conversationID, "\u3002\u4F1A\u8BDD ID \u7EC4\u6210\u65B9\u5F0F\uFF1A\n  C2C + userID\uFF08\u5355\u804A\uFF09\n  GROUP + groupID\uFF08\u7FA4\u804A\uFF09\n  @TIM#SYSTEM\uFF08\u7CFB\u7EDF\u901A\u77E5\u4F1A\u8BDD\uFF09"));
    return false;
  };

  var APIValidateConfig = {
    login: {
      userID: {
        type: 'String',
        required: true
      },
      userSig: {
        type: 'String',
        required: true
      }
    },
    addToBlacklist: {
      userIDList: {
        type: 'Array',
        required: true
      }
    },
    mutilParam: [{
      name: 'paramName',
      type: 'Number',
      required: true
    }, {
      name: 'paramName',
      type: 'String',
      required: true
    }],
    on: [{
      name: 'eventName',
      type: 'String',
      validator: function validator(param) {
        if (typeof param !== 'string' || param.length === 0) {
          console.warn('on 接口的 eventName 参数必须是 String 类型，且不能为空。');
          return false;
        }

        return true;
      }
    }, {
      name: 'handler',
      type: 'Function',
      validator: function validator(param) {
        if (typeof param !== 'function') {
          console.warn('on 接口的 handler 参数必须是 Function 类型。');
          return false;
        }

        if (param.name === '') {
          console.warn('on 接口的 handler 参数推荐使用具名函数。具名函数可以使用 off 接口取消订阅，匿名函数无法取消订阅。');
        }

        return true;
      }
    }],
    once: [{
      name: 'eventName',
      type: 'String',
      validator: function validator(param) {
        if (typeof param !== 'string' || param.length === 0) {
          console.warn('once 接口的 eventName 参数必须是 String 类型，且不能为空。');
          return false;
        }

        return true;
      }
    }, {
      name: 'handler',
      type: 'Function',
      validator: function validator(param) {
        if (typeof param !== 'function') {
          console.warn('once 接口的 handler 参数必须是 Function 类型。');
          return false;
        }

        if (param.name === '') {
          console.warn('once 接口的 handler 参数推荐使用具名函数。');
        }

        return true;
      }
    }],
    off: [{
      name: 'eventName',
      type: 'String',
      validator: function validator(param) {
        if (typeof param !== 'string' || param.length === 0) {
          console.warn('off 接口的 eventName 参数必须是 String 类型，且不能为空。');
          return false;
        }

        return true;
      }
    }, {
      name: 'handler',
      type: 'Function',
      validator: function validator(param) {
        if (typeof param !== 'function') {
          console.warn('off 接口的 handler 参数必须是 Function 类型。');
          return false;
        }

        if (param.name === '') {
          console.warn('off 接口的 handler 参数为匿名函数，无法取消订阅。');
        }

        return true;
      }
    }],
    sendMessage: [{
      name: 'message',
      type: 'Object',
      required: true
    }],
    getMessageList: {
      conversationID: {
        type: 'String',
        required: true,
        validator: function validator(param) {
          return isValidConversationID(param);
        }
      },
      nextReqMessageID: {
        type: 'String'
      },
      count: {
        type: 'Number',
        validator: function validator(param) {
          // 该属性可选
          if (isUndefined(param) || /^[1-9][0-9]*$/.test(param)) {
            return true;
          }

          console.warn('getMessageList 接口的 count 参数必须为正整数');
          return false;
        }
      }
    },
    setMessageRead: {
      conversationID: {
        type: 'String',
        required: true,
        validator: function validator(param) {
          return isValidConversationID(param);
        }
      }
    },
    // Conversation
    getConversationProfile: [{
      name: 'conversationID',
      type: 'String',
      required: true,
      validator: function validator(param) {
        return isValidConversationID(param);
      }
    }],
    deleteConversation: [{
      name: 'conversationID',
      type: 'String',
      required: true,
      validator: function validator(param) {
        return isValidConversationID(param);
      }
    }],
    // GROUP
    getGroupList: {
      groupProfileFilter: {
        type: 'Array'
      }
    },
    getGroupProfile: {
      groupID: {
        type: 'String',
        required: true
      },
      groupCustomFieldFilter: {
        type: 'Array'
      },
      memberCustomFieldFilter: {
        type: 'Array'
      }
    },
    getGroupProfileAdvance: {
      groupIDList: {
        type: 'Array',
        required: true
      }
    },
    createGroup: {
      name: {
        type: 'String',
        required: true
      }
    },
    joinGroup: {
      groupID: {
        type: 'String',
        required: true
      },
      type: {
        type: 'String'
      },
      applyMessage: {
        type: 'String'
      }
    },
    quitGroup: [{
      name: 'groupID',
      type: 'String',
      required: true
    }],
    handleApplication: {
      message: {
        type: 'Object',
        required: true
      },
      handleAction: {
        type: 'String',
        required: true
      },
      handleMessage: {
        type: 'String'
      }
    },
    changeGroupOwner: {
      groupID: {
        type: 'String',
        required: true
      },
      newOwnerID: {
        type: 'String',
        required: true
      }
    },
    updateGroupProfile: {
      groupID: {
        type: 'String',
        required: true
      }
    },
    dismissGroup: [{
      name: 'groupID',
      type: 'String',
      required: true
    }],
    searchGroupByID: [{
      name: 'groupID',
      type: 'String',
      required: true
    }],
    // Group Member
    getGroupMemberList: {
      groupID: {
        type: 'String',
        required: true
      },
      offset: {
        type: 'Number'
      },
      count: {
        type: 'Number'
      }
    },
    getGroupMemberProfile: {
      groupID: {
        type: 'String',
        required: true
      },
      userIDList: {
        type: 'Array',
        required: true
      },
      memberCustomFieldFilter: {
        type: 'Array'
      }
    },
    addGroupMemeber: {
      groupID: {
        type: 'String',
        required: true
      },
      userIDList: {
        type: 'Array',
        required: true
      }
    },
    setGroupMemberRole: {
      groupID: {
        type: 'String',
        required: true
      },
      userID: {
        type: 'String',
        required: true
      },
      role: {
        type: 'String',
        required: true
      }
    },
    setGroupMemberMuteTime: {
      groupID: {
        type: 'String',
        required: true
      },
      userID: {
        type: 'String',
        required: true
      },
      muteTime: {
        type: 'Number',
        validator: function validator(param) {
          return param >= 0;
        }
      }
    },
    setGroupMemberNameCard: {
      groupID: {
        type: 'String',
        required: true
      },
      userID: {
        type: 'String'
      },
      nameCard: {
        type: 'String',
        required: true,
        validator: function validator(param) {
          if (/^\s+$/.test(param) === true) {
            return false;
          }

          return true;
        }
      }
    },
    setMessageRemindType: {
      groupID: {
        type: 'String',
        required: true
      },
      messageRemindType: {
        type: 'String',
        required: true
      }
    },
    setGroupMemberCustomField: {
      groupID: {
        type: 'String',
        required: true
      },
      userID: {
        type: 'String'
      },
      memberCustomField: {
        type: 'Array',
        required: true
      }
    },
    deleteGroupMember: {
      groupID: {
        type: 'String',
        required: true
      }
    },
    createTextMessage: {
      to: {
        type: 'String',
        required: true
      },
      conversationType: {
        type: 'String',
        required: true
      },
      payload: {
        type: 'Object',
        required: true,
        validator: function validator(param) {
          if (!isString(param.text)) {
            console.warn('createTextMessage payload.text 类型必须为字符串。请参考 https://imsdk-1252463788.file.myqcloud.com/IM_DOC/Web/SDK.html#createTextMessage');
            return false;
          }

          if (param.text.length === 0) {
            console.warn('createTextMessage 消息内容不能为空。请参考 https://imsdk-1252463788.file.myqcloud.com/IM_DOC/Web/SDK.html#createTextMessage');
            return false;
          }

          return true;
        }
      }
    },
    createCustomMessage: {
      to: {
        type: 'String',
        required: true
      },
      conversationType: {
        type: 'String',
        required: true
      },
      payload: {
        type: 'Object',
        required: true
      }
    },
    createImageMessage: {
      to: {
        type: 'String',
        required: true
      },
      conversationType: {
        type: 'String',
        required: true
      },
      payload: {
        type: 'Object',
        required: true,
        validator: function validator(param) {
          if (isUndefined(param.file)) {
            console.warn('createImageMessage payload.file 不能为 undefined。请参考 https://imsdk-1252463788.file.myqcloud.com/IM_DOC/Web/SDK.html#createImageMessage');
            return false;
          }

          if (IN_BROWSER) {
            if (!(param.file instanceof HTMLInputElement) && !isFile(param.file)) {
              console.warn('createImageMessage payload.file 的类型必须是 HTMLInputElement 或 File。请参考 https://imsdk-1252463788.file.myqcloud.com/IM_DOC/Web/SDK.html#createImageMessage');
              return false;
            }

            if (param.file instanceof HTMLInputElement && param.file.files.length === 0) {
              console.warn('createImageMessage 您没有选择文件，无法发送。请参考 https://imsdk-1252463788.file.myqcloud.com/IM_DOC/Web/SDK.html#createImageMessage');
              return false;
            }
          }

          return true;
        },
        onProgress: {
          type: 'Function',
          required: false,
          validator: function validator(param) {
            if (isUndefined(param)) {
              console.warn('createImageMessage 没有 onProgress 回调，您将无法获取图片上传进度。请参考 https://imsdk-1252463788.file.myqcloud.com/IM_DOC/Web/SDK.html#createImageMessage');
            }

            return true;
          }
        }
      }
    },
    createAudioMessage: {
      to: {
        type: 'String',
        required: true
      },
      conversationType: {
        type: 'String',
        required: true
      },
      payload: {
        type: 'Object',
        required: true
      },
      onProgress: {
        type: 'Function',
        required: false,
        validator: function validator(param) {
          if (isUndefined(param)) {
            console.warn('createAudioMessage 没有 onProgress 回调，您将无法获取音频上传进度。请参考 https://imsdk-1252463788.file.myqcloud.com/IM_DOC/Web/SDK.html#createAudioMessage');
          }

          return true;
        }
      }
    },
    createVideoMessage: {
      to: {
        type: 'String',
        required: true
      },
      conversationType: {
        type: 'String',
        required: true
      },
      payload: {
        type: 'Object',
        required: true,
        validator: function validator(param) {
          if (isUndefined(param.file)) {
            console.warn('createVideoMessage payload.file 不能为 undefined。请参考 https://imsdk-1252463788.file.myqcloud.com/IM_DOC/Web/SDK.html#createVideoMessage');
            return false;
          }

          if (IN_BROWSER) {
            if (!(param.file instanceof HTMLInputElement) && !isFile(param.file)) {
              console.warn('createVideoMessage payload.file 的类型必须是 HTMLInputElement 或 File。请参考 https://imsdk-1252463788.file.myqcloud.com/IM_DOC/Web/SDK.html#createVideoMessage');
              return false;
            }

            if (param.file instanceof HTMLInputElement && param.file.files.length === 0) {
              console.warn('createVideoMessage 您没有选择文件，无法发送。请参考 https://imsdk-1252463788.file.myqcloud.com/IM_DOC/Web/SDK.html#createVideoMessage');
              return false;
            }
          }

          return true;
        }
      },
      onProgress: {
        type: 'Function',
        required: false,
        validator: function validator(param) {
          if (isUndefined(param)) {
            console.warn('createVideoMessage 没有 onProgress 回调，您将无法获取视频上传进度。请参考 https://imsdk-1252463788.file.myqcloud.com/IM_DOC/Web/SDK.html#createVideoMessage');
          }

          return true;
        }
      }
    },
    createFaceMessage: {
      to: {
        type: 'String',
        required: true
      },
      conversationType: {
        type: 'String',
        required: true
      },
      payload: {
        type: 'Object',
        required: true,
        validator: function validator(param) {
          if (!isPlainObject(param)) {
            return false;
          }

          if (!isNumber(param.index)) {
            console.warn('createFaceMessage payload.index 类型必须为 Number！');
            return false;
          }

          if (!isString(param.data)) {
            console.warn('createFaceMessage payload.data 类型必须为 String！');
            return false;
          }

          return true;
        }
      }
    },
    createFileMessage: {
      to: {
        type: 'String',
        required: true
      },
      conversationType: {
        type: 'String',
        required: true
      },
      payload: {
        type: 'Object',
        required: true,
        validator: function validator(param) {
          if (isUndefined(param.file)) {
            console.warn('createFileMessage payload.file 不能为 undefined。请参考 https://imsdk-1252463788.file.myqcloud.com/IM_DOC/Web/SDK.html#createFileMessage');
            return false;
          }

          if (IN_BROWSER) {
            if (!(param.file instanceof HTMLInputElement) && !isFile(param.file)) {
              console.warn('createFileMessage payload.file 的类型必须是 HTMLInputElement 或 File。请参考 https://imsdk-1252463788.file.myqcloud.com/IM_DOC/Web/SDK.html#createFileMessage');
              return false;
            }

            if (param.file instanceof HTMLInputElement && param.file.files.length === 0) {
              console.warn('createFileMessage 您没有选择文件，无法发送。请参考 https://imsdk-1252463788.file.myqcloud.com/IM_DOC/Web/SDK.html#createFileMessage');
              return false;
            }
          }

          return true;
        }
      },
      onProgress: {
        type: 'Function',
        required: false,
        validator: function validator(param) {
          if (isUndefined(param)) {
            console.warn('createFileMessage 没有 onProgress 回调，您将无法获取文件上传进度。请参考 https://imsdk-1252463788.file.myqcloud.com/IM_DOC/Web/SDK.html#createFileMessage');
          }

          return true;
        }
      }
    },
    revokeMessage: [{
      name: 'message',
      type: 'Object',
      required: true,
      validator: function validator(param) {
        if (!(param instanceof Message)) {
          console.warn('revokeMessage 参数 message 必须为 Message(https://imsdk-1252463788.file.myqcloud.com/IM_DOC/Web/Message.html) 实例。');
          return false;
        }

        if (param.conversationType === TYPES.CONV_SYSTEM) {
          console.warn('revokeMessage 不能撤回系统会话消息，只能撤回单聊消息或群消息');
          return false;
        }

        if (param.isRevoked === true) {
          console.warn('revokeMessage 消息已经被撤回，请勿重复操作');
          return false;
        }

        return true;
      }
    }],
    // 资料
    getUserProfile: {
      userIDList: {
        type: 'Array',
        validator: function validator(param) {
          if (!isArray(param)) {
            console.warn('getUserProfile userIDList 必须为数组，请参考 https://imsdk-1252463788.file.myqcloud.com/IM_DOC/Web/SDK.html#getUserProfile');
            return false;
          } // 传入空数组不会造成错误，但也得不到什么信息，加个告警日志


          if (param.length === 0) {
            console.warn('getUserProfile userIDList 不能为空数组，请参考 https://imsdk-1252463788.file.myqcloud.com/IM_DOC/Web/SDK.html#getUserProfile');
          }

          return true;
        }
      }
    },
    updateMyProfile: {
      profileCustomField: {
        type: 'Array',
        validator: function validator(param) {
          if (isUndefined(param)) {
            // profileCustomField 选填
            return true;
          }

          if (!isArray(param)) {
            console.warn('updateMyProfile profileCustomField 必须为数组，请参考 https://imsdk-1252463788.file.myqcloud.com/IM_DOC/Web/SDK.html#updateMyProfile');
            return false;
          }

          return true;
        }
      }
    }
  };

  /**
   * API 映射表
   * 示例：{
   *  sdk.js的方法名 : 暴露的API名
   * }
   */
  var APIList = {
    // Global
    login: 'login',
    logout: 'logout',
    on: 'on',
    once: 'once',
    off: 'off',
    setLogLevel: 'setLogLevel',
    downloadLog: 'downloadLog',
    registerPlugin: 'registerPlugin',
    destroy: 'destroy',
    // Message
    createTextMessage: 'createTextMessage',
    createImageMessage: 'createImageMessage',
    createAudioMessage: 'createAudioMessage',
    createVideoMessage: 'createVideoMessage',
    createCustomMessage: 'createCustomMessage',
    createFaceMessage: 'createFaceMessage',
    createFileMessage: 'createFileMessage',
    sendMessage: 'sendMessage',
    resendMessage: 'resendMessage',
    getMessageList: 'getMessageList',
    setMessageRead: 'setMessageRead',
    revokeMessage: 'revokeMessage',
    // Conversation
    getConversationList: 'getConversationList',
    getConversationProfile: 'getConversationProfile',
    deleteConversation: 'deleteConversation',
    // Group
    getGroupList: 'getGroupList',
    getGroupProfile: 'getGroupProfile',
    createGroup: 'createGroup',
    joinGroup: 'joinGroup',
    updateGroupProfile: 'updateGroupProfile',
    quitGroup: 'quitGroup',
    dismissGroup: 'dismissGroup',
    changeGroupOwner: 'changeGroupOwner',
    searchGroupByID: 'searchGroupByID',
    setMessageRemindType: 'setMessageRemindType',
    handleGroupApplication: 'handleGroupApplication',
    // Group Member
    getGroupMemberProfile: 'getGroupMemberProfile',
    getGroupMemberList: 'getGroupMemberList',
    addGroupMember: 'addGroupMember',
    deleteGroupMember: 'deleteGroupMember',
    setGroupMemberNameCard: 'setGroupMemberNameCard',
    setGroupMemberMuteTime: 'setGroupMemberMuteTime',
    setGroupMemberRole: 'setGroupMemberRole',
    setGroupMemberCustomField: 'setGroupMemberCustomField',
    // Profile
    getMyProfile: 'getMyProfile',
    getUserProfile: 'getUserProfile',
    updateMyProfile: 'updateMyProfile',
    // Contacts
    getBlacklist: 'getBlacklist',
    addToBlacklist: 'addToBlacklist',
    removeFromBlacklist: 'removeFromBlacklist',
    getFriendList: 'getFriendList' // 'sdk.js的方法名': '暴露的API名'

  };

  /**
   * 其他配置常量
   */
  // sdk版本
  var SDK = {
    VERSION: '1.7.3',
    // sdk版本号，暂定，此参数影响到后端接口返回的数据
    APPID: '537048168',
    // web im sdk 版本 APPID
    PLATFORM: '10' // 发送请求时判断其是来自web端的请求

  }; // 环境配置

  var PROTOCOL_TYPE = {
    PROTOBUF: 'protobuf',
    JSON: 'json'
  }; // 接口地址配置

  var SERVER = {
    HOST: {
      /**
       * @description 当前使用的接口类型，取值范围：SANDBOX: 1, TEST: 2，PRODUCTION: 3，详情请看`ACCESS_LAYER_TYPES`
       */
      TYPE: 3,

      /**
       * @description 接口类型配置,与ENV的配置相似，但这里使用了整型数据
       */
      ACCESS_LAYER_TYPES: {
        SANDBOX: 1,
        // 使用沙箱服务器,判断该值时，为服务端返回，只能取1
        TEST: 2,
        // 使用测试服务器
        PRODUCTION: 3 // 使用正式环境

      },

      /**
       * @description 当前生效的接口地址的配置,推荐从这里取得服务器配置
       **/
      CURRENT: {
        COMMON: 'https://webim.tim.qq.com',
        PIC: 'https://pic.tim.qq.com',
        COS: 'https://yun.tim.qq.com'
      },

      /**
       * @description 正式环境
       *  */
      PRODUCTION: {
        COMMON: 'https://webim.tim.qq.com',
        PIC: 'https://pic.tim.qq.com',
        COS: 'https://yun.tim.qq.com'
      },

      /**
       * @description 沙箱环境
       *  */
      SANDBOX: {
        COMMON: 'https://events.tim.qq.com',
        PIC: 'https://pic.tim.qq.com',
        COS: 'https://yun.tim.qq.com'
      },

      /**
       * @description 测试环境
       *  */
      TEST: {
        COMMON: 'https://test.tim.qq.com',
        PIC: 'https://pic.tim.qq.com',
        COS: 'https://yun.tim.qq.com'
      },

      /**
       *用来设置当前接口的环境
       *
       * @param {Number} accessLayerType - 此参数决定了使用的服务器类型，可以查阅`SERVER.HOST.ACCESS_LAYER_TYPES`
       *  1: 沙箱环境；
       *  2: 测试环境；
       *  3: 正式环境；
       * @caution 此函数也会同时改变`ENV.CURRENT`的取值
       */
      setCurrent: function setCurrent() {
        var accessLayerType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 3;

        switch (accessLayerType) {
          case this.ACCESS_LAYER_TYPES.SANDBOX:
            this.CURRENT = this.SANDBOX;
            this.TYPE = this.ACCESS_LAYER_TYPES.SANDBOX;
            break;

          case this.ACCESS_LAYER_TYPES.TEST:
            this.CURRENT = this.TEST;
            this.TYPE = this.ACCESS_LAYER_TYPES.TEST;
            break;

          default:
            this.CURRENT = this.PRODUCTION;
            this.TYPE = this.ACCESS_LAYER_TYPES.PRODUCTION;
            break;
        }
      }
    },
    // 服务名称
    NAME: {
      OPEN_IM: 'openim',
      // 私聊（拉取未读c2c消息，长轮询，c2c消息已读上报等）服务名
      GROUP: 'group_open_http_svc',
      // 群组管理（拉取群消息，创建群，群成员管理，群消息已读上报等）服务名
      FRIEND: 'sns',
      // 关系链管理（好友管理，黑名单管理等）服务名
      PROFILE: 'profile',
      // 资料管理（查询，设置个人资料等）服务名
      RECENT_CONTACT: 'recentcontact',
      // 最近联系人服务名
      PIC: 'openpic',
      // 图片（或文件）服务名
      BIG_GROUP_NO_AUTH: 'group_open_http_noauth_svc',
      // 直播大群 群组管理（申请加大群）服务名
      BIG_GROUP_LONG_POLLING_NO_AUTH: 'group_open_long_polling_http_noauth_svc',
      // 直播大群 长轮询（拉取消息等）服务名
      IM_OPEN_STAT: 'imopenstat',
      // 质量上报，统计接口错误率
      WEB_IM: 'webim',
      IM_COS_SIGN: 'im_cos_sign_svr'
    },

    /**
     * @uses 命令字，待补全
     **/
    CMD: {
      ACCESS_LAYER: 'accesslayer',
      // 获取沙箱
      LOGIN: 'login',
      // 登录
      LOGOUT_LONG_POLL: 'longpollinglogout',
      // 登出
      LOGOUT_ALL: 'logout',
      //
      PORTRAIT_GET: 'portrait_get_all',
      // 获取用户资料，包括标配资料和自定义资料
      PORTRAIT_SET: 'portrait_set',
      // 设置个人资料，包括标配资料和自定义资料
      GET_LONG_POLL_ID: 'getlongpollingid',
      LONG_POLL: 'longpolling',
      // 轮询
      AVCHATROOM_LONG_POLL: 'get_msg',
      // AVChatRoom 长轮询拉消息
      FRIEND_ADD: 'friend_add',
      // 加好友
      FRIEND_GET_ALL: 'friend_get_all',
      // 获取所有好友
      FRIEND_DELETE: 'friend_delete',
      // 删除好友
      RESPONSE_PENDENCY: 'friend_response',
      // 响应好友申请
      GET_PENDENCY: 'pendency_get',
      // 获取未决的好友申请列表
      DELETE_PENDENCY: 'pendency_delete',
      // 删除好友申请列表
      GET_GROUP_PENDENCY: 'get_pendency',
      // 获取加群申请列表
      GET_BLACKLIST: 'black_list_get',
      // 获取黑名单列表
      ADD_BLACKLIST: 'black_list_add',
      // 添加好友进黑名单
      DELETE_BLACKLIST: 'black_list_delete',
      // 将好友移出黑名单
      CREATE_GROUP: 'create_group',
      // 创建群组
      GET_JOINED_GROUPS: 'get_joined_group_list',
      // 获取用户加入的群组
      SEND_MESSAGE: 'sendmsg',
      // 发送私聊消息
      REVOKE_C2C_MESSAGE: 'msgwithdraw',
      // 撤回私聊消息
      SEND_GROUP_MESSAGE: 'send_group_msg',
      // 发送群消息
      REVOKE_GROUP_MESSAGE: 'group_msg_recall',
      // 撤回群聊消息
      GET_GROUP_INFO: 'get_group_info',
      // 获取群组详细信息
      GET_GROUP_MEMBER_INFO: 'get_specified_group_member_info',
      // 获取群成员资料
      GET_GROUP_MEMBER_LIST: 'get_group_member_info',
      // 获取群组成员信息列表（分页）
      QUIT_GROUP: 'quit_group',
      // 退出群组
      CHANGE_GROUP_OWNER: 'change_group_owner',
      // 转让群组
      DESTROY_GROUP: 'destroy_group',
      // 解散群组
      ADD_GROUP_MEMBER: 'add_group_member',
      // 添加群成员
      DELETE_GROUP_MEMBER: 'delete_group_member',
      // 删除群成员
      SEARCH_GROUP_BY_ID: 'get_group_public_info',
      // 搜索群组（ID）
      APPLY_JOIN_GROUP: 'apply_join_group',
      // 申请加群
      HANDLE_APPLY_JOIN_GROUP: 'handle_apply_join_group',
      // 处理加群申请
      MODIFY_GROUP_INFO: 'modify_group_base_info',
      // 修改群资料
      MODIFY_GROUP_MEMBER_INFO: 'modify_group_member_info',
      // 修改群成员资料
      DELETE_GROUP_SYSTEM_MESSAGE: 'deletemsg',
      // 修改群成员资料
      GET_CONVERSATION_LIST: 'get',
      // 获取会话列表
      PAGING_GET_CONVERSATION_LIST: 'page_get',
      // 分页获取会话列表
      DELETE_CONVERSATION: 'delete',
      // 删除会话
      GET_MESSAGES: 'getmsg',
      // 获取未读消息
      GET_C2C_ROAM_MESSAGES: 'getroammsg',
      // 获取C2C漫游消息
      GET_GROUP_ROAM_MESSAGES: 'group_msg_get',
      // 获取C2C漫游消息
      SET_C2C_MESSAGE_READ: 'msgreaded',
      SET_GROUP_MESSAGE_READ: 'msg_read_report',
      FILE_READ_AND_WRITE_AUTHKEY: 'authkey',
      FILE_UPLOAD: 'pic_up',
      COS_SIGN: 'cos',
      TIM_WEB_REPORT: 'tim_web_report',
      BIG_DATA_HALLWAY_AUTH_KEY: 'authkey'
    },
    CHANNEL: {
      SOCKET: 1,
      // - 使用socket请求
      XHR: 2,
      // - 使用XHR请求
      AUTO: 0 // - 由ConnectionController决定用什么方式完成请求

    },
    // 不同服务对应的版本号
    NAME_VERSION: {
      openim: 'v4',
      group_open_http_svc: 'v4',
      sns: 'v4',
      profile: 'v4',
      recentcontact: 'v4',
      openpic: 'v4',
      group_open_http_noauth_svc: 'v1',
      group_open_long_polling_http_noauth_svc: 'v1',
      imopenstat: 'v4',
      im_cos_sign_svr: 'v4',
      webim: 'v4'
    }
  }; // 注意！不允许在这里切换环境，使用代理切换到测试环境

  SERVER.HOST.setCurrent(SERVER.HOST.ACCESS_LAYER_TYPES.PRODUCTION);

  /**
   * 场景：后端CGI参数命名大多数为大驼峰形式，但也有部分是To_Account这种形式，或许也有其他形式。
   * 用途：该对象用于/utils/convertor中的converRequestParam方法。该方法默认将小驼峰参数转成大驼峰，需要自定义的在该对象中定义。
   * 说明：在map中的key为需要自定义的参数key值，value为自定义转换的value值
   * 注意：该对象为全局公用的keyMaps，若出现接口与该keyMaps冲突，请在对应接口配置文件加上配置。参考：const/packageConfig/friend.js 下的query配置
   * @example
   * keyMaps:{
   *  request: {
   *    toAccount: 'to_Account' //该配置会覆盖keyMaps中的配置
   *  }
   * }
   */
  var keyMaps = {
    request: {
      toAccount: 'To_Account',
      fromAccount: 'From_Account',
      to: 'To_Account',
      from: 'From_Account',
      groupID: 'GroupId',
      avatar: 'FaceUrl'
    },
    response: {
      GroupId: 'groupID',
      Member_Account: 'userID',
      MsgList: 'messageList',
      SyncFlag: 'syncFlag',
      To_Account: 'to',
      From_Account: 'from',
      MsgSeq: 'sequence',
      MsgRandom: 'random',
      MsgTimeStamp: 'time',
      MsgContent: 'content',
      MsgBody: 'elements',
      // 群消息撤回
      GroupWithdrawInfoArray: 'revokedInfos',
      // C2C消息撤回
      WithdrawC2cMsgNotify: 'c2cMessageRevokedNotify',
      C2cWithdrawInfoArray: 'revokedInfos',
      MsgRand: 'random',
      MsgType: 'type',
      MsgShow: 'messageShow',
      NextMsgSeq: 'nextMessageSeq',
      FaceUrl: 'avatar',
      ProfileDataMod: 'profileModify',
      Profile_Account: 'userID',
      ValueBytes: 'value',
      ValueNum: 'value',
      NoticeSeq: 'noticeSequence',
      NotifySeq: 'notifySequence',
      MsgFrom_AccountExtraInfo: 'messageFromAccountExtraInformation',
      // event4 & event5
      Operator_Account: 'operatorID',
      OpType: 'operationType',
      ReportType: 'operationType',
      UserId: 'userID',
      User_Account: 'userID',
      List_Account: 'userIDList',
      MsgOperatorMemberExtraInfo: 'operatorInfo',
      MsgMemberExtraInfo: 'memberInfoList',
      ImageUrl: 'avatar',
      NickName: 'nick',
      MsgGroupNewInfo: 'newGroupProfile',
      MsgAppDefinedData: 'groupCustomField',
      // 存放群自定义字段 key-value
      Owner_Account: 'ownerID',
      GroupName: 'name',
      GroupFaceUrl: 'avatar',
      GroupIntroduction: 'introduction',
      GroupNotification: 'notification',
      GroupApplyJoinOption: 'joinOption',
      MsgKey: 'messageKey',
      GroupInfo: 'groupProfile',
      ShutupTime: 'muteTime',
      // CUSTOM
      Desc: 'description',
      Ext: 'extension'
    },
    ignoreKeyWord: ['C2C', 'ID', 'USP'] // 这些关键字是要在 请求参数转换器的 非法参数检测中忽略的。例如：不会检查 groupID，userID 的合法性

  };

  // 内部事件
  var TIM_INNER_EVENT = {
    // context
    CONTEXT_UPDATED: '_contextWasUpdated',
    CONTEXT_RESET: '_contextWasReset',
    CONTEXT_A2KEY_AND_TINYID_UPDATED: '_a2KeyAndTinyIDUpdated',
    SPECIFIED_CONFIG_UPDATED: '_specifiedConfigUpdated',
    // 消息同步
    SYNC_MESSAGE_C2C_PROCESSING: '_noticeIsSynchronizing',
    SYNC_MESSAGE_C2C_FINISHED: '_noticeIsSynchronized',
    // 消息相关事件
    MESSAGE_SENT: '_messageSent',
    MESSAGE_SYNC_PROCESSING: '_syncMessageProcessing',
    // 同步未读正在进行
    MESSAGE_SYNC_FINISHED: '_syncMessageFinished',
    // 同步未读完成
    MESSAGE_C2C_INSTANT_RECEIVED: '_receiveInstantMessage',
    // 收到新的C2C即时消息
    MESSAGE_GROUP_INSTANT_RECEIVED: '_receiveGroupInstantMessage',
    // 收到新的群即时消息
    MESSAGE_GROUP_SYSTEM_NOTICE_RECEIVED: '_receveGroupSystemNotice',
    // 收到新的群系统通知
    MESSAGE_REVOKED: '_messageRevoked',
    // 通知相关
    NOTICE_LONGPOLL_GET_ID_FAILED: '_longPollGetIDFailed',
    // 获取 longpollingID 失败
    NOTICE_LONGPOLL_REQUEST_FAILED: '_longPollRequestFailed',
    // 表示 longpoll 的 请求失败
    NOTICE_LONGPOLL_RESPONSE_OK: '_longPollResponseOK',
    // 表示 longpoll 的 request 已经到达，并收到了服务端的正常响应
    // NOTICE_LONGPOLL_RESPONSE_ERROR: '_longPollResponseError', // 表示 longpoll 的 request 已经到达，并收到了服务端的响应，但响应内容有异常
    NOTICE_LONGPOLL_FAST_START: '_longPollFastStart',
    // 快启动，走同步未读，启动长轮询
    NOTICE_LONGPOLL_SLOW_START: '_longPollSlowStart',
    // 慢启动，走重新登录流程，启动长轮询
    NOTICE_LONGPOLL_KICKED_OUT: '_longPollKickedOut',
    NOTICE_LONGPOLL_MUTIPLE_DEVICE_KICKED_OUT: '_longPollMitipuleDeviceKickedOut',
    // mutiple
    NOTICE_LONGPOLL_NEW_C2C_NOTICE: '_longPollGetNewC2CNotice',
    NOTICE_LONGPOLL_NEW_GROUP_MESSAGES: '_longPollGetNewGroupMessages',
    NOTICE_LONGPOLL_NEW_GROUP_TIPS: '_longPollGetNewGroupTips',
    NOTICE_LONGPOLL_NEW_GROUP_NOTICE: '_longPollGetNewGroupNotice',
    NOTICE_LONGPOLL_NEW_FRIEND_MESSAGES: '_longPollGetNewFriendMessages',
    NOTICE_LONGPOLL_PROFILE_MODIFIED: '_longPollProfileModified',
    NOTICE_LONGPOLL_RECEIVE_SYSTEM_ORDERS: '_longPollNoticeReceiveSystemOrders',
    // 接收到系统指令
    NOTICE_LONGPOLL_GROUP_MESSAGE_REVOKED: ' _longpollGroupMessageRevoked',
    // 群消息撤回的通知
    NOTICE_LONGPOLL_C2C_MESSAGE_REVOKED: '_longpollC2CMessageRevoked',
    // c2c消息撤回的通知
    // avchatroom longpolling 相关
    AV_LONGPOLL_REQUEST_FAILED: '_avlongPollRequestFailed',
    // 表示 avchatroom longpoll 的 请求失败
    AV_LONGPOLL_RESPONSE_OK: '_avlongPollResponseOK',
    // // 表示 avchatroom longpoll 的 request 已经到达，并收到了服务端的正常响应
    // group操作相关
    GROUP_LIST_UPDATED: '_onGroupListUpdated',
    // 登入、登出事件
    SIGN_LOGIN_SUCCESS: '_loginSuccess',
    // 登录成功
    SIGN_LOGOUT_EXECUTING: '_signLogoutExcuting',
    // 登出正在执行，还未取得响应 executing
    SIGN_LOGOUT_SUCCESS: '_logoutSuccess',
    SIGN_A2KEY_EXPIRED: '_a2keyExpired',
    // 发现异常
    ERROR_DETECTED: '_errorHasBeenDetected',
    // 会话相关
    CONVERSATION_LIST_UPDATED: '_onConversationListUpdated',
    CONVERSATION_LIST_PROFILE_UPDATED: '_onConversationListProfileUpdated',
    CONVERSATION_DELETED: '_conversationDeleted',
    // 资料相关
    PROFILE_UPDATED: 'onProfileUpdated',
    // AVChatRoom相关
    AVCHATROOM_JOIN_SUCCESS: 'joinAVChatRoomSuccess',
    // 表示匿名加入avchatroom成功
    AVCHATROOM_JOIN_SUCCESS_NO_AUTH: 'joinAVChatRoomSuccessNoAuth',
    // SDK内部系统相关
    SDK_READY: '_sdkStateReady'
  };

  function camelCase(input, options) {
    if (!(typeof input === 'string' || Array.isArray(input))) {
      throw new TypeError('Expected the input to be `string | string[]`');
    }

    options = Object.assign({
      pascalCase: false
    }, options);

    var postProcess = function postProcess(x) {
      return options.pascalCase ? x.charAt(0).toUpperCase() + x.slice(1) : x;
    };

    if (Array.isArray(input)) {
      input = input.map(function (x) {
        return x.trim();
      }).filter(function (x) {
        return x.length;
      }).join('-');
    } else {
      input = input.trim();
    }

    if (input.length === 0) {
      return '';
    }

    if (input.length === 1) {
      return options.pascalCase ? input.toUpperCase() : input.toLowerCase();
    }

    var hasUpperCase = input !== input.toLowerCase();

    if (hasUpperCase) {
      input = preserveCamelCase(input);
    }

    input = input.replace(/^[_.\- ]+/, '').toLowerCase().replace(/[_.\- ]+(\w|$)/g, function (_, p1) {
      return p1.toUpperCase();
    }).replace(/\d+(\w|$)/g, function (m) {
      return m.toUpperCase();
    });
    return postProcess(input);
  }

  var preserveCamelCase = function preserveCamelCase(string) {
    var isLastCharLower = false;
    var isLastCharUpper = false;
    var isLastLastCharUpper = false;

    for (var i = 0; i < string.length; i++) {
      var character = string[i];

      if (isLastCharLower && /[a-zA-Z]/.test(character) && character.toUpperCase() === character) {
        string = string.slice(0, i) + '-' + string.slice(i);
        isLastCharLower = false;
        isLastLastCharUpper = isLastCharUpper;
        isLastCharUpper = true;
        i++;
      } else if (isLastCharUpper && isLastLastCharUpper && /[a-zA-Z]/.test(character) && character.toLowerCase() === character) {
        string = string.slice(0, i - 1) + '-' + string.slice(i - 1);
        isLastLastCharUpper = isLastCharUpper;
        isLastCharUpper = false;
        isLastCharLower = true;
      } else {
        isLastCharLower = character.toLowerCase() === character && character.toUpperCase() !== character;
        isLastLastCharUpper = isLastCharUpper;
        isLastCharUpper = character.toUpperCase() === character && character.toLowerCase() !== character;
      }
    }

    return string;
  };

  /**
   * 背景：后端CGI接口响应参数命名风格不统一，比如有大驼峰形式，也有下划线形式。
   * 用途：将小驼峰形式的参数转成大驼峰（默认），也可传入map参数自定义转换参数字段。
   * 注意：该转换器只转换key，不会改变value值。
   * @param {Object|Array} params - 待转换的参数
   * @param {Object} [map=keyMaps] - 参数的map表，默认值为定义在src/const/keyMaps/index.js中的keyMaps对象。
   * @param {TIM} tim - TIM 实例
   * @returns {object}
   * @example
   * const params = { "fromAccount":"id", "addFriendItem":[{ "toAccount":"id1", "addSourse":"AddSource_Type_XXXXXXXX" }]}
   * const map = {"fromAccount":"From_Account", "toAccount":"To_Account"}
   * // 传入map自定义参数转换格式
   * convertRequestParam(params, map)
   *
   * //返回
   * {
   *    "From_Account":"id",
   *    "AddFriendItem":[{"To_Account":"id1", "AddSource":"AddSource_Type_XXXXXXXX"}]
   * }
   */

  function convertRequestParam(params, map, tim) {
    var invalidParams = []; // 不合法的参数列表

    var recursiveLimit = 10; // 递归层级限制

    var recursiveCount = 0; // 当前递归层数

    map = _objectSpread2({}, keyMaps.request, {}, map);

    var result = function convert(params, map) {
      recursiveCount++;

      if (recursiveCount > recursiveLimit) {
        // 一层递归结束，返回上层
        recursiveCount--;
        return params;
      }
      /**
       * 参数值是数组
       * 注意：数组递归也是计算递归层数的
       * 若数组由Object组成，则递归每个value。否则不做处理。
       */


      if (isArray(params)) {
        var _result = params.map(function (param) {
          var needRecursive = isObject(param); // 是否需要递归

          return needRecursive ? convert(param, map) : param;
        }); // 一层递归结束，返回上层


        recursiveCount--;
        return _result;
      } // 参数值是对象


      if (isObject(params)) {
        // 先转换key。在转换key时，判断map中是否有key，如有则用对应的值，否则转成大驼峰形式。
        var _result2 = filterMapKeys(params, function (value, key) {
          // 过滤下划线和 $ 开头的key
          if (!isValidRequestKey(key)) {
            return false;
          }

          if (!isCamelCase(key)) {
            var isInvalidKey = true;

            for (var i = 0; i < keyMaps.ignoreKeyWord.length; i++) {
              if (key.includes(keyMaps.ignoreKeyWord[i])) {
                isInvalidKey = false;
                break;
              }
            }

            if (isInvalidKey) invalidParams.push(key);
          }

          return isUndefined(map[key]) ? toUpperCamelCase(key) : map[key];
        }); // 遍历value，遇到数组或者对象则递归，否则返回原value。


        _result2 = mapValues(_result2, function (value, key) {
          var needRecursive = isArray(value) || isObject(value); // 是否需要递归

          return needRecursive ? convert(value, map) : value;
        }); // 一层递归结束，返回上层

        recursiveCount--;
        return _result2;
      }
    }(params, map);

    if (invalidParams.length > 0) {
      tim.innerEmitter.emit(TIM_INNER_EVENT.ERROR_DETECTED, {
        code: ERROR_CODE.CONVERTOR_IRREGULAR_PARAMS,
        message: ERROR_MESSAGE.CONVERTOR_IRREGULAR_PARAMS
      });
    }

    return result;
  }
  /**
   * 场景：后端CGI接口响应参数命名风格不统一，比如有大驼峰形式，也有下划线形式。
   * 用途：将响应参数转换成小驼峰形式。
   * 注意：该转换器只转换key，不会改变value值。
   * @param {Object|Array} params - 待转换的参数
   * @param {Object} map - 响应参数keyMaps表
   * @returns {Object|Array} 转换后的参数
   * @example
   * const params = { To_Account: 'User1', ErrorCode: 0, }
   * convertResponseBody(params)
   * //返回
   * { 'toAccount': 'User1', 'errorCode': 0}
   *
   */

  function convertResponseBody(params, map) {
    map = _objectSpread2({}, keyMaps.response, {}, map);
    /**
     * 参数值是数组
     * 若数组由Object组成，则递归每个value。否则不做处理。
     */

    if (isArray(params)) {
      return params.map(function (param) {
        var needRecursive = isObject(param); // 是否需要递归

        return needRecursive ? convertResponseBody(param, map) : param;
      });
    }
    /**
     * 参数值是对象
     * 先遍历keys，把对象的key值转成小驼峰。
     * 然后遍历对象的value，若遇到数组或者对象的value，则递归，否则返回原value
     */


    if (isObject(params)) {
      var result = mapKeys(params, function (value, key) {
        return isUndefined(map[key]) ? camelCase(key) : map[key];
      });
      result = mapValues(result, function (value) {
        var needRecursive = isArray(value) || isObject(value); // 是否需要递归

        return needRecursive ? convertResponseBody(value, map) : value;
      });
      return result;
    }
  }
  /**
   * 字符串转大驼峰
   * @param {String} str - 需要转换的 字符串
   * @returns {string}
   */

  function toUpperCamelCase(str) {
    return str[0].toUpperCase() + camelCase(str).slice(1);
  }
  /**
   * 判断字符串是否是小驼峰
   *
   * @param {String} str - 参数字符串
   * @returns {boolean}
   */

  function isCamelCase(str) {
    return str === camelCase(str);
  }

  /**
   * 此类用于生成网络层传输用的“胶囊” capsule ，为什么要用”胶囊“一词， 因为 package 用了会报错，(T-T)
   */

  var TransportCapsule =
  /*#__PURE__*/
  function () {
    function TransportCapsule(packageOptions) {
      var _this = this;

      _classCallCheck(this, TransportCapsule);

      // url requestData method callback 是 ConnectionController.request 必需的
      this.url = '';
      this.requestData = null;
      this.method = packageOptions.method || 'POST';

      this.callback = function (response) {
        response = packageOptions.decode(response); // 把decode方法设置到回调中

        var result = convertResponseBody(response, _this._getResponseMap(packageOptions));
        return result;
      };

      this._initializeServerMap();

      this._initializeURL(packageOptions); // 打包request数据，会主调用包的encoder方法


      this._initializeRequestData(packageOptions);
    }

    _createClass(TransportCapsule, [{
      key: "_initializeServerMap",
      value: function _initializeServerMap() {
        this._serverMap = Object.create(null);
        var name = '';

        for (var p in SERVER.NAME) {
          if (!Object.prototype.hasOwnProperty.call(SERVER.NAME, p)) {
            continue;
          }

          name = SERVER.NAME[p];

          switch (name) {
            case SERVER.NAME.PIC:
              this._serverMap[name] = SERVER.HOST.CURRENT.PIC;
              break;

            case SERVER.NAME.IM_COS_SIGN:
              this._serverMap[name] = SERVER.HOST.CURRENT.COS;
              break;

            default:
              this._serverMap[name] = SERVER.HOST.CURRENT.COMMON;
          }
        }
      }
    }, {
      key: "_getHost",
      value: function _getHost(serverName) {
        if (typeof this._serverMap[serverName] !== 'undefined') {
          return this._serverMap[serverName];
        }

        throw new IMError({
          code: ERROR_CODE.NETWORK_UNDEFINED_SERVER_NAME,
          message: ERROR_MESSAGE.NETWORK_UNDEFINED_SERVER_NAME
        });
      }
      /**
       * 初始化URL，同时会配置好URL参数
       * @param {Object} packageOptions - packageConfig下对应接口的配置
       */

    }, {
      key: "_initializeURL",
      value: function _initializeURL(packageOptions) {
        var srvName = packageOptions.serverName;
        var cmd = packageOptions.cmd;

        var srvHost = this._getHost(srvName);

        var url = "".concat(srvHost, "/").concat(SERVER.NAME_VERSION[srvName], "/").concat(srvName, "/").concat(cmd);
        url += "?".concat(this._getQueryString(packageOptions.queryString));
        this.url = url;
      }
      /**
       * getUrl 目前用于轮询时，修改reqtime参数
       * @returns {string}
       */

    }, {
      key: "getUrl",
      value: function getUrl() {
        return this.url.replace(/&reqtime=(\d+)/, "&reqtime=".concat(Math.ceil(+new Date() / 1000)));
      }
      /**
       * 打包 requestData 这里会调用encode对requestData 进行编码。
       * @param {*} packageOptions - 参数配置
       */

    }, {
      key: "_initializeRequestData",
      value: function _initializeRequestData(packageOptions) {
        var data = {};
        var requestData = packageOptions.requestData;
        data = this._requestDataCleaner(requestData);
        this.requestData = packageOptions.encode(data);
      }
      /**
       *忽略掉带有以下特性的数据:
       * - 带“_” 前缀的 key
       * - 值为 null 的 key
       * - 在原型(__proto__)中的 key
       *
       * @param {object} data - 需要过滤的数据
       * @returns {object}
       * @memberof TransportCapsule
       */

    }, {
      key: "_requestDataCleaner",
      value: function _requestDataCleaner(data) {
        var result = Array.isArray(data) ? [] : Object.create(null);

        for (var key in data) {
          // 如果key 是 __proto__ 下的属性会返回 false，忽略掉
          if (!Object.prototype.hasOwnProperty.call(data, key)) {
            continue;
          } // 忽略掉不合法的 key


          if (!isValidRequestKey(key)) {
            continue;
          } // 忽略掉值为 null 的


          if (data[key] === null) {
            continue;
          }

          if (_typeof(data[key]) === 'object') {
            result[key] = this._requestDataCleaner.bind(this)(data[key]);
            continue;
          }

          result[key] = data[key];
        }

        return result;
      }
      /**
       * 拼装URL参数
       * @param {Object} queryStringObject - URL 参数对象
       * @returns {String}
       */

    }, {
      key: "_getQueryString",
      value: function _getQueryString(queryStringObject) {
        var tmp = [];

        for (var p in queryStringObject) {
          // 忽略 __proto__ 下的属性
          if (!Object.prototype.hasOwnProperty.call(queryStringObject, p)) {
            continue;
          }

          if (typeof queryStringObject[p] === 'function') {
            tmp.push("".concat(p, "=").concat(queryStringObject[p]()));
            continue;
          }

          tmp.push("".concat(p, "=").concat(queryStringObject[p]));
        }

        return tmp.join('&');
      }
    }, {
      key: "_getResponseMap",
      value: function _getResponseMap(packageOptions) {
        if (packageOptions.keyMaps) {
          if (packageOptions.keyMaps.response) {
            if (Object.keys(packageOptions.keyMaps.response).length > 0) {
              return packageOptions.keyMaps.response;
            }
          }
        }
      }
    }]);

    return TransportCapsule;
  }();

  /**
   * 为对象或实例添加ready状态管理机制
   * @author anderlu
   * @param {*} target
   * @example
   * import ReadyStatus from './base/mixin/ready-status.js';
   * // use in constructor
   * ReadyStatus(this);
   * // or
   * ReadyStatus.mixin(this);
   */
  function ReadyStatus(target) {
    this.mixin(target);
  }

  ReadyStatus.mixin = function (constructor) {
    var prototype = constructor.prototype || constructor;
    prototype._isReady = false;

    prototype.ready = function (fn) {
      var sync = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      if (!fn) {
        return;
      }

      if (!this._isReady) {
        this._readyQueue = this._readyQueue || [];

        this._readyQueue.push(fn);

        return;
      }

      if (sync) {
        fn.call(this);
      } else {
        // Call the function asynchronously by default for consistency
        setTimeout(fn, 1);
      }
    };

    prototype.triggerReady = function () {
      var _this = this;

      this._isReady = true; // Ensure ready is triggerd asynchronously

      setTimeout(function () {
        var readyQueue = _this._readyQueue; // Reset Ready Queue

        _this._readyQueue = [];

        if (readyQueue && readyQueue.length > 0) {
          readyQueue.forEach(function (fn) {
            // console.log(this);
            fn.call(this);
          }, _this);
        } // Allow for using event listeners also
        // emitter('ready');

      }, 1);
    };

    prototype.resetReady = function () {
      this._isReady = false;
      this._readyQueue = [];
    };

    prototype.isReady = function () {
      return this._isReady;
    };
  };

  var IMController =
  /*#__PURE__*/
  function () {
    function IMController(tim) {
      _classCallCheck(this, IMController);

      ReadyStatus.mixin(this);
      this.tim = tim;
    }
    /**
     * 判断当前 SDK 实例是否有账号登录了
     * @returns {Boolean}
     * @memberof IMController
     */


    _createClass(IMController, [{
      key: "isLoggedIn",
      value: function isLoggedIn() {
        return this.tim.context.login === TIM_STATUS.LOGIN.IS_LOGIN || !!this.tim.context.a2Key;
      }
      /**
       * 生成网络包配置，此包可以由 `ConnectionController.request()` 方法发送
       * @param {Object} options
       * @param {String} options.name - packageConfig 的名称
       * @param {String} options.action - packageConfig 的操作， 一个 packageConfig 有四个操作：create/query/update/delete
       * @param {Object} [options.param] - 接口的 POST 参数
       * @returns {object}
       */

    }, {
      key: "createTransportCapsule",
      value: function createTransportCapsule(options) {
        var packOptions = this.tim.packageConfig.get(options);

        if (!packOptions) {
          return null;
        }

        var capsule = new TransportCapsule(packOptions);
        return capsule;
      }
      /**
       * 发起网络请求
       * @param {Object} options
       * @param {String} options.name - packageConfig 的名称
       * @param {String} options.action - packageConfig 的操作， 一个 packageConfig 有四个操作：create/query/update/delete
       * @param {Object} [options.param] - 接口的 POST 参数
       * @returns {Promise}
       */

    }, {
      key: "request",
      value: function request(options) {
        var capsule = this.createTransportCapsule(options);

        if (!capsule) {
          logger.error('unknown transport capsule, please check!', options);
        }

        return this.tim.connectionController.request(capsule);
      }
      /**
       * 派发内部事件
       * @param {String} event
       * @param {*} eventData
       */

    }, {
      key: "emitInnerEvent",
      value: function emitInnerEvent(eventName, eventData) {
        this.tim.innerEmitter.emit(eventName, eventData);
      }
      /**
       * 派发外部事件
       * @param {String} eventName
       * @param {*} eventData
       */

    }, {
      key: "emitOuterEvent",
      value: function emitOuterEvent(eventName, eventData) {
        this.tim.outerEmitter.emit(eventName, eventData);
      }
      /**
       * 子类需要实现reset方法，否则一调用就会有警告
       */

    }, {
      key: "reset",
      value: function reset() {
        logger.warn(['method: IMController.reset() method must be implemented'].join());
      }
      /**
       * 登录、发消息失败等异步操作失败时调用此方法，发起网络探测。Promise状态始终是resolved。
       * @example
       * // bOnline true->已接入网络，false->未接入网络
       * // networkType 已接入的网络的类型，未接入网络时值为 NetworkType.NONE
       * this.probeNetwork().then(([bOnline, networkType]) => {
       *   console.log('probeNetwork info:', bOnline, networkType);
       * });
       * @returns {Promise}
       */

    }, {
      key: "probeNetwork",
      value: function probeNetwork() {
        return this.tim.netMonitor.probe();
      }
      /**
       * 获取网络类型
       * @returns {String}
       */

    }, {
      key: "getNetworkType",
      value: function getNetworkType() {
        return this.tim.netMonitor.getNetworkType();
      }
      /**
       * 获取平台信息
       * @returns {String}
       */

    }, {
      key: "getPlatform",
      value: function getPlatform() {
        var ret = 'web';

        if (IS_WECHAT) {
          ret = 'wechat';
        } else if (IN_WX_MINI_APP) {
          ret = 'wxmp';
        }

        return ret;
      }
    }]);

    return IMController;
  }();

  /**
   * @uses 用于登录上下文数据的存储
   */

  var Context =
  /*#__PURE__*/
  function () {
    function Context(data, innerEmitter) {
      _classCallCheck(this, Context);

      this.data = data;
      this._innerEmitter = innerEmitter; // 记录下原始值， 重置的时候比较方便

      this.defaultData = {};
      Object.assign(this.defaultData, data); // 深拷贝

      this.initGetterAndSetter();
    }
    /**
     * 配置 Context 的 setter 和 getter，目的是当 Context 的成员属性变更的时候，能发布更新事件。
     */


    _createClass(Context, [{
      key: "initGetterAndSetter",
      value: function initGetterAndSetter() {
        var self = this;

        var setValProxy = function setValProxy(key) {
          Object.defineProperty(self, key, {
            enumerable: true,
            configurable: true,
            get: function get() {
              return self.data[key];
            },
            set: function set(newValue) {
              // 发生改变才派发事件，避免死循环
              if (self.data[key] !== newValue) {
                self.data[key] = newValue;
                self.onChange.bind(self)(key, newValue);
              }
            }
          });
        };

        for (var key in self.data) {
          if (Object.prototype.hasOwnProperty.call(self.data, key)) {
            setValProxy(key);
          }
        }
      }
      /**
       * ctx成员属性已更新，发布`TIM_INNER_EVENT.CONTEXT_UPDATED`事件。
       * @param {String} key - 变更的key
       * @param {string | number} value - 新的值
       * @fires TIM_INNER_EVENT.CONTEXT_UPDATED - Context属性值变更事件。
       */

    }, {
      key: "onChange",
      value: function onChange(key, value) {
        this._innerEmitter.emit(TIM_INNER_EVENT.CONTEXT_UPDATED, {
          key: key,
          value: value
        });
      }
      /**
       * 重置
       */

    }, {
      key: "reset",
      value: function reset() {
        logger.log('Context.reset');

        for (var p in this.data) {
          if (Object.prototype.hasOwnProperty.call(this.data, p)) {
            this.data[p] = this.defaultData.hasOwnProperty(p) ? this.defaultData[p] : null;
          }
        }
      }
    }]);

    return Context;
  }();

  var ContextController =
  /*#__PURE__*/
  function (_IMController) {
    _inherits(ContextController, _IMController);

    function ContextController(tim) {
      var _this;

      _classCallCheck(this, ContextController);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(ContextController).call(this, tim));
      var loginInfo = _this.tim.loginInfo;
      _this._context = new Context({
        login: TIM_STATUS.LOGIN.IS_NOT_LOGIN,
        SDKAppID: loginInfo.SDKAppID,
        appIDAt3rd: null,
        accountType: loginInfo.accountType,
        identifier: loginInfo.identifier,
        tinyID: null,
        identifierNick: loginInfo.identifierNick,
        userSig: loginInfo.userSig,
        a2Key: null,
        contentType: 'json',
        apn: 1
      }, _this.tim.innerEmitter);

      _this._initListener();

      return _this;
    }

    _createClass(ContextController, [{
      key: "reset",
      value: function reset() {
        this._context.reset();

        this.emitInnerEvent(TIM_INNER_EVENT.CONTEXT_RESET);
      }
    }, {
      key: "_initListener",
      value: function _initListener() {
        this.tim.innerEmitter.on(TIM_INNER_EVENT.CONTEXT_UPDATED, this._onContextMemberChange, this);
        this.tim.innerEmitter.on(TIM_INNER_EVENT.SIGN_LOGIN_SUCCESS, this._updateA2KeyAndTinyID, this);
      }
    }, {
      key: "_updateA2KeyAndTinyID",
      value: function _updateA2KeyAndTinyID(_ref) {
        var _ref$data = _ref.data,
            a2Key = _ref$data.a2Key,
            tinyID = _ref$data.tinyID;
        this._context['a2Key'] = a2Key;
        this._context['tinyID'] = tinyID;
        this.emitInnerEvent(TIM_INNER_EVENT.CONTEXT_A2KEY_AND_TINYID_UPDATED);
        this.triggerReady();
      }
    }, {
      key: "getContext",
      value: function getContext() {
        return this._context;
      }
      /**
       * 当ctx变量内容发生变化时，会调用此方法
       * @private
       */

    }, {
      key: "_onContextMemberChange",
      value: function _onContextMemberChange(event) {
        var _event$data = event.data,
            key = _event$data.key,
            value = _event$data.value;

        if (key === 'tinyID') {
          // 如果 tinyID 为空了， 说明不在登录状态
          if (value.length <= 0) {
            this._context['login'] = TIM_STATUS.LOGIN.IS_NOT_LOGIN;
          } else {
            this._context['login'] = this._context['a2Key'] !== null ? TIM_STATUS.LOGIN.IS_LOGIN : TIM_STATUS.LOGIN.IS_NOT_LOGIN;
          }
        } else if (key === 'a2Key') {
          // 如果a2Key为空了， 说明不在登录状态
          if (value.length <= 0) {
            this._context['login'] = TIM_STATUS.LOGIN.IS_NOT_LOGIN;
          } else {
            this._context['login'] = this._context['a2Key'] !== null ? TIM_STATUS.LOGIN.IS_LOGIN : TIM_STATUS.LOGIN.IS_NOT_LOGIN;
          }
        }
      }
    }]);

    return ContextController;
  }(IMController);

  /**
   * 标准 Response 类 <br/>
   * @class IMResponse
   * @param {Object} options
   * @param {Number} options.code
   * @param {*} options.data
   */
  var IMResponse = function IMResponse(options) {
    _classCallCheck(this, IMResponse);

    this.code = 0;
    this.data = options || {};
  };

  /**
   * sdk对接入侧的统一的Promise入口
   */

  var _emitter = null;
  var IMPromise = {
    hookEmitter: function hookEmitter(emitter) {
      _emitter = emitter;
    },
    resolve: function resolve(options) {
      if (options instanceof IMResponse) {
        logger.warn('IMPromise.resolve 此函数会自动用options创建IMResponse实例，调用侧不需创建，建议修改！');
        return Promise.resolve(options);
      }

      return Promise.resolve(new IMResponse(options));
    },

    /**
     * 返回一个带有拒绝原因(错误信息)的 Promise 对象
     * @param {Object} options - 创建 IMError 实例的配置，包含 code 和 message
     * @param {Number} options.code - 错误码
     * @param {String} options.message - 错误信息
     * @param {*} bEmitErrorEvent 是否派发错误事件的标识，默认 false。设置为 true 将派发 TIM_OUTER_EVENT.ERROR 事件
     * @returns {Promise}
     */
    reject: function reject(options) {
      var bEmitErrorEvent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      if (options instanceof IMError) {
        bEmitErrorEvent && _emitter !== null && _emitter.emit(TIM_OUTER_EVENT.ERROR, options);
        return Promise.reject(options);
      }

      if (options instanceof Error) {
        var _imError = new IMError({
          code: ERROR_CODE.UNCAUGHT_ERROR,
          message: options.message
        });

        bEmitErrorEvent && _emitter !== null && _emitter.emit(TIM_OUTER_EVENT.ERROR, _imError);
        return Promise.reject(_imError);
      } // 这两种错误应该在开发阶段解决掉，不对外提供错误码


      if (isUndefined(options) || isUndefined(options.code) || isUndefined(options.message)) {
        logger.error('IMPromise.reject 必须指定code(错误码)和message(错误信息)!!!');
        return;
      }

      if (!isNumber(options.code) || !isString(options.message)) {
        logger.error('IMPromise.reject code(错误码)必须为数字，message(错误信息)必须为字符串!!!');
        return;
      }

      var imError = new IMError(options);
      bEmitErrorEvent && _emitter !== null && _emitter.emit(TIM_OUTER_EVENT.ERROR, imError);
      return Promise.reject(imError);
    }
  };

  // logger.time 函数的 label 常量。 用于统计耗时。
  var label = {
    SDK_READY: 'sdkReady',
    LOGIN: 'login',
    LONG_POLLING: 'longpolling',
    LONG_POLLING_AV: 'longpollingAV',
    SEND_MESSAGE: 'sendMessage',
    INIT_CONVERSATION_LIST: 'initConversationList',
    INIT_GROUP_LIST: 'initGroupList',
    UPLOAD: 'upload'
  };

  /**
   * SSO 上报通道的数据结构
   * @class SSOLogData
   */

  var SSOLogData =
  /*#__PURE__*/
  function () {
    /**
     * Creates an instance of SSOLogData.
     * @memberof SSOLogData
     */
    function SSOLogData() {
      _classCallCheck(this, SSOLogData);

      this.SDKAppID = ''; // SDKAppID

      this.version = ''; // SDK 版本号

      this.tinyID = ''; // tinyID 可用于定位用户

      this.userID = ''; // userID

      this.platform = ''; // 平台类型 web/wechat/miniapp

      this.method = ''; // 方法名，枚举值在 const/sso-methods.js

      this.time = ''; // 本条日志创建的时间

      this.startts = 0; // 函数开始执行的时间

      this.endts = 0; // 函数结束的时间

      this.timespan = 0; // 从 start 到 end 花费的时间

      this.codeint = 0; // 运行结果，有错误码的情况下使用，默认为 0

      this.message = ''; // 错误信息

      this.text = ''; // 其它数据，默认为 ''

      this.msgType = ''; // 消息类型

      this.networkType = ''; // 网络类型

      this.platform = ''; // 平台类型
      // 状态机：初始化 -> 收集信息 -> 发送，不可逆

      this._sentFlag = false; // 是否已被发送的标识
    }
    /**
     * 在原型链上绑定事件统计控制器，方便调用。静态函数。
     * @param {EventStatController} controller 事件统计控制器
     */


    _createClass(SSOLogData, [{
      key: "setCommonInfo",
      value: function setCommonInfo(SDKAppID, version, tinyID, userID, platform) {
        this.SDKAppID = "".concat(SDKAppID);
        this.version = "".concat(version);
        this.tinyID = tinyID;
        this.userID = userID;
        this.platform = platform;
        this.time = date2ISOString();

        if (this.startts && this.endts && !this.timespan) {
          // 计算 timespan 的值，timespan 的值为 endts 和 startts 的差值
          this.timespan = Math.abs(this.endts - this.startts);
        }
      }
      /**
       * 设置 method 字段，method 的值需要使用 src/const/sso-methods.js 文件内定义的
       * @param {String} value - 方法名称
       * @returns {SSOLogData}
       */

    }, {
      key: "setMethod",
      value: function setMethod(value) {
        this.method = value;
        return this;
      }
      /**
       * 设置 startts 字段，startts 为开始时间戳
       */

    }, {
      key: "setStart",
      value: function setStart() {
        this.startts = Date.now();
      }
      /**
       * 设置 endts 字段，endts 为结束时间戳
       * @param {Boolean} bSync 默认值为 false，异步执行；true 则同步执行
       */

    }, {
      key: "setEnd",
      value: function setEnd() {
        var _this = this;

        var bSync = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

        if (this._sentFlag) {
          // 不可重复发送
          return;
        }

        this.endts = Date.now();

        if (!bSync) {
          setTimeout(function () {
            _this._sentFlag = true; // 此属性在 sdk 构造函数内被挂载到 SSOLogData 的原型链上，可以直接使用

            _this._eventStatController.pushIn(_this);
          }, 0);
        } else {
          this._sentFlag = true; // 此属性在 sdk 构造函数内被挂载到 SSOLogData 的原型链上，可以直接使用

          this._eventStatController.pushIn(this);
        }
      }
      /**
       * 传递 Error 实例，如果有 code 或 message，则统计上报
       * @param {Error} value Error 实例
       * @param {Boolean} bOnline 是否接入了网络
       * @param {String} networkType 接入网络时的网络类型
       * @returns {SSOLogData}
       */

    }, {
      key: "setError",
      value: function setError(value, bOnline, networkType) {
        if (!(value instanceof Error)) {
          logger.warn('SSOLogData.setError value not instanceof Error, please check!');
          return this;
        }

        if (this._sentFlag) {
          // 状态机的状态不可逆
          return this;
        }

        this.setNetworkType(networkType);

        if (bOnline) {
          if (value.code) {
            this.setCode(value.code);
          }

          if (value.message) {
            this.setMessage(value.message);
          }
        } else {
          // 标识出由于未连接网络导致的发送失败
          this.setCode(ERROR_CODE.NO_NETWORK);
          this.setMessage(ERROR_MESSAGE.NO_NETWORK);
        }

        return this;
      }
      /**
      * 设置 code 字段， code 字段可用于记录服务器返回的错误码
      * @param {Number} value - code 值，整数;
      * @returns {SSOLogData}
      */

    }, {
      key: "setCode",
      value: function setCode(value) {
        if (isUndefined(value) || this._sentFlag) {
          return this;
        }

        if (isNumber(value)) {
          this.codeint = value;
        } else {
          logger.warn('SSOLogData.setCode value not a number, please check!');
        }

        return this;
      }
      /**
       *设置 message 字段，message 字段通常为错误信息，当 code 不为零时调用。
       * @param {String} value - 错误信息
       * @returns {SSOLogData}
       */

    }, {
      key: "setMessage",
      value: function setMessage(value) {
        if (isUndefined(value) || this._sentFlag) {
          return this;
        } // 字符串，直接赋值


        if (isString(value)) {
          this.message = value;
          return this;
        }

        return this;
      }
      /**
       * 设置 text 字段，text 字段可用于记录关键日志
       * @param {String} value - 日志数据
       * @returns {SSOLogData}
       */

    }, {
      key: "setText",
      value: function setText(value) {
        if (isNumber(value)) {
          this.text = value.toString();
        } else if (isString(value)) {
          this.text = value;
        }

        return this;
      }
      /**
       * 设置 msgtype 字段，记录所发消息类型
       * @param {String} value 消息类型
       * @returns {SSOLogData}
       */

    }, {
      key: "setMessageType",
      value: function setMessageType(value) {
        this.msgType = value;
        return this;
      }
      /**
       * 设置 networktype 字段，记录网络类型
       * @param {String} value 网络类型
       * @returns {SSOLogData}
       */

    }, {
      key: "setNetworkType",
      value: function setNetworkType(value) {
        if (isUndefined(value)) {
          logger.warn('SSOLogData.setNetworkType value is undefined, please check!');
        } else {
          this.networkType = value;
        }

        return this;
      }
    }], [{
      key: "bindController",
      value: function bindController(controller) {
        SSOLogData.prototype._eventStatController = controller;
      }
    }]);

    return SSOLogData;
  }();

  var SSOMethods = {
    // -----SDK 初始化-----
    SDK_CONSTRUCT: 'sdkConstruct',
    SDK_READY: 'sdkReady',
    // -----接入-----
    ACCESS_LAYER: 'accessLayer',
    LOGIN: 'login',
    // -----消息收发-----
    CREATE_TEXT_MESSAGE: 'createTextMessage',
    CREATE_IMAGE_MESSAGE: 'createImageMessage',
    CREATE_AUDIO_MESSAGE: 'createAudioMessage',
    CREATE_VIDEO_MESSAGE: 'createVideoMessage',
    CREATE_FILE_MESSAGE: 'createFileMessage',
    CREATE_CUSTOM_MESSAGE: 'createCustomMessage',
    UPLOAD: 'upload',
    SEND_MESSAGE: 'sendMessage',
    GET_C2C_ROAMING_MESSAGES: 'getC2CRoamingMessages',
    GET_GROUP_ROAMING_MESSAGES: 'getGroupRoamingMessages',
    REVOKE_MESSAGE: 'revokeMessage',
    SET_C2C_MESSAGE_READ: 'setC2CMessageRead',
    SET_GROUP_MESSAGE_READ: 'setGroupMessageRead',
    // -----会话-----
    GET_CONVERSATION_LIST: 'getConversationList',
    // 获取会话列表，会同步最新的100条会话
    GET_CONVERSATION_LIST_IN_STORAGE: 'getConversationListInStorage',
    // 读取本地缓存的 conversation 数据
    SYNC_CONVERSATION_LIST: 'syncConversationList',
    // 同步会话列表，会从旧往新同步所有会话，SDK 内部自动分页拉取
    // -----群组-----
    CREATE_GROUP: 'createGroup',
    APPLY_JOIN_GROUP: 'applyJoinGroup',
    QUIT_GROUP: 'quitGroup',
    CHANGE_GROUP_OWNER: 'changeGroupOwner',
    DISMISS_GROUP: 'dismissGroup',
    UPDATE_GROUP_PROFILE: 'updateGroupProfile',
    GET_GROUP_LIST: 'getGroupList',
    GET_GROUP_LIST_IN_STORAGE: 'getGroupListInStorage',
    // 读取本地缓存的 group 数据
    GET_GROUP_LAST_SEQUENCE: 'getGroupLastSequence',
    // -----群成员-----
    SET_GROUPMEMBER_MUTE_TIME: 'setGroupMemberMuteTime',
    SET_GROUPMEMBER_NAME_CARD: 'setGroupMemberNameCard',
    SET_GROUPMEMBER_ROLE: 'setGroupMemberRole',
    SET_GROUPMEMBER_CUSTOM_FIELD: 'setGroupMemberCustomField',
    // -----消息通道-----
    SYNC_MESSAGE: 'syncMessage',
    GET_LONGPOLL_ID: 'getLongPollID',
    LONG_POLLING_ERROR: 'longPollingError',
    LONG_POLLING_AV_ERROR: 'longPollingAVError',
    // avchatroom 长轮询出错
    NETWORK_JITTER: 'networkJitter',
    // 网络抖动
    FAST_START: 'fastStart',
    // 快启动
    SLOW_START: 'slowStart',
    // 慢启动
    // -----资料 & 关系链-----
    GET_USER_PROFILE: 'getUserProfile',
    GET_BLACKLIST: 'getBlacklist',
    // ----小程序相关-----
    MP_HIDE_TO_SHOW: 'mpHideToShow'
  };

  /**
   * 用于处理登录、登出等逻辑
   * @class
   * @author SaxonGao
   */

  var SignController =
  /*#__PURE__*/
  function (_IMController) {
    _inherits(SignController, _IMController);

    /**
     * @param {TIM} tim - TIM 实例
     */
    function SignController(tim) {
      var _this;

      _classCallCheck(this, SignController);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(SignController).call(this, tim));

      _this._initializeListener();

      return _this;
    }
    /**
     * @uses 处理用户登录，如果当前已经登录，则会重启消息通道
     * @param {object} options - 登录参数
     * @param {string} options.SDKAppID - 用户标识接入SDK的应用ID，必填
     * @param {string} options.accountType - 用户标识接入SDK的应用ID，选填
     * @param {string} options.identifier - 用户帐号,必须是字符串类型，必填
     * @param {string} options.userSig - 鉴权Token，必须是字符串类型，必填
     * @description 登录流程为 ：
     * 1. 请求沙箱类型
     * 2. 设置API地址
     * 3. 正式登录
     * 4. 抛出登录成功事件或登录失败事件
     * @returns {IMPromise}
     */


    _createClass(SignController, [{
      key: "login",
      value: function login(options) {
        // 1、修正一个自测出的隐藏BUG：如果在没有登出的前提下，直接调用登录，会引发“登录->踢出”死循环。
        if (this.isLoggedIn()) {
          // 重复登录
          var tips = "\u60A8\u5DF2\u7ECF\u767B\u5F55\u8D26\u53F7".concat(options.identifier, "\uFF01\u5982\u9700\u5207\u6362\u8D26\u53F7\u767B\u5F55\uFF0C\u8BF7\u5148\u8C03\u7528 logout \u63A5\u53E3\u767B\u51FA\uFF0C\u518D\u8C03\u7528 login \u63A5\u53E3\u767B\u5F55\u3002");
          logger.warn(tips);
          return IMPromise.resolve({
            actionStatus: 'OK',
            errorCode: 0,
            errorInfo: tips,
            repeatLogin: true // 标识当前账号已登录

          });
        }

        logger.log('SignController.login userID=', options.identifier);
        logger.time(label.LOGIN);

        var ret = this._checkLoginInfo(options);

        if (!isEmpty(ret)) {
          return IMPromise.reject(ret);
        } // TODO: 这里会导致 PackageConfig 的 _initConfig 方法连续执行4次


        this.tim.context.identifier = options.identifier;
        this.tim.context.userSig = options.userSig;

        if (this.tim.context.identifier && this.tim.context.userSig) {
          return this._accessLayer();
        }
      }
      /**
       *判断当前调用 login 接口的 userID 是否和当前登录的 userID 一致
       *
       * @param {string} identifier - 用户id
       * @returns {boolean}
       * @memberof SignController
       */

    }, {
      key: "_isLoginCurrentUser",
      value: function _isLoginCurrentUser(identifier) {
        return this.tim.context.identifier === identifier;
      }
      /**
       * 绑定事件
       */

    }, {
      key: "_initializeListener",
      value: function _initializeListener() {
        var innerEmitter = this.tim.innerEmitter; // 多实例被踢

        innerEmitter.on(TIM_INNER_EVENT.NOTICE_LONGPOLL_KICKED_OUT, this._onKickedOut, this); // 多终端被踢

        innerEmitter.on(TIM_INNER_EVENT.NOTICE_LONGPOLL_MUTIPLE_DEVICE_KICKED_OUT, this._onMultipleDeviceKickedOut, this); // userSig && A2key 到期

        innerEmitter.on(TIM_INNER_EVENT.SIGN_A2KEY_EXPIRED, this._onUserSigExpired, this);
      }
      /**
       * 请求沙箱类型
       * @returns {promise} result
       */

    }, {
      key: "_accessLayer",
      value: function _accessLayer() {
        var _this2 = this;

        // event stat
        var ssoLog = new SSOLogData();
        ssoLog.setMethod(SSOMethods.ACCESS_LAYER).setStart();
        logger.log('SignController._accessLayer.');
        return this.request({
          name: 'accessLayer',
          action: 'query'
        }).then(function (response) {
          // event stat
          ssoLog.setCode(0).setNetworkType(_this2.getNetworkType()).setText(response.data.webImAccessLayer).setEnd();
          logger.log("SignController._accessLayer ok. webImAccessLayer=".concat(response.data.webImAccessLayer)); // TIPS: 以下逻辑是选择不同的沙箱，events.tim.qq.com是活动沙箱

          if (response.data.webImAccessLayer === 1) {
            SERVER.HOST.setCurrent(response.data.webImAccessLayer);
          }

          return _this2._login();
        })["catch"](function (error) {
          // event stat
          _this2.probeNetwork().then(function (_ref) {
            var _ref2 = _slicedToArray(_ref, 2),
                bOnline = _ref2[0],
                networkType = _ref2[1];

            // 登陆流程比较特殊，失败时日志同步推送到日志队列，目的时为了上报时把日志都收集到。其它情况，可以异步推送到日志队列
            ssoLog.setError(error, bOnline, networkType).setEnd(true);

            _this2.tim.eventStatController.reportAtOnce();
          });

          logger.error("SignController._accessLayer failed. error:".concat(error)); // 统计用（在这里派发登录失败更准确些，因为login操作如果失败，这里也能捕获到；而accessLayer操作失败，实际也会导致登录失败）

          return IMPromise.reject(error);
        });
      }
      /**
       * @returns {promise} result
       */

    }, {
      key: "_login",
      value: function _login() {
        var _this3 = this;

        // event stat
        var ssoLog = new SSOLogData();
        ssoLog.setMethod(SSOMethods.LOGIN).setStart();
        return this.request({
          name: 'login',
          action: 'query'
        }).then(function (response) {
          var imError = null;

          if (!response.data.tinyID) {
            imError = new IMError({
              code: ERROR_CODE.NO_TINYID,
              message: ERROR_MESSAGE.NO_TINYID
            }); // event stat

            ssoLog.setError(imError, true, _this3.getNetworkType()).setEnd();
            throw imError;
          }

          if (!response.data.a2Key) {
            imError = new IMError({
              code: ERROR_CODE.NO_A2KEY,
              message: ERROR_MESSAGE.NO_A2KEY
            }); // event stat

            ssoLog.setError(imError, true, _this3.getNetworkType()).setEnd();
            throw imError;
          } // event stat


          ssoLog.setCode(0).setNetworkType(_this3.getNetworkType()).setText("".concat(_this3.tim.loginInfo.identifier)).setEnd();
          logger.log("SignController.login ok. userID=".concat(_this3.tim.loginInfo.identifier, " loginCost=").concat(logger.timeEnd(label.LOGIN), "ms")); // 统计用

          _this3.emitInnerEvent(TIM_INNER_EVENT.SIGN_LOGIN_SUCCESS, {
            a2Key: response.data.a2Key,
            tinyID: response.data.tinyID
          });

          return IMPromise.resolve(response.data);
        })["catch"](function (error) {
          // event stat
          _this3.probeNetwork().then(function (_ref3) {
            var _ref4 = _slicedToArray(_ref3, 2),
                bOnline = _ref4[0],
                networkType = _ref4[1];

            // 登陆流程比较特殊，失败时日志同步推送到日志队列，目的时为了上报时把日志都收集到。其它情况，可以异步推送到日志队列
            ssoLog.setError(error, bOnline, networkType).setEnd(true);
          });

          logger.error("SignController.login failed. error:".concat(error));
          return IMPromise.reject(error); // 这里不需抛出事件，在accessLayer.catch中统一抛出即可。
        });
      }
      /**
       * @descriptionSDK 登出
       * 分为以下步骤
       * 1. 调用后端 longpolling logout 接口
       * 2. 关闭长轮询通道且 reset SDK 的数据
       * @returns {IMPromise}
       */

    }, {
      key: "logout",
      value: function logout() {
        logger.info('SignController.logout');
        this.emitInnerEvent(TIM_INNER_EVENT.SIGN_LOGOUT_EXECUTING); // 无论then/catch 都是登出成功

        return this._logout(LOGOUT_TYPES.LONG_POLL).then(this._emitLogoutSuccess.bind(this))["catch"](this._emitLogoutSuccess.bind(this));
      }
      /**
       * 登出
       * @param {Number} type - 登出的类型
       * @description
       *  type为`LOGOUT_TYPES.ALL`时: webim 完全退出登录态
       *  type为`LOGOUT_TYPES.LONG_POLL`时: 仅注销掉longPollID
       * @returns {IMPromise}
       */

    }, {
      key: "_logout",
      value: function _logout(type) {
        var notificationController = this.tim.notificationController;
        var name = type === LOGOUT_TYPES.ALL ? 'logout' : 'longPollLogout';
        var packOptions = type === LOGOUT_TYPES.ALL ? {
          name: name,
          action: 'query'
        } : {
          name: name,
          action: 'query',
          param: {
            longPollID: notificationController.getLongPollID()
          }
        };
        return this.request(packOptions)["catch"](function (error) {
          logger.error('SignController._logout error:', error);
          return IMPromise.reject(error);
        });
      }
      /**
       * @description 检测loginInfo是否规范
       * @param {object} loginInfo - 登录参数
       * @returns {object} - loginInfo相关参数都ok，返回一个空的{}，如果有不规范的参数，则返回一个包含code和message的{}
       */

    }, {
      key: "_checkLoginInfo",
      value: function _checkLoginInfo(loginInfo) {
        var code = 0;
        var message = '';

        if (loginInfo.SDKAppID === null) {
          code = ERROR_CODE.NO_SDKAPPID;
          message = ERROR_MESSAGE.NO_SDKAPPID;
        } else if (loginInfo.accountType === null) {
          code = ERROR_CODE.NO_ACCOUNT_TYPE;
          message = ERROR_MESSAGE.NO_ACCOUNT_TYPE;
        } else if (loginInfo.identifier === null) {
          code = ERROR_CODE.NO_IDENTIFIER;
          message = ERROR_MESSAGE.NO_IDENTIFIER;
        } else if (loginInfo.userSig === null) {
          code = ERROR_CODE.NO_USERSIG;
          message = ERROR_MESSAGE.NO_USERSIG;
        } // identifierNick  暂时不做检测


        if (!isEmpty(code) && !isEmpty(message)) {
          return {
            code: code,
            message: message
          };
        }

        return {};
      }
      /**
       * 抛出登出成功事件
       * @private
       * @memberof SignController
       * @returns {IMPromise}
       */

    }, {
      key: "_emitLogoutSuccess",
      value: function _emitLogoutSuccess() {
        this.emitInnerEvent(TIM_INNER_EVENT.SIGN_LOGOUT_SUCCESS);
        return IMPromise.resolve({});
      }
      /**
       * 多实例被踢出
       */

    }, {
      key: "_onKickedOut",
      value: function _onKickedOut() {
        var _this4 = this;

        logger.warn("SignController._onKickedOut kicked out. userID=".concat(this.tim.loginInfo.identifier));
        this.tim.logout().then(function () {
          _this4.emitOuterEvent(TIM_OUTER_EVENT.KICKED_OUT, {
            type: TYPES.KICKED_OUT_MULT_ACCOUNT
          });
        });
      }
      /**
       * 多终端被踢出
       */

    }, {
      key: "_onMultipleDeviceKickedOut",
      value: function _onMultipleDeviceKickedOut() {
        var _this5 = this;

        logger.warn("SignController._onMultipleDeviceKickedOut kicked out. userID=".concat(this.tim.loginInfo.identifier));
        this.tim.logout().then(function () {
          _this5.emitOuterEvent(TIM_OUTER_EVENT.KICKED_OUT, {
            type: TYPES.KICKED_OUT_MULT_DEVICE
          });
        });
      }
      /**
       * 当 userSig 和 a2key 过期时，自行登出
       * > 注： userSig 和  a2key 会同时过期，对后端来说，是 A2key 过期，对用户来说是 userSig 过期
       */

    }, {
      key: "_onUserSigExpired",
      value: function _onUserSigExpired() {
        logger.warn('SignController._onUserSigExpired: userSig 签名过期被踢下线');
        this.emitOuterEvent(TIM_OUTER_EVENT.KICKED_OUT, {
          type: TYPES.KICKED_OUT_USERSIG_EXPIRED
        });
        this.tim.resetSDK();
      } // must be implemented

    }, {
      key: "reset",
      value: function reset() {
        logger.info('SignController.reset');
      }
    }]);

    return SignController;
  }(IMController);

  var bind = function bind(fn, thisArg) {
    return function wrap() {
      var args = new Array(arguments.length);
      for (var i = 0; i < args.length; i++) {
        args[i] = arguments[i];
      }
      return fn.apply(thisArg, args);
    };
  };

  /*!
   * Determine if an object is a Buffer
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   */

  var isBuffer = function isBuffer (obj) {
    return obj != null && obj.constructor != null &&
      typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
  };

  /*global toString:true*/

  // utils is a library of generic helper functions non-specific to axios

  var toString = Object.prototype.toString;

  /**
   * Determine if a value is an Array
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is an Array, otherwise false
   */
  function isArray$1(val) {
    return toString.call(val) === '[object Array]';
  }

  /**
   * Determine if a value is an ArrayBuffer
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is an ArrayBuffer, otherwise false
   */
  function isArrayBuffer(val) {
    return toString.call(val) === '[object ArrayBuffer]';
  }

  /**
   * Determine if a value is a FormData
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is an FormData, otherwise false
   */
  function isFormData(val) {
    return (typeof FormData !== 'undefined') && (val instanceof FormData);
  }

  /**
   * Determine if a value is a view on an ArrayBuffer
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
   */
  function isArrayBufferView(val) {
    var result;
    if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
      result = ArrayBuffer.isView(val);
    } else {
      result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);
    }
    return result;
  }

  /**
   * Determine if a value is a String
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is a String, otherwise false
   */
  function isString$1(val) {
    return typeof val === 'string';
  }

  /**
   * Determine if a value is a Number
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is a Number, otherwise false
   */
  function isNumber$1(val) {
    return typeof val === 'number';
  }

  /**
   * Determine if a value is undefined
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if the value is undefined, otherwise false
   */
  function isUndefined$1(val) {
    return typeof val === 'undefined';
  }

  /**
   * Determine if a value is an Object
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is an Object, otherwise false
   */
  function isObject$1(val) {
    return val !== null && typeof val === 'object';
  }

  /**
   * Determine if a value is a Date
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is a Date, otherwise false
   */
  function isDate(val) {
    return toString.call(val) === '[object Date]';
  }

  /**
   * Determine if a value is a File
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is a File, otherwise false
   */
  function isFile$1(val) {
    return toString.call(val) === '[object File]';
  }

  /**
   * Determine if a value is a Blob
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is a Blob, otherwise false
   */
  function isBlob(val) {
    return toString.call(val) === '[object Blob]';
  }

  /**
   * Determine if a value is a Function
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is a Function, otherwise false
   */
  function isFunction$1(val) {
    return toString.call(val) === '[object Function]';
  }

  /**
   * Determine if a value is a Stream
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is a Stream, otherwise false
   */
  function isStream(val) {
    return isObject$1(val) && isFunction$1(val.pipe);
  }

  /**
   * Determine if a value is a URLSearchParams object
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is a URLSearchParams object, otherwise false
   */
  function isURLSearchParams(val) {
    return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
  }

  /**
   * Trim excess whitespace off the beginning and end of a string
   *
   * @param {String} str The String to trim
   * @returns {String} The String freed of excess whitespace
   */
  function trim(str) {
    return str.replace(/^\s*/, '').replace(/\s*$/, '');
  }

  /**
   * Determine if we're running in a standard browser environment
   *
   * This allows axios to run in a web worker, and react-native.
   * Both environments support XMLHttpRequest, but not fully standard globals.
   *
   * web workers:
   *  typeof window -> undefined
   *  typeof document -> undefined
   *
   * react-native:
   *  navigator.product -> 'ReactNative'
   * nativescript
   *  navigator.product -> 'NativeScript' or 'NS'
   */
  function isStandardBrowserEnv() {
    if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' ||
                                             navigator.product === 'NativeScript' ||
                                             navigator.product === 'NS')) {
      return false;
    }
    return (
      typeof window !== 'undefined' &&
      typeof document !== 'undefined'
    );
  }

  /**
   * Iterate over an Array or an Object invoking a function for each item.
   *
   * If `obj` is an Array callback will be called passing
   * the value, index, and complete array for each item.
   *
   * If 'obj' is an Object callback will be called passing
   * the value, key, and complete object for each property.
   *
   * @param {Object|Array} obj The object to iterate
   * @param {Function} fn The callback to invoke for each item
   */
  function forEach(obj, fn) {
    // Don't bother if no value provided
    if (obj === null || typeof obj === 'undefined') {
      return;
    }

    // Force an array if not already something iterable
    if (typeof obj !== 'object') {
      /*eslint no-param-reassign:0*/
      obj = [obj];
    }

    if (isArray$1(obj)) {
      // Iterate over array values
      for (var i = 0, l = obj.length; i < l; i++) {
        fn.call(null, obj[i], i, obj);
      }
    } else {
      // Iterate over object keys
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          fn.call(null, obj[key], key, obj);
        }
      }
    }
  }

  /**
   * Accepts varargs expecting each argument to be an object, then
   * immutably merges the properties of each object and returns result.
   *
   * When multiple objects contain the same key the later object in
   * the arguments list will take precedence.
   *
   * Example:
   *
   * ```js
   * var result = merge({foo: 123}, {foo: 456});
   * console.log(result.foo); // outputs 456
   * ```
   *
   * @param {Object} obj1 Object to merge
   * @returns {Object} Result of all merge properties
   */
  function merge(/* obj1, obj2, obj3, ... */) {
    var result = {};
    function assignValue(val, key) {
      if (typeof result[key] === 'object' && typeof val === 'object') {
        result[key] = merge(result[key], val);
      } else {
        result[key] = val;
      }
    }

    for (var i = 0, l = arguments.length; i < l; i++) {
      forEach(arguments[i], assignValue);
    }
    return result;
  }

  /**
   * Function equal to merge with the difference being that no reference
   * to original objects is kept.
   *
   * @see merge
   * @param {Object} obj1 Object to merge
   * @returns {Object} Result of all merge properties
   */
  function deepMerge$1(/* obj1, obj2, obj3, ... */) {
    var result = {};
    function assignValue(val, key) {
      if (typeof result[key] === 'object' && typeof val === 'object') {
        result[key] = deepMerge$1(result[key], val);
      } else if (typeof val === 'object') {
        result[key] = deepMerge$1({}, val);
      } else {
        result[key] = val;
      }
    }

    for (var i = 0, l = arguments.length; i < l; i++) {
      forEach(arguments[i], assignValue);
    }
    return result;
  }

  /**
   * Extends object a by mutably adding to it the properties of object b.
   *
   * @param {Object} a The object to be extended
   * @param {Object} b The object to copy properties from
   * @param {Object} thisArg The object to bind function to
   * @return {Object} The resulting value of object a
   */
  function extend(a, b, thisArg) {
    forEach(b, function assignValue(val, key) {
      if (thisArg && typeof val === 'function') {
        a[key] = bind(val, thisArg);
      } else {
        a[key] = val;
      }
    });
    return a;
  }

  var utils = {
    isArray: isArray$1,
    isArrayBuffer: isArrayBuffer,
    isBuffer: isBuffer,
    isFormData: isFormData,
    isArrayBufferView: isArrayBufferView,
    isString: isString$1,
    isNumber: isNumber$1,
    isObject: isObject$1,
    isUndefined: isUndefined$1,
    isDate: isDate,
    isFile: isFile$1,
    isBlob: isBlob,
    isFunction: isFunction$1,
    isStream: isStream,
    isURLSearchParams: isURLSearchParams,
    isStandardBrowserEnv: isStandardBrowserEnv,
    forEach: forEach,
    merge: merge,
    deepMerge: deepMerge$1,
    extend: extend,
    trim: trim
  };

  function encode(val) {
    return encodeURIComponent(val).
      replace(/%40/gi, '@').
      replace(/%3A/gi, ':').
      replace(/%24/g, '$').
      replace(/%2C/gi, ',').
      replace(/%20/g, '+').
      replace(/%5B/gi, '[').
      replace(/%5D/gi, ']');
  }

  /**
   * Build a URL by appending params to the end
   *
   * @param {string} url The base of the url (e.g., http://www.google.com)
   * @param {object} [params] The params to be appended
   * @returns {string} The formatted url
   */
  var buildURL = function buildURL(url, params, paramsSerializer) {
    /*eslint no-param-reassign:0*/
    if (!params) {
      return url;
    }

    var serializedParams;
    if (paramsSerializer) {
      serializedParams = paramsSerializer(params);
    } else if (utils.isURLSearchParams(params)) {
      serializedParams = params.toString();
    } else {
      var parts = [];

      utils.forEach(params, function serialize(val, key) {
        if (val === null || typeof val === 'undefined') {
          return;
        }

        if (utils.isArray(val)) {
          key = key + '[]';
        } else {
          val = [val];
        }

        utils.forEach(val, function parseValue(v) {
          if (utils.isDate(v)) {
            v = v.toISOString();
          } else if (utils.isObject(v)) {
            v = JSON.stringify(v);
          }
          parts.push(encode(key) + '=' + encode(v));
        });
      });

      serializedParams = parts.join('&');
    }

    if (serializedParams) {
      var hashmarkIndex = url.indexOf('#');
      if (hashmarkIndex !== -1) {
        url = url.slice(0, hashmarkIndex);
      }

      url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
    }

    return url;
  };

  function InterceptorManager() {
    this.handlers = [];
  }

  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  InterceptorManager.prototype.use = function use(fulfilled, rejected) {
    this.handlers.push({
      fulfilled: fulfilled,
      rejected: rejected
    });
    return this.handlers.length - 1;
  };

  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   */
  InterceptorManager.prototype.eject = function eject(id) {
    if (this.handlers[id]) {
      this.handlers[id] = null;
    }
  };

  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   */
  InterceptorManager.prototype.forEach = function forEach(fn) {
    utils.forEach(this.handlers, function forEachHandler(h) {
      if (h !== null) {
        fn(h);
      }
    });
  };

  var InterceptorManager_1 = InterceptorManager;

  /**
   * Transform the data for a request or a response
   *
   * @param {Object|String} data The data to be transformed
   * @param {Array} headers The headers for the request or response
   * @param {Array|Function} fns A single function or Array of functions
   * @returns {*} The resulting transformed data
   */
  var transformData = function transformData(data, headers, fns) {
    /*eslint no-param-reassign:0*/
    utils.forEach(fns, function transform(fn) {
      data = fn(data, headers);
    });

    return data;
  };

  var isCancel = function isCancel(value) {
    return !!(value && value.__CANCEL__);
  };

  // shim for using process in browser
  // based off https://github.com/defunctzombie/node-process/blob/master/browser.js

  function defaultSetTimout() {
      throw new Error('setTimeout has not been defined');
  }
  function defaultClearTimeout () {
      throw new Error('clearTimeout has not been defined');
  }
  var cachedSetTimeout = defaultSetTimout;
  var cachedClearTimeout = defaultClearTimeout;
  if (typeof global$1.setTimeout === 'function') {
      cachedSetTimeout = setTimeout;
  }
  if (typeof global$1.clearTimeout === 'function') {
      cachedClearTimeout = clearTimeout;
  }

  function runTimeout(fun) {
      if (cachedSetTimeout === setTimeout) {
          //normal enviroments in sane situations
          return setTimeout(fun, 0);
      }
      // if setTimeout wasn't available but was latter defined
      if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
          cachedSetTimeout = setTimeout;
          return setTimeout(fun, 0);
      }
      try {
          // when when somebody has screwed with setTimeout but no I.E. maddness
          return cachedSetTimeout(fun, 0);
      } catch(e){
          try {
              // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
              return cachedSetTimeout.call(null, fun, 0);
          } catch(e){
              // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
              return cachedSetTimeout.call(this, fun, 0);
          }
      }


  }
  function runClearTimeout(marker) {
      if (cachedClearTimeout === clearTimeout) {
          //normal enviroments in sane situations
          return clearTimeout(marker);
      }
      // if clearTimeout wasn't available but was latter defined
      if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
          cachedClearTimeout = clearTimeout;
          return clearTimeout(marker);
      }
      try {
          // when when somebody has screwed with setTimeout but no I.E. maddness
          return cachedClearTimeout(marker);
      } catch (e){
          try {
              // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
              return cachedClearTimeout.call(null, marker);
          } catch (e){
              // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
              // Some versions of I.E. have different rules for clearTimeout vs setTimeout
              return cachedClearTimeout.call(this, marker);
          }
      }



  }
  var queue = [];
  var draining = false;
  var currentQueue;
  var queueIndex = -1;

  function cleanUpNextTick() {
      if (!draining || !currentQueue) {
          return;
      }
      draining = false;
      if (currentQueue.length) {
          queue = currentQueue.concat(queue);
      } else {
          queueIndex = -1;
      }
      if (queue.length) {
          drainQueue();
      }
  }

  function drainQueue() {
      if (draining) {
          return;
      }
      var timeout = runTimeout(cleanUpNextTick);
      draining = true;

      var len = queue.length;
      while(len) {
          currentQueue = queue;
          queue = [];
          while (++queueIndex < len) {
              if (currentQueue) {
                  currentQueue[queueIndex].run();
              }
          }
          queueIndex = -1;
          len = queue.length;
      }
      currentQueue = null;
      draining = false;
      runClearTimeout(timeout);
  }
  function nextTick(fun) {
      var args = new Array(arguments.length - 1);
      if (arguments.length > 1) {
          for (var i = 1; i < arguments.length; i++) {
              args[i - 1] = arguments[i];
          }
      }
      queue.push(new Item(fun, args));
      if (queue.length === 1 && !draining) {
          runTimeout(drainQueue);
      }
  }
  // v8 likes predictible objects
  function Item(fun, array) {
      this.fun = fun;
      this.array = array;
  }
  Item.prototype.run = function () {
      this.fun.apply(null, this.array);
  };
  var title = 'browser';
  var platform = 'browser';
  var browser = true;
  var env = {};
  var argv = [];
  var version$1 = ''; // empty string to avoid regexp issues
  var versions = {};
  var release = {};
  var config = {};

  function noop$1() {}

  var on = noop$1;
  var addListener = noop$1;
  var once = noop$1;
  var off = noop$1;
  var removeListener = noop$1;
  var removeAllListeners = noop$1;
  var emit = noop$1;

  function binding(name) {
      throw new Error('process.binding is not supported');
  }

  function cwd () { return '/' }
  function chdir (dir) {
      throw new Error('process.chdir is not supported');
  }function umask() { return 0; }

  // from https://github.com/kumavis/browser-process-hrtime/blob/master/index.js
  var performance = global$1.performance || {};
  var performanceNow =
    performance.now        ||
    performance.mozNow     ||
    performance.msNow      ||
    performance.oNow       ||
    performance.webkitNow  ||
    function(){ return (new Date()).getTime() };

  // generate timestamp or delta
  // see http://nodejs.org/api/process.html#process_process_hrtime
  function hrtime(previousTimestamp){
    var clocktime = performanceNow.call(performance)*1e-3;
    var seconds = Math.floor(clocktime);
    var nanoseconds = Math.floor((clocktime%1)*1e9);
    if (previousTimestamp) {
      seconds = seconds - previousTimestamp[0];
      nanoseconds = nanoseconds - previousTimestamp[1];
      if (nanoseconds<0) {
        seconds--;
        nanoseconds += 1e9;
      }
    }
    return [seconds,nanoseconds]
  }

  var startTime = new Date();
  function uptime() {
    var currentTime = new Date();
    var dif = currentTime - startTime;
    return dif / 1000;
  }

  var process = {
    nextTick: nextTick,
    title: title,
    browser: browser,
    env: env,
    argv: argv,
    version: version$1,
    versions: versions,
    on: on,
    addListener: addListener,
    once: once,
    off: off,
    removeListener: removeListener,
    removeAllListeners: removeAllListeners,
    emit: emit,
    binding: binding,
    cwd: cwd,
    chdir: chdir,
    umask: umask,
    hrtime: hrtime,
    platform: platform,
    release: release,
    config: config,
    uptime: uptime
  };

  var normalizeHeaderName = function normalizeHeaderName(headers, normalizedName) {
    utils.forEach(headers, function processHeader(value, name) {
      if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
        headers[normalizedName] = value;
        delete headers[name];
      }
    });
  };

  /**
   * Update an Error with the specified config, error code, and response.
   *
   * @param {Error} error The error to update.
   * @param {Object} config The config.
   * @param {string} [code] The error code (for example, 'ECONNABORTED').
   * @param {Object} [request] The request.
   * @param {Object} [response] The response.
   * @returns {Error} The error.
   */
  var enhanceError = function enhanceError(error, config, code, request, response) {
    error.config = config;
    if (code) {
      error.code = code;
    }

    error.request = request;
    error.response = response;
    error.isAxiosError = true;

    error.toJSON = function() {
      return {
        // Standard
        message: this.message,
        name: this.name,
        // Microsoft
        description: this.description,
        number: this.number,
        // Mozilla
        fileName: this.fileName,
        lineNumber: this.lineNumber,
        columnNumber: this.columnNumber,
        stack: this.stack,
        // Axios
        config: this.config,
        code: this.code
      };
    };
    return error;
  };

  /**
   * Create an Error with the specified message, config, error code, request and response.
   *
   * @param {string} message The error message.
   * @param {Object} config The config.
   * @param {string} [code] The error code (for example, 'ECONNABORTED').
   * @param {Object} [request] The request.
   * @param {Object} [response] The response.
   * @returns {Error} The created error.
   */
  var createError = function createError(message, config, code, request, response) {
    var error = new Error(message);
    return enhanceError(error, config, code, request, response);
  };

  /**
   * Resolve or reject a Promise based on response status.
   *
   * @param {Function} resolve A function that resolves the promise.
   * @param {Function} reject A function that rejects the promise.
   * @param {object} response The response.
   */
  var settle = function settle(resolve, reject, response) {
    var validateStatus = response.config.validateStatus;
    if (!validateStatus || validateStatus(response.status)) {
      resolve(response);
    } else {
      reject(createError(
        'Request failed with status code ' + response.status,
        response.config,
        null,
        response.request,
        response
      ));
    }
  };

  // Headers whose duplicates are ignored by node
  // c.f. https://nodejs.org/api/http.html#http_message_headers
  var ignoreDuplicateOf = [
    'age', 'authorization', 'content-length', 'content-type', 'etag',
    'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
    'last-modified', 'location', 'max-forwards', 'proxy-authorization',
    'referer', 'retry-after', 'user-agent'
  ];

  /**
   * Parse headers into an object
   *
   * ```
   * Date: Wed, 27 Aug 2014 08:58:49 GMT
   * Content-Type: application/json
   * Connection: keep-alive
   * Transfer-Encoding: chunked
   * ```
   *
   * @param {String} headers Headers needing to be parsed
   * @returns {Object} Headers parsed into an object
   */
  var parseHeaders = function parseHeaders(headers) {
    var parsed = {};
    var key;
    var val;
    var i;

    if (!headers) { return parsed; }

    utils.forEach(headers.split('\n'), function parser(line) {
      i = line.indexOf(':');
      key = utils.trim(line.substr(0, i)).toLowerCase();
      val = utils.trim(line.substr(i + 1));

      if (key) {
        if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
          return;
        }
        if (key === 'set-cookie') {
          parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
        } else {
          parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
        }
      }
    });

    return parsed;
  };

  var isURLSameOrigin = (
    utils.isStandardBrowserEnv() ?

    // Standard browser envs have full support of the APIs needed to test
    // whether the request URL is of the same origin as current location.
      (function standardBrowserEnv() {
        var msie = /(msie|trident)/i.test(navigator.userAgent);
        var urlParsingNode = document.createElement('a');
        var originURL;

        /**
      * Parse a URL to discover it's components
      *
      * @param {String} url The URL to be parsed
      * @returns {Object}
      */
        function resolveURL(url) {
          var href = url;

          if (msie) {
          // IE needs attribute set twice to normalize properties
            urlParsingNode.setAttribute('href', href);
            href = urlParsingNode.href;
          }

          urlParsingNode.setAttribute('href', href);

          // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
          return {
            href: urlParsingNode.href,
            protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
            host: urlParsingNode.host,
            search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
            hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
            hostname: urlParsingNode.hostname,
            port: urlParsingNode.port,
            pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
              urlParsingNode.pathname :
              '/' + urlParsingNode.pathname
          };
        }

        originURL = resolveURL(window.location.href);

        /**
      * Determine if a URL shares the same origin as the current location
      *
      * @param {String} requestURL The URL to test
      * @returns {boolean} True if URL shares the same origin, otherwise false
      */
        return function isURLSameOrigin(requestURL) {
          var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
          return (parsed.protocol === originURL.protocol &&
              parsed.host === originURL.host);
        };
      })() :

    // Non standard browser envs (web workers, react-native) lack needed support.
      (function nonStandardBrowserEnv() {
        return function isURLSameOrigin() {
          return true;
        };
      })()
  );

  var cookies = (
    utils.isStandardBrowserEnv() ?

    // Standard browser envs support document.cookie
      (function standardBrowserEnv() {
        return {
          write: function write(name, value, expires, path, domain, secure) {
            var cookie = [];
            cookie.push(name + '=' + encodeURIComponent(value));

            if (utils.isNumber(expires)) {
              cookie.push('expires=' + new Date(expires).toGMTString());
            }

            if (utils.isString(path)) {
              cookie.push('path=' + path);
            }

            if (utils.isString(domain)) {
              cookie.push('domain=' + domain);
            }

            if (secure === true) {
              cookie.push('secure');
            }

            document.cookie = cookie.join('; ');
          },

          read: function read(name) {
            var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
            return (match ? decodeURIComponent(match[3]) : null);
          },

          remove: function remove(name) {
            this.write(name, '', Date.now() - 86400000);
          }
        };
      })() :

    // Non standard browser env (web workers, react-native) lack needed support.
      (function nonStandardBrowserEnv() {
        return {
          write: function write() {},
          read: function read() { return null; },
          remove: function remove() {}
        };
      })()
  );

  var xhr = function xhrAdapter(config) {
    return new Promise(function dispatchXhrRequest(resolve, reject) {
      var requestData = config.data;
      var requestHeaders = config.headers;

      if (utils.isFormData(requestData)) {
        delete requestHeaders['Content-Type']; // Let the browser set it
      }

      var request = new XMLHttpRequest();

      // HTTP basic authentication
      if (config.auth) {
        var username = config.auth.username || '';
        var password = config.auth.password || '';
        requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
      }

      request.open(config.method.toUpperCase(), buildURL(config.url, config.params, config.paramsSerializer), true);

      // Set the request timeout in MS
      request.timeout = config.timeout;

      // Listen for ready state
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }

        // The request errored out and we didn't get a response, this will be
        // handled by onerror instead
        // With one exception: request that using file: protocol, most browsers
        // will return status as 0 even though it's a successful request
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
          return;
        }

        // Prepare the response
        var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
        var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;
        var response = {
          data: responseData,
          status: request.status,
          statusText: request.statusText,
          headers: responseHeaders,
          config: config,
          request: request
        };

        settle(resolve, reject, response);

        // Clean up request
        request = null;
      };

      // Handle browser request cancellation (as opposed to a manual cancellation)
      request.onabort = function handleAbort() {
        if (!request) {
          return;
        }

        reject(createError('Request aborted', config, 'ECONNABORTED', request));

        // Clean up request
        request = null;
      };

      // Handle low level network errors
      request.onerror = function handleError() {
        // Real errors are hidden from us by the browser
        // onerror should only fire if it's a network error
        reject(createError('Network Error', config, null, request));

        // Clean up request
        request = null;
      };

      // Handle timeout
      request.ontimeout = function handleTimeout() {
        reject(createError('timeout of ' + config.timeout + 'ms exceeded', config, 'ECONNABORTED',
          request));

        // Clean up request
        request = null;
      };

      // Add xsrf header
      // This is only done if running in a standard browser environment.
      // Specifically not if we're in a web worker, or react-native.
      if (utils.isStandardBrowserEnv()) {
        var cookies$1 = cookies;

        // Add xsrf header
        var xsrfValue = (config.withCredentials || isURLSameOrigin(config.url)) && config.xsrfCookieName ?
          cookies$1.read(config.xsrfCookieName) :
          undefined;

        if (xsrfValue) {
          requestHeaders[config.xsrfHeaderName] = xsrfValue;
        }
      }

      // Add headers to the request
      if ('setRequestHeader' in request) {
        utils.forEach(requestHeaders, function setRequestHeader(val, key) {
          if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
            // Remove Content-Type if data is undefined
            delete requestHeaders[key];
          } else {
            // Otherwise add header to the request
            request.setRequestHeader(key, val);
          }
        });
      }

      // Add withCredentials to request if needed
      if (config.withCredentials) {
        request.withCredentials = true;
      }

      // Add responseType to request if needed
      if (config.responseType) {
        try {
          request.responseType = config.responseType;
        } catch (e) {
          // Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2.
          // But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function.
          if (config.responseType !== 'json') {
            throw e;
          }
        }
      }

      // Handle progress if needed
      if (typeof config.onDownloadProgress === 'function') {
        request.addEventListener('progress', config.onDownloadProgress);
      }

      // Not all browsers support upload events
      if (typeof config.onUploadProgress === 'function' && request.upload) {
        request.upload.addEventListener('progress', config.onUploadProgress);
      }

      if (config.cancelToken) {
        // Handle cancellation
        config.cancelToken.promise.then(function onCanceled(cancel) {
          if (!request) {
            return;
          }

          request.abort();
          reject(cancel);
          // Clean up request
          request = null;
        });
      }

      if (requestData === undefined) {
        requestData = null;
      }

      // Send the request
      request.send(requestData);
    });
  };

  var DEFAULT_CONTENT_TYPE = {
    'Content-Type': 'application/x-www-form-urlencoded'
  };

  function setContentTypeIfUnset(headers, value) {
    if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
      headers['Content-Type'] = value;
    }
  }

  function getDefaultAdapter() {
    var adapter;
    // Only Node.JS has a process variable that is of [[Class]] process
    if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {
      // For node use HTTP adapter
      adapter = xhr;
    } else if (typeof XMLHttpRequest !== 'undefined') {
      // For browsers use XHR adapter
      adapter = xhr;
    }
    return adapter;
  }

  var defaults = {
    adapter: getDefaultAdapter(),

    transformRequest: [function transformRequest(data, headers) {
      normalizeHeaderName(headers, 'Accept');
      normalizeHeaderName(headers, 'Content-Type');
      if (utils.isFormData(data) ||
        utils.isArrayBuffer(data) ||
        utils.isBuffer(data) ||
        utils.isStream(data) ||
        utils.isFile(data) ||
        utils.isBlob(data)
      ) {
        return data;
      }
      if (utils.isArrayBufferView(data)) {
        return data.buffer;
      }
      if (utils.isURLSearchParams(data)) {
        setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
        return data.toString();
      }
      if (utils.isObject(data)) {
        setContentTypeIfUnset(headers, 'application/json;charset=utf-8');
        return JSON.stringify(data);
      }
      return data;
    }],

    transformResponse: [function transformResponse(data) {
      /*eslint no-param-reassign:0*/
      if (typeof data === 'string') {
        try {
          data = JSON.parse(data);
        } catch (e) { /* Ignore */ }
      }
      return data;
    }],

    /**
     * A timeout in milliseconds to abort a request. If set to 0 (default) a
     * timeout is not created.
     */
    timeout: 0,

    xsrfCookieName: 'XSRF-TOKEN',
    xsrfHeaderName: 'X-XSRF-TOKEN',

    maxContentLength: -1,

    validateStatus: function validateStatus(status) {
      return status >= 200 && status < 300;
    }
  };

  defaults.headers = {
    common: {
      'Accept': 'application/json, text/plain, */*'
    }
  };

  utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
    defaults.headers[method] = {};
  });

  utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
    defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
  });

  var defaults_1 = defaults;

  /**
   * Determines whether the specified URL is absolute
   *
   * @param {string} url The URL to test
   * @returns {boolean} True if the specified URL is absolute, otherwise false
   */
  var isAbsoluteURL = function isAbsoluteURL(url) {
    // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
    // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
    // by any combination of letters, digits, plus, period, or hyphen.
    return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
  };

  /**
   * Creates a new URL by combining the specified URLs
   *
   * @param {string} baseURL The base URL
   * @param {string} relativeURL The relative URL
   * @returns {string} The combined URL
   */
  var combineURLs = function combineURLs(baseURL, relativeURL) {
    return relativeURL
      ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '')
      : baseURL;
  };

  /**
   * Throws a `Cancel` if cancellation has been requested.
   */
  function throwIfCancellationRequested(config) {
    if (config.cancelToken) {
      config.cancelToken.throwIfRequested();
    }
  }

  /**
   * Dispatch a request to the server using the configured adapter.
   *
   * @param {object} config The config that is to be used for the request
   * @returns {Promise} The Promise to be fulfilled
   */
  var dispatchRequest = function dispatchRequest(config) {
    throwIfCancellationRequested(config);

    // Support baseURL config
    if (config.baseURL && !isAbsoluteURL(config.url)) {
      config.url = combineURLs(config.baseURL, config.url);
    }

    // Ensure headers exist
    config.headers = config.headers || {};

    // Transform request data
    config.data = transformData(
      config.data,
      config.headers,
      config.transformRequest
    );

    // Flatten headers
    config.headers = utils.merge(
      config.headers.common || {},
      config.headers[config.method] || {},
      config.headers || {}
    );

    utils.forEach(
      ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
      function cleanHeaderConfig(method) {
        delete config.headers[method];
      }
    );

    var adapter = config.adapter || defaults_1.adapter;

    return adapter(config).then(function onAdapterResolution(response) {
      throwIfCancellationRequested(config);

      // Transform response data
      response.data = transformData(
        response.data,
        response.headers,
        config.transformResponse
      );

      return response;
    }, function onAdapterRejection(reason) {
      if (!isCancel(reason)) {
        throwIfCancellationRequested(config);

        // Transform response data
        if (reason && reason.response) {
          reason.response.data = transformData(
            reason.response.data,
            reason.response.headers,
            config.transformResponse
          );
        }
      }

      return Promise.reject(reason);
    });
  };

  /**
   * Config-specific merge-function which creates a new config-object
   * by merging two configuration objects together.
   *
   * @param {Object} config1
   * @param {Object} config2
   * @returns {Object} New object resulting from merging config2 to config1
   */
  var mergeConfig = function mergeConfig(config1, config2) {
    // eslint-disable-next-line no-param-reassign
    config2 = config2 || {};
    var config = {};

    utils.forEach(['url', 'method', 'params', 'data'], function valueFromConfig2(prop) {
      if (typeof config2[prop] !== 'undefined') {
        config[prop] = config2[prop];
      }
    });

    utils.forEach(['headers', 'auth', 'proxy'], function mergeDeepProperties(prop) {
      if (utils.isObject(config2[prop])) {
        config[prop] = utils.deepMerge(config1[prop], config2[prop]);
      } else if (typeof config2[prop] !== 'undefined') {
        config[prop] = config2[prop];
      } else if (utils.isObject(config1[prop])) {
        config[prop] = utils.deepMerge(config1[prop]);
      } else if (typeof config1[prop] !== 'undefined') {
        config[prop] = config1[prop];
      }
    });

    utils.forEach([
      'baseURL', 'transformRequest', 'transformResponse', 'paramsSerializer',
      'timeout', 'withCredentials', 'adapter', 'responseType', 'xsrfCookieName',
      'xsrfHeaderName', 'onUploadProgress', 'onDownloadProgress', 'maxContentLength',
      'validateStatus', 'maxRedirects', 'httpAgent', 'httpsAgent', 'cancelToken',
      'socketPath'
    ], function defaultToConfig2(prop) {
      if (typeof config2[prop] !== 'undefined') {
        config[prop] = config2[prop];
      } else if (typeof config1[prop] !== 'undefined') {
        config[prop] = config1[prop];
      }
    });

    return config;
  };

  /**
   * Create a new instance of Axios
   *
   * @param {Object} instanceConfig The default config for the instance
   */
  function Axios(instanceConfig) {
    this.defaults = instanceConfig;
    this.interceptors = {
      request: new InterceptorManager_1(),
      response: new InterceptorManager_1()
    };
  }

  /**
   * Dispatch a request
   *
   * @param {Object} config The config specific for this request (merged with this.defaults)
   */
  Axios.prototype.request = function request(config) {
    /*eslint no-param-reassign:0*/
    // Allow for axios('example/url'[, config]) a la fetch API
    if (typeof config === 'string') {
      config = arguments[1] || {};
      config.url = arguments[0];
    } else {
      config = config || {};
    }

    config = mergeConfig(this.defaults, config);
    config.method = config.method ? config.method.toLowerCase() : 'get';

    // Hook up interceptors middleware
    var chain = [dispatchRequest, undefined];
    var promise = Promise.resolve(config);

    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      chain.unshift(interceptor.fulfilled, interceptor.rejected);
    });

    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      chain.push(interceptor.fulfilled, interceptor.rejected);
    });

    while (chain.length) {
      promise = promise.then(chain.shift(), chain.shift());
    }

    return promise;
  };

  Axios.prototype.getUri = function getUri(config) {
    config = mergeConfig(this.defaults, config);
    return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, '');
  };

  // Provide aliases for supported request methods
  utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
    /*eslint func-names:0*/
    Axios.prototype[method] = function(url, config) {
      return this.request(utils.merge(config || {}, {
        method: method,
        url: url
      }));
    };
  });

  utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
    /*eslint func-names:0*/
    Axios.prototype[method] = function(url, data, config) {
      return this.request(utils.merge(config || {}, {
        method: method,
        url: url,
        data: data
      }));
    };
  });

  var Axios_1 = Axios;

  /**
   * A `Cancel` is an object that is thrown when an operation is canceled.
   *
   * @class
   * @param {string=} message The message.
   */
  function Cancel(message) {
    this.message = message;
  }

  Cancel.prototype.toString = function toString() {
    return 'Cancel' + (this.message ? ': ' + this.message : '');
  };

  Cancel.prototype.__CANCEL__ = true;

  var Cancel_1 = Cancel;

  /**
   * A `CancelToken` is an object that can be used to request cancellation of an operation.
   *
   * @class
   * @param {Function} executor The executor function.
   */
  function CancelToken(executor) {
    if (typeof executor !== 'function') {
      throw new TypeError('executor must be a function.');
    }

    var resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve) {
      resolvePromise = resolve;
    });

    var token = this;
    executor(function cancel(message) {
      if (token.reason) {
        // Cancellation has already been requested
        return;
      }

      token.reason = new Cancel_1(message);
      resolvePromise(token.reason);
    });
  }

  /**
   * Throws a `Cancel` if cancellation has been requested.
   */
  CancelToken.prototype.throwIfRequested = function throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  };

  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  CancelToken.source = function source() {
    var cancel;
    var token = new CancelToken(function executor(c) {
      cancel = c;
    });
    return {
      token: token,
      cancel: cancel
    };
  };

  var CancelToken_1 = CancelToken;

  /**
   * Syntactic sugar for invoking a function and expanding an array for arguments.
   *
   * Common use case would be to use `Function.prototype.apply`.
   *
   *  ```js
   *  function f(x, y, z) {}
   *  var args = [1, 2, 3];
   *  f.apply(null, args);
   *  ```
   *
   * With `spread` this example can be re-written.
   *
   *  ```js
   *  spread(function(x, y, z) {})([1, 2, 3]);
   *  ```
   *
   * @param {Function} callback
   * @returns {Function}
   */
  var spread = function spread(callback) {
    return function wrap(arr) {
      return callback.apply(null, arr);
    };
  };

  /**
   * Create an instance of Axios
   *
   * @param {Object} defaultConfig The default config for the instance
   * @return {Axios} A new instance of Axios
   */
  function createInstance(defaultConfig) {
    var context = new Axios_1(defaultConfig);
    var instance = bind(Axios_1.prototype.request, context);

    // Copy axios.prototype to instance
    utils.extend(instance, Axios_1.prototype, context);

    // Copy context to instance
    utils.extend(instance, context);

    return instance;
  }

  // Create the default instance to be exported
  var axios = createInstance(defaults_1);

  // Expose Axios class to allow class inheritance
  axios.Axios = Axios_1;

  // Factory for creating new instances
  axios.create = function create(instanceConfig) {
    return createInstance(mergeConfig(axios.defaults, instanceConfig));
  };

  // Expose Cancel & CancelToken
  axios.Cancel = Cancel_1;
  axios.CancelToken = CancelToken_1;
  axios.isCancel = isCancel;

  // Expose all/spread
  axios.all = function all(promises) {
    return Promise.all(promises);
  };
  axios.spread = spread;

  var axios_1 = axios;

  // Allow use of default import syntax in TypeScript
  var default_1 = axios;
  axios_1.default = default_1;

  var axios$1 = axios_1;

  var IMAxios = axios$1.create({
    timeout: 30000,
    headers: {
      'Content-Type': 'application/x-www-form-urlencoded;charset=UTF-8'
    }
  }); // IMAxios.defaults.withCredentials = true; // - 暂时不打开 ， 服务端还不支持 `Access-Controller-Allow-Credentials`

  IMAxios.interceptors.response.use(function (response) {
    // eslint-disable-next-line camelcase
    var _response$data = response.data,
        error_code = _response$data.error_code,
        ErrorCode = _response$data.ErrorCode; // 气人，有两种errorCode 名称…… fuck x 2

    var errorCode = ErrorCode;

    if (isNumber(error_code)) {
      // eslint-disable-next-line camelcase
      errorCode = error_code;
    }

    if (errorCode !== TIM_STATUS.REQUEST.SUCCESS) {
      response.data.ErrorCode = Number(errorCode); // 维持服务端错误码不变 qiaoyang
    }

    return response;
  }, function (error) {
    if (error.message === 'Network Error') {
      if (IMAxios.defaults.withCredentials === true) {
        logger.warn('Network Error, try to close `IMAxios.defaults.withCredentials` to false. (IMAxios.js)');
      }

      IMAxios.defaults.withCredentials = false;
    }

    return Promise.reject(error);
  });

  var ConnectionBase =
  /*#__PURE__*/
  function () {
    function ConnectionBase() {
      _classCallCheck(this, ConnectionBase);
    }

    _createClass(ConnectionBase, [{
      key: "request",

      /**
       * 提交异步请求
       * @param {String} options.url string 是 开发者服务器接口地址
       * @param {*} options.data - string/object/ArrayBuffer 否 请求的参数
       * @param {Object} options.header - Object 否 设置请求的 header，
       * @param {String} options.method - string GET 否 HTTP 请求方法
       * @param {String} options.dataType - string json 否 返回的数据格式
       * @param {String} options.responseType - string text 否 响应的数据类型
       * @param {Boolean}isRetry string text false 是否为重试的请求
       */
      value: function request(options) {
        console.warn('请注意： ConnectionBase.request() 方法必须被派生类重写:');
        console.log("\u53C2\u6570\u5982\u4E0B\uFF1A\n    * @param {String} options.url string \u662F \u5F00\u53D1\u8005\u670D\u52A1\u5668\u63A5\u53E3\u5730\u5740\n    * @param {*} options.data - string/object/ArrayBuffer \u5426 \u8BF7\u6C42\u7684\u53C2\u6570\n    * @param {Object} options.header - Object \u5426 \u8BBE\u7F6E\u8BF7\u6C42\u7684 header\uFF0C\n    * @param {String} options.method - string GET \u5426 HTTP \u8BF7\u6C42\u65B9\u6CD5\n    * @param {String} options.dataType - string json \u5426 \u8FD4\u56DE\u7684\u6570\u636E\u683C\u5F0F\n    * @param {String} options.responseType - string text \u5426 \u54CD\u5E94\u7684\u6570\u636E\u7C7B\u578B\n    * @param {Boolean} isRetry - string text false \u662F\u5426\u4E3A\u91CD\u8BD5\u7684\u8BF7\u6C42\n   ");
      }
    }, {
      key: "_checkOptions",
      value: function _checkOptions(options) {
        if (!!options.url === false) {
          throw new IMError({
            code: ERROR_CODE.NETWORK_BASE_OPTIONS_NO_URL,
            message: ERROR_MESSAGE.NETWORK_BASE_OPTIONS_NO_URL
          });
        }
      }
    }, {
      key: "_initOptions",
      value: function _initOptions(options) {
        options.method = ['POST', 'GET', 'PUT', 'DELETE', 'OPTION'].indexOf(options.method) >= 0 ? options.method : 'POST';
        options.dataType = options.dataType || 'json';
        options.responseType = options.responseType || 'json'; // options.header= {
        //   "Content-Type": "x-www-form-urlencoded"
        // };
      }
    }]);

    return ConnectionBase;
  }();

  /**
   * @uses 使用xhr发送网络请求
   * @name xhr
   */
  // @TODO 换成axios

  var XHR =
  /*#__PURE__*/
  function (_ConnectionBase) {
    _inherits(XHR, _ConnectionBase);

    function XHR() {
      var _this;

      _classCallCheck(this, XHR);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(XHR).call(this));
      _this.retry = 2;
      return _this;
    }
    /**
     * 提交异步请求
     * @param {object.<url:string,data:object,header:object,method:string,dataType:string,responseType:string,isRetry:boolean>} options - 请求参数
     * @property {String} url - 开发者服务器接口地址
     * @property {Any} data - string/object/ArrayBuffer 否 请求的参数
     * @property {Object} header - Object 否 设置请求的 header，header 中不能设置 Referer。
     * @property {String} method - string GET 否 HTTP 请求方法
     * @property {String} dataType - string json 否 返回的数据格式
     * @property {String} responseType - string text 否 响应的数据类型 1.7.0
     * @returns {IMPromise}
     */


    _createClass(XHR, [{
      key: "request",
      value: function request(options) {
        this._checkOptions(options);

        this._initOptions(options);

        return this._requestWithRetry({
          url: options.url,
          data: options.data,
          method: options.method
        });
      }
    }, {
      key: "_requestWithRetry",
      value: function _requestWithRetry(options) {
        var _this2 = this;

        var retryCount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        // eslint-disable-next-line new-cap
        return IMAxios(options)["catch"](function (error) {
          if (_this2.retry && retryCount < _this2.retry) {
            return _this2._requestWithRetry(options, ++retryCount);
          }

          return IMPromise.reject(new IMError({
            code: error.code || '',
            message: error.message || ''
          }));
        });
      }
    }]);

    return XHR;
  }(ConnectionBase);

  var lookup = [];
  var revLookup = [];
  var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
  var inited = false;
  function init () {
    inited = true;
    var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
    for (var i = 0, len = code.length; i < len; ++i) {
      lookup[i] = code[i];
      revLookup[code.charCodeAt(i)] = i;
    }

    revLookup['-'.charCodeAt(0)] = 62;
    revLookup['_'.charCodeAt(0)] = 63;
  }

  function toByteArray (b64) {
    if (!inited) {
      init();
    }
    var i, j, l, tmp, placeHolders, arr;
    var len = b64.length;

    if (len % 4 > 0) {
      throw new Error('Invalid string. Length must be a multiple of 4')
    }

    // the number of equal signs (place holders)
    // if there are two placeholders, than the two characters before it
    // represent one byte
    // if there is only one, then the three characters before it represent 2 bytes
    // this is just a cheap hack to not do indexOf twice
    placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;

    // base64 is 4/3 + up to two characters of the original data
    arr = new Arr(len * 3 / 4 - placeHolders);

    // if there are placeholders, only get up to the last complete 4 chars
    l = placeHolders > 0 ? len - 4 : len;

    var L = 0;

    for (i = 0, j = 0; i < l; i += 4, j += 3) {
      tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)];
      arr[L++] = (tmp >> 16) & 0xFF;
      arr[L++] = (tmp >> 8) & 0xFF;
      arr[L++] = tmp & 0xFF;
    }

    if (placeHolders === 2) {
      tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4);
      arr[L++] = tmp & 0xFF;
    } else if (placeHolders === 1) {
      tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2);
      arr[L++] = (tmp >> 8) & 0xFF;
      arr[L++] = tmp & 0xFF;
    }

    return arr
  }

  function tripletToBase64 (num) {
    return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
  }

  function encodeChunk (uint8, start, end) {
    var tmp;
    var output = [];
    for (var i = start; i < end; i += 3) {
      tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);
      output.push(tripletToBase64(tmp));
    }
    return output.join('')
  }

  function fromByteArray (uint8) {
    if (!inited) {
      init();
    }
    var tmp;
    var len = uint8.length;
    var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
    var output = '';
    var parts = [];
    var maxChunkLength = 16383; // must be multiple of 3

    // go through the array every three bytes, we'll deal with trailing stuff later
    for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
      parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)));
    }

    // pad the end with zeros, but make sure to not forget the extra bytes
    if (extraBytes === 1) {
      tmp = uint8[len - 1];
      output += lookup[tmp >> 2];
      output += lookup[(tmp << 4) & 0x3F];
      output += '==';
    } else if (extraBytes === 2) {
      tmp = (uint8[len - 2] << 8) + (uint8[len - 1]);
      output += lookup[tmp >> 10];
      output += lookup[(tmp >> 4) & 0x3F];
      output += lookup[(tmp << 2) & 0x3F];
      output += '=';
    }

    parts.push(output);

    return parts.join('')
  }

  function read (buffer, offset, isLE, mLen, nBytes) {
    var e, m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? (nBytes - 1) : 0;
    var d = isLE ? -1 : 1;
    var s = buffer[offset + i];

    i += d;

    e = s & ((1 << (-nBits)) - 1);
    s >>= (-nBits);
    nBits += eLen;
    for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

    m = e & ((1 << (-nBits)) - 1);
    e >>= (-nBits);
    nBits += mLen;
    for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

    if (e === 0) {
      e = 1 - eBias;
    } else if (e === eMax) {
      return m ? NaN : ((s ? -1 : 1) * Infinity)
    } else {
      m = m + Math.pow(2, mLen);
      e = e - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
  }

  function write (buffer, value, offset, isLE, mLen, nBytes) {
    var e, m, c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);
    var i = isLE ? 0 : (nBytes - 1);
    var d = isLE ? 1 : -1;
    var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

    value = Math.abs(value);

    if (isNaN(value) || value === Infinity) {
      m = isNaN(value) ? 1 : 0;
      e = eMax;
    } else {
      e = Math.floor(Math.log(value) / Math.LN2);
      if (value * (c = Math.pow(2, -e)) < 1) {
        e--;
        c *= 2;
      }
      if (e + eBias >= 1) {
        value += rt / c;
      } else {
        value += rt * Math.pow(2, 1 - eBias);
      }
      if (value * c >= 2) {
        e++;
        c /= 2;
      }

      if (e + eBias >= eMax) {
        m = 0;
        e = eMax;
      } else if (e + eBias >= 1) {
        m = (value * c - 1) * Math.pow(2, mLen);
        e = e + eBias;
      } else {
        m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
        e = 0;
      }
    }

    for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

    e = (e << mLen) | m;
    eLen += mLen;
    for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

    buffer[offset + i - d] |= s * 128;
  }

  var toString$1 = {}.toString;

  var isArray$2 = Array.isArray || function (arr) {
    return toString$1.call(arr) == '[object Array]';
  };

  var INSPECT_MAX_BYTES = 50;

  /**
   * If `Buffer.TYPED_ARRAY_SUPPORT`:
   *   === true    Use Uint8Array implementation (fastest)
   *   === false   Use Object implementation (most compatible, even IE6)
   *
   * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
   * Opera 11.6+, iOS 4.2+.
   *
   * Due to various browser bugs, sometimes the Object implementation will be used even
   * when the browser supports typed arrays.
   *
   * Note:
   *
   *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
   *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
   *
   *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
   *
   *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
   *     incorrect length in some situations.

   * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
   * get the Object implementation, which is slower but behaves correctly.
   */
  Buffer.TYPED_ARRAY_SUPPORT = global$1.TYPED_ARRAY_SUPPORT !== undefined
    ? global$1.TYPED_ARRAY_SUPPORT
    : true;

  function kMaxLength () {
    return Buffer.TYPED_ARRAY_SUPPORT
      ? 0x7fffffff
      : 0x3fffffff
  }

  function createBuffer (that, length) {
    if (kMaxLength() < length) {
      throw new RangeError('Invalid typed array length')
    }
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      // Return an augmented `Uint8Array` instance, for best performance
      that = new Uint8Array(length);
      that.__proto__ = Buffer.prototype;
    } else {
      // Fallback: Return an object instance of the Buffer class
      if (that === null) {
        that = new Buffer(length);
      }
      that.length = length;
    }

    return that
  }

  /**
   * The Buffer constructor returns instances of `Uint8Array` that have their
   * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
   * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
   * and the `Uint8Array` methods. Square bracket notation works as expected -- it
   * returns a single octet.
   *
   * The `Uint8Array` prototype remains unmodified.
   */

  function Buffer (arg, encodingOrOffset, length) {
    if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
      return new Buffer(arg, encodingOrOffset, length)
    }

    // Common case.
    if (typeof arg === 'number') {
      if (typeof encodingOrOffset === 'string') {
        throw new Error(
          'If encoding is specified then the first argument must be a string'
        )
      }
      return allocUnsafe(this, arg)
    }
    return from(this, arg, encodingOrOffset, length)
  }

  Buffer.poolSize = 8192; // not used by this implementation

  // TODO: Legacy, not needed anymore. Remove in next major version.
  Buffer._augment = function (arr) {
    arr.__proto__ = Buffer.prototype;
    return arr
  };

  function from (that, value, encodingOrOffset, length) {
    if (typeof value === 'number') {
      throw new TypeError('"value" argument must not be a number')
    }

    if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
      return fromArrayBuffer(that, value, encodingOrOffset, length)
    }

    if (typeof value === 'string') {
      return fromString(that, value, encodingOrOffset)
    }

    return fromObject(that, value)
  }

  /**
   * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
   * if value is a number.
   * Buffer.from(str[, encoding])
   * Buffer.from(array)
   * Buffer.from(buffer)
   * Buffer.from(arrayBuffer[, byteOffset[, length]])
   **/
  Buffer.from = function (value, encodingOrOffset, length) {
    return from(null, value, encodingOrOffset, length)
  };

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    Buffer.prototype.__proto__ = Uint8Array.prototype;
    Buffer.__proto__ = Uint8Array;
  }

  function assertSize (size) {
    if (typeof size !== 'number') {
      throw new TypeError('"size" argument must be a number')
    } else if (size < 0) {
      throw new RangeError('"size" argument must not be negative')
    }
  }

  function alloc (that, size, fill, encoding) {
    assertSize(size);
    if (size <= 0) {
      return createBuffer(that, size)
    }
    if (fill !== undefined) {
      // Only pay attention to encoding if it's a string. This
      // prevents accidentally sending in a number that would
      // be interpretted as a start offset.
      return typeof encoding === 'string'
        ? createBuffer(that, size).fill(fill, encoding)
        : createBuffer(that, size).fill(fill)
    }
    return createBuffer(that, size)
  }

  /**
   * Creates a new filled Buffer instance.
   * alloc(size[, fill[, encoding]])
   **/
  Buffer.alloc = function (size, fill, encoding) {
    return alloc(null, size, fill, encoding)
  };

  function allocUnsafe (that, size) {
    assertSize(size);
    that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
    if (!Buffer.TYPED_ARRAY_SUPPORT) {
      for (var i = 0; i < size; ++i) {
        that[i] = 0;
      }
    }
    return that
  }

  /**
   * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
   * */
  Buffer.allocUnsafe = function (size) {
    return allocUnsafe(null, size)
  };
  /**
   * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
   */
  Buffer.allocUnsafeSlow = function (size) {
    return allocUnsafe(null, size)
  };

  function fromString (that, string, encoding) {
    if (typeof encoding !== 'string' || encoding === '') {
      encoding = 'utf8';
    }

    if (!Buffer.isEncoding(encoding)) {
      throw new TypeError('"encoding" must be a valid string encoding')
    }

    var length = byteLength(string, encoding) | 0;
    that = createBuffer(that, length);

    var actual = that.write(string, encoding);

    if (actual !== length) {
      // Writing a hex string, for example, that contains invalid characters will
      // cause everything after the first invalid character to be ignored. (e.g.
      // 'abxxcd' will be treated as 'ab')
      that = that.slice(0, actual);
    }

    return that
  }

  function fromArrayLike (that, array) {
    var length = array.length < 0 ? 0 : checked(array.length) | 0;
    that = createBuffer(that, length);
    for (var i = 0; i < length; i += 1) {
      that[i] = array[i] & 255;
    }
    return that
  }

  function fromArrayBuffer (that, array, byteOffset, length) {
    array.byteLength; // this throws if `array` is not a valid ArrayBuffer

    if (byteOffset < 0 || array.byteLength < byteOffset) {
      throw new RangeError('\'offset\' is out of bounds')
    }

    if (array.byteLength < byteOffset + (length || 0)) {
      throw new RangeError('\'length\' is out of bounds')
    }

    if (byteOffset === undefined && length === undefined) {
      array = new Uint8Array(array);
    } else if (length === undefined) {
      array = new Uint8Array(array, byteOffset);
    } else {
      array = new Uint8Array(array, byteOffset, length);
    }

    if (Buffer.TYPED_ARRAY_SUPPORT) {
      // Return an augmented `Uint8Array` instance, for best performance
      that = array;
      that.__proto__ = Buffer.prototype;
    } else {
      // Fallback: Return an object instance of the Buffer class
      that = fromArrayLike(that, array);
    }
    return that
  }

  function fromObject (that, obj) {
    if (internalIsBuffer(obj)) {
      var len = checked(obj.length) | 0;
      that = createBuffer(that, len);

      if (that.length === 0) {
        return that
      }

      obj.copy(that, 0, 0, len);
      return that
    }

    if (obj) {
      if ((typeof ArrayBuffer !== 'undefined' &&
          obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
        if (typeof obj.length !== 'number' || isnan(obj.length)) {
          return createBuffer(that, 0)
        }
        return fromArrayLike(that, obj)
      }

      if (obj.type === 'Buffer' && isArray$2(obj.data)) {
        return fromArrayLike(that, obj.data)
      }
    }

    throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
  }

  function checked (length) {
    // Note: cannot use `length < kMaxLength()` here because that fails when
    // length is NaN (which is otherwise coerced to zero.)
    if (length >= kMaxLength()) {
      throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                           'size: 0x' + kMaxLength().toString(16) + ' bytes')
    }
    return length | 0
  }
  Buffer.isBuffer = isBuffer$1;
  function internalIsBuffer (b) {
    return !!(b != null && b._isBuffer)
  }

  Buffer.compare = function compare (a, b) {
    if (!internalIsBuffer(a) || !internalIsBuffer(b)) {
      throw new TypeError('Arguments must be Buffers')
    }

    if (a === b) return 0

    var x = a.length;
    var y = b.length;

    for (var i = 0, len = Math.min(x, y); i < len; ++i) {
      if (a[i] !== b[i]) {
        x = a[i];
        y = b[i];
        break
      }
    }

    if (x < y) return -1
    if (y < x) return 1
    return 0
  };

  Buffer.isEncoding = function isEncoding (encoding) {
    switch (String(encoding).toLowerCase()) {
      case 'hex':
      case 'utf8':
      case 'utf-8':
      case 'ascii':
      case 'latin1':
      case 'binary':
      case 'base64':
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return true
      default:
        return false
    }
  };

  Buffer.concat = function concat (list, length) {
    if (!isArray$2(list)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }

    if (list.length === 0) {
      return Buffer.alloc(0)
    }

    var i;
    if (length === undefined) {
      length = 0;
      for (i = 0; i < list.length; ++i) {
        length += list[i].length;
      }
    }

    var buffer = Buffer.allocUnsafe(length);
    var pos = 0;
    for (i = 0; i < list.length; ++i) {
      var buf = list[i];
      if (!internalIsBuffer(buf)) {
        throw new TypeError('"list" argument must be an Array of Buffers')
      }
      buf.copy(buffer, pos);
      pos += buf.length;
    }
    return buffer
  };

  function byteLength (string, encoding) {
    if (internalIsBuffer(string)) {
      return string.length
    }
    if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
        (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
      return string.byteLength
    }
    if (typeof string !== 'string') {
      string = '' + string;
    }

    var len = string.length;
    if (len === 0) return 0

    // Use a for loop to avoid recursion
    var loweredCase = false;
    for (;;) {
      switch (encoding) {
        case 'ascii':
        case 'latin1':
        case 'binary':
          return len
        case 'utf8':
        case 'utf-8':
        case undefined:
          return utf8ToBytes(string).length
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return len * 2
        case 'hex':
          return len >>> 1
        case 'base64':
          return base64ToBytes(string).length
        default:
          if (loweredCase) return utf8ToBytes(string).length // assume utf8
          encoding = ('' + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer.byteLength = byteLength;

  function slowToString (encoding, start, end) {
    var loweredCase = false;

    // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
    // property of a typed array.

    // This behaves neither like String nor Uint8Array in that we set start/end
    // to their upper/lower bounds if the value passed is out of range.
    // undefined is handled specially as per ECMA-262 6th Edition,
    // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
    if (start === undefined || start < 0) {
      start = 0;
    }
    // Return early if start > this.length. Done here to prevent potential uint32
    // coercion fail below.
    if (start > this.length) {
      return ''
    }

    if (end === undefined || end > this.length) {
      end = this.length;
    }

    if (end <= 0) {
      return ''
    }

    // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
    end >>>= 0;
    start >>>= 0;

    if (end <= start) {
      return ''
    }

    if (!encoding) encoding = 'utf8';

    while (true) {
      switch (encoding) {
        case 'hex':
          return hexSlice(this, start, end)

        case 'utf8':
        case 'utf-8':
          return utf8Slice(this, start, end)

        case 'ascii':
          return asciiSlice(this, start, end)

        case 'latin1':
        case 'binary':
          return latin1Slice(this, start, end)

        case 'base64':
          return base64Slice(this, start, end)

        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return utf16leSlice(this, start, end)

        default:
          if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
          encoding = (encoding + '').toLowerCase();
          loweredCase = true;
      }
    }
  }

  // The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
  // Buffer instances.
  Buffer.prototype._isBuffer = true;

  function swap (b, n, m) {
    var i = b[n];
    b[n] = b[m];
    b[m] = i;
  }

  Buffer.prototype.swap16 = function swap16 () {
    var len = this.length;
    if (len % 2 !== 0) {
      throw new RangeError('Buffer size must be a multiple of 16-bits')
    }
    for (var i = 0; i < len; i += 2) {
      swap(this, i, i + 1);
    }
    return this
  };

  Buffer.prototype.swap32 = function swap32 () {
    var len = this.length;
    if (len % 4 !== 0) {
      throw new RangeError('Buffer size must be a multiple of 32-bits')
    }
    for (var i = 0; i < len; i += 4) {
      swap(this, i, i + 3);
      swap(this, i + 1, i + 2);
    }
    return this
  };

  Buffer.prototype.swap64 = function swap64 () {
    var len = this.length;
    if (len % 8 !== 0) {
      throw new RangeError('Buffer size must be a multiple of 64-bits')
    }
    for (var i = 0; i < len; i += 8) {
      swap(this, i, i + 7);
      swap(this, i + 1, i + 6);
      swap(this, i + 2, i + 5);
      swap(this, i + 3, i + 4);
    }
    return this
  };

  Buffer.prototype.toString = function toString () {
    var length = this.length | 0;
    if (length === 0) return ''
    if (arguments.length === 0) return utf8Slice(this, 0, length)
    return slowToString.apply(this, arguments)
  };

  Buffer.prototype.equals = function equals (b) {
    if (!internalIsBuffer(b)) throw new TypeError('Argument must be a Buffer')
    if (this === b) return true
    return Buffer.compare(this, b) === 0
  };

  Buffer.prototype.inspect = function inspect () {
    var str = '';
    var max = INSPECT_MAX_BYTES;
    if (this.length > 0) {
      str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
      if (this.length > max) str += ' ... ';
    }
    return '<Buffer ' + str + '>'
  };

  Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
    if (!internalIsBuffer(target)) {
      throw new TypeError('Argument must be a Buffer')
    }

    if (start === undefined) {
      start = 0;
    }
    if (end === undefined) {
      end = target ? target.length : 0;
    }
    if (thisStart === undefined) {
      thisStart = 0;
    }
    if (thisEnd === undefined) {
      thisEnd = this.length;
    }

    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
      throw new RangeError('out of range index')
    }

    if (thisStart >= thisEnd && start >= end) {
      return 0
    }
    if (thisStart >= thisEnd) {
      return -1
    }
    if (start >= end) {
      return 1
    }

    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;

    if (this === target) return 0

    var x = thisEnd - thisStart;
    var y = end - start;
    var len = Math.min(x, y);

    var thisCopy = this.slice(thisStart, thisEnd);
    var targetCopy = target.slice(start, end);

    for (var i = 0; i < len; ++i) {
      if (thisCopy[i] !== targetCopy[i]) {
        x = thisCopy[i];
        y = targetCopy[i];
        break
      }
    }

    if (x < y) return -1
    if (y < x) return 1
    return 0
  };

  // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
  // OR the last index of `val` in `buffer` at offset <= `byteOffset`.
  //
  // Arguments:
  // - buffer - a Buffer to search
  // - val - a string, Buffer, or number
  // - byteOffset - an index into `buffer`; will be clamped to an int32
  // - encoding - an optional encoding, relevant is val is a string
  // - dir - true for indexOf, false for lastIndexOf
  function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
    // Empty buffer means no match
    if (buffer.length === 0) return -1

    // Normalize byteOffset
    if (typeof byteOffset === 'string') {
      encoding = byteOffset;
      byteOffset = 0;
    } else if (byteOffset > 0x7fffffff) {
      byteOffset = 0x7fffffff;
    } else if (byteOffset < -0x80000000) {
      byteOffset = -0x80000000;
    }
    byteOffset = +byteOffset;  // Coerce to Number.
    if (isNaN(byteOffset)) {
      // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
      byteOffset = dir ? 0 : (buffer.length - 1);
    }

    // Normalize byteOffset: negative offsets start from the end of the buffer
    if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
    if (byteOffset >= buffer.length) {
      if (dir) return -1
      else byteOffset = buffer.length - 1;
    } else if (byteOffset < 0) {
      if (dir) byteOffset = 0;
      else return -1
    }

    // Normalize val
    if (typeof val === 'string') {
      val = Buffer.from(val, encoding);
    }

    // Finally, search either indexOf (if dir is true) or lastIndexOf
    if (internalIsBuffer(val)) {
      // Special case: looking for empty string/buffer always fails
      if (val.length === 0) {
        return -1
      }
      return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
    } else if (typeof val === 'number') {
      val = val & 0xFF; // Search for a byte value [0-255]
      if (Buffer.TYPED_ARRAY_SUPPORT &&
          typeof Uint8Array.prototype.indexOf === 'function') {
        if (dir) {
          return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
        } else {
          return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
        }
      }
      return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
    }

    throw new TypeError('val must be string, number or Buffer')
  }

  function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
    var indexSize = 1;
    var arrLength = arr.length;
    var valLength = val.length;

    if (encoding !== undefined) {
      encoding = String(encoding).toLowerCase();
      if (encoding === 'ucs2' || encoding === 'ucs-2' ||
          encoding === 'utf16le' || encoding === 'utf-16le') {
        if (arr.length < 2 || val.length < 2) {
          return -1
        }
        indexSize = 2;
        arrLength /= 2;
        valLength /= 2;
        byteOffset /= 2;
      }
    }

    function read (buf, i) {
      if (indexSize === 1) {
        return buf[i]
      } else {
        return buf.readUInt16BE(i * indexSize)
      }
    }

    var i;
    if (dir) {
      var foundIndex = -1;
      for (i = byteOffset; i < arrLength; i++) {
        if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
          if (foundIndex === -1) foundIndex = i;
          if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
        } else {
          if (foundIndex !== -1) i -= i - foundIndex;
          foundIndex = -1;
        }
      }
    } else {
      if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
      for (i = byteOffset; i >= 0; i--) {
        var found = true;
        for (var j = 0; j < valLength; j++) {
          if (read(arr, i + j) !== read(val, j)) {
            found = false;
            break
          }
        }
        if (found) return i
      }
    }

    return -1
  }

  Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1
  };

  Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
  };

  Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
  };

  function hexWrite (buf, string, offset, length) {
    offset = Number(offset) || 0;
    var remaining = buf.length - offset;
    if (!length) {
      length = remaining;
    } else {
      length = Number(length);
      if (length > remaining) {
        length = remaining;
      }
    }

    // must be an even number of digits
    var strLen = string.length;
    if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

    if (length > strLen / 2) {
      length = strLen / 2;
    }
    for (var i = 0; i < length; ++i) {
      var parsed = parseInt(string.substr(i * 2, 2), 16);
      if (isNaN(parsed)) return i
      buf[offset + i] = parsed;
    }
    return i
  }

  function utf8Write (buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
  }

  function asciiWrite (buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length)
  }

  function latin1Write (buf, string, offset, length) {
    return asciiWrite(buf, string, offset, length)
  }

  function base64Write (buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length)
  }

  function ucs2Write (buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
  }

  Buffer.prototype.write = function write (string, offset, length, encoding) {
    // Buffer#write(string)
    if (offset === undefined) {
      encoding = 'utf8';
      length = this.length;
      offset = 0;
    // Buffer#write(string, encoding)
    } else if (length === undefined && typeof offset === 'string') {
      encoding = offset;
      length = this.length;
      offset = 0;
    // Buffer#write(string, offset[, length][, encoding])
    } else if (isFinite(offset)) {
      offset = offset | 0;
      if (isFinite(length)) {
        length = length | 0;
        if (encoding === undefined) encoding = 'utf8';
      } else {
        encoding = length;
        length = undefined;
      }
    // legacy write(string, encoding, offset, length) - remove in v0.13
    } else {
      throw new Error(
        'Buffer.write(string, encoding, offset[, length]) is no longer supported'
      )
    }

    var remaining = this.length - offset;
    if (length === undefined || length > remaining) length = remaining;

    if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
      throw new RangeError('Attempt to write outside buffer bounds')
    }

    if (!encoding) encoding = 'utf8';

    var loweredCase = false;
    for (;;) {
      switch (encoding) {
        case 'hex':
          return hexWrite(this, string, offset, length)

        case 'utf8':
        case 'utf-8':
          return utf8Write(this, string, offset, length)

        case 'ascii':
          return asciiWrite(this, string, offset, length)

        case 'latin1':
        case 'binary':
          return latin1Write(this, string, offset, length)

        case 'base64':
          // Warning: maxLength not taken into account in base64Write
          return base64Write(this, string, offset, length)

        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return ucs2Write(this, string, offset, length)

        default:
          if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
          encoding = ('' + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  };

  Buffer.prototype.toJSON = function toJSON () {
    return {
      type: 'Buffer',
      data: Array.prototype.slice.call(this._arr || this, 0)
    }
  };

  function base64Slice (buf, start, end) {
    if (start === 0 && end === buf.length) {
      return fromByteArray(buf)
    } else {
      return fromByteArray(buf.slice(start, end))
    }
  }

  function utf8Slice (buf, start, end) {
    end = Math.min(buf.length, end);
    var res = [];

    var i = start;
    while (i < end) {
      var firstByte = buf[i];
      var codePoint = null;
      var bytesPerSequence = (firstByte > 0xEF) ? 4
        : (firstByte > 0xDF) ? 3
        : (firstByte > 0xBF) ? 2
        : 1;

      if (i + bytesPerSequence <= end) {
        var secondByte, thirdByte, fourthByte, tempCodePoint;

        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 0x80) {
              codePoint = firstByte;
            }
            break
          case 2:
            secondByte = buf[i + 1];
            if ((secondByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);
              if (tempCodePoint > 0x7F) {
                codePoint = tempCodePoint;
              }
            }
            break
          case 3:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);
              if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                codePoint = tempCodePoint;
              }
            }
            break
          case 4:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            fourthByte = buf[i + 3];
            if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);
              if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                codePoint = tempCodePoint;
              }
            }
        }
      }

      if (codePoint === null) {
        // we did not generate a valid codePoint so insert a
        // replacement char (U+FFFD) and advance only 1 byte
        codePoint = 0xFFFD;
        bytesPerSequence = 1;
      } else if (codePoint > 0xFFFF) {
        // encode to utf16 (surrogate pair dance)
        codePoint -= 0x10000;
        res.push(codePoint >>> 10 & 0x3FF | 0xD800);
        codePoint = 0xDC00 | codePoint & 0x3FF;
      }

      res.push(codePoint);
      i += bytesPerSequence;
    }

    return decodeCodePointsArray(res)
  }

  // Based on http://stackoverflow.com/a/22747272/680742, the browser with
  // the lowest limit is Chrome, with 0x10000 args.
  // We go 1 magnitude less, for safety
  var MAX_ARGUMENTS_LENGTH = 0x1000;

  function decodeCodePointsArray (codePoints) {
    var len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
    }

    // Decode in chunks to avoid "call stack size exceeded".
    var res = '';
    var i = 0;
    while (i < len) {
      res += String.fromCharCode.apply(
        String,
        codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
      );
    }
    return res
  }

  function asciiSlice (buf, start, end) {
    var ret = '';
    end = Math.min(buf.length, end);

    for (var i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i] & 0x7F);
    }
    return ret
  }

  function latin1Slice (buf, start, end) {
    var ret = '';
    end = Math.min(buf.length, end);

    for (var i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i]);
    }
    return ret
  }

  function hexSlice (buf, start, end) {
    var len = buf.length;

    if (!start || start < 0) start = 0;
    if (!end || end < 0 || end > len) end = len;

    var out = '';
    for (var i = start; i < end; ++i) {
      out += toHex(buf[i]);
    }
    return out
  }

  function utf16leSlice (buf, start, end) {
    var bytes = buf.slice(start, end);
    var res = '';
    for (var i = 0; i < bytes.length; i += 2) {
      res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    }
    return res
  }

  Buffer.prototype.slice = function slice (start, end) {
    var len = this.length;
    start = ~~start;
    end = end === undefined ? len : ~~end;

    if (start < 0) {
      start += len;
      if (start < 0) start = 0;
    } else if (start > len) {
      start = len;
    }

    if (end < 0) {
      end += len;
      if (end < 0) end = 0;
    } else if (end > len) {
      end = len;
    }

    if (end < start) end = start;

    var newBuf;
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      newBuf = this.subarray(start, end);
      newBuf.__proto__ = Buffer.prototype;
    } else {
      var sliceLen = end - start;
      newBuf = new Buffer(sliceLen, undefined);
      for (var i = 0; i < sliceLen; ++i) {
        newBuf[i] = this[i + start];
      }
    }

    return newBuf
  };

  /*
   * Need to make sure that buffer isn't trying to write out of bounds.
   */
  function checkOffset (offset, ext, length) {
    if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
    if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
  }

  Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);

    var val = this[offset];
    var mul = 1;
    var i = 0;
    while (++i < byteLength && (mul *= 0x100)) {
      val += this[offset + i] * mul;
    }

    return val
  };

  Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) {
      checkOffset(offset, byteLength, this.length);
    }

    var val = this[offset + --byteLength];
    var mul = 1;
    while (byteLength > 0 && (mul *= 0x100)) {
      val += this[offset + --byteLength] * mul;
    }

    return val
  };

  Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 1, this.length);
    return this[offset]
  };

  Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] | (this[offset + 1] << 8)
  };

  Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 2, this.length);
    return (this[offset] << 8) | this[offset + 1]
  };

  Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);

    return ((this[offset]) |
        (this[offset + 1] << 8) |
        (this[offset + 2] << 16)) +
        (this[offset + 3] * 0x1000000)
  };

  Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);

    return (this[offset] * 0x1000000) +
      ((this[offset + 1] << 16) |
      (this[offset + 2] << 8) |
      this[offset + 3])
  };

  Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);

    var val = this[offset];
    var mul = 1;
    var i = 0;
    while (++i < byteLength && (mul *= 0x100)) {
      val += this[offset + i] * mul;
    }
    mul *= 0x80;

    if (val >= mul) val -= Math.pow(2, 8 * byteLength);

    return val
  };

  Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);

    var i = byteLength;
    var mul = 1;
    var val = this[offset + --i];
    while (i > 0 && (mul *= 0x100)) {
      val += this[offset + --i] * mul;
    }
    mul *= 0x80;

    if (val >= mul) val -= Math.pow(2, 8 * byteLength);

    return val
  };

  Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 1, this.length);
    if (!(this[offset] & 0x80)) return (this[offset])
    return ((0xff - this[offset] + 1) * -1)
  };

  Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 2, this.length);
    var val = this[offset] | (this[offset + 1] << 8);
    return (val & 0x8000) ? val | 0xFFFF0000 : val
  };

  Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 2, this.length);
    var val = this[offset + 1] | (this[offset] << 8);
    return (val & 0x8000) ? val | 0xFFFF0000 : val
  };

  Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);

    return (this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16) |
      (this[offset + 3] << 24)
  };

  Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);

    return (this[offset] << 24) |
      (this[offset + 1] << 16) |
      (this[offset + 2] << 8) |
      (this[offset + 3])
  };

  Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);
    return read(this, offset, true, 23, 4)
  };

  Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);
    return read(this, offset, false, 23, 4)
  };

  Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 8, this.length);
    return read(this, offset, true, 52, 8)
  };

  Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 8, this.length);
    return read(this, offset, false, 52, 8)
  };

  function checkInt (buf, value, offset, ext, max, min) {
    if (!internalIsBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
    if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
    if (offset + ext > buf.length) throw new RangeError('Index out of range')
  }

  Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) {
      var maxBytes = Math.pow(2, 8 * byteLength) - 1;
      checkInt(this, value, offset, byteLength, maxBytes, 0);
    }

    var mul = 1;
    var i = 0;
    this[offset] = value & 0xFF;
    while (++i < byteLength && (mul *= 0x100)) {
      this[offset + i] = (value / mul) & 0xFF;
    }

    return offset + byteLength
  };

  Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) {
      var maxBytes = Math.pow(2, 8 * byteLength) - 1;
      checkInt(this, value, offset, byteLength, maxBytes, 0);
    }

    var i = byteLength - 1;
    var mul = 1;
    this[offset + i] = value & 0xFF;
    while (--i >= 0 && (mul *= 0x100)) {
      this[offset + i] = (value / mul) & 0xFF;
    }

    return offset + byteLength
  };

  Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
    if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
    this[offset] = (value & 0xff);
    return offset + 1
  };

  function objectWriteUInt16 (buf, value, offset, littleEndian) {
    if (value < 0) value = 0xffff + value + 1;
    for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
      buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
        (littleEndian ? i : 1 - i) * 8;
    }
  }

  Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value & 0xff);
      this[offset + 1] = (value >>> 8);
    } else {
      objectWriteUInt16(this, value, offset, true);
    }
    return offset + 2
  };

  Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value >>> 8);
      this[offset + 1] = (value & 0xff);
    } else {
      objectWriteUInt16(this, value, offset, false);
    }
    return offset + 2
  };

  function objectWriteUInt32 (buf, value, offset, littleEndian) {
    if (value < 0) value = 0xffffffff + value + 1;
    for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
      buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff;
    }
  }

  Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset + 3] = (value >>> 24);
      this[offset + 2] = (value >>> 16);
      this[offset + 1] = (value >>> 8);
      this[offset] = (value & 0xff);
    } else {
      objectWriteUInt32(this, value, offset, true);
    }
    return offset + 4
  };

  Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value >>> 24);
      this[offset + 1] = (value >>> 16);
      this[offset + 2] = (value >>> 8);
      this[offset + 3] = (value & 0xff);
    } else {
      objectWriteUInt32(this, value, offset, false);
    }
    return offset + 4
  };

  Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength - 1);

      checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }

    var i = 0;
    var mul = 1;
    var sub = 0;
    this[offset] = value & 0xFF;
    while (++i < byteLength && (mul *= 0x100)) {
      if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
        sub = 1;
      }
      this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
    }

    return offset + byteLength
  };

  Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength - 1);

      checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }

    var i = byteLength - 1;
    var mul = 1;
    var sub = 0;
    this[offset + i] = value & 0xFF;
    while (--i >= 0 && (mul *= 0x100)) {
      if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
        sub = 1;
      }
      this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
    }

    return offset + byteLength
  };

  Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
    if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
    if (value < 0) value = 0xff + value + 1;
    this[offset] = (value & 0xff);
    return offset + 1
  };

  Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value & 0xff);
      this[offset + 1] = (value >>> 8);
    } else {
      objectWriteUInt16(this, value, offset, true);
    }
    return offset + 2
  };

  Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value >>> 8);
      this[offset + 1] = (value & 0xff);
    } else {
      objectWriteUInt16(this, value, offset, false);
    }
    return offset + 2
  };

  Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value & 0xff);
      this[offset + 1] = (value >>> 8);
      this[offset + 2] = (value >>> 16);
      this[offset + 3] = (value >>> 24);
    } else {
      objectWriteUInt32(this, value, offset, true);
    }
    return offset + 4
  };

  Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
    if (value < 0) value = 0xffffffff + value + 1;
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value >>> 24);
      this[offset + 1] = (value >>> 16);
      this[offset + 2] = (value >>> 8);
      this[offset + 3] = (value & 0xff);
    } else {
      objectWriteUInt32(this, value, offset, false);
    }
    return offset + 4
  };

  function checkIEEE754 (buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length) throw new RangeError('Index out of range')
    if (offset < 0) throw new RangeError('Index out of range')
  }

  function writeFloat (buf, value, offset, littleEndian, noAssert) {
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 4);
    }
    write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4
  }

  Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert)
  };

  Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert)
  };

  function writeDouble (buf, value, offset, littleEndian, noAssert) {
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 8);
    }
    write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8
  }

  Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert)
  };

  Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert)
  };

  // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
  Buffer.prototype.copy = function copy (target, targetStart, start, end) {
    if (!start) start = 0;
    if (!end && end !== 0) end = this.length;
    if (targetStart >= target.length) targetStart = target.length;
    if (!targetStart) targetStart = 0;
    if (end > 0 && end < start) end = start;

    // Copy 0 bytes; we're done
    if (end === start) return 0
    if (target.length === 0 || this.length === 0) return 0

    // Fatal error conditions
    if (targetStart < 0) {
      throw new RangeError('targetStart out of bounds')
    }
    if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
    if (end < 0) throw new RangeError('sourceEnd out of bounds')

    // Are we oob?
    if (end > this.length) end = this.length;
    if (target.length - targetStart < end - start) {
      end = target.length - targetStart + start;
    }

    var len = end - start;
    var i;

    if (this === target && start < targetStart && targetStart < end) {
      // descending copy from end
      for (i = len - 1; i >= 0; --i) {
        target[i + targetStart] = this[i + start];
      }
    } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
      // ascending copy from start
      for (i = 0; i < len; ++i) {
        target[i + targetStart] = this[i + start];
      }
    } else {
      Uint8Array.prototype.set.call(
        target,
        this.subarray(start, start + len),
        targetStart
      );
    }

    return len
  };

  // Usage:
  //    buffer.fill(number[, offset[, end]])
  //    buffer.fill(buffer[, offset[, end]])
  //    buffer.fill(string[, offset[, end]][, encoding])
  Buffer.prototype.fill = function fill (val, start, end, encoding) {
    // Handle string cases:
    if (typeof val === 'string') {
      if (typeof start === 'string') {
        encoding = start;
        start = 0;
        end = this.length;
      } else if (typeof end === 'string') {
        encoding = end;
        end = this.length;
      }
      if (val.length === 1) {
        var code = val.charCodeAt(0);
        if (code < 256) {
          val = code;
        }
      }
      if (encoding !== undefined && typeof encoding !== 'string') {
        throw new TypeError('encoding must be a string')
      }
      if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
        throw new TypeError('Unknown encoding: ' + encoding)
      }
    } else if (typeof val === 'number') {
      val = val & 255;
    }

    // Invalid ranges are not set to a default, so can range check early.
    if (start < 0 || this.length < start || this.length < end) {
      throw new RangeError('Out of range index')
    }

    if (end <= start) {
      return this
    }

    start = start >>> 0;
    end = end === undefined ? this.length : end >>> 0;

    if (!val) val = 0;

    var i;
    if (typeof val === 'number') {
      for (i = start; i < end; ++i) {
        this[i] = val;
      }
    } else {
      var bytes = internalIsBuffer(val)
        ? val
        : utf8ToBytes(new Buffer(val, encoding).toString());
      var len = bytes.length;
      for (i = 0; i < end - start; ++i) {
        this[i + start] = bytes[i % len];
      }
    }

    return this
  };

  // HELPER FUNCTIONS
  // ================

  var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

  function base64clean (str) {
    // Node strips out invalid characters like \n and \t from the string, base64-js does not
    str = stringtrim(str).replace(INVALID_BASE64_RE, '');
    // Node converts strings with length < 2 to ''
    if (str.length < 2) return ''
    // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
    while (str.length % 4 !== 0) {
      str = str + '=';
    }
    return str
  }

  function stringtrim (str) {
    if (str.trim) return str.trim()
    return str.replace(/^\s+|\s+$/g, '')
  }

  function toHex (n) {
    if (n < 16) return '0' + n.toString(16)
    return n.toString(16)
  }

  function utf8ToBytes (string, units) {
    units = units || Infinity;
    var codePoint;
    var length = string.length;
    var leadSurrogate = null;
    var bytes = [];

    for (var i = 0; i < length; ++i) {
      codePoint = string.charCodeAt(i);

      // is surrogate component
      if (codePoint > 0xD7FF && codePoint < 0xE000) {
        // last char was a lead
        if (!leadSurrogate) {
          // no lead yet
          if (codePoint > 0xDBFF) {
            // unexpected trail
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
            continue
          } else if (i + 1 === length) {
            // unpaired lead
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
            continue
          }

          // valid lead
          leadSurrogate = codePoint;

          continue
        }

        // 2 leads in a row
        if (codePoint < 0xDC00) {
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          leadSurrogate = codePoint;
          continue
        }

        // valid surrogate pair
        codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
      } else if (leadSurrogate) {
        // valid bmp char, but last char was a lead
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
      }

      leadSurrogate = null;

      // encode utf8
      if (codePoint < 0x80) {
        if ((units -= 1) < 0) break
        bytes.push(codePoint);
      } else if (codePoint < 0x800) {
        if ((units -= 2) < 0) break
        bytes.push(
          codePoint >> 0x6 | 0xC0,
          codePoint & 0x3F | 0x80
        );
      } else if (codePoint < 0x10000) {
        if ((units -= 3) < 0) break
        bytes.push(
          codePoint >> 0xC | 0xE0,
          codePoint >> 0x6 & 0x3F | 0x80,
          codePoint & 0x3F | 0x80
        );
      } else if (codePoint < 0x110000) {
        if ((units -= 4) < 0) break
        bytes.push(
          codePoint >> 0x12 | 0xF0,
          codePoint >> 0xC & 0x3F | 0x80,
          codePoint >> 0x6 & 0x3F | 0x80,
          codePoint & 0x3F | 0x80
        );
      } else {
        throw new Error('Invalid code point')
      }
    }

    return bytes
  }

  function asciiToBytes (str) {
    var byteArray = [];
    for (var i = 0; i < str.length; ++i) {
      // Node's code seems to be doing this and not & 0x7F..
      byteArray.push(str.charCodeAt(i) & 0xFF);
    }
    return byteArray
  }

  function utf16leToBytes (str, units) {
    var c, hi, lo;
    var byteArray = [];
    for (var i = 0; i < str.length; ++i) {
      if ((units -= 2) < 0) break

      c = str.charCodeAt(i);
      hi = c >> 8;
      lo = c % 256;
      byteArray.push(lo);
      byteArray.push(hi);
    }

    return byteArray
  }


  function base64ToBytes (str) {
    return toByteArray(base64clean(str))
  }

  function blitBuffer (src, dst, offset, length) {
    for (var i = 0; i < length; ++i) {
      if ((i + offset >= dst.length) || (i >= src.length)) break
      dst[i + offset] = src[i];
    }
    return i
  }

  function isnan (val) {
    return val !== val // eslint-disable-line no-self-compare
  }


  // the following is from is-buffer, also by Feross Aboukhadijeh and with same lisence
  // The _isBuffer check is for Safari 5-7 support, because it's missing
  // Object.prototype.constructor. Remove this eventually
  function isBuffer$1(obj) {
    return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj))
  }

  function isFastBuffer (obj) {
    return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
  }

  // For Node v0.10 support. Remove this eventually.
  function isSlowBuffer (obj) {
    return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isFastBuffer(obj.slice(0, 0))
  }

  function isNumber$2(arg) {
    return typeof arg === 'number';
  }

  var WXRequest =
  /*#__PURE__*/
  function (_ConnectionBase) {
    _inherits(WXRequest, _ConnectionBase);

    function WXRequest() {
      var _this;

      _classCallCheck(this, WXRequest);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(WXRequest).call(this));
      _this.retry = 2; // 重试次数

      _this._request = _this.promisify(wx.request);
      return _this;
    }
    /**
     * 提交异步请求
     * @param {Object} options 配置
     * @param {String} options.url string 是 开发者服务器接口地址
     * @param {*} options.data - string/object/ArrayBuffer 否 请求的参数
     * @param {Object} options.header Object 否 设置请求的 header，header 中不能设置 Referer。
     * @param {String} options.method string GET 否 HTTP 请求方法
     * @param {String} options.dataType string json 否 返回的数据格式
     * @param {String} options.responseType string text 否 响应的数据类型 1.7.0
     * @returns {Promise}
     */


    _createClass(WXRequest, [{
      key: "request",
      value: function request(options) {
        this._checkOptions(options);

        this._initOptions(options);

        options = _objectSpread2({}, options, {
          responseType: 'text'
        });
        return this._requestWithRetry(options);
      }
    }, {
      key: "_requestWithRetry",
      value: function _requestWithRetry(options) {
        var _this2 = this;

        var retryCount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        return this._request(options).then(this._handleResolve)["catch"](function (error) {
          if (isString(error.errMsg)) {
            // 主动中断请求
            if (error.errMsg.includes('abort')) {
              return IMPromise.resolve({});
            } // 请求超时


            if (error.errMsg.includes('timeout')) {
              // 自动重试
              if (_this2.retry > 0 && retryCount < _this2.retry) {
                return _this2._requestWithRetry(options, ++retryCount);
              }

              return IMPromise.reject(new IMError({
                code: ERROR_CODE.NETWORK_TIMEOUT,
                message: error.errMsg
              }));
            } // 请求失败


            if (error.errMsg.includes('fail')) {
              // 自动重试
              if (_this2.retry > 0 && retryCount < _this2.retry) {
                return _this2._requestWithRetry(options, ++retryCount);
              }

              return IMPromise.reject(new IMError({
                code: ERROR_CODE.NETWORK_ERROR,
                message: error.errMsg
              }));
            }
          }

          return IMPromise.reject(new IMError(_objectSpread2({
            code: ERROR_CODE.UNCAUGHT_ERROR,
            message: error.message
          }, error)));
        });
      }
    }, {
      key: "_handleResolve",
      value: function _handleResolve(response) {
        // eslint-disable-next-line camelcase
        var _response$data = response.data,
            error_code = _response$data.error_code,
            ErrorCode = _response$data.ErrorCode; // 气人，有两种errorCode 名称…… fuck x 2

        var errorCode = ErrorCode;

        if (isNumber$2(error_code)) {
          // eslint-disable-next-line camelcase
          errorCode = error_code;
        }

        if (errorCode !== TIM_STATUS.REQUEST.SUCCESS) {
          response.data.ErrorCode = Number("".concat(errorCode));
        }

        return response;
      }
    }, {
      key: "promisify",
      value: function promisify(api) {
        return function (options) {
          return new Promise(function (resolve, reject) {
            var task = api(Object.assign({}, options, {
              success: resolve,
              fail: reject
            }));

            if (options.updateAbort) {
              options.updateAbort(function () {
                if (task && isFunction(task.abort)) {
                  task.abort();
                }
              });
            }
          });
        };
      }
    }]);

    return WXRequest;
  }(ConnectionBase);

  var RunLoopStats =
  /*#__PURE__*/
  function () {
    function RunLoopStats() {
      _classCallCheck(this, RunLoopStats);

      this.request = 0; // 请求次数

      this.success = 0; // 成功次数

      this.fail = 0; // 失败次数

      this.reportRate = 10; // 10次轮询报告一次

      this.requestTimeCost = []; // 每次请求花费的时间
    }

    _createClass(RunLoopStats, [{
      key: "report",
      value: function report() {
        if (this.request === 1) {
          return;
        }

        if (this.request % this.reportRate !== 0) {
          return null;
        }

        var avgTime = this.avgRequestTime();
        var string = "runLoop reports: success=".concat(this.success, ",fail=").concat(this.fail, ",total=").concat(this.request, ",avg=").concat(avgTime, ",cur=").concat(this.requestTimeCost[this.requestTimeCost.length - 1], ",max=").concat(Math.max.apply(null, this.requestTimeCost), ",min=").concat(Math.min.apply(null, this.requestTimeCost)); // this.reset();

        logger.log(string);
      }
    }, {
      key: "setRequestTime",
      value: function setRequestTime(t1, t2) {
        var diff = Math.abs(t2 - t1);

        if (this.requestTimeCost.length === 100) {
          this.requestTimeCost.shift();
        }

        this.requestTimeCost.push(diff);
      }
    }, {
      key: "avgRequestTime",
      value: function avgRequestTime() {
        var len = this.requestTimeCost.length;
        var sum = 0;
        var avg = 0;

        for (var i = 0; i < len; i++) {
          sum += this.requestTimeCost[i];
        }

        avg = sum / len;
        return Math.round(avg * 100) / 100;
      }
    }]);

    return RunLoopStats;
  }();

  var IMAxiosAVChatroom = axios$1.create({
    timeout: 6000,
    headers: {
      'Content-Type': 'application/x-www-form-urlencoded;charset=UTF-8'
    }
  }); // IMAxios.defaults.withCredentials = true; // - 暂时不打开 ， 服务端还不支持 `Access-Controller-Allow-Credentials`

  IMAxiosAVChatroom.interceptors.response.use(function (response) {
    // eslint-disable-next-line camelcase
    var _response$data = response.data,
        error_code = _response$data.error_code,
        ErrorCode = _response$data.ErrorCode; // 气人，有两种errorCode 名称…… fuck x 2

    var errorCode = ErrorCode;

    if (isNumber(error_code)) {
      // eslint-disable-next-line camelcase
      errorCode = error_code;
    }

    if (errorCode !== TIM_STATUS.REQUEST.SUCCESS) {
      response.data.ErrorCode = Number(errorCode); // 维持服务端错误码不变 qiaoyang
    }

    return response;
  }, function (error) {
    if (error.message === 'Network Error') {
      if (IMAxiosAVChatroom.defaults.withCredentials === true) {
        logger.warn('Network Error, try to close `IMAxiosAVChatroom.defaults.withCredentials` to false. (IMAxiosAVChatroom.js)');
      }

      IMAxiosAVChatroom.defaults.withCredentials = false;
    }

    return Promise.reject(error);
  });

  var CancelToken$1 = axios$1.CancelToken;

  var XHRRunLoop =
  /*#__PURE__*/
  function () {
    /**
     *
     * @param {*} options
     * @param {Function} options.before - 回调函数，此函数会在每次请求发出前执行
     * @param {Function} options.success - 成功回调函数，此函数会在请求成功后执行
     * @param {Function} options.fail - 失败回调函数，此函数会在网络请求失败后执行
     */
    function XHRRunLoop(options) {
      _classCallCheck(this, XHRRunLoop);

      this._initializeOptions(options);

      this._initializeMembers();

      this.status = new RunLoopStats();
    }
    /**
     * 自我销毁，并反回索引
     * @returns {Number} index
     */


    _createClass(XHRRunLoop, [{
      key: "destructor",
      value: function destructor() {
        clearTimeout(this._seedID);

        var index = this._index();

        for (var p in this) {
          if (Object.prototype.hasOwnProperty.call(this, p)) {
            this[p] = null;
          }
        }

        return index;
      }
      /**
       * 记录一下自己实例的索引
       * @param {*} value
       */

    }, {
      key: "setIndex",
      value: function setIndex(value) {
        this._index = value;
      }
      /**
       * 获取实例的索引
       */

    }, {
      key: "getIndex",
      value: function getIndex() {
        return this._index;
      }
    }, {
      key: "isRunning",
      value: function isRunning() {
        return !this._stoped;
      }
    }, {
      key: "_initializeOptions",
      value: function _initializeOptions(options) {
        this.options = options;
      }
    }, {
      key: "_initializeMembers",
      value: function _initializeMembers() {
        this._index = -1;
        this._seedID = 0;
        this._requestStatus = false;
        this._stoped = false;
        this._intervalTime = 0; // 本次拿到 reponse 后，到下一次请求发起的时间间隔，默认为0，但在服务器快速返回的情况下，会马上进行下一次请求，因此需要做控制，毫秒

        this._intervalIncreaseStep = 1000; // _intervalTime 每次步进的幅度，毫秒

        this._intervalDecreaseStep = 1000; // _intervalTime 每次步减的幅度，毫秒

        this._intervalTimeMax = 5000; // setTimeout的最大时间间隔，毫秒

        this._protectTimeout = 3000; // 设置一个保护值，防止服务器下发错误的值导致请求过于频繁，毫秒

        this._getNoticeSeq = this.options.getNoticeSeq;
        this._retryCount = 0;
        this._responseTime = Date.now();
        this._responseTimeThreshold = 2000; // 两次连续的 response 时差的阀值，大于这个阀值，当做正常请求，小于这个阀值，可能会引起爆炸式请求，会提高 _intervalTime 。毫秒

        if (this.options.isAVChatRoomLoop) {
          this.requestor = IMAxiosAVChatroom;
        } else {
          this.requestor = IMAxios;
        }

        logger.log("XHRRunLoop._initializeMembers isAVChatRoomLoop=".concat(this.options.isAVChatRoomLoop ? true : false));
        this.abort = null; // 取消当前请求
      }
    }, {
      key: "start",
      value: function start() {
        if (this._seedID !== 0) {
          logger.log('XHRRunLoop.start(), XHRRunLoop is running now, if you want to restart runLoop , please run "stop()" first.');
          return;
        }

        this._stoped = false;

        this._send();
      }
    }, {
      key: "_reset",
      value: function _reset() {
        logger.log('XHRRunLoop._reset(), reset long poll _intervalTime', this._intervalTime);
        this.stop();
        this.start();
      }
      /**
       * 加大请求间隔
       */

    }, {
      key: "_intervalTimeIncrease",
      value: function _intervalTimeIncrease() {
        if (this._intervalTime === this._responseTimeThreshold) {
          return;
        }

        if (this._intervalTime < this._responseTimeThreshold) {
          this._intervalTime += this._intervalIncreaseStep;
        }

        if (this._intervalTime > this._responseTimeThreshold) {
          this._intervalTime = this._responseTimeThreshold;
        }
      }
      /**
       * 减少请求间隔
       */

    }, {
      key: "_intervalTimeDecrease",
      value: function _intervalTimeDecrease() {
        if (this._intervalTime === 0) {
          return;
        }

        if (this._intervalTime > 0) {
          this._intervalTime -= this._intervalDecreaseStep;
        }

        if (this._intervalTime < 0) {
          this._intervalTime = 0;
        }
      }
      /**
       * 调整 _intervalTime 的大小， 频保
       */

    }, {
      key: "_intervalTimeAdjustment",
      value: function _intervalTimeAdjustment() {
        var timeNew = Date.now();
        var diffriece = Math.floor((timeNew - this._responseTime) / 100) * 100;

        if (diffriece <= this._responseTimeThreshold) {
          this._intervalTimeIncrease(); // logger.log(`WXRunLoop._intervalTimeAdjustment Increase:timeNew - _responseTime≈${diffriece}, IT/Threshold: ${this._intervalTime}/${this._responseTimeThreshold}`);

        } else {
          this._intervalTimeDecrease(); // logger.log(`WXRunLoop._intervalTimeAdjustment Decrease:timeNew - _responseTime≈${diffriece}, IT/Threshold: ${this._intervalTime}/${this._responseTimeThreshold}`);

        }

        this._responseTime = timeNew;
      }
      /**
       * 基于response.data 对频繁进行调整
       * @param {*} responseData
       */

    }, {
      key: "_intervalTimeAdjustmentBaseOnResponseData",
      value: function _intervalTimeAdjustmentBaseOnResponseData(responseData) {
        // 如果收到错误码，提高间隔，降低频率，反之慢慢降到0
        if (responseData.ErrorCode === TIM_STATUS.REQUEST.SUCCESS) {
          this._intervalTimeDecrease(); // logger.log(`WXRunLoop._intervalTimeAdjustmentBaseOnResponseData Decrease - errorCode: ${responseData.ErrorCode} , IT/Threshold: ${this._intervalTime}/${this._responseTimeThreshold}`);

        } else {
          this._intervalTimeIncrease(); // logger.log(`WXRunLoop._intervalTimeAdjustmentBaseOnResponseData Increase - errorCode: ${responseData.ErrorCode} , IT/Threshold: ${this._intervalTime}/${this._responseTimeThreshold}`);

        }
      }
      /**
       * 提交请求
       * @description `_send`函数请求执行的时间为：每`_intervalTime`秒执行一次，当`_requestStatus`为false时，才会提交请求，这样防止重复提交，防止网络请求没必要的`abort`
       */

    }, {
      key: "_send",
      value: function _send() {
        var _this = this;

        // 如果之前的请求还没有结论，不进行本次请求
        if (this._requestStatus === true) {
          return;
        }

        this._requestStatus = true;
        this.status.request++;

        if (typeof this.options.before === 'function') {
          this.options.before(this.options.pack.requestData);
        }

        var timeStart = Date.now();
        var timeEnd = 0;
        this.requestor.request({
          url: this.options.pack.getUrl(),
          data: this.options.pack.requestData,
          method: this.options.pack.method,
          // 参考axios 文档：https://github.com/axios/axios#cancellation
          cancelToken: new CancelToken$1(function (abort) {
            _this.abort = abort;
          })
        }).then(function (response) {
          _this._intervalTimeAdjustmentBaseOnResponseData.bind(_this)(response.data); // 基于 responseData 的频保


          _this._retryCount > 0 ? _this._retryCount = 0 : null; // 请求成功时，把this._retryCount归零

          _this.status.success++;
          timeEnd = Date.now();

          _this.status.setRequestTime(timeStart, timeEnd);

          response.data.timecost = timeEnd - timeStart; // 方便上层统计耗时

          if (typeof _this.options.success === 'function') {
            // 防止回调出错，用try catch 包起来
            try {
              _this.options.success({
                pack: _this.options.pack,
                error: false,
                data: _this.options.pack.callback(response.data) // 轮询返回体进行参数key转换

              });
            } catch (userError) {
              logger.warn('XHRRunLoop._send(), error:', userError);
            }
          }

          _this._requestStatus = false;

          if (_this._stoped === false) {
            _this._seedID = setTimeout(_this._send.bind(_this), _this._intervalTime);
          }

          _this.status.report();
        })["catch"](function (error) {
          _this.status.fail++;
          _this._retryCount++;

          _this._intervalTimeAdjustment.bind(_this)(); // 频保


          if (_this._stoped === false) {
            _this._seedID = setTimeout(_this._send.bind(_this), _this._intervalTime);
          }

          _this._requestStatus = false;

          if (typeof _this.options.fail === 'function' && typeof error.request !== 'undefined') {
            // 防止回调出错，用try catch 包起来
            try {
              _this.options.fail({
                pack: _this.options.pack,
                error: error,
                data: false
              });
            } catch (userError) {
              logger.warn('XHRRunLoop._send(), fail callback error:');
              logger.error(userError);
            }
          }

          timeEnd = Date.now();

          _this.status.setRequestTime(timeStart, timeEnd);

          _this.status.report();
        });
      }
      /**
       * 停止轮询
       */

    }, {
      key: "stop",
      value: function stop() {
        this._clearAllTimeOut();

        this._stoped = true;
      }
    }, {
      key: "_clearAllTimeOut",
      value: function _clearAllTimeOut() {
        clearTimeout(this._seedID);
        this._seedID = 0;
      }
    }]);

    return XHRRunLoop;
  }();

  var WXRunLoop =
  /*#__PURE__*/
  function () {
    /**
     *
     * @param {*} options
     * @param {Function} options.before - 回调函数，此函数会在每次请求发出前执行
     * @param {Function} options.success - 成功回调函数，此函数会在请求成功后执行
     * @param {Function} options.fail - 失败回调函数，此函数会在网络请求失败后执行
     */
    function WXRunLoop(options) {
      _classCallCheck(this, WXRunLoop);

      this._initializeOptions(options);

      this._initializeMembers();

      this.status = new RunLoopStats();
    }
    /**
     * 自我销毁，并反回索引
     * @returns {Number} index
     */


    _createClass(WXRunLoop, [{
      key: "destructor",
      value: function destructor() {
        clearTimeout(this._seedID);

        var index = this._index();

        for (var p in this) {
          if (Object.prototype.hasOwnProperty.call(this, p)) {
            this[p] = null;
          }
        }

        return index;
      }
      /**
       * 记录一下自己实例的索引
       * @param {*} value
       */

    }, {
      key: "setIndex",
      value: function setIndex(value) {
        this._index = value;
      }
    }, {
      key: "isRunning",
      value: function isRunning() {
        return !this._stoped;
      }
      /**
       * 获取实例的索引
       */

    }, {
      key: "getIndex",
      value: function getIndex() {
        return this._index;
      }
    }, {
      key: "_initializeOptions",
      value: function _initializeOptions(options) {
        this.options = options;
      }
    }, {
      key: "_initializeMembers",
      value: function _initializeMembers() {
        this._index = -1;
        this._seedID = 0;
        this._requestStatus = false;
        this._stoped = false;
        this._intervalTime = 0; // 本次拿到 reponse 后，到下一次请求发起的时间间隔，默认为0，但在服务器快速返回的情况下，会马上进行下一次请求，因此需要做控制，毫秒

        this._intervalIncreaseStep = 1000; // _intervalTime 每次步进的幅度，毫秒

        this._intervalDecreaseStep = 1000; // _intervalTime 每次步减的幅度，毫秒

        this._intervalTimeMax = 5000; // setTimeout的最大时间间隔，毫秒

        this._protectTimeout = 3000; // 设置一个保护值，防止服务器下发错误的值导致请求过于频繁，毫秒

        this._getNoticeSeq = this.options.getNoticeSeq;
        this._retryCount = 0;
        this._responseTime = Date.now();
        this._responseTimeThreshold = 2000; // 两次连续的 response 时差的阀值，大于这个阀值，当做正常请求，小于这个阀值，可能会引起爆炸式请求，会提高 _intervalTime 。毫秒

        this.requestor = new WXRequest(); // wx.request 的超时时间由 app.json 的 networkTimeout 控制，默认是60000

        this.abort = null; // 取消当前请求
      }
    }, {
      key: "start",
      value: function start() {
        if (this._seedID !== 0) {
          logger.log('WXRunLoop.start(): WXRunLoop is running now, if you want to restart runLoop , please run "stop()" first.');
          return;
        } // 这里暂时不使用递归，看看能不能减少一点函数调用栈


        this._stoped = false;

        this._send();
      }
    }, {
      key: "_reset",
      value: function _reset() {
        logger.log('WXRunLoop.reset(), long poll _intervalMaxRate', this._intervalMaxRate);
        this.stop();
        this.start();
      }
      /**
       * 加大请求间隔
       */

    }, {
      key: "_intervalTimeIncrease",
      value: function _intervalTimeIncrease() {
        if (this._intervalTime === this._responseTimeThreshold) {
          return;
        }

        if (this._intervalTime < this._responseTimeThreshold) {
          this._intervalTime += this._intervalIncreaseStep;
        }

        if (this._intervalTime > this._responseTimeThreshold) {
          this._intervalTime = this._responseTimeThreshold;
        }
      }
      /**
       * 减少请求间隔
       */

    }, {
      key: "_intervalTimeDecrease",
      value: function _intervalTimeDecrease() {
        if (this._intervalTime === 0) {
          return;
        }

        if (this._intervalTime > 0) {
          this._intervalTime -= this._intervalDecreaseStep;
        }

        if (this._intervalTime < 0) {
          this._intervalTime = 0;
        }
      }
      /**
       * 调整 _intervalTime 的大小， 频保
       */

    }, {
      key: "_intervalTimeAdjustment",
      value: function _intervalTimeAdjustment() {
        var timeNew = Date.now();
        var diffriece = Math.floor((timeNew - this._responseTime) / 100) * 100;

        if (diffriece <= this._responseTimeThreshold) {
          this._intervalTimeIncrease(); // logger.log(`WXRunLoop._intervalTimeAdjustment Increase timeNew - _responseTime≈${diffriece}, IT/Threshold: ${this._intervalTime}/${this._responseTimeThreshold}`);

        } else {
          this._intervalTimeDecrease(); // logger.log(`WXRunLoop._intervalTimeAdjustment Decrease timeNew - _responseTime≈${diffriece}, IT/Threshold: ${this._intervalTime}/${this._responseTimeThreshold}`);

        }

        this._responseTime = timeNew;
      }
      /**
       * 基于response.data 对频繁进行调整
       * @param {*} responseData
       */

    }, {
      key: "_intervalTimeAdjustmentBaseOnResponseData",
      value: function _intervalTimeAdjustmentBaseOnResponseData(responseData) {
        // 如果收到错误码，提高间隔，降低频率，反之慢慢降到0
        if (responseData.ErrorCode === TIM_STATUS.REQUEST.SUCCESS) {
          this._intervalTimeDecrease(); // logger.log(`WXRunLoop._intervalTimeAdjustmentBaseOnResponseData Decrease errorCode: ${responseData.ErrorCode} , IT/Threshold: ${this._intervalTime}/${this._responseTimeThreshold}`);

        } else {
          this._intervalTimeIncrease(); // logger.log(`WXRunLoop._intervalTimeAdjustmentBaseOnResponseData Increase errorCode: ${responseData.ErrorCode} , IT/Threshold: ${this._intervalTime}/${this._responseTimeThreshold}`);

        }
      }
      /**
       * 提交请求
       * @description `_send`函数请求执行的时间为：每`_intervalMaxRate`秒执行一次，当`_requestStatus`为false时，才会提交请求，这样防止重复提交，防止网络请求没必要的`abort`
       */

    }, {
      key: "_send",
      value: function _send() {
        var _this = this;

        if (this._requestStatus === true) {
          return;
        }

        var self = this;
        this._requestStatus = true;
        this.status.request++;

        if (typeof this.options.before === 'function') {
          this.options.before(self.options.pack.requestData);
        }

        var timeStart = Date.now();
        var timeEnd = 0; // 参考小程序文档：https://developers.weixin.qq.com/miniprogram/dev/api/network/request/RequestTask.html

        this.requestor.request({
          url: self.options.pack.getUrl(),
          data: self.options.pack.requestData,
          method: self.options.pack.method,
          updateAbort: function updateAbort(abort) {
            _this.abort = abort;
          }
        }).then(function (response) {
          self._intervalTimeAdjustmentBaseOnResponseData.bind(_this)(response.data); // 基于 responseData 的频保


          self._retryCount > 0 ? self._retryCount = 0 : null; // 请求成功时，把self._retryCount归零

          _this.status.success++;
          timeEnd = Date.now();

          _this.status.setRequestTime(timeStart, timeEnd);

          response.data.timecost = timeEnd - timeStart; // 方便上层统计耗时

          if (typeof self.options.success === 'function') {
            // 防止回调出错，用try catch 包起来
            try {
              _this.options.success({
                pack: _this.options.pack,
                error: false,
                data: _this.options.pack.callback(response.data) // 轮询返回体进行参数key转换

              });
            } catch (userError) {
              logger.warn('WXRunLoop._send(), error:', userError);
            }
          }

          self._requestStatus = false;

          if (self._stoped === false) {
            self._seedID = setTimeout(self._send.bind(self), self._intervalTime);
          }

          _this.status.report();
        })["catch"](function (error) {
          _this.status.fail++;
          self._retryCount++;

          self._intervalTimeAdjustment.bind(_this)(); // 频保


          if (self._stoped === false) {
            self._seedID = setTimeout(self._send.bind(self), self._intervalTime);
          }

          self._requestStatus = false;

          if (typeof self.options.fail === 'function') {
            // 防止回调出错，用try catch 包起来
            try {
              _this.options.fail({
                pack: _this.options.pack,
                error: error,
                data: false
              });
            } catch (userError) {
              logger.warn('WXRunLoop._send(), fail callback error:');
              logger.error(userError);
            }
          }

          timeEnd = Date.now();

          _this.status.setRequestTime(timeStart, timeEnd);

          _this.status.report();
        });
      }
      /**
       * 停止轮询
       */

    }, {
      key: "stop",
      value: function stop() {
        this._clearAllTimeOut();

        this._stoped = true;
      }
    }, {
      key: "_clearAllTimeOut",
      value: function _clearAllTimeOut() {
        clearTimeout(this._seedID);
        this._seedID = 0;
      }
    }]);

    return WXRunLoop;
  }();

  /**
   * 网络控制逻辑，不需要继承 IMController
   */

  var ConnectionController =
  /*#__PURE__*/
  function () {
    function ConnectionController(tim) {
      _classCallCheck(this, ConnectionController);

      this.tim = tim;

      if (IN_WX_MINI_APP) {
        this.httpConnection = new WXRequest();
      } else {
        this.httpConnection = new XHR();
      }

      this.keepAliveConnections = [];
    }

    _createClass(ConnectionController, [{
      key: "initializeListener",
      value: function initializeListener() {
        var innerEmitter = this.tim.innerEmitter;
        innerEmitter.on(TIM_INNER_EVENT.SIGN_LOGOUT_EXECUTING, this._stopAllRunLoop, this);
      }
    }, {
      key: "request",
      value: function request(pack) {
        var requestOption = {
          url: pack.url,
          data: pack.requestData,
          method: pack.method,
          callback: pack.callback
        };
        return this.httpConnection.request(requestOption).then(function (response) {
          // decode 和 convertor Key转换
          response.data = pack.callback(response.data);

          if (response.data.errorCode !== TIM_STATUS.REQUEST.SUCCESS) {
            return IMPromise.reject(new IMError({
              code: response.data.errorCode,
              message: response.data.errorInfo
            }));
          }

          return response;
        });
      }
      /**
       * 返回一个runLoop实例
       * @param {*} options
       * @param {Function} options.before - 发送前回调
       * @param {Function} options.success - 成功后回调
       * @param {Function} options.fail - 失败后回调
       * @example
       * let runLoop = connectionController.createRunLoop({
       *    before: function(){},
       *    success: function(){},
       *    fail: function(){}
       * })
       * runLoop.start(); // 启动轮询
       * runLoop.stop(); // 停止轮询
       * connectionController.startRunLoopExclusive(runLoop); // 排它启动 - 停止别人，启动自己
       * connectionController.destroyRunLoop(runLoop); // 销毁一个轮询实例
       */

    }, {
      key: "createRunLoop",
      value: function createRunLoop(options) {
        var xhrRunLoop = this.createKeepAliveConnection(options);
        xhrRunLoop.setIndex(this.keepAliveConnections.push(xhrRunLoop) - 1);
        return xhrRunLoop;
      }
      /**
       * 停止某个runLoop实例，但不会销毁该实例
       * @param {*} xhrRunLoop
       */

    }, {
      key: "stopRunLoop",
      value: function stopRunLoop(xhrRunLoop) {
        xhrRunLoop.stop();
      }
      /**
       * 关闭掉所有的 runLoop
       */

    }, {
      key: "_stopAllRunLoop",
      value: function _stopAllRunLoop() {
        var length = this.keepAliveConnections.length;

        for (var i = 0; i < length; i++) {
          this.keepAliveConnections[i].stop();
        }
      }
      /**
       * 停止并销毁某个runLoop实例
       * @param {*} xhrRunLoop
       */

    }, {
      key: "destroyRunLoop",
      value: function destroyRunLoop(xhrRunLoop) {
        xhrRunLoop.stop();
        var index = xhrRunLoop.destructor();
        this.keepAliveConnections.slice(index, 1);
      }
      /**
       * 排它启用，关闭非其他的实例，启动自己
       * @param {*} xhrRunLoop
       */

    }, {
      key: "startRunLoopExclusive",
      value: function startRunLoopExclusive(xhrRunLoop) {
        var index = xhrRunLoop.getIndex();

        for (var i = 0; i < this.keepAliveConnections.length; i++) {
          i !== index ? this.keepAliveConnections[i].stop() : null;
        }

        xhrRunLoop.start();
      }
      /**
       * 获取`keepAliveConnection`
       */

    }, {
      key: "createKeepAliveConnection",
      value: function createKeepAliveConnection(options) {
        if (IN_WX_MINI_APP) {
          return new WXRunLoop(options);
        } // 先查看是否有强制配置使用 XHR 方式轮询


        if (this.tim.options.runLoopNetType === RUNLOOP_TYPES.XHR) {
          return new XHRRunLoop(options);
        } // 查看是否有强制配置使用 SOCKET 方式轮询


        if (this.tim.options.runLoopNetType === RUNLOOP_TYPES.SOCKET) ; // return new SocketRunLoop(options);

        return new XHRRunLoop(options);
      }
    }, {
      key: "clearAll",
      value: function clearAll() {
        this.conn.cancelAll();
      }
    }, {
      key: "reset",
      value: function reset() {
        this.keepAliveConnections = [];
      }
    }]);

    return ConnectionController;
  }();

  var ExceptionController =
  /*#__PURE__*/
  function () {
    function ExceptionController(tim) {
      _classCallCheck(this, ExceptionController);

      this.tim = tim;
      this.tim.innerEmitter.on(TIM_INNER_EVENT.ERROR_DETECTED, this._onErrorDetected, this);
    } // 监测到有错误发生


    _createClass(ExceptionController, [{
      key: "_onErrorDetected",
      value: function _onErrorDetected(event) {
        var imError = event.data;

        if (imError.code) {
          logger.warn("Oops! code:".concat(imError.code, " message:").concat(imError.message));
        } else {
          logger.warn("Oops! message:".concat(imError.message, " stack:").concat(imError.stack));
        }

        this.tim.outerEmitter.emit(TIM_OUTER_EVENT.ERROR, imError);
      }
    }]);

    return ExceptionController;
  }();

  /**
   * 用户资料对象，用于描述用户具有的属性，如昵称、头像地址、个性签名、性别等，包含标配资料和自定义资料。
   * @class Profile
   * @property {String} userID 用户账号
   * @property {String} nick 昵称，长度不得超过500个字节
   * @property {String} gender 性别<br/>
   * - TIM.TYPES.GENDER_UNKNOWN（未设置性别）
   * - TIM.TYPES.GENDER_FEMALE（女）
   * - TIM.TYPES.GENDER_MALE（男）
   * @property {Number} birthday 生日 uint32 推荐用法：20000101
   * @property {String} location 所在地 长度不得超过16个字节，推荐用法如下：App 本地定义一套数字到地名的映射关系 后台实际保存的是4个 uint32_t 类型的数字：
   * - 第一个 uint32_t 表示国家
   * - 第二个 uint32_t 用于表示省份
   * - 第三个 uint32_t 用于表示城市
   * - 第四个 uint32_t 用于表示区县
   * @property {String} selfSignature 个性签名 长度不得超过500个字节
   * @property {String} allowType 加好友验证方式<br/>
   * - TIM.TYPES.ALLOW_TYPE_ALLOW_ANY（允许任何人添加自己为好友）
   * - TIM.TYPES.ALLOW_TYPE_NEED_CONFIRM（需要经过自己确认才能添加自己为好友）
   * - TIM.TYPES.ALLOW_TYPE_DENY_ANY（不允许任何人添加自己为好友）
   * @property {Number} language 语言 uint32
   * @property {String} avatar 头像URL，长度不得超过500个字节
   * @property {Number} messageSettings 消息设置 uint32 标志位：Bit0：置0表示接收消息，置1则不接收消息
   * @property {String} adminForbidType 管理员禁止加好友标识<br/>
   * - TIM.TYPES.FORBID_TYPE_NONE（默认值，允许加好友）
   * - TIM.TYPES.FORBID_TYPE_SEND_OUT（禁止该用户发起加好友请求）
   * @property {Number} level 等级 uint32 建议拆分以保存多种角色的等级信息
   * @property {Number} role 角色 uint32 建议拆分以保存多种角色信息
   * @property {Number} lastUpdatedTime 上次更新时间，用户本地时间
   * @property {Array.<Object>} profileCustomField 自定义资料键值对集合，可根据业务侧需要使用，详细请参考: https://cloud.tencent.com/document/product/269/1500#.E8.87.AA.E5.AE.9A.E4.B9.89.E8.B5.84.E6.96.99.E5.AD.97.E6.AE.B5
   */

  var Profile =
  /*#__PURE__*/
  function () {
    function Profile(options) {
      var _this = this;

      _classCallCheck(this, Profile);

      if (!isEmpty(options)) {
        this.userID = options.userID || '';
        this.nick = options.nick || '';
        this.gender = options.gender || '';
        this.birthday = options.birthday || 0;
        this.location = options.location || '';
        this.selfSignature = options.selfSignature || '';
        this.allowType = options.allowType || TYPES.ALLOW_TYPE_ALLOW_ANY;
        this.language = options.language || 0;
        this.avatar = options.avatar || '';
        this.messageSettings = options.messageSettings || 0;
        this.adminForbidType = options.adminForbidType || TYPES.FORBID_TYPE_NONE;
        this.level = options.level || 0;
        this.role = options.role || 0;
        this.lastUpdatedTime = 0;
        this.profileCustomField = []; // 自定义资料字段

        if (!isEmpty(options.profileCustomField)) {
          // cp
          options.profileCustomField.forEach(function (item) {
            _this.profileCustomField.push({
              key: item.key,
              value: item.value
            });
          });
        }
      }
    }
    /**
     * 验证配置是否有效
     * @param {*} options
     * @returns {*} {key, tips}
     * @private
     */


    _createClass(Profile, [{
      key: "validate",
      value: function validate(options) {
        var valid = true;
        var tips = '';

        if (isEmpty(options)) {
          return {
            valid: false,
            tips: 'empty options'
          };
        } // 检查自定义资料字段


        if (options.profileCustomField) {
          var length = options.profileCustomField.length;
          var item = null;

          for (var i = 0; i < length; i++) {
            item = options.profileCustomField[i];

            if (!isString(item.key) || item.key.indexOf('Tag_Profile_Custom') === -1) {
              return {
                valid: false,
                tips: '自定义资料字段的前缀必须是 Tag_Profile_Custom'
              };
            }

            if (!isString(item.value)) {
              return {
                valid: false,
                tips: '自定义资料字段的 value 必须是字符串'
              };
            }
          }
        }

        for (var key in options) {
          if (Object.prototype.hasOwnProperty.call(options, key)) {
            if (key === 'profileCustomField') {
              continue;
            } // key对应的value检测出是empty，并且既不是''，也不是0（如可能是undefined或者null）


            if (isEmpty(options[key]) && !isString(options[key]) && !isNumber(options[key])) {
              tips = 'key:' + key + ', invalid value:' + options[key];
              valid = false;
              continue;
            } // 检测每个key对应的value的类型是否正确


            switch (key) {
              case 'nick':
                if (!isString(options[key])) {
                  tips = 'nick should be a string';
                  valid = false;
                } // 昵称长度限制为`NICK_NAME_LENGTH_LIMIT`个字节


                if (stringSize(options[key]) > NICK_NAME_LENGTH_LIMIT) {
                  tips = "nick name limited: must less than or equal to ".concat(NICK_NAME_LENGTH_LIMIT, " bytes, current size: ").concat(stringSize(options[key]), " bytes");
                  valid = false;
                }

                break;

              case 'gender':
                if (!isValidType(GENDER_TYPES, options.gender)) {
                  tips = 'key:gender, invalid value:' + options.gender;
                  valid = false;
                }

                break;

              case 'birthday':
                if (!isNumber(options.birthday)) {
                  tips = 'birthday should be a number';
                  valid = false;
                }

                break;

              case 'location':
                if (!isString(options.location)) {
                  tips = 'location should be a string';
                  valid = false;
                }

                break;

              case 'selfSignature':
                if (!isString(options.selfSignature)) {
                  tips = 'selfSignature should be a string';
                  valid = false;
                }

                break;

              case 'allowType':
                if (!isValidType(ALLOW_TYPES, options.allowType)) {
                  tips = 'key:allowType, invalid value:' + options.allowType;
                  valid = false;
                }

                break;

              case 'language':
                if (!isNumber(options.language)) {
                  tips = 'language should be a number';
                  valid = false;
                }

                break;

              case 'avatar':
                if (!isString(options.avatar)) {
                  tips = 'avatar should be a string';
                  valid = false;
                }

                break;

              case 'messageSettings':
                if (options.messageSettings !== 0 && options.messageSettings !== 1) {
                  tips = 'messageSettings should be 0 or 1';
                  valid = false;
                }

                break;

              case 'adminForbidType':
                if (!isValidType(FORBID_TYPES, options.adminForbidType)) {
                  tips = 'key:adminForbidType, invalid value:' + options.adminForbidType;
                  valid = false;
                }

                break;

              case 'level':
                if (!isNumber(options.level)) {
                  tips = 'level should be a number';
                  valid = false;
                }

                break;

              case 'role':
                if (!isNumber(options.role)) {
                  tips = 'role should be a number';
                  valid = false;
                }

                break;

              default:
                tips = 'unknown key:' + key + '  ' + options[key];
                valid = false;
                break;
            }
          }
        }

        return {
          valid: valid,
          tips: tips
        };
      }
    }]);

    return Profile;
  }();

  /**
   * 处理profile相关
   * @author qiaoyang
   */

  var ProfileHandler =
  /*#__PURE__*/
  function () {
    function ProfileHandler(userController) {
      _classCallCheck(this, ProfileHandler);

      this.userController = userController;
      this.TAG = 'profile';
      this.Actions = {
        Q: 'query',
        U: 'update'
      };
      this.accountProfileMap = new Map(); // map->(account,profile)

      this.expirationTime = 86400000; // profile过期时间，默认1天，单位毫秒
    }
    /**
     * 设置缓存失效时间
     * @param {*} time
     */


    _createClass(ProfileHandler, [{
      key: "setExpirationTime",
      value: function setExpirationTime(time) {
        this.expirationTime = time;
      } // 获取用户资料

    }, {
      key: "getUserProfile",
      value: function getUserProfile(options) {
        var _this = this;

        var toAccount = options.userIDList;
        options.fromAccount = this.userController.getMyAccount();

        if (toAccount.length > 100) {
          logger.warn('ProfileHandler.getUserProfile 获取用户资料人数不能超过100人');
          toAccount.length = 100;
        }

        var newToAccount = []; // 需要异步查询的账户列表

        var cachedProfileArray = [];
        var tempAccount;

        for (var i = 0, len = toAccount.length; i < len; i++) {
          tempAccount = toAccount[i]; // 非好友，或好友但无好友profile缓存，则需异步拉取

          if (!this.userController.isMyFriend(tempAccount) || !this._containsAccount(tempAccount)) {
            newToAccount.push(tempAccount);
          } else {
            cachedProfileArray.push(this._getProfileFromMap(tempAccount));
          }
        } // 刚好要查询的profile缓存里都有，直接返回


        if (newToAccount.length === 0) {
          return IMPromise.resolve(cachedProfileArray);
        }

        options.toAccount = newToAccount;
        var bFromGetMyProfile = options.bFromGetMyProfile || false; // 同时查询标配资料和自定义资料

        var userItem = [];
        options.toAccount.forEach(function (account) {
          userItem.push({
            toAccount: account,
            standardSequence: 0,
            customSequence: 0
          });
        });
        options.userItem = userItem; // event stat

        var ssoLog = new SSOLogData();
        ssoLog.setMethod(SSOMethods.GET_USER_PROFILE).setStart();
        var config = this.userController.generateConfig(this.TAG, this.Actions.Q, options);
        var result = this.userController.request(config);
        return result.then(function (response) {
          // event stat
          ssoLog.setCode(0).setNetworkType(_this.userController.getNetworkType()).setText(response.data.userProfileItem.length).setEnd();
          logger.info('ProfileHandler.getUserProfile ok');

          var profileArray = _this._handleResponse(response).concat(cachedProfileArray);

          if (bFromGetMyProfile) {
            _this.userController.onGotMyProfile();

            return new IMResponse(profileArray[0]); // getMyProfile 接口返回一个 promise 对象
          }

          return new IMResponse(profileArray); // getUserProfile 接口返回一个包含 promise 对象的数组
        })["catch"](function (error) {
          // event stat
          _this.userController.probeNetwork().then(function (_ref) {
            var _ref2 = _slicedToArray(_ref, 2),
                bOnline = _ref2[0],
                networkType = _ref2[1];

            ssoLog.setError(error, bOnline, networkType).setEnd();
          });

          logger.error('ProfileHandler.getUserProfile error:', error);
          return IMPromise.reject(error);
        });
      } // 获取我的个人信息

    }, {
      key: "getMyProfile",
      value: function getMyProfile() {
        var myAccount = this.userController.getMyAccount();
        logger.log('ProfileHandler.getMyProfile myAccount=' + myAccount);

        this._fillMap(); // 先查缓存，有则返回，无则异步获取


        if (this._containsAccount(myAccount)) {
          var myProfile = this._getProfileFromMap(myAccount);

          logger.debug('ProfileHandler.getMyProfile from cache, myProfile:' + JSON.stringify(myProfile));
          this.userController.onGotMyProfile();
          return IMPromise.resolve(myProfile);
        }

        var result = this.getUserProfile({
          fromAccount: myAccount,
          userIDList: [myAccount],
          bFromGetMyProfile: true // 此标识为true，表明是 getMyProfile 接口发起的请求

        });
        return result;
      }
      /**
       * 返回包含这些profile对象的数组
       * @param {*} response
       */

    }, {
      key: "_handleResponse",
      value: function _handleResponse(response) {
        var now = TimeUtil.now();
        var userProfileItem = response.data.userProfileItem;
        var profileArray = [];
        var userID;
        var latestProfile;

        for (var i = 0, len = userProfileItem.length; i < len; i++) {
          // TODO: 这里用resultCode处理可能会更好一些
          if (userProfileItem[i].to === '@TLS#NOT_FOUND' || userProfileItem[i].to === '') {
            // 防御后台的鬼才设计
            continue;
          }

          userID = userProfileItem[i].to; // 这个操作会填充默认值（全量更新）
          // latestProfile = new Profile(this._getLatestProfileFromResponse(userID, userProfileItem[i].profileItem));
          // this._updateMap(userID, latestProfile);

          latestProfile = this._updateMap(userID, this._getLatestProfileFromResponse(userID, userProfileItem[i].profileItem));
          profileArray.push(latestProfile);
        }

        logger.log('ProfileHandler._handleResponse cost ' + (TimeUtil.now() - now) + ' ms');
        return profileArray;
      }
      /**
       * 从server response里获取最新的profile
       * @param {*} userID 用户账号
       * @param {*} profileList [{tag1, value1}, {tag2, value2}, ...]
       */

    }, {
      key: "_getLatestProfileFromResponse",
      value: function _getLatestProfileFromResponse(userID, profileList) {
        var ret = {};
        ret.userID = userID;
        ret.profileCustomField = []; // 保存自定义资料的键值信息，在 Profile model里处理
        // profileList可能为undefined，需要做防御

        if (!isEmpty(profileList)) {
          for (var j = 0, length = profileList.length; j < length; j++) {
            if (profileList[j].tag.indexOf('Tag_Profile_Custom') > -1) {
              // 自定义资料
              ret.profileCustomField.push({
                key: profileList[j].tag,
                value: profileList[j].value
              });
            } else {
              // 标配资料
              switch (profileList[j].tag) {
                case STANDARD_IM_PROFILE.NICK:
                  ret.nick = profileList[j].value;
                  break;

                case STANDARD_IM_PROFILE.GENDER:
                  ret.gender = profileList[j].value;
                  break;

                case STANDARD_IM_PROFILE.BIRTHDAY:
                  ret.birthday = profileList[j].value;
                  break;

                case STANDARD_IM_PROFILE.LOCATION:
                  ret.location = profileList[j].value;
                  break;

                case STANDARD_IM_PROFILE.SELFSIGNATURE:
                  ret.selfSignature = profileList[j].value;
                  break;

                case STANDARD_IM_PROFILE.ALLOWTYPE:
                  ret.allowType = profileList[j].value;
                  break;

                case STANDARD_IM_PROFILE.LANGUAGE:
                  ret.language = profileList[j].value;
                  break;

                case STANDARD_IM_PROFILE.AVATAR:
                  ret.avatar = profileList[j].value;
                  break;

                case STANDARD_IM_PROFILE.MESSAGESETTINGS:
                  ret.messageSettings = profileList[j].value;
                  break;

                case STANDARD_IM_PROFILE.ADMINFORBIDTYPE:
                  ret.adminForbidType = profileList[j].value;
                  break;

                case STANDARD_IM_PROFILE.LEVEL:
                  ret.level = profileList[j].value;
                  break;

                case STANDARD_IM_PROFILE.ROLE:
                  ret.role = profileList[j].value;
                  break;

                default:
                  logger.warn('ProfileHandler._handleResponse unkown tag->', profileList[j].tag, profileList[j].value);
              }
            }
          }
        }

        return ret;
      } // 更新我的资料

    }, {
      key: "updateMyProfile",
      value: function updateMyProfile(options) {
        var _this2 = this;

        // 检测传入的配置是否有效
        var profile = new Profile();
        var ret = profile.validate(options);

        if (!ret.valid) {
          logger.error("ProfileHandler.updateMyProfile info:".concat(ret.tips, "\uFF0C\u8BF7\u53C2\u8003 https://imsdk-1252463788.file.myqcloud.com/IM_DOC/Web/SDK.html#updateMyProfile"));
          return IMPromise.reject({
            code: ERROR_CODE.UPDATE_PROFILE_INVALID_PARAM,
            message: ERROR_MESSAGE.UPDATE_PROFILE_INVALID_PARAM
          });
        } // 转为server需要的格式


        var profileItem = [];

        for (var k in options) {
          if (Object.prototype.hasOwnProperty.call(options, k)) {
            // 区分标配资料字段和自定义资料字段
            if (k === 'profileCustomField') {
              // options.profileCustomField 是数组 [{}, {}]
              options.profileCustomField.forEach(function (item) {
                profileItem.push({
                  tag: item.key,
                  value: item.value
                });
              });
            } else {
              profileItem.push({
                tag: STANDARD_IM_PROFILE[k.toUpperCase()],
                value: options[k]
              });
            }
          }
        }

        if (profileItem.length === 0) {
          logger.error("ProfileHandler.updateMyProfile info:".concat(ERROR_MESSAGE.UPDATE_PROFILE_NO_KEY, "\uFF0C\u8BF7\u53C2\u8003 https://imsdk-1252463788.file.myqcloud.com/IM_DOC/Web/SDK.html#updateMyProfile"));
          return IMPromise.reject({
            code: ERROR_CODE.UPDATE_PROFILE_NO_KEY,
            message: ERROR_MESSAGE.UPDATE_PROFILE_NO_KEY
          });
        } // 请求并处理


        var config = this.userController.generateConfig(this.TAG, this.Actions.U, {
          fromAccount: this.userController.getMyAccount(),
          profileItem: profileItem
        });
        var result = this.userController.request(config);
        return result.then(function (response) {
          logger.info('ProfileHandler.updateMyProfile ok');

          var latestProfile = _this2._updateMap(_this2.userController.getMyAccount(), options);

          _this2.userController.emitOuterEvent(TIM_OUTER_EVENT.PROFILE_UPDATED, [latestProfile]); // 事件统一对应数组形式


          return IMPromise.resolve(latestProfile);
        })["catch"](function (error) {
          logger.error('ProfileHandler.updateMyProfile error:', error);
          return IMPromise.reject(error);
        });
      } // 当收到其他用户profile更新的通知时处理

    }, {
      key: "onProfileModified",
      value: function onProfileModified(modifiedData) {
        var data = modifiedData.data;

        if (isEmpty(data)) {
          return;
        }

        var length = data.length;
        logger.info('ProfileHandler.onProfileModified length=' + length);
        var userID;
        var latestProfile;
        var latestProfileArray = [];

        for (var i = 0; i < length; i++) {
          userID = data[i].userID; // 用户有可能在其它端修改自己的profile
          // if (userID == this.userController.getMyAccount()) {
          //   continue;
          // }
          // 先写入内存的map，然后择机写入缓存（不填充默认值，增量更新）

          latestProfile = this._updateMap(userID, this._getLatestProfileFromResponse(userID, data[i].profileList));
          latestProfileArray.push(latestProfile);
        }

        this.userController.emitInnerEvent(TIM_INNER_EVENT.PROFILE_UPDATED, latestProfileArray); // TODO: 后续统一修改

        this.userController.emitOuterEvent(TIM_OUTER_EVENT.PROFILE_UPDATED, latestProfileArray); // 事件统一对应数组形式
      } // 读取本地在有效期内的缓存并填充account-profile map

    }, {
      key: "_fillMap",
      value: function _fillMap() {
        if (this.accountProfileMap.size === 0) {
          var cachedProfileArray = this._getCachedProfiles();

          var now = Date.now();

          for (var i = 0, len = cachedProfileArray.length; i < len; i++) {
            if (now - cachedProfileArray[i].lastUpdatedTime < this.expirationTime) {
              this.accountProfileMap.set(cachedProfileArray[i].userID, cachedProfileArray[i]);
            }
          }

          logger.log('ProfileHandler._fillMap from cache, map.size=' + this.accountProfileMap.size);
        }
      } // 更新account-profile map，并调用接口写缓存

    }, {
      key: "_updateMap",
      value: function _updateMap(account, options) {
        var profile;
        var now = Date.now();

        if (!this._containsAccount(account)) {
          // 这个操作会填充默认值（全量更新）
          profile = new Profile(options); // 只存自己和好友的profile

          if (this.userController.isMyFriend(account) || account === this.userController.getMyAccount()) {
            profile.lastUpdatedTime = now;
            this.accountProfileMap.set(account, profile);
          }
        } else {
          profile = this._getProfileFromMap(account); // 数组单独处理，不使用 deepMerge，避免问题

          if (options.profileCustomField) {
            updateCustomField(profile.profileCustomField, options.profileCustomField);
          }

          deepMerge(profile, options, ['profileCustomField']);
          profile.lastUpdatedTime = now;
        } // 自己的资料更新立即写入缓存，其他人的定时写入


        this._flushMap(account === this.userController.getMyAccount());

        return profile;
      }
      /**
       * account-profile map的内容写入本地缓存（全量更新）
       * @param {Boolean} bFlushAtOnce true 立即写入本地缓存；false 定时写入
       */

    }, {
      key: "_flushMap",
      value: function _flushMap(bFlushAtOnce) {
        var profileArray = _toConsumableArray(this.accountProfileMap.values());

        var storage = this.userController.tim.storage;
        logger.debug("ProfileHandler._flushMap length=".concat(profileArray.length, " flushAtOnce=").concat(bFlushAtOnce));
        storage.setItem(this.TAG, profileArray, bFlushAtOnce);
      } // account-profile map是否有缓存指定account的profile

    }, {
      key: "_containsAccount",
      value: function _containsAccount(account) {
        return this.accountProfileMap.has(account);
      } // 从account-profile map读取指定account的profile

    }, {
      key: "_getProfileFromMap",
      value: function _getProfileFromMap(account) {
        return this.accountProfileMap.get(account);
      } // 从本地缓存里读取profile

    }, {
      key: "_getCachedProfiles",
      value: function _getCachedProfiles() {
        var storage = this.userController.tim.storage;
        var cachedProfileArray = storage.getItem(this.TAG);

        if (isEmpty(cachedProfileArray)) {
          return [];
        }

        return cachedProfileArray;
      } // 收到会话列表发过来的Profile更新通知。如果userID对应的profile在map里不存在，则拉取最新的，成功后好友资料保存到map
      // 如果userID对应的profile在map里存在，但nick或avatar跟map里保存的不同，则表明用户的profile有更新，拉取最新的，成功后好友资料保存到map

    }, {
      key: "onConversationsProfileUpdated",
      value: function onConversationsProfileUpdated(profileArray) {
        var tempObj;
        var userID;
        var toAccount = [];
        var currentProfile;

        for (var i = 0, length = profileArray.length; i < length; i++) {
          tempObj = profileArray[i];
          userID = tempObj.userID;

          if (!this.userController.isMyFriend(userID)) {
            continue;
          }

          if (!this._containsAccount(userID)) {
            toAccount.push(tempObj.userID);
          } else {
            currentProfile = this._getProfileFromMap(userID); // 有合并项，说明本地保存的profile已经过时了，需要拉取最新的

            if (deepMerge(currentProfile, tempObj) > 0) {
              toAccount.push(userID);
            }
          }
        }

        if (toAccount.length === 0) {
          return;
        }

        logger.info('ProfileHandler.onConversationsProfileUpdated toAccount:', toAccount);
        this.getUserProfile({
          userIDList: toAccount
        });
      }
    }, {
      key: "reset",
      value: function reset() {
        this._flushMap(true); // reset时立即写入本地缓存


        this.accountProfileMap.clear();
      }
    }]);

    return ProfileHandler;
  }();

  /**
   * 用于打点测试,可以用于函数、流程的性能分析
   * @example
   * var p= new Pointer(true);
   * p.newTask('taskName');
   * //xxxx code
   * p.dot('pointerName01', 'taskName');
   * //logic coding....
   * p.dot('pointerName02', 'taskName');
   * p.report('taskName');
   */
  var Pointer =
  /*#__PURE__*/
  function () {
    function Pointer(tim) {
      _classCallCheck(this, Pointer);

      // this.pointsList = [];
      this.options = tim ? tim.options : {
        enablePointer: true
      };
      this.pointsList = {};
      this.reportText = {};
      this.maxNameLen = 0;
      this.gapChar = '-';
      this.log = console.log;
      this.currentTask = '';
    }
    /**
     * 创建新的打点任务
     * @param {String} taskName - 任务名
     */


    _createClass(Pointer, [{
      key: "newTask",
      value: function newTask(taskName) {
        if (this.options.enablePointer === false) {
          return;
        }

        if (!taskName) {
          taskName = ['task', this._timeFormat()].join('-');
        }

        this.pointsList[taskName] = [];
        this.currentTask = taskName;
        console.log("Pointer new Task : ".concat(this.currentTask));
      }
      /**
       * 删除掉某一个任务
       * @param {String} taskName - 任务名
       */

    }, {
      key: "deleteTask",
      value: function deleteTask(taskName) {
        if (this.options.enablePointer === false) {
          return;
        }

        if (!taskName) {
          taskName = this.currentTask;
        }

        this.pointsList[taskName].length = 0;
        delete this.pointsList[taskName];
      }
      /**
       * 打点，`pointerName`将会记录到`pointsList`中
       * @param {String} pointerName
       */

    }, {
      key: "dot",
      value: function dot() {
        var pointerName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
        var taskName = arguments.length > 1 ? arguments[1] : undefined;

        if (this.options.enablePointer === false) {
          return;
        }

        taskName = taskName ? taskName : this.currentTask;
        var time = +new Date();
        this.maxNameLen = this.maxNameLen < pointerName.length ? pointerName.length : this.maxNameLen;
        this.flen = this.maxNameLen + 10;
        this.pointsList[taskName].push({
          pointerName: pointerName,
          time: time
        });
      }
      /**
       * 分析打点结果，生成汇总数据
       * @name _analisys
       * @private
       * @param {String} taskName - 任务名称
       */

    }, {
      key: "_analisys",
      value: function _analisys(taskName) {
        if (this.options.enablePointer === false) {
          return;
        }

        taskName = taskName ? taskName : this.currentTask;
        var list = this.pointsList[taskName];
        var len = list.length;
        var tempArr = [];
        var tmpArr = [];

        for (var i = 0; i < len; i++) {
          if (i === 0) {
            continue;
          }

          tmpArr = this._analisysTowPoints(list[i - 1], list[i]);
          tempArr.push(tmpArr.join(''));
        }

        tmpArr = this._analisysTowPoints(list[0], list[len - 1], true);
        tempArr.push(tmpArr.join(''));
        return tempArr.join('');
      }
    }, {
      key: "_analisysTowPoints",
      value: function _analisysTowPoints(last, curr) {
        var color = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

        if (this.options.enablePointer === false) {
          return;
        }

        var flen = this.flen;
        var timeDiff = curr.time - last.time;
        var timtStr = timeDiff.toString();
        var v1 = last.pointerName + this.gapChar.repeat(flen - last.pointerName.length);
        var v2 = curr.pointerName + this.gapChar.repeat(flen - curr.pointerName.length);
        var v3 = this.gapChar.repeat(4 - timtStr.length) + timtStr;
        var tmpArr = color ? ['%c', v1, v2, v3, 'ms\n%c'] : [v1, v2, v3, 'ms\n'];
        return tmpArr;
      }
      /**
       * 输出当前任务的分析数据
       * @param {String} taskName
       */

    }, {
      key: "report",
      value: function report(taskName) {
        if (this.options.enablePointer === false) {
          return;
        }

        taskName = taskName ? taskName : this.currentTask;

        var reportText = this._analisys(taskName);

        this.pointsList = []; // let title = taskName

        var time = this._timeFormat();

        var title = "Pointer[".concat(taskName, "(").concat(time, ")]");
        var maxLen = this.maxNameLen * 4;
        var hafLen = (maxLen - title.length) / 2;
        console.log(['-'.repeat(hafLen), title, '-'.repeat(hafLen)].join(''));
        console.log('%c' + reportText, 'color:#66a', 'color:red', 'color:#66a');
        console.log('-'.repeat(maxLen));
      }
    }, {
      key: "_timeFormat",
      value: function _timeFormat() {
        var date = new Date();
        var m = this.zeroFix(date.getMonth() + 1, 2);
        var d = this.zeroFix(date.getDate(), 2);
        return "".concat(m, "-").concat(d, " ").concat(date.getHours(), ":").concat(date.getSeconds(), ":").concat(date.getMinutes(), "~").concat(date.getMilliseconds());
      }
    }, {
      key: "zeroFix",
      value: function zeroFix(num, length) {
        return ('000000000' + num).slice(-length);
      }
      /**
       *输出所有任务的报告
       */

    }, {
      key: "reportAll",
      value: function reportAll() {
        if (this.options.enablePointer === false) {
          return;
        }

        for (var taskName in this.pointsList) {
          if (Object.prototype.hasOwnProperty.call(this.pointsList, taskName)) {
            this.eport(taskName);
          }
        }
      }
    }]);

    return Pointer;
  }();

  var Friend = function Friend(userID, snsProfileItem) {
    _classCallCheck(this, Friend);

    this.userID = userID;
    var ret = {};
    ret.userID = userID; // snsProfileItem可能为undefined，需要做防御

    if (!isEmpty(snsProfileItem)) {
      for (var j = 0, length = snsProfileItem.length; j < length; j++) {
        switch (snsProfileItem[j].tag) {
          case STANDARD_IM_PROFILE.NICK:
            ret.nick = snsProfileItem[j].value;
            break;

          case STANDARD_IM_PROFILE.GENDER:
            ret.gender = snsProfileItem[j].value;
            break;

          case STANDARD_IM_PROFILE.BIRTHDAY:
            ret.birthday = snsProfileItem[j].value;
            break;

          case STANDARD_IM_PROFILE.LOCATION:
            ret.location = snsProfileItem[j].value;
            break;

          case STANDARD_IM_PROFILE.SELFSIGNATURE:
            ret.selfSignature = snsProfileItem[j].value;
            break;

          case STANDARD_IM_PROFILE.ALLOWTYPE:
            ret.allowType = snsProfileItem[j].value;
            break;

          case STANDARD_IM_PROFILE.LANGUAGE:
            ret.language = snsProfileItem[j].value;
            break;

          case STANDARD_IM_PROFILE.AVATAR:
            ret.avatar = snsProfileItem[j].value;
            break;

          case STANDARD_IM_PROFILE.MESSAGESETTINGS:
            ret.messageSettings = snsProfileItem[j].value;
            break;

          case STANDARD_IM_PROFILE.ADMINFORBIDTYPE:
            ret.adminForbidType = snsProfileItem[j].value;
            break;

          case STANDARD_IM_PROFILE.LEVEL:
            ret.level = snsProfileItem[j].value;
            break;

          case STANDARD_IM_PROFILE.ROLE:
            ret.role = snsProfileItem[j].value;
            break;

          default:
            // Tag_SNS_IM_Remark 好友备注
            // TODO: 现在关系链不完善，输出warn级别的日志可能会引起误解
            logger.debug('snsProfileItem unkown tag->', snsProfileItem[j].tag);
        }
      }
    }

    this.profile = new Profile(ret);
  };

  /**
   * 处理friend相关
   */

  var FriendHandler =
  /*#__PURE__*/
  function () {
    function FriendHandler(userController) {
      _classCallCheck(this, FriendHandler);

      this.userController = userController;
      this.TAG = 'friend';
      this.Actions = {
        G: 'get',
        D: 'delete'
      };
      this.friends = new Map();
      this.pointer = new Pointer();
    }
    /**
     * 判断某用户是否为我的朋友
     * @param {*} userID
     */


    _createClass(FriendHandler, [{
      key: "isMyFriend",
      value: function isMyFriend(userID) {
        var ret = this.friends.has(userID);

        if (!ret) {
          logger.debug('FriendHandler.isMyFriend ' + userID + ' is not my friend');
        }

        return ret;
      }
    }, {
      key: "_transformFriendList",
      value: function _transformFriendList(data) {
        if (isEmpty(data) || isEmpty(data.infoItem)) {
          // poor boy，一个朋友也没有...
          return;
        }

        logger.info('FriendHandler._transformFriendList friendNum=' + data.friendNum);
        var infoItems = data.infoItem;
        var friend;
        var userID;

        for (var i = 0, length = infoItems.length; i < length; i++) {
          userID = infoItems[i].infoAccount;
          friend = new Friend(userID, infoItems[i].snsProfileItem);
          this.friends.set(userID, friend);
        }
      }
    }, {
      key: "_friends2map",
      value: function _friends2map(friends) {
        var map = new Map();

        for (var friend in friends) {
          if (Object.prototype.hasOwnProperty.call(friends, friend)) {
            map.set(friend, friends[friend]);
          }
        }

        return map;
      }
      /**
       * @description 拉取我的好友列表 [详细的参数信息]{@link https://cloud.tencent.com/document/product/269/1647}
       * @param {Object} options - 请求参数
       * @param {Array.<string>} options.tagList - 必填 指定要拉取的字段 Tag
       * @param {Number} [options.startIndex=0] - 选填 拉取的开始位置
       * @param {Number} [options.lastStandardSequence=0] - 选填 上次拉取标配关系链的 Sequence，仅在只拉取标配关系链字段时有用
       * @param {Number} [options.getCount=100] - 选填 每页需要拉取的好友数量
       * @returns {Promise}
       */

    }, {
      key: "getFriendList",
      value: function getFriendList() {
        var _this = this;

        // 不管外面的fromAccount填的是谁，强行设置为“我”的，避免查到别人的好友关系
        var options = {};
        options.fromAccount = this.userController.getMyAccount();
        logger.info('FriendHandler.getFriendList myAccount=' + options.fromAccount);
        var config = this.userController.generateConfig(this.TAG, this.Actions.G, options);
        var result = this.userController.request(config);
        return result.then(function (response) {
          logger.info('FriendHandler.getFriendList ok');

          _this._transformFriendList(response.data);

          var friendsArray = _toConsumableArray(_this.friends.values());

          return IMPromise.resolve(friendsArray);
        })["catch"](function (error) {
          logger.error('FriendHandler.getFriendList error:', JSON.stringify(error));
          return IMPromise.reject(error);
        });
      }
      /**
       * 删除好友
       *
       * @param {Object} options
       * @param {array} options.toAccount - 待删除的好友的 Identifier 列表，单次请求的 To_Account 数不得超过 1000
       * @param {String} options.deleteType - 删除模式，[详情参考]{@link https://cloud.tencent.com/document/product/269/1501#.E5.88.A0.E9.99.A4.E5.A5.BD.E5.8F.8B}
       * @memberOf UserController
       * @returns {Promise}
       * @example
       * app.userController.deleteFriend({
        *  toAccount: ['User4Test02'],
        *  deleteType: 'CheckResult_Type_Singal'
        * })
        */

    }, {
      key: "deleteFriend",
      value: function deleteFriend(options) {
        if (!Array.isArray(options.toAccount)) {
          logger.error('FriendHandler.deleteFriend options.toAccount 必需是数组');
          return IMPromise.reject({
            code: ERROR_CODE.DEL_FRIEND_INVALID_PARAM,
            message: ERROR_MESSAGE.DEL_FRIEND_INVALID_PARAM
          });
        }

        if (options.toAccount.length > 1000) {
          logger.warn('FriendHandler.deleteFriend 删除好友人数不能超过1000人');
          options.toAccount.length = 1000;
        }

        var config = this.userController.generateConfig(this.TAG, this.Actions.D, options);
        var result = this.userController.request(config);
        return result.then(function (response) {
          logger.info('FriendHandler.deleteFriend ok');
          return IMPromise.resolve();
        })["catch"](function (error) {
          logger.error('FriendHandler.deleteFriend error:', error);
          return IMPromise.reject(error);
        });
      }
    }]);

    return FriendHandler;
  }();

  /**
   * 黑名单的具体信息，描述用户id，及该id被添加到黑名单的时间戳
   * @class BannedAccount
   * @param {Object} options
   * @param {String} options.userID 用户账号
   * @param {String} options.timeStamp 添加到黑名单的时间
   */

  var BannedInfo = function BannedInfo(options) {
    _classCallCheck(this, BannedInfo);

    if (!isEmpty) {
      this.userID = options.userID || '';
      this.timeStamp = options.timeStamp || 0;
    }
  };

  /**
   * 处理黑名单相关
   */

  var BlacklistHandler =
  /*#__PURE__*/
  function () {
    function BlacklistHandler(userController) {
      _classCallCheck(this, BlacklistHandler);

      this.userController = userController;
      this.TAG = 'blacklist';
      this.Actions = {
        G: 'get',
        C: 'create',
        D: 'delete'
      };
      this.blacklistMap = new Map();
      this.startIndex = 0;
      this.maxLimited = 100;
      this.curruentSequence = 0;
    } // 获取黑名单


    _createClass(BlacklistHandler, [{
      key: "getBlacklist",
      value: function getBlacklist() {
        var _this = this;

        var options = {};
        options.fromAccount = this.userController.getMyAccount();
        options.maxLimited = this.maxLimited; // 每页最多拉取的黑名单数

        options.startIndex = 0; // 拉取的起始位置

        options.lastSequence = this.curruentSequence; // 上一次拉黑名单时后台返回给客户端的 Seq，初次拉取时为0
        // event stat

        var ssoLog = new SSOLogData();
        ssoLog.setMethod(SSOMethods.GET_BLACKLIST).setStart();
        var config = this.userController.generateConfig(this.TAG, this.Actions.G, options);
        var result = this.userController.request(config);
        return result.then(function (response) {
          // event stat
          var nums = isEmpty(response.data.blackListItem) ? 0 : response.data.blackListItem.length;
          ssoLog.setCode(0).setNetworkType(_this.userController.getNetworkType()).setText(nums).setEnd();
          logger.info('BlacklistHandler.getBlacklist ok');
          _this.curruentSequence = response.data.curruentSequence; // 黑名单最新的 Seq

          _this._handleResponse(response.data.blackListItem, true);

          return _this._onBlacklistUpdated();
        })["catch"](function (error) {
          // event stat
          _this.userController.probeNetwork().then(function (_ref) {
            var _ref2 = _slicedToArray(_ref, 2),
                bOnline = _ref2[0],
                networkType = _ref2[1];

            ssoLog.setError(error, bOnline, networkType).setEnd();
          });

          logger.error('BlacklistHandler.getBlacklist error:', error);
          return IMPromise.reject(error);
        });
      } // 增加黑名单

    }, {
      key: "addBlacklist",
      value: function addBlacklist(options) {
        var _this2 = this;

        if (!isArray(options.userIDList)) {
          logger.error('BlacklistHandler.addBlacklist options.userIDList 必需是数组');
          return IMPromise.reject({
            code: ERROR_CODE.ADD_BLACKLIST_INVALID_PARAM,
            message: ERROR_MESSAGE.ADD_BLACKLIST_INVALID_PARAM
          });
        }

        var selfUserID = this.userController.tim.loginInfo.identifier; // 不能把自己拉进黑名单

        if (options.userIDList.length === 1 && options.userIDList[0] === selfUserID) {
          logger.error('BlacklistHandler.addBlacklist 不能把自己拉黑');
          return IMPromise.reject({
            code: ERROR_CODE.CANNOT_ADD_SELF_TO_BLACKLIST,
            message: ERROR_MESSAGE.CANNOT_ADD_SELF_TO_BLACKLIST
          });
        } // 若批量拉黑，且有自己，过滤掉即可


        if (options.userIDList.includes(selfUserID)) {
          options.userIDList = options.userIDList.filter(function (userID) {
            return userID !== selfUserID;
          });
          logger.warn('BlacklistHandler.addBlacklist 不能把自己拉黑，已过滤');
        }

        options.fromAccount = this.userController.getMyAccount();
        options.toAccount = options.userIDList;
        var config = this.userController.generateConfig(this.TAG, this.Actions.C, options);
        var result = this.userController.request(config);
        return result.then(function (response) {
          logger.info('BlacklistHandler.addBlacklist ok');

          _this2._handleResponse(response.data.resultItem, true);

          return _this2._onBlacklistUpdated();
        })["catch"](function (error) {
          logger.error('BlacklistHandler.addBlacklist error:', error);
          return IMPromise.reject(error);
        });
      } // 处理服务器响应数据，bAdd为true，表示往blacklistMap里插入数据，false表示从blacklistMap删除数据

    }, {
      key: "_handleResponse",
      value: function _handleResponse(items, bAdd) {
        if (!isEmpty(items)) {
          var bannedInfo;
          var userID;
          var resultCode; // 服务器返回的结果码

          for (var i = 0, length = items.length; i < length; i++) {
            userID = items[i].to;
            resultCode = items[i].resultCode;

            if (isUndefined(resultCode) || resultCode === 0) {
              if (bAdd) {
                // add
                !this.blacklistMap.has(userID) ? bannedInfo = new BannedInfo() : bannedInfo = this.blacklistMap.get(userID);
                bannedInfo.userID = userID;
                !isEmpty(items[i].addBlackTimeStamp) && (bannedInfo.timeStamp = items[i].addBlackTimeStamp);
                this.blacklistMap.set(userID, bannedInfo);
              } else {
                // remove
                if (this.blacklistMap.has(userID)) {
                  bannedInfo = this.blacklistMap.get(userID);
                  this.blacklistMap["delete"](userID);
                }
              }
            }
          }
        }

        logger.log('BlacklistHandler._handleResponse total=' + this.blacklistMap.size + ' bAdd=' + bAdd);
      } // 删除黑名单

    }, {
      key: "deleteBlacklist",
      value: function deleteBlacklist(options) {
        var _this3 = this;

        if (!isArray(options.userIDList)) {
          logger.error('BlacklistHandler.deleteBlacklist options.userIDList 必需是数组');
          return IMPromise.reject({
            code: ERROR_CODE.DEL_BLACKLIST_INVALID_PARAM,
            message: ERROR_MESSAGE.DEL_BLACKLIST_INVALID_PARAM
          });
        }

        options.fromAccount = this.userController.getMyAccount();
        options.toAccount = options.userIDList;
        var config = this.userController.generateConfig(this.TAG, this.Actions.D, options);
        var result = this.userController.request(config);
        return result.then(function (response) {
          logger.info('BlacklistHandler.deleteBlacklist ok');

          _this3._handleResponse(response.data.resultItem, false);

          return _this3._onBlacklistUpdated();
        })["catch"](function (error) {
          logger.error('BlacklistHandler.deleteBlacklist error:', error);
          return IMPromise.reject(error);
        });
      }
    }, {
      key: "_onBlacklistUpdated",
      value: function _onBlacklistUpdated() {
        // 全量黑名单
        var bannedAccounts = _toConsumableArray(this.blacklistMap.keys());

        this.userController.emitOuterEvent(TIM_OUTER_EVENT.BLACKLIST_UPDATED, bannedAccounts);
        return IMPromise.resolve(bannedAccounts);
      } // 处理从黑名单删除账号的通知

    }, {
      key: "handleBlackListDelAccount",
      value: function handleBlackListDelAccount(accounts) {
        var delUserIDList = [];
        var userID;

        for (var i = 0, length = accounts.length; i < length; i++) {
          userID = accounts[i];

          if (this.blacklistMap.has(userID)) {
            this.blacklistMap["delete"](userID);
            delUserIDList.push(userID);
          }
        } // 有更新才派发事件


        if (delUserIDList.length > 0) {
          logger.log('BlacklistHandler.handleBlackListDelAccount delCount=' + delUserIDList.length + ' : ' + delUserIDList.join(','));
          this.userController.emitOuterEvent(TIM_OUTER_EVENT.BLACKLIST_UPDATED, _toConsumableArray(this.blacklistMap.keys()));
        }
      } // 处理添加账号到黑名单的通知

    }, {
      key: "handleBlackListAddAccount",
      value: function handleBlackListAddAccount(accounts) {
        var addUserIDList = [];
        var userID;

        for (var i = 0, length = accounts.length; i < length; i++) {
          userID = accounts[i];

          if (!this.blacklistMap.has(userID)) {
            this.blacklistMap.set(userID, new BannedInfo({
              userID: userID
            }));
            addUserIDList.push(userID);
          }
        } // 有更新才派发事件


        if (addUserIDList.length > 0) {
          logger.log('BlacklistHandler.handleBlackListAddAccount addCount=' + addUserIDList.length + ' : ' + addUserIDList.join(','));
          this.userController.emitOuterEvent(TIM_OUTER_EVENT.BLACKLIST_UPDATED, _toConsumableArray(this.blacklistMap.keys()));
        }
      }
    }, {
      key: "reset",
      value: function reset() {
        this.blacklistMap.clear();
        this.startIndex = 0;
        this.maxLimited = 100;
        this.curruentSequence = 0;
      }
    }]);

    return BlacklistHandler;
  }();

  /**
   * 处理申请相关
   */
  var ApplyC2CHandler =
  /*#__PURE__*/
  function () {
    function ApplyC2CHandler(userController) {
      _classCallCheck(this, ApplyC2CHandler);

      this.userController = userController;
      this.TAG = 'applyC2C';
      this.Actions = {
        C: 'create',
        G: 'get',
        D: 'delete',
        U: 'update'
      };
    }
    /**
     * 申请添加好友，
     * @description [详细的参数信息]{@link https://cloud.tencent.com/document/product/269/1643#.E8.AF.B7.E6.B1.82.E5.8C.85.E5.AD.97.E6.AE.B5.E8.AF.B4.E6.98.8E}
     * @param {Object} options - 添加好友的参数配置
     * @param {Array} options.addFriendItem - 必填，添加好友的对象结构
     * @param {String} options.addFriendItem.toAccount - 必填，需要添加的好友identifier
     * @param {String} options.addFriendItem.remark - 选填，备注信息
     * @param {String} options.addFriendItem.groupName - 选填，分组名称
     * @param {String} options.addFriendItem.addSource - 选填，好友来源
     * @param {String} options.addFriendItem.addWording - 选填，附言信息
     * @param {String} options.addType - 选填，加好友方式，单向加好友："Add_Type_Single"; 双向加好友:"Add_Type_Both"，默认为"Add_Type_Both"
     * @param {String} options.forceAddFlags - 选填，管理员强制加好友标记：1 表示强制加好友；0 表示常规加好友方式
     * @fires TIM_EVENT.APPLY.ADD_FRIEND.SUCCESS
     * @fires TIM_EVENT.APPLY.ADD_FRIEND.FAIL
     * @returns {Promise}
     * @throws {IMError}
     */


    _createClass(ApplyC2CHandler, [{
      key: "applyAddFriend",
      value: function applyAddFriend(options) {
        var _this = this;

        var config = this.userController.generateConfig(this.TAG, this.Actions.C, options);
        var result = this.userController.request(config);
        result.then(function (response) {
          if (_this.userController.isActionSuccessful('applyAddFriend', _this.Actions.C, response)) ;
        })["catch"](function (error) {});
        return result;
      }
      /**
       * 获取未受理的好友申请
       *
       * @param {Object} options
       * @param {String} [options.pendencyType='Pendency_Type_ComeIn'] - Pendency_Type_ComeIn: 别人发给我的; Pendency_Type_SendOut: 我发给别人的
       * @param {Number} [options.startTime=0] - 好友申请的起始时间
       * @param {Number} [options.maxLimited=30] - 分页大小，如果取值为30 则表示客户端要求服务器端每页最多返回30个好友申请
       * @param {Number} [options.lastSequence=0] - 好友申请数据的版本号，用户每收到或删除一条好友申请，服务器端就自增一次好友申请数据版本号，一般传0，表示拉取最新的数据
       * @returns {Promise}
       * @memberof UserController
       */

    }, {
      key: "getPendency",
      value: function getPendency(options) {
        var _this2 = this;

        var config = this.userController.generateConfig(this.TAG, this.Actions.G, options);
        var result = this.userController.request(config);
        result.then(function (response) {
          if (_this2.userController.isActionSuccessful('getPendency', _this2.Actions.G, response)) ;
        })["catch"](function (error) {});
        return result;
      }
      /**
       * 删除好友申请
       *
       * @param {Object} options
       * @param {string[]} options.toAccount - 用户账号或昵称
       * @param {String} [options.pendencyType='Pendency_Type_ComeIn'] - Pendency_Type_ComeIn: 别人发给我的; Pendency_Type_SendOut: 我发给别人的
       * @returns {Promise}
       * @memberof UserController
       */

    }, {
      key: "deletePendency",
      value: function deletePendency(options) {
        var _this3 = this;

        var config = this.userController.generateConfig(this.TAG, this.Actions.D, options);
        var result = this.userController.request(config);
        result.then(function (response) {
          if (_this3.userController.isActionSuccessful('deletePendency', _this3.Actions.D, response)) ;
        })["catch"](function (error) {});
        return result;
      }
      /**
       *
       *
       * @param {Object} options - 请求参数
       * @param {String} options.toAccount - 目标用户名
       * @param {Number} options.action - 0（同意） / 1（同意并加为好友）/ -1 (拒绝)
       * @param {Object[]} [options.items] - 可选字段，用于批量处理好友申请。当使用该字段时则options.toAccount和options.action失效。
       * @param {String} [options.items.toAccount] - 目标用户名
       * @param {Number} [options.items.action] - 0（同意） / 1（同意并加为好友）/ -1 (拒绝)
       * @returns {Promise}
       * @memberof UserController
       */

    }, {
      key: "replyPendency",
      value: function replyPendency() {
        var _this4 = this;

        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var config = this.userController.generateConfig(this.TAG, this.Actions.U, options);
        var result = this.userController.request(config);
        result.then(function (response) {
          if (_this4.userController.isActionSuccessful('replyPendency', _this4.Actions.U, response)) ;
        })["catch"](function (error) {});
        return result;
      }
    }]);

    return ApplyC2CHandler;
  }();

  /**
   * 用户资料类，管理profile friends blacklist apply等
   * @class
   * @extends IMController
   * @uses TransportCapsule
   */

  var UserController =
  /*#__PURE__*/
  function (_IMController) {
    _inherits(UserController, _IMController);

    /**
     * @constructor
     * @param { TIM } tim
     */
    function UserController(tim) {
      var _this;

      _classCallCheck(this, UserController);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(UserController).call(this, tim));
      _this.profileHandler = new ProfileHandler(_assertThisInitialized(_this));
      _this.friendHandler = new FriendHandler(_assertThisInitialized(_this));
      _this.blacklistHandler = new BlacklistHandler(_assertThisInitialized(_this));
      _this.applyC2CHandler = new ApplyC2CHandler(_assertThisInitialized(_this));

      _this._initializeListener();

      return _this;
    }

    _createClass(UserController, [{
      key: "_initializeListener",
      value: function _initializeListener(event) {
        var innerEmitter = this.tim.innerEmitter; // 登录态变更时触发，登录成功必触发一次

        innerEmitter.on(TIM_INNER_EVENT.CONTEXT_A2KEY_AND_TINYID_UPDATED, this.onContextUpdated, this);
        innerEmitter.on(TIM_INNER_EVENT.NOTICE_LONGPOLL_PROFILE_MODIFIED, this.onProfileModified, this);
        innerEmitter.on(TIM_INNER_EVENT.NOTICE_LONGPOLL_NEW_FRIEND_MESSAGES, this.onNewFriendMessages, this);
        innerEmitter.on(TIM_INNER_EVENT.CONVERSATION_LIST_PROFILE_UPDATED, this.onConversationsProfileUpdated, this);
      }
    }, {
      key: "onContextUpdated",
      value: function onContextUpdated(event) {
        // 在 context.a2Key 和 context.tinyID 没赋值的情况下， 不继续执行查询。
        var context = this.tim.context;

        if (!!context.a2Key === false || !!context.tinyID === false) {
          return;
        }

        this.profileHandler.getMyProfile();
        this.friendHandler.getFriendList();
        this.blacklistHandler.getBlacklist();
      } // 获取个人资料成功，triggerReady

    }, {
      key: "onGotMyProfile",
      value: function onGotMyProfile() {
        this.triggerReady();
      }
    }, {
      key: "onProfileModified",
      value: function onProfileModified(event) {
        this.profileHandler.onProfileModified(event);
      }
    }, {
      key: "onNewFriendMessages",
      value: function onNewFriendMessages(event) {
        logger.debug('onNewFriendMessages', JSON.stringify(event.data));

        if (!isEmpty(event.data.blackListDelAccount)) {
          this.blacklistHandler.handleBlackListDelAccount(event.data.blackListDelAccount);
        }

        if (!isEmpty(event.data.blackListAddAccount)) {
          this.blacklistHandler.handleBlackListAddAccount(event.data.blackListAddAccount);
        }
      }
    }, {
      key: "onConversationsProfileUpdated",
      value: function onConversationsProfileUpdated(event) {
        this.profileHandler.onConversationsProfileUpdated(event.data);
      } // 获取我的账号

    }, {
      key: "getMyAccount",
      value: function getMyAccount() {
        return this.tim.context.identifier;
      }
    }, {
      key: "isMyFriend",
      value: function isMyFriend(userID) {
        return this.friendHandler.isMyFriend(userID);
      }
    }, {
      key: "generateConfig",
      value: function generateConfig(name, action, options) {
        return {
          name: name,
          action: action,
          param: options
        };
      } // 拉取个人资料

    }, {
      key: "getMyProfile",
      value: function getMyProfile() {
        return this.profileHandler.getMyProfile();
      }
      /**
       * 拉取其他用户资料（也可用于搜索用户）
       * @param {Object} options 请求参数
       * @param {String[]} options.userIDList userID 列表
       * @param {String[]} [options.tagList] 默认查询所有资料。
       * 可传入 tag 指定拉取资料，支持字段参考：inner-types.js 文件下的 STANDARD_IM_PROFILE（供内部使用，不暴露给接入测）
       * @returns {Promise}
       */

    }, {
      key: "getUserProfile",
      value: function getUserProfile(options) {
        return this.profileHandler.getUserProfile(options);
      } // 更新个人资料

    }, {
      key: "updateMyProfile",
      value: function updateMyProfile(options) {
        return this.profileHandler.updateMyProfile(options);
      } // 拉取我的好友列表

    }, {
      key: "getFriendList",
      value: function getFriendList() {
        return this.friendHandler.getFriendList();
      }
      /**
       * 删除好友
       *
       * @param {Object} options
       * @param {array} options.toAccount - 待删除的好友的 Identifier 列表，单次请求的 To_Account 数不得超过 1000
       * @param {String} options.deleteType - 删除模式，[详情参考]{@link https://cloud.tencent.com/document/product/269/1501#.E5.88.A0.E9.99.A4.E5.A5.BD.E5.8F.8B}
       * @memberOf UserController
       * @returns {Promise}
       * @example
       * app.userController.deleteFriend({
       *  toAccount: ['User4Test02'],
       *  deleteType: 'CheckResult_Type_Singal'
       * })
       */

    }, {
      key: "deleteFriend",
      value: function deleteFriend(options) {
        return this.friendHandler.deleteFriend(options);
      } // 获取黑名单

    }, {
      key: "getBlacklist",
      value: function getBlacklist() {
        return this.blacklistHandler.getBlacklist();
      } // 增加黑名单

    }, {
      key: "addBlacklist",
      value: function addBlacklist(options) {
        return this.blacklistHandler.addBlacklist(options);
      } // 删除黑名单

    }, {
      key: "deleteBlacklist",
      value: function deleteBlacklist(options) {
        return this.blacklistHandler.deleteBlacklist(options);
      }
      /**
       * 添加好友申请
       * @param { array.<[{To_Account: string, Remark: string, GroupName: string, AddSource: string, AddWording: string}]> } options - 添加好友信息的结构数组，详情请参考：{@link https://cloud.tencent.com/document/product/269/1643#.E8.AF.B7.E6.B1.82.E5.8C.85.E5.AD.97.E6.AE.B5.E8.AF.B4.E6.98.8E | 添加好友API}
       * @param {String} options[n].To_Account - 必填，添加的好友的账号
       * @param {String} options[n].Remark - 选填，备注
       * @param {String} options[n].GroupName - 选填，分组信息
       * @param {String} options[n].AddSource - 选填，好友来源
       * @param {String} options[n].AddWording - 选填，附言
       * @param {String} options.AddType - 选填，加好友方式，"Add_Type_Single" 表示单向加好友，"Add_Type_Both"表示双向加好友，默认为"Add_Type_Both"
       * @description
       */

    }, {
      key: "applyAddFriend",
      value: function applyAddFriend(options) {
        return this.applyC2CHandler.applyAddFriend(options);
      }
      /**
       * 获取未受理的好友申请
       *
       * @param {Object} options
       * @param {String} [options.pendencyType='Pendency_Type_ComeIn'] - Pendency_Type_ComeIn: 别人发给我的; Pendency_Type_SendOut: 我发给别人的
       * @param {Number} [options.startTime=0] - 好友申请的起始时间
       * @param {Number} [options.maxLimited=30] - 分页大小，如果取值为30 则表示客户端要求服务器端每页最多返回30个好友申请
       * @param {Number} [options.lastSequence=0] - 好友申请数据的版本号，用户每收到或删除一条好友申请，服务器端就自增一次好友申请数据版本号，一般传0，表示拉取最新的数据
       * @returns {Promise}
       * @memberof UserController
       */

    }, {
      key: "getPendency",
      value: function getPendency(options) {
        return this.applyC2CHandler.getPendency(options);
      }
      /**
       * 删除好友申请
       *
       * @param {Object} options
       * @param {string[]} options.toAccount - 用户账号或昵称
       * @param {String} [options.pendencyType='Pendency_Type_ComeIn'] - Pendency_Type_ComeIn: 别人发给我的; Pendency_Type_SendOut: 我发给别人的
       * @returns {Promise}
       * @memberof UserController
       */

    }, {
      key: "deletePendency",
      value: function deletePendency(options) {
        return this.applyC2CHandler.deletePendency(options);
      }
      /**
       *
       *
       * @param {Object} options - 请求参数
       * @param {String} options.toAccount - 目标用户名
       * @param {Number} options.action - 0（同意） / 1（同意并加为好友）/ -1 (拒绝)
       * @param {Object[]} [options.items] - 可选字段，用于批量处理好友申请。当使用该字段时则options.toAccount和options.action失效。
       * @param {String} [options.items.toAccount] - 目标用户名
       * @param {Number} [options.items.action] - 0（同意） / 1（同意并加为好友）/ -1 (拒绝)
       * @returns {Promise}
       * @memberof UserController
       */

    }, {
      key: "replyPendency",
      value: function replyPendency(options) {
        return this.applyC2CHandler.replyPendency(options);
      }
    }, {
      key: "reset",
      value: function reset() {
        logger.info('UserController.reset');
        this.resetReady();
        this.profileHandler.reset();
        this.blacklistHandler.reset(); // 是否需要清理定时器？

        this.checkTimes = 0;
      }
    }]);

    return UserController;
  }(IMController);

  var validGroupProperty = ['groupID', 'name', 'avatar', 'type', 'introduction', 'notification', 'ownerID', 'selfInfo', 'createTime', 'infoSequence', 'lastInfoTime', 'lastMessage', 'nextMessageSeq', 'memberNum', 'maxMemberNum', 'memberList', 'joinOption', 'groupCustomField'];
  /**
   * 群组对象，用于描述群组具有的属性，如类型、群组公告、创建时间等。
   * @class Group
   * @property {String} groupID 群组的唯一标识，群组 ID，App 内保证唯一，其格式前缀为 @TGS#。另外，App 亦可自定义群组 ID
   * @property {String} name 群组名称，最长30字节，不可调整
   * @property {String} avatar 群组头像 URL，最长100字节，不可调整
   * @property {String} type 群组类型，当前 SDK 支持的类型如下：<br/>
   * | 类型 | 含义 |
   * | :--- | :---- |
   * | TIM.TYPES.GRP_PRIVATE | 私有群 |
   * | TIM.TYPES.GRP_PUBLIC | 公开群 |
   * | TIM.TYPES.GRP_CHATROOM | 聊天室 |
   * | TIM.TYPES.GRP_AVCHATROOM | 音视频聊天室 |
   * @property {String} introduction 群组简介，最长120字节，不可调整
   * @property {String} notification 群组公告，最长150字节，不可调整
   * @property {String} ownerID 群主 ID
   * @property {Number} createTime 群组的创建时间
   * @property {Number} infoSequence 群资料的每次变都会增加该值
   * @property {Number} lastInfoTime 群组最后一次信息变更时间
   * @property {Object} selfInfo 当前用户在群组中的信息
   * @property {String} selfInfo.role 角色
   * @property {String} selfInfo.messageRemindType 消息接收选项<br/>
   * - TIM.TYPES.MSG_REMIND_ACPT_AND_NOTE - SDK 接收消息并通知接入侧（抛出 {@link  module:EVENT.MESSAGE_RECEIVED 收到消息事件}），接入侧做提示
   * - TIM.TYPES.MSG_REMIND_ACPT_NOT_NOTE - SDK 接收消息并通知接入侧（抛出 {@link  module:EVENT.MESSAGE_RECEIVED 收到消息事件}），接入侧不做提示
   * - TIM.TYPES.MSG_REMIND_DISCARD - SDK 拒收消息
   * @property {Number} selfInfo.joinTime 入群时间
   * @property {String} selfInfo.nameCard 群名片
   * @property {Object} lastMessage 群组最后一条消息。注意：若会话列表中没有该群组，则该对象只有 lastTime 有值，其他值为空。
   * @property {Number} lastMessage.lastTime 群组最后一条消息的时间戳，单位：秒
   * @property {Number} lastMessage.lastSequence - 当前群组类型会话的最新消息的 Seq
   * @property {Number} lastMessage.fromAccount 群组最后一条消息的来源用户
   * @property {Number} lastMessage.messageForShow 用于展示的群组最后一条消息的简要内容，文本则展示原内容，图片则展示“[图片]”。
   * @property {Number} nextMessageSeq 群内下一条消息的 Seq，群组内每一条消息都有一条唯一的消息 Seq，且该 Seq 是按照发消息顺序而连续的。从 1 开始，群内每增加一条消息，nextMessageSeq 就会增加 1
   * @property {Number} memberNum 当前成员数量
   * @property {Number} maxMemberNum 最大成员数量
   * @property {String} joinOption 申请加群选项。
     * - TIM.TYPES.JOIN_OPTIONS_FREE_ACCESS（自由加入，音视频聊天室固定为该值）
     * - TIM.TYPES.JOIN_OPTIONS_NEED_PERMISSION（需要验证）
     * - TIM.TYPES.JOIN_OPTIONS_DISABLE_APPLY（禁止加群，私有群固定为该值）
   * @property {Object[]} groupCustomField 群组自定义字段。默认情况是没有的。开通群组维度的自定义字段详情请参见 {@link https://cloud.tencent.com/document/product/269/1502#.E8.87.AA.E5.AE.9A.E4.B9.89.E5.AD.97.E6.AE.B5 自定义字段}
   * @property {String} groupCustomField.key 群组自定义字段的 Key
   * @property {String} groupCustomField.value 群组自定义字段的 Value
   */

  var Group =
  /*#__PURE__*/
  function () {
    function Group(options) {
      _classCallCheck(this, Group);

      this.groupID = '';
      this.name = '';
      this.avatar = '';
      this.type = '';
      this.introduction = '';
      this.notification = '';
      this.ownerID = '';
      this.createTime = '';
      this.infoSequence = '';
      this.lastInfoTime = '';
      this.selfInfo = {
        messageRemindType: '',
        joinTime: '',
        nameCard: '',
        role: ''
      };
      this.lastMessage = {
        lastTime: '',
        lastSequence: '',
        fromAccount: '',
        messageForShow: ''
      };
      this.nextMessageSeq = '';
      this.memberNum = '';
      this.maxMemberNum = '';
      this.joinOption = '';
      this.groupCustomField = [];

      this._initGroup(options);
    }

    _createClass(Group, [{
      key: "_initGroup",
      value: function _initGroup(options) {
        for (var key in options) {
          if (validGroupProperty.indexOf(key) < 0) continue;

          if (key === 'selfInfo') {
            this.updateSelfInfo(options[key]);
            continue;
          }

          this[key] = options[key];
        }
      }
      /**
       * 更新群组信息
       * @private
       * @param {Object} group 待更新的群组资料配置
       * @memberof Group
       */

    }, {
      key: "updateGroup",
      value: function updateGroup(group) {
        // 把后端接口的 lastMsgTime 存入 lastMessage.lastTime 中
        if (group.lastMsgTime) {
          this.lastMessage.lastTime = group.lastMsgTime;
        } // 更新自定义字段


        if (group.groupCustomField) {
          updateCustomField(this.groupCustomField, group.groupCustomField);
        }

        deepMerge(this, group, ['members', 'errorCode', 'lastMsgTime', 'groupCustomField']);
      }
      /**
       * 更新 selfInfo
       * 注意：messageRemindType 无法更新，因为获取群成员资料接口拿不到这个字段
       * TODO: 后续要找后端同学支持查询 selfInfo
       * @param {GroupMember} member 自己的群成员资料 Model
       * @memberof Group
       * @private
       */

    }, {
      key: "updateSelfInfo",
      value: function updateSelfInfo(_ref) {
        var nameCard = _ref.nameCard,
            joinTime = _ref.joinTime,
            role = _ref.role,
            messageRemindType = _ref.messageRemindType;
        deepMerge(this.selfInfo, {
          nameCard: nameCard,
          joinTime: joinTime,
          role: role,
          messageRemindType: messageRemindType
        }, [], ['', null, undefined, 0, NaN]);
      }
      /**
       * @private
       * @param {String} nameCard 群名片
       * @memberof Group
       */

    }, {
      key: "setSelfNameCard",
      value: function setSelfNameCard(nameCard) {
        this.selfInfo.nameCard = nameCard;
      }
    }]);

    return Group;
  }();

  var mapMessageForShow = function mapMessageForShow(type, payload) {
    if (isUndefined(payload)) {
      return '';
    }

    switch (type) {
      case TYPES.MSG_TEXT:
        return payload.text;

      case TYPES.MSG_IMAGE:
        return '[图片]';

      case TYPES.MSG_GEO:
        return '[位置]';

      case TYPES.MSG_AUDIO:
        return '[语音]';

      case TYPES.MSG_VIDEO:
        return '[视频]';

      case TYPES.MSG_FILE:
        return '[文件]';

      case TYPES.MSG_CUSTOM:
        return '[自定义消息]';

      case TYPES.MSG_GRP_TIP:
        return '[群提示消息]';

      case TYPES.MSG_GRP_SYS_NOTICE:
        return '[群系统通知]';

      case TYPES.MSG_FACE:
        return '[动画表情]';

      default:
        return '';
    }
  };
  /**
   * 计算 lastMessage
   * @param {Object|Message} message 消息
   * @returns {Object}
   * @private
   */


  var computeLastMessage = function computeLastMessage(message) {
    if (isUndefined(message)) {
      return {
        lastTime: 0,
        lastSequence: 0,
        fromAccount: 0,
        messageForShow: '',
        payload: null,
        type: '',
        isRevoked: false
      };
    } // 登录期间收到消息时会执行到此处


    if (message instanceof Message) {
      return {
        lastTime: message.time || 0,
        lastSequence: message.sequence || 0,
        fromAccount: message.from || '',
        messageForShow: mapMessageForShow(message.type, message.payload),
        payload: message.payload || null,
        type: message.type || null,
        isRevoked: false
      };
    } // 拉取会话列表后创建会话 Model 会执行到此处
    // 不使用后端的messageForShow字段，原因：最后一条消息是视频消息时，后端给的该字段是空值


    return _objectSpread2({}, message, {
      isRevoked: false,
      messageForShow: mapMessageForShow(message.type, message.payload)
    });
  };
  /**
   * 会话对象，用于描述会话具有的属性，如类型、消息未读计数、最新消息等。
   * @class Conversation
   * @property {String} conversationID - 会话 ID。会话ID组成方式：<br/>
   * - C2C+userID（单聊）
   * - GROUP+groupID（群聊）
   * - @TIM#SYSTEM（系统通知会话）
   * @property {String} type - 会话类型，具体如下：<br/>
   * | 类型 | 含义 |
   * | :--- | :---- |
   * | TIM.TYPES.CONV_C2C | C2C（Client to Client, 端到端）会话 |
   * | TIM.TYPES.CONV_GROUP | GROUP（群组）会话 |
   * | TIM.TYPES.CONV_SYSTEM | SYSTEM（系统）会话。该会话只能接收来自系统的通知消息，不能发送消息。 |
   * @property {String} subType - 群组会话的群组类型，具体如下：<br/>
   * | 类型 | 含义 |
   * | :--- | :---- |
   * | TIM.TYPES.GRP_PRIVATE | 私有群 |
   * | TIM.TYPES.GRP_PUBLIC | 公开群 |
   * | TIM.TYPES.GRP_CHATROOM | 聊天室 |
   * | TIM.TYPES.GRP_AVCHATROOM | 音视频聊天室 |
   * @property {Number} unreadCount - 未读计数。TIM.TYPES.GRP_CHATROOM / TIM.TYPES.GRP_AVCHATROOM 类型的群组会话不记录未读计数，该字段值为0
   * @property {Object} lastMessage - 会话最新的消息
   * @property {Number} lastMessage.lastTime - 当前会话最新消息的时间戳，单位：秒
   * @property {Number} lastMessage.lastSequence - 当前会话的最新消息的 Sequence
   * @property {String} lastMessage.fromAccount - 最新消息来源用户的 userID
   * @property {String} lastMessage.messageForShow - 最新消息的内容，用于展示。可能值：文本消息内容、"[图片]"、"[语音]"、"[位置]"、"[表情]"、"[文件]"、"[自定义消息]"。<br/>
   * 若该字段不满足您的需求，您可以使用 payload 来自定义渲染。
   * @property {String} lastMessage.type - 消息类型，具体如下：<br/>
   * | 类型 | 含义 |
   * | :--- | :---- |
   * | TIM.TYPES.MSG_TEXT | 文本消息 |
   * | TIM.TYPES.MSG_IMAGE | 图片消息 |
   * | TIM.TYPES.MSG_SOUND | 音频消息（已废弃，请使用 TIM.TYPES.MSG_AUDIO ） |
   * | TIM.TYPES.MSG_AUDIO | 音频消息 |
   * | TIM.TYPES.MSG_FILE | 文件消息 |
   * | TIM.TYPES.MSG_GRP_TIP | 群提示消息 |
   * | TIM.TYPES.MSG_GRP_SYS_NOTICE | 群系统通知消息 |
   * @property {Object} lastMessage.payload - 消息的内容，具体如下：<br/>
   * - {@link Message.TextPayload 文本}
   * - {@link Message.ImagePayload 图片}
   * - {@link Message.AudioPayload 音频}
   * - {@link Message.FilePayload 文件}
   * - {@link Message.CustomPayload 自定义}
   * - {@link Message.GroupTipPayload 群提示消息}
   * - {@link Message.GroupSystemNoticePayload 群系统通知} <br/>
   * 注意：收到的音频 / 文件消息的 payload 中没有 url 字段。
   * @property {Group} groupProfile - 群组会话的群组资料
   * @property {Profile} userProfile - C2C会话的用户资料
   *
   */


  var Conversation =
  /*#__PURE__*/
  function () {
    function Conversation(options) {
      _classCallCheck(this, Conversation);

      this.conversationID = options.conversationID || '';
      this.unreadCount = options.unreadCount || 0;
      this.type = options.type || '';
      this.lastMessage = computeLastMessage(options.lastMessage); // this._hasInfo = false; // 是否有 userProfile / groupProfile，用于渲染会话列表

      this._isInfoCompleted = false; // userProfile / groupProfile 信息是否完整，用于渲染当前会话

      this._initProfile(options);
    }

    _createClass(Conversation, [{
      key: "_initProfile",
      value: function _initProfile(options) {
        var _this = this;

        Object.keys(options).forEach(function (key) {
          switch (key) {
            case 'userProfile':
              _this.userProfile = options.userProfile;
              break;

            case 'groupProfile':
              _this.groupProfile = options.groupProfile;
              break;
          }
        });

        if (isUndefined(this.userProfile) && this.type === TYPES.CONV_C2C) {
          this.userProfile = new Profile({
            userID: options.conversationID.replace('C2C', '')
          });
        } else if (isUndefined(this.groupProfile) && this.type === TYPES.CONV_GROUP) {
          this.groupProfile = new Group({
            groupID: options.conversationID.replace('GROUP', '')
          });
        }
      }
      /**
       * 更新未读计数
       * @param {Number} nextUnreadCount 当前会话收到的实时消息数量 或者 后端给的未读计数
       * @param {Boolean} [isFromGetConversationList] 该次更新未读计数是否由【拉取会话列表】触发
       * 1. true，则 nextUnreadCount 表示后端给的未读计数
       * 2. false，则 nextUnreadCount 表示当前会话收到的实时消息数量
       * @returns {undefined}
       * @memberof Conversation
       * @private
       */

    }, {
      key: "updateUnreadCount",
      value: function updateUnreadCount(nextUnreadCount, isFromGetConversationList) {
        if (isUndefined(nextUnreadCount)) {
          return;
        } // ChatRoom 和 AVChatRoom 无未读


        if (isChatRoom(this.subType) || isAVChatRoom(this.subType)) {
          this.unreadCount = 0;
          return;
        } // 拉取会话列表时，C2C 未读不变，群组未读用后端计数


        if (isFromGetConversationList && this.type === TYPES.CONV_GROUP) {
          this.unreadCount = nextUnreadCount;
          return;
        } // 其他情况直接累加


        this.unreadCount = this.unreadCount + nextUnreadCount;
      }
      /**
       * 每调用一次，会话的未读数 -1
       * @private
       */

    }, {
      key: "reduceUnreadCount",
      value: function reduceUnreadCount() {
        if (this.unreadCount >= 1) {
          this.unreadCount -= 1;
        }
      }
      /**
       * 判断是否是会话的 lastMessage 被撤回了
       * @param {Message} message 被撤回的消息实例
       * @returns {Boolean}
       * @memberof Conversation
       */

    }, {
      key: "isLastMessageRevoked",
      value: function isLastMessageRevoked(_ref) {
        var sequence = _ref.sequence,
            time = _ref.time;

        // C2C 会话判断 sequence 和 time 是否匹配
        if (this.type === TYPES.CONV_C2C && sequence === this.lastMessage.lastSequence && time === this.lastMessage.lastTime) {
          return true;
        } // GROUP 会话判断 sequence 是否匹配


        if (this.type === TYPES.CONV_GROUP && sequence === this.lastMessage.lastSequence) {
          return true;
        }

        return false;
      }
    }, {
      key: "setLastMessageRevoked",
      value: function setLastMessageRevoked(value) {
        this.lastMessage.isRevoked = value;
      }
    }, {
      key: "toAccount",
      get: function get() {
        return this.conversationID.replace('C2C', '').replace('GROUP', '');
      }
      /**
       * 群组会话的群类型
       * @readonly
       * @memberof Conversation
       * @private
       */

    }, {
      key: "subType",
      get: function get() {
        if (this.groupProfile) {
          return this.groupProfile.type;
        }

        return '';
      }
    }]);

    return Conversation;
  }();

  /**
   * 会话管理
   * @class ConversationController
   * @extends {IMController}
   * @author rychouwei
   */

  var ConversationController =
  /*#__PURE__*/
  function (_IMController) {
    _inherits(ConversationController, _IMController);

    function ConversationController(tim) {
      var _this;

      _classCallCheck(this, ConversationController);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(ConversationController).call(this, tim));
      _this.pagingStatus = TIM_STATUS.PAGING_CONVERSATION.NOT_START; // 分页同步会话列表的状态

      _this.pagingTimeStamp = 0; // 分页同步会话列表的时间戳

      _this.conversationMap = new Map(); // Map<conversationID, Conversation>
      // 该字段用于防止：更新对应群组会话的groupProfile时，但内存中还没有conversationMap，导致会话群组信息更新被忽略

      _this.tempGroupList = [];

      _this._initListeners();

      return _this;
    }

    _createClass(ConversationController, [{
      key: "hasLocalConversationMap",
      value: function hasLocalConversationMap() {
        return this.conversationMap.size > 0;
      }
      /**
       * 创建临时会话
       * @param {string} conversationID - 会话ID
       * @memberof ConversationController
       * @returns {Conversation}
       */

    }, {
      key: "createLocalConversation",
      value: function createLocalConversation(conversationID) {
        // 如果内存没有当前会话，则创建
        if (this.conversationMap.has(conversationID)) {
          return this.conversationMap.get(conversationID);
        }

        return new Conversation({
          conversationID: conversationID,
          type: conversationID.slice(0, 3) === TYPES.CONV_C2C ? TYPES.CONV_C2C : TYPES.CONV_GROUP
        });
      }
      /**
       * 判断内存中某会话是否存在
       * @param {String} conversationID - 会话ID
       * @returns {Boolean} 是否存在某会话
       */

    }, {
      key: "hasLocalConversation",
      value: function hasLocalConversation(conversationID) {
        return this.conversationMap.has(conversationID);
      }
      /**
       * 拉取最新100条会话更新。
       * @returns {Promise}
       * @memberof ConversationController
       */

    }, {
      key: "getConversationList",
      value: function getConversationList() {
        var _this2 = this;

        logger.log('ConversationController.getConversationList.'); // 若分页同步会话列表时，异常中断了，可在此处继续分页同步

        if (this.pagingStatus === TIM_STATUS.PAGING_CONVERSATION.REJECTED) {
          logger.log('ConversationController.getConversationList. continue to sync conversationList');

          this._syncConversationList();
        } // event stat


        var ssoLog = new SSOLogData();
        ssoLog.setMethod(SSOMethods.GET_CONVERSATION_LIST).setStart();
        return this.request({
          name: 'conversation',
          action: 'query'
        }).then(function (_ref) {
          var _ref$data$conversatio = _ref.data.conversations,
              conversations = _ref$data$conversatio === void 0 ? [] : _ref$data$conversatio;

          var conversationOptions = _this2._getConversationOptions(conversations);

          _this2._updateLocalConversationList(conversationOptions, true);

          _this2._setStorageConversationList(); // event stat


          ssoLog.setCode(0).setText(conversations.length).setNetworkType(_this2.getNetworkType()).setEnd();
          logger.log('ConversationController.getConversationList ok.');
          return IMPromise.resolve({
            conversationList: _this2.getLocalConversationList()
          });
        })["catch"](function (error) {
          // event stat
          _this2.probeNetwork().then(function (_ref2) {
            var _ref3 = _slicedToArray(_ref2, 2),
                bOnline = _ref3[0],
                networkType = _ref3[1];

            ssoLog.setError(error, bOnline, networkType).setEnd();
          });

          logger.error('ConversationController.getConversationList error:', error);
          return IMPromise.reject(error);
        });
      }
      /**
       * 同步会话列表
       * 注意：
       * 1. 该接口会自动分页同步，每同步一页，都会全量抛出本地的会话列表。
       * 2. 若同步过程中，拉取某页会话异常，经过网络层的自动重试后，还是异常，此时同步会话列表失败。
       * 3. 在接入侧调用 getConversationList 时，会尝试继续同步会话列表。
       * @returns {Promise}
       * @memberof ConversationController
       */

    }, {
      key: "_syncConversationList",
      value: function _syncConversationList() {
        var _this3 = this;

        // event stat
        var ssoLog = new SSOLogData();
        ssoLog.setMethod(SSOMethods.SYNC_CONVERSATION_LIST).setStart(); // 首次同步时，本地 Map 的数据是历史缓存的，先清理后再执行同步

        if (this.pagingStatus === TIM_STATUS.PAGING_CONVERSATION.NOT_START) {
          this.conversationMap.clear();
        }

        return this._autoPagingSyncConversationList().then(function (imResponse) {
          // 同步完成
          _this3.pagingStatus = TIM_STATUS.PAGING_CONVERSATION.RESOLVED;

          _this3._setStorageConversationList(); // event stat


          ssoLog.setCode(0).setText("".concat(_this3.conversationMap.size)).setNetworkType(_this3.getNetworkType()).setEnd();
          return imResponse;
        })["catch"](function (error) {
          // 同步失败
          _this3.pagingStatus = TIM_STATUS.PAGING_CONVERSATION.REJECTED; // event stat

          ssoLog.setText(_this3.pagingTimeStamp);

          _this3.probeNetwork().then(function (_ref4) {
            var _ref5 = _slicedToArray(_ref4, 2),
                bOnline = _ref5[0],
                networkType = _ref5[1];

            ssoLog.setError(error, bOnline, networkType).setEnd();
          });

          return IMPromise.reject(error);
        });
      }
      /**
       * 自动分页同步会话列表
       * @returns {Promise}
       * @memberof ConversationController
       */

    }, {
      key: "_autoPagingSyncConversationList",
      value: function _autoPagingSyncConversationList() {
        var _this4 = this;

        this.pagingStatus = TIM_STATUS.PAGING_CONVERSATION.PENDING;
        return this.request({
          name: 'conversation',
          action: 'pagingQuery',
          param: {
            fromAccount: this.tim.context.identifier,
            timeStamp: this.pagingTimeStamp,
            orderType: 1 // 表示从旧往新拉取，目前只支持这种方式

          }
        }).then(function (_ref6) {
          var _ref6$data = _ref6.data,
              completeFlag = _ref6$data.completeFlag,
              _ref6$data$conversati = _ref6$data.conversations,
              conversations = _ref6$data$conversati === void 0 ? [] : _ref6$data$conversati,
              timeStamp = _ref6$data.timeStamp;
          logger.log("ConversationController._autoPagingSyncConversationList completeFlag=".concat(completeFlag, " nums=").concat(conversations.length));

          if (conversations.length > 0) {
            var conversationOptions = _this4._getConversationOptions(conversations);

            _this4._updateLocalConversationList(conversationOptions, true);
          } // 注意：triggerReady 时机不能轻易变更，SDK_READY 时机取决于 conversation ready。
          // 例如：不能放到上面 if 代码块，放到上面代码块的话，新注册的用户登录时，就无法 triggerReady


          if (_this4._isReady) {
            _this4._emitConversationUpdate();
          } else {
            _this4.triggerReady();
          }

          _this4.pagingTimeStamp = timeStamp; // 未拉完则自动续拉

          if (completeFlag !== 1) {
            return _this4._autoPagingSyncConversationList();
          }

          return IMPromise.resolve();
        });
      }
      /**
       * 获取会话信息
       * @param {String} conversationID - 会话ID
       * @returns {IMPromise}
       */

    }, {
      key: "getConversationProfile",
      value: function getConversationProfile(conversationID) {
        var conversation = this.conversationMap.has(conversationID) ? this.conversationMap.get(conversationID) : this.createLocalConversation(conversationID); // 1. 若会话资料已经完整 或 群系统类型会话，则直接返回对应会话

        if (conversation._isInfoCompleted || conversation.type === TYPES.CONV_SYSTEM) {
          return IMPromise.resolve({
            conversation: conversation
          });
        } // 2. 完整更新会话 Info


        logger.log('ConversationController.getConversationProfile. conversationID:', conversationID);
        return this._updateUserOrGroupProfileCompletely(conversation).then(function (imResponse) {
          logger.log('ConversationController.getConversationProfile ok. conversationID:', conversationID);
          return imResponse;
        })["catch"](function (imError) {
          logger.error('ConversationController.getConversationProfile error:', imError);
          return IMPromise.reject(imError);
        });
      }
      /**
       * 删除会话。
       * 注意：如果没有该会话，会返回true。
       * @param {String|Number} conversationID
       * @returns {Promise} 若删除成功则执行then，否则执行catch
       * @memberof ConversationController
       */

    }, {
      key: "deleteConversation",
      value: function deleteConversation(conversationID) {
        var _this5 = this;

        var options = {};

        if (!this.conversationMap.has(conversationID)) {
          var error = new IMError({
            code: ERROR_CODE.CONVERSATION_NOT_FOUND,
            message: ERROR_MESSAGE.CONVERSATION_NOT_FOUND
          });
          return IMPromise.reject(error);
        }

        switch (this.conversationMap.get(conversationID).type) {
          case TYPES.CONV_C2C:
            options.type = 1;
            options.toAccount = conversationID.slice(3);
            break;

          case TYPES.CONV_GROUP:
            options.type = 2;
            options.toGroupID = conversationID.slice(5);
            break;

          case TYPES.CONV_SYSTEM:
            // 删除所有群系统消息
            this.tim.groupController.deleteGroupSystemNotice({
              messageList: this.tim.messageController.getLocalMessageList(conversationID)
            });
            this.deleteLocalConversation(conversationID);
            return IMPromise.resolve({
              conversationID: conversationID
            });

          default:
            {
              var _error = new IMError({
                code: ERROR_CODE.CONVERSATION_UN_RECORDED_TYPE,
                message: ERROR_MESSAGE.CONVERSATION_UN_RECORDED_TYPE
              });

              return IMPromise.reject(_error);
            }
        }

        logger.log('ConversationController.deleteConversation. conversationID:', conversationID);
        return this.tim.setMessageRead({
          conversationID: conversationID
        }).then(function () {
          return _this5.request({
            name: 'conversation',
            action: 'delete',
            param: options
          });
        }).then(function () {
          logger.log('ConversationController.deleteConversation ok. conversationID:', conversationID);

          _this5.deleteLocalConversation(conversationID);

          return IMPromise.resolve({
            conversationID: conversationID
          });
        })["catch"](function (error) {
          logger.error('ConversationController.deleteConversation error:', error);
          return IMPromise.reject(error);
        });
      }
      /**
       * 获取会话列表
       * @returns {Promise}
       * @memberof ConversationController
       */

    }, {
      key: "getLocalConversationList",
      value: function getLocalConversationList() {
        return _toConsumableArray(this.conversationMap.values());
      }
      /**
       * 会话对象
       * @typedef {Object} Conversation
       */

      /**
       * 根据conversationID获取会话
       * @param {String} conversationID
       * @returns {Conversation}
       * @memberof ConversationController
       */

    }, {
      key: "getLocalConversation",
      value: function getLocalConversation(conversationID) {
        return this.conversationMap.get(conversationID);
      }
      /**
       * 初始化会话列表。若缓存有则用缓存初始化会话列表，等待消息初始化完成并组装最后一条消息，排序后，向外抛事件
       * @private
       * @memberof ConversationController
       */

    }, {
      key: "_initLocalConversationList",
      value: function _initLocalConversationList() {
        // event stat
        var ssoLog = new SSOLogData();
        ssoLog.setMethod(SSOMethods.GET_CONVERSATION_LIST_IN_STORAGE).setStart();
        logger.time(label.INIT_CONVERSATION_LIST);
        logger.log('ConversationController._initLocalConversationList init');

        var storageConversationList = this._getStorageConversationList(); // 1. 从本地 storage 初始化会话列表


        if (storageConversationList) {
          // 由本地缓存初始化会话列表。
          var length = storageConversationList.length;

          for (var i = 0; i < length; i++) {
            this.conversationMap.set(storageConversationList[i].conversationID, new Conversation(storageConversationList[i]));
          }

          this._emitConversationUpdate(true, false); // event stat


          ssoLog.setCode(0).setNetworkType(this.getNetworkType()).setText(length).setEnd();
        } else {
          // event stat
          ssoLog.setCode(0).setNetworkType(this.getNetworkType()).setText(0).setEnd(); // it means we have no cache
        } // 2. 同步会话列表


        this._syncConversationList();
      }
      /**
       * 获取本地 Storage 的会话列表
       * @private
       * @returns {Object}
       * @memberof ConversationController
       */

    }, {
      key: "_getStorageConversationList",
      value: function _getStorageConversationList() {
        return this.tim.storage.getItem('conversationMap');
      }
      /**
       * 设置本地 Storage 会话列表
       * @private
       * @param {Object} conversationMap
       * @memberof ConversationController
       */

    }, {
      key: "_setStorageConversationList",
      value: function _setStorageConversationList() {
        var localConversationList = this.getLocalConversationList();
        var tempConversationList = localConversationList.slice(0, 20).map(function (conversation) {
          return {
            conversationID: conversation.conversationID,
            type: conversation.type,
            subType: conversation.subType,
            lastMessage: conversation.lastMessage,
            groupProfile: conversation.groupProfile,
            userProfile: conversation.userProfile
          };
        });
        this.tim.storage.setItem('conversationMap', tempConversationList);
      }
      /**
       * 注册监听器
       * @private
       * @memberof ConversationController
       */

    }, {
      key: "_initListeners",
      value: function _initListeners() {
        var _this6 = this;

        // 登录态变更时触发，登录成功必触发一次
        this.tim.innerEmitter.once(TIM_INNER_EVENT.CONTEXT_A2KEY_AND_TINYID_UPDATED, this._initLocalConversationList, this); // 消息发送成功后触发

        this.tim.innerEmitter.on(TIM_INNER_EVENT.MESSAGE_SENT, this._onSendOrReceiveMessage, this); // 同步未读消息

        this.tim.innerEmitter.on(TIM_INNER_EVENT.MESSAGE_SYNC_PROCESSING, this._handleSyncMessages, this);
        this.tim.innerEmitter.on(TIM_INNER_EVENT.MESSAGE_SYNC_FINISHED, this._handleSyncMessages, this); // 收到消息推送,C2C消息

        this.tim.innerEmitter.on(TIM_INNER_EVENT.MESSAGE_C2C_INSTANT_RECEIVED, this._onSendOrReceiveMessage, this);
        this.tim.innerEmitter.on(TIM_INNER_EVENT.MESSAGE_GROUP_INSTANT_RECEIVED, this._onSendOrReceiveMessage, this);
        this.tim.innerEmitter.on(TIM_INNER_EVENT.MESSAGE_GROUP_SYSTEM_NOTICE_RECEIVED, this._onSendOrReceiveMessage, this); // 群组列表更新时触发

        this.tim.innerEmitter.on(TIM_INNER_EVENT.GROUP_LIST_UPDATED, this._onGroupListUpdated, this); // 有用户资料变更时触发

        this.tim.innerEmitter.on(TIM_INNER_EVENT.PROFILE_UPDATED, this._updateConversationUserProfile, this); // 有消息被撤回

        this.tim.innerEmitter.on(TIM_INNER_EVENT.MESSAGE_REVOKED, this._onMessageRevoked, this); // ready 时触发

        this.ready(function () {
          if (_this6.tempGroupList.length > 0) {
            _this6._updateConversationGroupProfile(_this6.tempGroupList);

            _this6.tempGroupList.length = 0;
          }
        });
      }
    }, {
      key: "_onGroupListUpdated",
      value: function _onGroupListUpdated(event) {
        this._updateConversationGroupProfile(event.data);
      }
      /**
       * 更新会话的群组信息
       * @private
       * @param {Group[]} groupList 群组列表
       * @memberof ConversationController
       */

    }, {
      key: "_updateConversationGroupProfile",
      value: function _updateConversationGroupProfile(groupList) {
        var _this7 = this;

        if (isArray(groupList) && groupList.length === 0) {
          return;
        }

        if (!this.hasLocalConversationMap()) {
          this.tempGroupList = groupList; // 该字段用于处理 本地无数据，对方请求先回来导致，更新被忽略的问题。

          return;
        }

        groupList.forEach(function (group) {
          var conversationID = "GROUP".concat(group.groupID);

          if (_this7.conversationMap.has(conversationID)) {
            var conversation = _this7.conversationMap.get(conversationID);

            conversation.groupProfile = group;
            conversation.lastMessage.lastSequence = group.nextMessageSeq - 1;

            if (!conversation.subType) {
              conversation.subType = group.type;
            }
          }
        });

        this._emitConversationUpdate(true, false);
      }
      /**
       * 更新会话的 userProfile
       * 当有用户资料更新时，会调用该函数
       * @param {Profile[]} profileList
       * @memberof ConversationController
       */

    }, {
      key: "_updateConversationUserProfile",
      value: function _updateConversationUserProfile(_ref7) {
        var _this8 = this;

        var profileList = _ref7.data;
        profileList.forEach(function (profile) {
          var conversationID = "C2C".concat(profile.userID);

          if (_this8.conversationMap.has(conversationID)) {
            _this8.conversationMap.get(conversationID).userProfile = profile;
          }
        });

        this._emitConversationUpdate(true, false);
      }
      /**
       * 当有消息撤回时，需要更新未读计数以及 lastMessage
       * @param {Object} event 事件
       * @memberof ConversationController
       */

    }, {
      key: "_onMessageRevoked",
      value: function _onMessageRevoked(event) {
        var _this9 = this;

        var messageList = event.data;

        if (messageList.length === 0) {
          return;
        }

        var conversation = null;
        var hasUpdated = false;
        messageList.forEach(function (message) {
          conversation = _this9.conversationMap.get(message.conversationID);

          if (conversation) {
            // 由于重新登陆后，c2c / group 的未读计数的行为不一致，先不在消息撤回后更新未读计数
            // conversation.reduceUnreadCount();
            if (conversation.isLastMessageRevoked(message)) {
              hasUpdated = true;
              conversation.setLastMessageRevoked(true);
            }
          }
        });

        if (hasUpdated) {
          this._emitConversationUpdate(true, false);
        }
      }
      /**
       * 处理同步消息
       * @param {Object} event 事件
       * @memberof ConversationController
       */

    }, {
      key: "_handleSyncMessages",
      value: function _handleSyncMessages(event) {
        this._onSendOrReceiveMessage(event, true);
      }
      /**
       * 收到消息或者发送消息时，更新会话
       * @private
       * @param {Object} event
       * @param {Boolean} isFromSync 是否来自同步未读消息，在同步未读的消息更新会话时，不更新 lastMessage 字段
       * @memberof ConversationController
       */

    }, {
      key: "_onSendOrReceiveMessage",
      value: function _onSendOrReceiveMessage(event) {
        var _this10 = this;

        var isFromSync = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        var conversations = event.data.eventDataList;

        if (!this._isReady) {
          this.ready(function () {
            _this10._onSendOrReceiveMessage(event, isFromSync);
          });
          return;
        }

        if (conversations.length === 0) {
          return;
        } // 1. 更新内存的会话列表


        this._updateLocalConversationList(conversations, false, isFromSync); // 2. 同步到 storage


        this._setStorageConversationList(); // 3. emit事件


        this._emitConversationUpdate();
      }
      /**
       * 更新会话。若已有会话则更新会话，否则新建会话
       * @private
       * @param {Array} conversationOptions 创建会话所需的配置
       * @param {Boolean} isFromGetConversations 是否来自于拉取会话列表。用于 unreadCount 的更新。
       * @param {Boolean} isFromSync 是否来自同步未读消息，在同步未读的消息更新会话时，不更新 lastMessage 字段
       * @example
       * // 会话更新逻辑
       * let conversations = ['a','b','c','d','e']; //现有的会话列表
       * // 若 d,e 会话先后收到消息，则更新逻辑为
       * // 1.取出更新的部分,并删除原会话列表更新的部分
       * let temp = ['d','e']; //更新的会话
       * let conversations = ['a','b','c'] // 删除待更新会话后的会话列表
       * // 2.排序更新的部分
       * let sortedTemp = ['e','d']; //排序后的临时会话
       * // 3.从头部插入
       * new Map([...temp, ...conversations])
       */

    }, {
      key: "_updateLocalConversationList",
      value: function _updateLocalConversationList(conversationOptions, isFromGetConversations, isFromSync) {
        var temp = {
          conversations: [],
          // 临时会话列表，存有所有待更新的会话
          newerConversations: [] // 存有新增的会话，后续要更新这些会话的 userProfile || groupProfile

        }; // 1. 更新临时会话列表

        temp = this._updateTempConversations(conversationOptions, isFromGetConversations, isFromSync); // 2. 合并会话列表后 排序

        this.conversationMap = new Map(this._sortConversations([].concat(_toConsumableArray(temp.conversations), _toConsumableArray(this.conversationMap)))); // 3. 【异步】 更新新增的会话中的 userProfile || groupProfile 至够渲染会话（有名称、头像）
        // 3.1 获取会话列表后创建的新会话，不需要执行下面的代码
        // 3.2 收到消息创建的新会话，需要执行下面的代码

        if (!isFromGetConversations) {
          this._updateUserOrGroupProfile(temp.newerConversations);
        }
      }
      /**
       * 更新临时会话列表
       * @param {Obejct[]} conversations
       * @param {Boolean} isFromGetConversations
       * @param {Boolean} isFromSync 是否来自同步未读消息，在同步未读的消息更新会话时，不更新 lastMessage 字段
       * @returns
       * @memberof ConversationController
       */

    }, {
      key: "_updateTempConversations",
      value: function _updateTempConversations(conversationOptions, isFromGetConversations, isFromSync) {
        // 临时保存更新的会话，对更新的部分进行排序（减少排序的数量，降低复杂度），然后用 new Map([...tempConversations, ...this.conversationMap])实现更新
        var tempConversations = [];
        var tempNewerConversations = [];

        for (var i = 0, length = conversationOptions.length; i < length; i++) {
          // 1. 创建临时会话 和 取得现有会话
          var tempConversation = new Conversation(conversationOptions[i]); // 临时会话

          var conversation = this.conversationMap.get(tempConversation.conversationID); // 现有会话
          // 2. 记录新增的会话，后续要更新这个数组内的 userProfile || groupProfile

          if (!this.conversationMap.has(tempConversation.conversationID)) {
            // 新建的群组会话，若是 ChatRoom/AVChatRoom，则未读计数为0
            if (tempConversation.type === TYPES.CONV_GROUP) {
              var groupID = tempConversation.groupProfile.groupID;
              var group = this.tim.groupController.getLocalGroupProfile(groupID);

              if (group) {
                tempConversation.groupProfile = group;
                tempConversation.updateUnreadCount(0);
              }
            }

            tempNewerConversations.push(tempConversation);
            tempConversations.push([tempConversation.conversationID, tempConversation]);
          } else {
            // 忽略 payload 的 merge。因为不同类型消息的 payload merge 后会导致：payload 混杂各种消息类型的消息体。
            var keysToIgnoreMerge = ['unreadCount', 'allowType', 'adminForbidType', 'payload']; // 同步未读时，不更新lastMessage字段。原因：未读的最后一条消息不一定是该会话的最后一条消息，该会话最后一条消息可能是自己发送的，但不是未读。

            if (isFromSync) {
              keysToIgnoreMerge.push('lastMessage');
            }

            var valuesIgnore = [null, undefined, '', 0, NaN];
            deepMerge(conversation, tempConversation, keysToIgnoreMerge, valuesIgnore); // 3. 更新临时会话的未读计数

            conversation.updateUnreadCount(tempConversation.unreadCount, isFromGetConversations); // 4. 更新 payload

            if (!isFromSync) {
              conversation.lastMessage.payload = conversationOptions[i].lastMessage.payload;
            } // 5. 移除现有会话


            this.conversationMap["delete"](conversation.conversationID); // 6. 将临时会话插入 tempConversations

            tempConversations.push([conversation.conversationID, conversation]);
          }
        }

        return {
          conversations: tempConversations,
          newerConversations: tempNewerConversations
        };
      }
      /**
       * 排序会话列表（从新往旧排序）
       * @param {Object[]} conversations 待排序的会话列表
       * @returns {Conversation[]}
       * @memberof ConversationController
       */

    }, {
      key: "_sortConversations",
      value: function _sortConversations(conversations) {
        return conversations.sort(function (a, b) {
          return b[1].lastMessage.lastTime - a[1].lastMessage.lastTime;
        });
      }
      /**
       * 更新会话的 userProfile/groupProfile，更新至够渲染会话列表。
       * @param {Conversation} conversations 待更新的会话列表
       * @returns {Undefined}
       * @memberof ConversationController
       */

    }, {
      key: "_updateUserOrGroupProfile",
      value: function _updateUserOrGroupProfile(conversations) {
        var _this11 = this;

        if (conversations.length === 0) {
          return;
        }

        var C2CUserIDList = [];
        var groupIDList = []; // 1. 遍历找出哪些会话需要更新 userProfile / groupProfile

        conversations.forEach(function (conversation) {
          if (conversation.type === TYPES.CONV_C2C) {
            C2CUserIDList.push(conversation.toAccount);
          } else if (conversation.type === TYPES.CONV_GROUP) {
            var groupID = conversation.toAccount; // 若群组列表中已经有该群，则不需要发请求

            if (_this11.tim.groupController.hasLocalGroup(groupID)) {
              conversation.groupProfile = _this11.tim.groupController.getLocalGroupProfile(groupID);
            } else {
              groupIDList.push(groupID);
            }
          }
        }); // 2. 更新 userProfile

        if (C2CUserIDList.length > 0) {
          this.tim.getUserProfile({
            userIDList: C2CUserIDList
          }).then(function (_ref8) {
            var data = _ref8.data;

            if (isArray(data)) {
              data.forEach(function (item) {
                _this11.conversationMap.get("C2C".concat(item.userID)).userProfile = item;
              });
            } else {
              _this11.conversationMap.get("C2C".concat(data.userID)).userProfile = data;
            }
          });
        } // 3. 更新 groupProfile


        if (groupIDList.length > 0) {
          this.tim.groupController.getGroupProfileAdvance({
            groupIDList: groupIDList,
            responseFilter: {
              groupBaseInfoFilter: ['Type', 'Name', 'FaceUrl']
            }
          }).then(function (_ref9) {
            var groups = _ref9.data.successGroupList;
            groups.forEach(function (group) {
              var conversationID = "GROUP".concat(group.groupID);

              if (_this11.conversationMap.has(conversationID)) {
                var conversation = _this11.conversationMap.get(conversationID);

                deepMerge(conversation.groupProfile, group, [], [null, undefined, '', 0, NaN]); // 更新subType

                if (!conversation.subType && group.type) {
                  conversation.subType = group.type;
                }
              }
            });
          });
        }
      }
      /**
       * 全量更新会话的 userProfile/groupProfile，更新至够渲染会话完整资料
       * @param {String} conversationID
       * @returns
       * @memberof ConversationController
       */

    }, {
      key: "_updateUserOrGroupProfileCompletely",
      value: function _updateUserOrGroupProfileCompletely(conversation) {
        var _this12 = this;

        if (conversation.type === TYPES.CONV_C2C) {
          return this.tim.getUserProfile({
            userIDList: [conversation.toAccount]
          }).then(function (_ref10) {
            var data = _ref10.data;

            if (data.length === 0) {
              return IMPromise.reject(new IMError({
                code: ERROR_CODE.USER_OR_GROUP_NOT_FOUND,
                message: ERROR_MESSAGE.USER_OR_GROUP_NOT_FOUND
              }));
            }

            conversation.userProfile = data[0];
            conversation._isInfoCompleted = true;

            _this12._unshiftConversation(conversation);

            return IMPromise.resolve({
              conversation: conversation
            });
          });
        }

        return this.tim.getGroupProfile({
          groupID: conversation.toAccount
        }).then(function (response) {
          conversation.groupProfile = response.data.group;
          conversation._isInfoCompleted = true;

          _this12._unshiftConversation(conversation);

          return IMPromise.resolve({
            conversation: conversation
          });
        });
      }
      /**
       * 从conversationMap头部插入会话
       * @private
       * @param {Object} conversation
       * @memberof ConversationController
       */

    }, {
      key: "_unshiftConversation",
      value: function _unshiftConversation(conversation) {
        if (conversation instanceof Conversation && !this.conversationMap.has(conversation.conversationID)) {
          this.conversationMap = new Map([[conversation.conversationID, conversation]].concat(_toConsumableArray(this.conversationMap)));

          this._setStorageConversationList();

          this._emitConversationUpdate(true, false);
        }
      }
      /**
       * 删除内存中的会话
       * @private
       * @param {String} conversationID
       */

    }, {
      key: "deleteLocalConversation",
      value: function deleteLocalConversation(conversationID) {
        this.conversationMap["delete"](conversationID);

        this._setStorageConversationList();

        this.emitInnerEvent(TIM_INNER_EVENT.CONVERSATION_DELETED, conversationID);

        this._emitConversationUpdate(true, false);

        return this.conversationMap.has(conversationID);
      }
      /**
       * 从后端返回的会话列表，解析出能够初始化 Conversation 的 options
       * @private
       * @param {Array} conversations
       */

    }, {
      key: "_getConversationOptions",
      value: function _getConversationOptions(conversations) {
        // 用于 ProfileHandler 控制缓存数据更新
        var profiles = []; // 有极少数情况下后端 lastMsg 转 json 会失败，导致返回的会话列表中没有 lastMsg，此处将这些没有 lastMsg 的会话过滤

        var filteredConversations = conversations.filter(function (_ref11) {
          var lastMsg = _ref11.lastMsg;
          return isPlainObject(lastMsg);
        });
        var conversationOptions = filteredConversations.map(function (conversation) {
          // C2C 类型
          if (conversation.type === 1) {
            var profileOptions = {
              userID: conversation.userID,
              nick: conversation.c2CNick,
              avatar: conversation.c2CImage
            };
            profiles.push(profileOptions);
            return {
              conversationID: "C2C".concat(conversation.userID),
              type: 'C2C',
              lastMessage: {
                lastTime: conversation.time,
                lastSequence: conversation.sequence,
                fromAccount: conversation.lastC2CMsgFromAccount,
                messageForShow: conversation.messageShow,
                type: conversation.lastMsg.elements[0] ? conversation.lastMsg.elements[0].type : null,
                payload: conversation.lastMsg.elements[0] ? conversation.lastMsg.elements[0].content : null
              },
              userProfile: new Profile(profileOptions)
            };
          } // GROUP 类型


          return {
            conversationID: "GROUP".concat(conversation.groupID),
            type: 'GROUP',
            lastMessage: {
              lastTime: conversation.time,
              lastSequence: conversation.messageReadSeq + conversation.unreadCount,
              fromAccount: conversation.msgGroupFromAccount,
              messageForShow: conversation.messageShow,
              type: conversation.lastMsg.elements[0] ? conversation.lastMsg.elements[0].type : null,
              payload: conversation.lastMsg.elements[0] ? conversation.lastMsg.elements[0].content : null
            },
            groupProfile: new Group({
              groupID: conversation.groupID,
              name: conversation.groupNick,
              avatar: conversation.groupImage
            }),
            unreadCount: conversation.unreadCount
          };
        }); // 抛事件通知 ProfileHandler

        if (profiles.length > 0) {
          this.emitInnerEvent(TIM_INNER_EVENT.CONVERSATION_LIST_PROFILE_UPDATED, profiles);
        }

        return conversationOptions;
      }
      /**
       * 更新群组会话的 unreadCount 和 subType
       * @private
       * @param {Array} conversations
       */
      // _updateGroupConversationsUnreadCountAndSubType(conversations) {
      //   // 1 保存群组类型会话的 messageReadSeq，用于后面计算未读计数
      //   let tempMessageReadSeq = {};
      //   // 2 取得群组类型会话的 groupID列表
      //   let groupIDList = conversations
      //     .filter(conversation => conversation.type === 2)
      //     .map(conversation => {
      //       tempMessageReadSeq[conversation.groupID] = conversation.messageReadSeq;
      //       return conversation.groupID;
      //     });
      //   // 3 若 groupIDList 为空 则直接返回
      //   if (groupIDList.length === 0) {
      //     return Promise.resolve(this.getLocalConversationList());
      //   }
      //   return this.tim
      //     .getGroupProfileAdvance({
      //       groupIDList,
      //       responseFilter: {
      //         groupBaseInfoFilter: ['NextMsgSeq', 'Type']
      //       }
      //     })
      //     .then(({ data: { successGroupList: groups } }) => {
      //       // 4 更新群组会话的 lastSequence, subType, unreadCount
      //       for (let i = 0, len = groups.length; i < len; i++) {
      //         let groupID = groups[i].groupID;
      //         let conversation = this.conversationMap.get(`GROUP${groupID}`);
      //         conversation.lastMessage.lastSequence = groups[i].nextMessageSeq - 1;
      //         conversation.subType = groups[i].type;
      //         // 若是 ChatRoom 类型的群会话，则未读置为 0，因为 ChatRoom 无未读
      //         conversation.unreadCount =
      //           groups[i].type === 'ChatRoom' ? 0 : conversation.lastMessage.lastSequence - tempMessageReadSeq[groupID];
      //       }
      //       return this.getLocalConversationList();
      //     });
      // }

      /**
       * 抛出 会话更新 事件
       * @param {Conversation[]} conversations
       * @param {Boolean} [outer=true] 是否抛外部事件 默认抛外部
       * @param {Boolean} [inner=true] 是否抛内部事件 默认抛内部
       * @memberof ConversationController
       */

    }, {
      key: "_emitConversationUpdate",
      value: function _emitConversationUpdate() {
        var outer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
        var inner = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

        var conversationList = _toConsumableArray(this.conversationMap.values());

        if (inner) {
          this.emitInnerEvent(TIM_INNER_EVENT.CONVERSATION_LIST_UPDATED, conversationList);
        }

        if (outer) {
          this.emitOuterEvent(TIM_OUTER_EVENT.CONVERSATION_LIST_UPDATED, conversationList);
        }
      }
      /**
       * 删除本地会话 Map 中比远端多出的部分
       * 刷新会话列表时，不直接清空本地 Map 的原因是：防止原有的数据丢失，如 C2C 未读计数
       * @param {Object} conversationOptions 会话配置列表
       * @memberof ConversationController
       */

    }, {
      key: "_conversationMapTreeShaking",
      value: function _conversationMapTreeShaking(conversationOptions) {
        var _this13 = this;

        var tempConversationMap = new Map(_toConsumableArray(this.conversationMap));
        conversationOptions.forEach(function (item) {
          return tempConversationMap["delete"](item.conversationID);
        }); // 找出多出的会话
        // 忽略系统通知会话

        if (tempConversationMap.has(TYPES.CONV_SYSTEM)) {
          tempConversationMap["delete"](TYPES.CONV_SYSTEM);
        } // 忽略已加入的AVChatRoom


        var joinedAVChatRoom = this.tim.groupController.getJoinedAVChatRoom();

        if (joinedAVChatRoom) {
          tempConversationMap["delete"]("".concat(TYPES.CONV_GROUP).concat(joinedAVChatRoom.groupID));
        }

        var keysToDelete = _toConsumableArray(tempConversationMap.keys());

        keysToDelete.forEach(function (key) {
          return _this13.conversationMap["delete"](key);
        });
      }
      /**
       * reset ConversationController
       */

    }, {
      key: "reset",
      value: function reset() {
        this.pagingStatus = TIM_STATUS.PAGING_CONVERSATION.NOT_START;
        this.pagingTimeStamp = 0;
        this.conversationMap.clear();
        this.resetReady();
        this.tim.innerEmitter.once(TIM_INNER_EVENT.CONTEXT_A2KEY_AND_TINYID_UPDATED, this._initLocalConversationList, this);
      }
    }]);

    return ConversationController;
  }(IMController);

  /**
   * 消息列表, 同时也负责管理消息的缓存
   * @author SaxonGao
   */

  var MessagesList =
  /*#__PURE__*/
  function () {
    function MessagesList(options) {
      _classCallCheck(this, MessagesList);

      if (typeof options === 'undefined') {
        throw new IMError({
          code: ERROR_CODE.MESSAGE_LIST_CONSTRUCTOR_NEED_OPTIONS,
          message: ERROR_MESSAGE.MESSAGE_LIST_CONSTRUCTOR_NEED_OPTIONS
        });
      }

      if (typeof options.tim === 'undefined') {
        throw new IMError({
          code: ERROR_CODE.MESSAGE_LIST_CONSTRUCTOR_NEED_OPTIONS,
          message: "".concat(ERROR_MESSAGE.MESSAGE_LIST_CONSTRUCTOR_NEED_OPTIONS, ".tim")
        });
      } // Map<conversationID, Map<messageID, Message>>


      this.list = new Map();
      this.tim = options.tim;

      this._initializeOptions(options);
    }
    /**
     * 获取某个会话下最旧的一条消息
     * @param {String} conversationID - 会话ID
     */


    _createClass(MessagesList, [{
      key: "getLocalOldestMessageByConversationID",
      value: function getLocalOldestMessageByConversationID(conversationID) {
        if (!conversationID) {
          return null;
        }

        if (!this.list.has(conversationID)) {
          return null;
        }

        var messagesIterator = this.list.get(conversationID).values();

        if (!messagesIterator) {
          return null;
        }

        return messagesIterator.next().value;
      }
      /**
       * 初始化配置参数
       * @param {object} param
       */

    }, {
      key: "_initializeOptions",
      value: function _initializeOptions(param) {
        this.options = {};
        var defaultOptions = {
          memory: {
            maxDatasPerKey: 100,
            // 每个 key 下最多存储的数据条数, 默认100，0为不限制
            maxBytesPerData: 256,
            // 每条数据的大小限制，单位是字节，默认256 , 0 为不限制
            maxKeys: 0 // key的总数限制,默认为0，不限制

          },
          cache: {
            maxDatasPerKey: 10,
            // 每个 key 下最多存储的数据条数, 默认100，0为不限制
            maxBytesPerData: 256,
            // 每条数据的大小限制，单位是字节，默认256 , 0 为不限制
            maxKeys: 0 // key的总数限制,默认为0，不限制

          }
        };

        for (var p in defaultOptions) {
          if (Object.prototype.hasOwnProperty.call(defaultOptions, p)) {
            if (typeof param[p] === 'undefined') {
              this.options[p] = defaultOptions[p];
              continue;
            }

            var typesOptions = defaultOptions[p];

            for (var key in typesOptions) {
              if (Object.prototype.hasOwnProperty.call(typesOptions, key)) {
                if (typeof param[p][key] === 'undefined') {
                  this.options[p][key] = typesOptions[key];
                  continue;
                }

                this.options[p][key] = param[p][key];
              }
            }
          }
        }
      }
      /**
       * 把一条消息从 MessageList 底部插入
       * @param {Message} message - 消息实例
       * @returns {Boolean} 是否入库成功
       */

    }, {
      key: "pushIn",
      value: function pushIn(message) {
        var conversationID = message.conversationID,
            ID = message.ID; // 是否入库成功

        var isSuccess = true;

        if (!this.list.has(conversationID)) {
          this.list.set(conversationID, new Map());
        }

        if (this.list.has(conversationID) && this.list.get(conversationID).has(ID)) {
          isSuccess = false;
        } else {
          this.list.get(conversationID).set(ID, message);
        }

        return isSuccess;
      }
      /**
       * 从MessageList的顶部插入消息
       * @param {Message|Array<Message>} messages - Message 实例或存储 Message 实例的数组
       */

    }, {
      key: "unshift",
      value: function unshift(messages) {
        if (isArray(messages)) {
          if (messages.length > 0) {
            this._unshiftMultipleMessages(messages);
          }
        } else {
          this._unshiftSingleMessage(messages);
        }
      }
      /**
       * 把一条消息从 MessageList 顶部插入
       * @param {Message} message - Message 实例
       */

    }, {
      key: "_unshiftSingleMessage",
      value: function _unshiftSingleMessage(message) {
        var conversationID = message.conversationID,
            ID = message.ID;

        if (!this.list.has(conversationID)) {
          this.list.set(conversationID, new Map());
          this.list.get(conversationID).set(ID, message);
          return;
        } // Map 对象无法直接做shift 操作，先转化为数组


        var conversationsMessageListArray = Array.from(this.list.get(conversationID)); // unshift

        conversationsMessageListArray.unshift([ID, message]); // 重新转化为Map

        this.list.set(conversationID, new Map(conversationsMessageListArray));
      }
      /**
       * 把多条消息从 MessageList 顶部插入
       * @param {Array<Message>} messages - Message 实例的数组
       */

    }, {
      key: "_unshiftMultipleMessages",
      value: function _unshiftMultipleMessages(messages) {
        var len = messages.length;
        var tempList = [];
        var conversationID = messages[0].conversationID;
        var conversationsMessageListArray = this.list.has(conversationID) ? Array.from(this.list.get(conversationID)) : [];

        for (var i = 0; i < len; i++) {
          tempList.push([messages[i].ID, messages[i]]);
        }

        this.list.set(conversationID, new Map(tempList.concat(conversationsMessageListArray)));
      }
      /**
       * 从消息列表中删除一条消息
       * @param {Message} message Message 实例
       */

    }, {
      key: "remove",
      value: function remove(message) {
        var conversationID = message.conversationID,
            ID = message.ID;

        if (this.list.has(conversationID)) {
          this.list.get(conversationID)["delete"](ID);
        }
      }
      /**
       * 撤回指定会话的指定消息。注意！撤回 c2c 消息用 sequence 和 random，撤回群聊消息用 sequence 就可以了
       * @param {String} conversationID 会话 ID
       * @param {Number} sequence 消息的 sequence
       * @param {Number} random 消息的 random
       * @returns {Message} 被撤回的消息实例
       */

    }, {
      key: "revoke",
      value: function revoke(conversationID, sequence, random) {
        logger.debug('revoke message', conversationID, sequence, random);

        if (this.list.has(conversationID)) {
          var tmpMap = this.list.get(conversationID);
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            for (var _iterator = tmpMap[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var _step$value = _slicedToArray(_step.value, 2),
                  message = _step$value[1];

              if (message.sequence === sequence && !message.isRevoked) {
                if (isUndefined(random) || message.random === random) {
                  message.isRevoked = true; // 被撤回的标识置为true

                  return message;
                }
              }
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                _iterator["return"]();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }
        }

        return null;
      }
      /**
       * 以 conversationID 为维度删除消息列表
       * @param {String} conversationID - 需要删除的 key
       * @memberof MessagesList
       */

    }, {
      key: "removeByConversationID",
      value: function removeByConversationID(conversationID) {
        if (this.list.has(conversationID)) {
          this.list["delete"](conversationID);
        }
      }
      /**
       * 判断内存中是否有某会话的消息列表
       * @param {String} conversationID 会话 ID
       * @returns {Boolean}
       * @memberof MessagesList
       */

    }, {
      key: "hasLocalMessageList",
      value: function hasLocalMessageList(conversationID) {
        return this.list.has(conversationID);
      }
      /**
       * 获取内存某会话的消息列表
       * @param {String} conversationID - 会话ID
       * @returns {Array}
       */

    }, {
      key: "getLocalMessageList",
      value: function getLocalMessageList(conversationID) {
        if (this.hasLocalMessageList(conversationID)) {
          return _toConsumableArray(this.list.get(conversationID).values());
        }

        return [];
      }
      /**
       * 判断内存中是否有某会话的某条消息
       * @param {String} conversationID 会话 ID
       * @param {String} messageID 消息 ID
       * @returns {Boolean}
       * @memberof MessagesList
       */

    }, {
      key: "hasLocalMessage",
      value: function hasLocalMessage(conversationID, messageID) {
        if (this.hasLocalMessageList(conversationID)) {
          return this.list.get(conversationID).has(messageID);
        }

        return false;
      }
      /**
       * 获取内存中某会话的某条消息
       * @param {String} conversationID - 会话ID
       * @param {String} messageID - 消息ID
       * @returns {object}
       */

    }, {
      key: "getLocalMessage",
      value: function getLocalMessage(conversationID, messageID) {
        if (this.hasLocalMessage(conversationID, messageID)) {
          return this.list.get(conversationID).get(messageID);
        }

        return null;
      }
    }, {
      key: "reset",
      value: function reset() {
        // 清空消息列表
        this.list.clear();
      }
    }]);

    return MessagesList;
  }();

  var ReadReportHandler =
  /*#__PURE__*/
  function () {
    function ReadReportHandler(tim) {
      _classCallCheck(this, ReadReportHandler);

      this.tim = tim;
    }
    /**
     * 消息已读上报
     * @param {Object} options 选项
     * @param {String} options.conversationID 会话 ID
     * @param {String} options.messageID 消息 ID，目前没用
     * @returns {Promise}
     */


    _createClass(ReadReportHandler, [{
      key: "setMessageRead",
      value: function setMessageRead(_ref) {
        var conversationID = _ref.conversationID,
            messageID = _ref.messageID;
        var conversation = this.tim.conversationController.getLocalConversation(conversationID);
        logger.log("ReadReportHandler.setMessageRead conversationID=".concat(conversationID, " unreadCount=").concat(!conversation ? 0 : conversation.unreadCount));

        if (!conversation || conversation.unreadCount === 0) {
          return IMPromise.resolve();
        }

        var message = messageID ? this.tim.messageController.getLocalMessage(conversationID, messageID) : null;

        switch (conversation.type) {
          case TYPES.CONV_C2C:
            return this._setC2CMessageRead({
              conversationID: conversationID,
              lastMessageTime: message ? message.time : conversation.lastMessage.lastTime
            });

          case TYPES.CONV_GROUP:
            return this._setGroupMessageRead({
              conversationID: conversationID,
              lastMessageSeq: message ? message.sequence : conversation.lastMessage.lastSequence
            });

          case TYPES.CONV_SYSTEM:
            conversation.unreadCount = 0;
            return IMPromise.resolve();

          default:
            return IMPromise.resolve();
        }
      }
      /**
       * C2C 消息已读
       * @param {Object} options 选项
       * @param {String} options.conversationID 会话 ID
       * @param {Number} options.lastMessageTime 当前会话最新消息的时间戳，单位：秒
       * @returns {Promise}
       */

    }, {
      key: "_setC2CMessageRead",
      value: function _setC2CMessageRead(_ref2) {
        var _this = this;

        var conversationID = _ref2.conversationID,
            lastMessageTime = _ref2.lastMessageTime;
        logger.log("ReadReportHandler._setC2CMessageRead conversationID=".concat(conversationID, " lastMessageTime=").concat(lastMessageTime));

        if (!isNumber(lastMessageTime)) {
          logger.warn('ReadReportHandler._setC2CMessageRead 请勿修改 Conversation.lastMessage.lastTime，否则可能会导致已读上报结果不准确');
        } // event stat


        var ssoLog = new SSOLogData();
        ssoLog.setMethod(SSOMethods.SET_C2C_MESSAGE_READ) // conversationID-lastMessageTime
        .setText("".concat(conversationID, "-").concat(lastMessageTime)).setStart();
        return this.tim.messageController.request({
          name: 'conversation',
          action: 'setC2CMessageRead',
          param: {
            C2CMsgReaded: {
              cookie: '',
              C2CMsgReadedItem: [{
                toAccount: conversationID.replace('C2C', ''),
                lastMessageTime: lastMessageTime
              }]
            }
          }
        }).then(function () {
          // event stat
          ssoLog.setCode(0).setNetworkType(_this.tim.netMonitor.getNetworkType()).setEnd();
          logger.log('ReadReportHandler._setC2CMessageRead ok.');

          _this._updateIsReadAfterReadReport({
            conversationID: conversationID,
            lastMessageTime: lastMessageTime
          });

          _this._updateUnreadCount(conversationID);

          return new IMResponse();
        })["catch"](function (error) {
          // event stat
          _this.tim.netMonitor.probe().then(function (_ref3) {
            var _ref4 = _slicedToArray(_ref3, 2),
                bOnline = _ref4[0],
                networkType = _ref4[1];

            ssoLog.setError(error, bOnline, networkType).setEnd();
          });

          logger.log("ReadReportHandler._setC2CMessageRead failed. ".concat(stringifyError(error)));
          return IMPromise.reject(error);
        });
      }
      /**
       * 群消息已读
       * @param {Object} options  选项
       * @param {String} options.conversationID 会话 ID
       * @param {Number} options.lastMessageSeq 当前会话的最新消息的 Sequence
       * @returns {Promise}
         */

    }, {
      key: "_setGroupMessageRead",
      value: function _setGroupMessageRead(_ref5) {
        var _this2 = this;

        var conversationID = _ref5.conversationID,
            lastMessageSeq = _ref5.lastMessageSeq;
        logger.log("ReadReportHandler._setGroupMessageRead conversationID=".concat(conversationID, " lastMessageSeq=").concat(lastMessageSeq));

        if (!isNumber(lastMessageSeq)) {
          logger.warn('ReadReportHandler._setGroupMessageRead 请勿修改 Conversation.lastMessage.lastSequence，否则可能会导致已读上报结果不准确');
        } // event stat


        var ssoLog = new SSOLogData();
        ssoLog.setMethod(SSOMethods.SET_GROUP_MESSAGE_READ) // conversationID-lastMessageSeq
        .setText("".concat(conversationID, "-").concat(lastMessageSeq)).setStart();
        return this.tim.messageController.request({
          name: 'conversation',
          action: 'setGroupMessageRead',
          param: {
            groupID: conversationID.replace('GROUP', ''),
            messageReadSeq: lastMessageSeq
          }
        }).then(function () {
          // event stat
          ssoLog.setCode(0).setNetworkType(_this2.tim.netMonitor.getNetworkType()).setEnd();
          logger.log('ReadReportHandler._setGroupMessageRead ok.');

          _this2._updateIsReadAfterReadReport({
            conversationID: conversationID,
            lastMessageSeq: lastMessageSeq
          });

          _this2._updateUnreadCount(conversationID);

          return new IMResponse();
        })["catch"](function (error) {
          // event stat
          _this2.tim.netMonitor.probe().then(function (_ref6) {
            var _ref7 = _slicedToArray(_ref6, 2),
                bOnline = _ref7[0],
                networkType = _ref7[1];

            ssoLog.setError(error, bOnline, networkType).setEnd();
          });

          logger.log("ReadReportHandler._setGroupMessageRead failed. ".concat(stringifyError(error)));
          return IMPromise.reject(error);
        });
      }
      /**
       * 更新会话的未读数
       * 调用时机：上报已读后
       * @param {String} conversationID 会话 ID
       */

    }, {
      key: "_updateUnreadCount",
      value: function _updateUnreadCount(conversationID) {
        var _this$tim = this.tim,
            conversationController = _this$tim.conversationController,
            messageController = _this$tim.messageController;
        var conversation = conversationController.getLocalConversation(conversationID);
        var messageList = messageController.getLocalMessageList(conversationID);

        if (!conversation) {
          return;
        }

        conversation.unreadCount = messageList.filter(function (item) {
          return !item.isRead;
        }).length;
        logger.log("ReadReportHandler._updateUnreadCount conversationID=".concat(conversation.conversationID, " unreadCount=").concat(conversation.unreadCount));
      }
      /**
       * 更新消息列表的 isRead 值
       * 调用时机：上报已读后调用
       * @private
       * @param {Object} options 选项
       * @param {String} options.conversationID 会话 ID
       * @param {Number} [options.lastMessageTime] 更新C2C会话lastMessageTime之前的消息的isRead值为 true
       * @param {Number} [options.lastMessageSeq] 更新GROUP会话lastMessageSeq之前的消息的isRead值为 true
       */

    }, {
      key: "_updateIsReadAfterReadReport",
      value: function _updateIsReadAfterReadReport(_ref8) {
        var conversationID = _ref8.conversationID,
            lastMessageSeq = _ref8.lastMessageSeq,
            lastMessageTime = _ref8.lastMessageTime;
        var messageList = this.tim.messageController.getLocalMessageList(conversationID);

        if (messageList.length === 0) {
          return;
        } // 从后往前遍历


        var message;

        for (var i = messageList.length - 1; i >= 0; i--) {
          message = messageList[i]; // 不在上报范围的消息 continue

          if (lastMessageTime && message.time > lastMessageTime || lastMessageSeq && message.sequence > lastMessageSeq) {
            continue;
          } // 遇到 收到的 且 isRead 为true的消息时，跳出循环。因为该消息之前的isRead都为true


          if (message.flow === 'in' && message.isRead) {
            break;
          }

          message.setIsRead(true);
        }
      }
      /**
       * 更新消息列表的 isRead 值
       * 调用时机：拉取 C2C / Group 历史消息后
       * 1. Message Model 默认 isRead = false
       * 2. 自己发送的消息： isRead = true
       * 3. 收到的消息：根据会话未读计数来计算哪些消息 isRead = true
       * @param {String} conversationID 会话 ID
       */

    }, {
      key: "updateIsRead",
      value: function updateIsRead(conversationID) {
        var _this$tim2 = this.tim,
            conversationController = _this$tim2.conversationController,
            messageController = _this$tim2.messageController;
        var conversation = conversationController.getLocalConversation(conversationID);
        var messageList = messageController.getLocalMessageList(conversationID);

        if (!conversation || messageList.length === 0 || isSystemConversation(conversation.type)) {
          return;
        }

        var receivedMessageList = [];

        for (var i = 0; i < messageList.length; i++) {
          if (messageList[i].flow === 'in') {
            receivedMessageList.push(messageList[i]);
            continue;
          } // 自己发送的消息，isRead = true


          if (messageList[i].flow === 'out' && !messageList[i].isRead) {
            messageList[i].setIsRead(true);
          }
        }

        var len = 0; // FIXME:
        // 本地计算会有坑，后面要想办法去掉 isRead 字段
        // 后台逻辑：
        // C2C 会话，被撤回消息不计入未读计数。
        // GROUP 会话，被撤回消息计入未读计数。

        if (conversation.type === TYPES.CONV_C2C) {
          var tempList = receivedMessageList.slice(-conversation.unreadCount);
          var revokedCount = tempList.filter(function (item) {
            return item.isRevoked;
          }).length;
          len = receivedMessageList.length - conversation.unreadCount - revokedCount;
        } else {
          len = receivedMessageList.length - conversation.unreadCount;
        } // 收到的消息根据未读计数来处理


        for (var _i = 0; _i < len; _i++) {
          // 遇到isRead为true的消息时则跳出循环，因为此后的消息isRead都是true
          if (receivedMessageList[_i].isRead) {
            break;
          }

          receivedMessageList[_i].setIsRead(true);
        }
      }
    }]);

    return ReadReportHandler;
  }();

  var GetMessageHandler =
  /*#__PURE__*/
  function () {
    function GetMessageHandler(_ref) {
      var tim = _ref.tim,
          messageController = _ref.messageController;

      _classCallCheck(this, GetMessageHandler);

      this.tim = tim;
      this.messageController = messageController;
      this.completedMap = new Map(); // 记录哪些会话已经拉完历史消息

      this._initListener();
    }
    /**
     * 获取消息列表
     * @param {Object} options 请求参数
     * @returns {Promise}
     * @memberof GetMessageHandler
     */


    _createClass(GetMessageHandler, [{
      key: "getMessageList",
      value: function getMessageList(_ref2) {
        var _this = this;

        var conversationID = _ref2.conversationID,
            nextReqMessageID = _ref2.nextReqMessageID,
            count = _ref2.count;
        // 由于 AVChatRoom 没有漫游，故不支持拉取 AVChatRoom 的消息列表
        var isAVChatRoom = this.tim.groupController.checkJoinedAVChatRoomByID(conversationID.replace('GROUP', ''));

        if (isAVChatRoom) {
          logger.log("GetMessageHandler.getMessageList not available in avchatroom. conversationID=".concat(conversationID));
          return IMPromise.resolve({
            messageList: [],
            nextReqMessageID: '',
            isCompleted: true
          });
        } // 默认值和最大值： 15


        if (isUndefined(count) || count > 15) {
          count = 15;
        } // 1. 计算剩余消息数量


        var leftCount = this._computeLeftCount({
          conversationID: conversationID,
          nextReqMessageID: nextReqMessageID
        });

        logger.log("GetMessageHandler.getMessageList. conversationID=".concat(conversationID, " leftCount=").concat(leftCount, " count=").concat(count, " nextReqMessageID=").concat(nextReqMessageID)); // 2. 判断是否要拉历史记录

        if (this._needGetHistory({
          conversationID: conversationID,
          leftCount: leftCount,
          count: count
        })) {
          return this.messageController.getHistoryMessages({
            conversationID: conversationID,
            count: 20
          }).then(function () {
            leftCount = _this._computeLeftCount({
              conversationID: conversationID,
              nextReqMessageID: nextReqMessageID
            });
            return new IMResponse(_this._computeResult({
              conversationID: conversationID,
              nextReqMessageID: nextReqMessageID,
              count: count,
              leftCount: leftCount
            }));
          });
        }

        logger.log('GetMessageHandler.getMessageList. get messagelist from memory'); // 3. 不拉历史则返回数据

        return IMPromise.resolve(this._computeResult({
          conversationID: conversationID,
          nextReqMessageID: nextReqMessageID,
          count: count,
          leftCount: leftCount
        }));
      }
      /**
       * 记录某会话已经拉完历史消息
       * @param {String} conversationID
       * @memberof GetMessageHandler
       */

    }, {
      key: "setCompleted",
      value: function setCompleted(conversationID) {
        logger.log("GetMessageHandler.setCompleted. conversationID=".concat(conversationID));
        this.completedMap.set(conversationID, true);
      }
      /**
       * 从 completedMap 中移除元素
       * @param {String} conversationID 会话ID
       * @memberof GetMessageHandler
       * @returns {void}
       */

    }, {
      key: "deleteCompletedItem",
      value: function deleteCompletedItem(conversationID) {
        logger.log("GetMessageHandler.deleteCompletedItem. conversationID=".concat(conversationID));
        this.completedMap["delete"](conversationID);
      }
    }, {
      key: "_initListener",
      value: function _initListener() {
        var _this2 = this;

        this.tim.innerEmitter.on(TIM_INNER_EVENT.SDK_READY, function () {
          // SDK_READY时说明已经同步完未读，这时候群系统通知会话的ev5都拉下来了。将群系统通知会话加入completedMap中
          _this2.setCompleted(TYPES.CONV_SYSTEM);
        });
        this.tim.innerEmitter.on(TIM_INNER_EVENT.AVCHATROOM_JOIN_SUCCESS, function (_ref3) {
          var groupID = _ref3.data;

          _this2.setCompleted("".concat(TYPES.CONV_GROUP).concat(groupID));
        });
      }
      /**
       * 获取本地某会话的消息列表大小
       * @private
       * @param {String} conversationID 会话ID
       * @returns {Number}
       * @memberof GetMessageHandler
       */

    }, {
      key: "_getMessageListSize",
      value: function _getMessageListSize(conversationID) {
        return this.messageController.getLocalMessageList(conversationID).length;
      }
      /**
       * 判断是否需要拉历史消息
       * @private
       * @param {Object} options
       * @param {Object} options.conversationID
       * @param {Object} options.leftCount 符合要求的剩余消息数量
       * @param {Object} options.count 用户需要的消息数量
       * @returns {Boolean}
       * @memberof GetMessageHandler
       */

    }, {
      key: "_needGetHistory",
      value: function _needGetHistory(_ref4) {
        var conversationID = _ref4.conversationID,
            leftCount = _ref4.leftCount,
            count = _ref4.count;
        var conversation = this.tim.conversationController.getLocalConversation(conversationID);
        var isSystemConversation = conversation ? conversation.type === TYPES.CONV_SYSTEM : false;
        var isAVChatRoom = conversation ? conversation.subType === TYPES.GRP_AVCHATROOM : false; // 群系统通知 和 AVChatRoom 会话不拉历史

        if (isSystemConversation || isAVChatRoom) {
          return false;
        } // 剩余消息数不够 且 未拉完历史消息时 需要拉历史消息


        return leftCount < count && !this.completedMap.has(conversationID);
      }
      /**
       * 计算 getMessageList 的返回结果
       * @private
       * @param {Object} options
       * @param {Object} options.conversationID
       * @param {Object} options.nextReqMessageID
       * @param {Object} options.leftCount 符合要求的剩余消息数量
       * @param {Object} options.count 用户需要的消息数量
       * @returns {Boolean}
       * @memberof GetMessageHandler
       */

    }, {
      key: "_computeResult",
      value: function _computeResult(_ref5) {
        var conversationID = _ref5.conversationID,
            nextReqMessageID = _ref5.nextReqMessageID,
            count = _ref5.count,
            leftCount = _ref5.leftCount;

        var messageList = this._computeMessageList({
          conversationID: conversationID,
          nextReqMessageID: nextReqMessageID,
          count: count
        });

        var isCompleted = this._computeIsCompleted({
          conversationID: conversationID,
          leftCount: leftCount,
          count: count
        });

        var computedNextReqMessageID = this._computeNextReqMessageID({
          messageList: messageList,
          isCompleted: isCompleted,
          conversationID: conversationID
        });

        logger.log("GetMessageHandler._computeResult. conversationID=".concat(conversationID, " leftCount=").concat(leftCount, " count=").concat(count, " nextReqMessageID=").concat(computedNextReqMessageID, " nums=").concat(messageList.length, " isCompleted=").concat(isCompleted));
        return {
          messageList: messageList,
          nextReqMessageID: computedNextReqMessageID,
          isCompleted: isCompleted
        };
      }
      /**
       * 计算 nextReqMessageID
       * @private
       * @param {Obejct} options
       * @param {Array} options.messageList
       * @param {Array} options.isCompleted true 时表示没有更多消息可拉取
       * @returns {String}
       * @memberof GetMessageHandler
       */

    }, {
      key: "_computeNextReqMessageID",
      value: function _computeNextReqMessageID(_ref6) {
        var messageList = _ref6.messageList,
            isCompleted = _ref6.isCompleted,
            conversationID = _ref6.conversationID;

        if (!isCompleted) {
          return messageList.length === 0 ? '' : messageList[0].ID;
        }

        var completedMessageList = this.messageController.getLocalMessageList(conversationID);
        return completedMessageList.length === 0 ? '' : completedMessageList[0].ID;
      }
      /**
       * 计算 getMessageList 返回的消息列表
       * @private
       * @param {Object} options
       * @param {String} options.conversationID
       * @param {String} options.nextReqMessageID
       * @param {Number} options.count 用户需要的消息数量
       * @returns {Message[]}
       * @memberof GetMessageHandler
       */

    }, {
      key: "_computeMessageList",
      value: function _computeMessageList(_ref7) {
        var conversationID = _ref7.conversationID,
            nextReqMessageID = _ref7.nextReqMessageID,
            count = _ref7.count;
        var messageList = this.messageController.getLocalMessageList(conversationID);

        var indexEnd = this._computeIndexEnd({
          nextReqMessageID: nextReqMessageID,
          messageList: messageList
        });

        var indexStart = this._computeIndexStart({
          indexEnd: indexEnd,
          count: count
        });

        return messageList.slice(indexStart, indexEnd);
      }
      /**
       * 计算 slice 的 indexEnd
       * @private
       * @param {Object} options
       * @param {Message[]} [options.messageList=[]]
       * @param {String} options.nextReqMessageID
       * @returns {Number}
       * @memberof GetMessageHandler
       */

    }, {
      key: "_computeIndexEnd",
      value: function _computeIndexEnd(_ref8) {
        var _ref8$messageList = _ref8.messageList,
            messageList = _ref8$messageList === void 0 ? [] : _ref8$messageList,
            nextReqMessageID = _ref8.nextReqMessageID;
        return !nextReqMessageID ? messageList.length : messageList.findIndex(function (message) {
          return message.ID === nextReqMessageID;
        });
      }
      /**
       * 计算 slice 的 indexStart
       * @private
       * @param {Object} options
       * @param {Number} options.indexEnd
       * @param {Number} options.count
       * @returns {Number}
       * @memberof GetMessageHandler
       */

    }, {
      key: "_computeIndexStart",
      value: function _computeIndexStart(_ref9) {
        var indexEnd = _ref9.indexEnd,
            count = _ref9.count;
        return indexEnd > count ? indexEnd - count : 0;
      }
      /**
       * 计算剩余消息数量
       * @private
       * @returns
       * @memberof GetMessageHandler
       */

    }, {
      key: "_computeLeftCount",
      value: function _computeLeftCount(_ref10) {
        var conversationID = _ref10.conversationID,
            nextReqMessageID = _ref10.nextReqMessageID;

        // 1. 第一次调用，剩余数量为内存中的消息列表长度
        if (!nextReqMessageID) {
          return this._getMessageListSize(conversationID);
        } // 2. 非第一次调用，剩余数量等于 nextReqMessageID 在内存消息列表的索引值


        return this.messageController.getLocalMessageList(conversationID).findIndex(function (message) {
          return message.ID === nextReqMessageID;
        });
      }
      /**
       * 计算返回值中的 isCompleted 字段
       * isCompleted 为true，表示 UI 层已经拉完了所有的历史记录
       * @private
       * @param {Object} options
       * @param {String} options.conversationID
       * @param {Number} options.leftCount
       * @param {Number} options.count
       * @returns {Boolean}
       * @memberof GetMessageHandler
       */

    }, {
      key: "_computeIsCompleted",
      value: function _computeIsCompleted(_ref11) {
        var conversationID = _ref11.conversationID,
            leftCount = _ref11.leftCount,
            count = _ref11.count;

        if (leftCount <= count && this.completedMap.has(conversationID)) {
          return true;
        }

        return false;
      }
    }, {
      key: "reset",
      value: function reset() {
        logger.log('GetMessageHandler.reset');
        this.completedMap.clear();
      }
    }]);

    return GetMessageHandler;
  }();

  /**
   * 单向链表节点类
   */
  var ListNode = function ListNode(value) {
    _classCallCheck(this, ListNode);

    this.value = value;
    this.next = null;
  };

  /**
   * 单向链表，用于频繁尾增，头删、查询数值的场景
   */

  var SinglyLinkedList =
  /*#__PURE__*/
  function () {
    function SinglyLinkedList(size) {
      _classCallCheck(this, SinglyLinkedList);

      this.MAX_LENGTH = size; // 链表最大长度

      this.pTail = null; // 指向尾节点指针

      this.pNodeToDel = null; // 指向待删除节点的指针

      this.map = new Map();
      logger.log("SinglyLinkedList init MAX_LENGTH=".concat(this.MAX_LENGTH));
    }
    /**
     * 将数值存入链表
     * @param {Number} value 数值
     */


    _createClass(SinglyLinkedList, [{
      key: "pushIn",
      value: function pushIn(value) {
        var node = new ListNode(value); // 不超过链表最大长度时，在尾部插入

        if (this.map.size < this.MAX_LENGTH) {
          if (this.pTail === null) {
            this.pTail = node;
            this.pNodeToDel = node;
          } else {
            this.pTail.next = node;
            this.pTail = node;
          }

          this.map.set(value, 1);
        } else {
          // 先头部删除，后尾增
          var tmpNode = this.pNodeToDel;
          this.pNodeToDel = this.pNodeToDel.next;
          this.map["delete"](tmpNode.value); // 释放引用，等待回收

          tmpNode.next = null;
          tmpNode = null;
          this.pTail.next = node;
          this.pTail = node;
          this.map.set(value, 1);
        }
      }
      /**
       * 判断指定的数值是否在链表节点中
       * @param {*} value value 数值
       * @returns {Boolean} true->存在 false->不存在
       */

    }, {
      key: "has",
      value: function has(value) {
        return this.map.has(value);
      }
      /**
       * 删除全部链表节点，重置指针，清空map
       */

    }, {
      key: "reset",
      value: function reset() {
        var tmpNode;

        while (this.pNodeToDel !== null) {
          tmpNode = this.pNodeToDel;
          this.pNodeToDel = this.pNodeToDel.next;
          tmpNode.next = null;
          tmpNode = null;
        }

        this.pTail = null;
        this.map.clear();
      }
    }]);

    return SinglyLinkedList;
  }();

  /**
   * 文件类消息上传模块
   * UploadFileHandler 处理各类消息上传逻辑
   * UploadController 提供基础上传功能
   * @class UploadFileHandle
   */

  var UploadFileHandler =
  /*#__PURE__*/
  function () {
    function UploadFileHandler(tim) {
      _classCallCheck(this, UploadFileHandler);

      this.tim = tim;
    }
    /**
     * 上传文件类消息
     * @param {Message} message 消息实例
     * @memberof UploadFileHandle
     * @returns {Promise}
     */


    _createClass(UploadFileHandler, [{
      key: "upload",
      value: function upload(message) {
        switch (message.type) {
          case TYPES.MSG_IMAGE:
            return this._uploadImage(message);

          case TYPES.MSG_FILE:
            return this._uploadFile(message);

          case TYPES.MSG_AUDIO:
            return this._uploadAudio(message);

          case TYPES.MSG_VIDEO:
            return this._uploadVideo(message);

          default:
            return Promise.resolve();
        }
      }
    }, {
      key: "_uploadImage",
      value: function _uploadImage(message) {
        var _this$tim = this.tim,
            uploadController = _this$tim.uploadController,
            messageController = _this$tim.messageController;
        var element = message.getElements()[0];

        var _options = messageController.getMessageOptionByID(message.messageID);

        return uploadController.uploadImage({
          file: _options.payload.file,
          to: _options.to,
          onProgress: function onProgress(process) {
            element.updatePercent(process);

            if (isFunction(_options.onProgress)) {
              try {
                _options.onProgress(process);
              } catch (e) {
                return IMPromise.reject(new IMError({
                  code: ERROR_CODE.MESSAGE_ONPROGRESS_FUNCTION_ERROR,
                  message: "".concat(ERROR_MESSAGE.MESSAGE_ONPROGRESS_FUNCTION_ERROR)
                }));
              }
            }
          }
        }).then(function (_ref) {
          var location = _ref.location,
              fileType = _ref.fileType,
              fileSize = _ref.fileSize;
          var imageUrl = uniformHTTPS(location);
          element.updateImageFormat(fileType);
          element.updateImageInfoArray({
            size: fileSize,
            url: imageUrl
          });
          return probeImageWidthHeight(element._imageMemoryURL);
        }).then(function (_ref2) {
          var width = _ref2.width,
              height = _ref2.height;
          // logger.log(`MessageController.probeImageWidthHeight width=${info.width} height=${info.height}`);
          element.updateImageInfoArray({
            width: width,
            height: height
          });
          return message;
        });
      }
    }, {
      key: "_uploadFile",
      value: function _uploadFile(message) {
        var _this$tim2 = this.tim,
            uploadController = _this$tim2.uploadController,
            messageController = _this$tim2.messageController;
        var element = message.getElements()[0];

        var _options = messageController.getMessageOptionByID(message.messageID);

        return uploadController.uploadFile({
          file: _options.payload.file,
          to: _options.to,
          onProgress: function onProgress(process) {
            element.updatePercent(process);

            if (isFunction(_options.onProgress)) {
              try {
                _options.onProgress(process);
              } catch (e) {
                return IMPromise.reject(new IMError({
                  code: ERROR_CODE.MESSAGE_ONPROGRESS_FUNCTION_ERROR,
                  message: "".concat(ERROR_MESSAGE.MESSAGE_ONPROGRESS_FUNCTION_ERROR)
                }));
              }
            }
          }
        }).then(function (_ref3) {
          var location = _ref3.location;
          var fileUrl = uniformHTTPS(location);
          element.updateFileUrl(fileUrl);
          return message;
        });
      }
    }, {
      key: "_uploadAudio",
      value: function _uploadAudio(message) {
        var _this$tim3 = this.tim,
            uploadController = _this$tim3.uploadController,
            messageController = _this$tim3.messageController;
        var element = message.getElements()[0];

        var _options = messageController.getMessageOptionByID(message.messageID);

        return uploadController.uploadAudio({
          file: _options.payload.file,
          to: _options.to,
          onProgress: function onProgress(process) {
            element.updatePercent(process);

            if (isFunction(_options.onProgress)) {
              try {
                _options.onProgress(process);
              } catch (e) {
                return IMPromise.reject(new IMError({
                  code: ERROR_CODE.MESSAGE_ONPROGRESS_FUNCTION_ERROR,
                  message: "".concat(ERROR_MESSAGE.MESSAGE_ONPROGRESS_FUNCTION_ERROR)
                }));
              }
            }
          }
        }).then(function (_ref4) {
          var location = _ref4.location;
          var fileUrl = uniformHTTPS(location);
          element.updateAudioUrl(fileUrl);
          return message;
        });
      }
    }, {
      key: "_uploadVideo",
      value: function _uploadVideo(message) {
        var _this$tim4 = this.tim,
            uploadController = _this$tim4.uploadController,
            messageController = _this$tim4.messageController;
        var element = message.getElements()[0];

        var _options = messageController.getMessageOptionByID(message.messageID);

        return uploadController.uploadVideo({
          file: _options.payload.file,
          to: _options.to,
          onProgress: function onProgress(process) {
            element.updatePercent(process);

            if (isFunction(_options.onProgress)) {
              try {
                _options.onProgress(process);
              } catch (e) {
                return IMPromise.reject(new IMError({
                  code: ERROR_CODE.MESSAGE_ONPROGRESS_FUNCTION_ERROR,
                  message: "".concat(ERROR_MESSAGE.MESSAGE_ONPROGRESS_FUNCTION_ERROR)
                }));
              }
            }
          }
        }).then(function (res) {
          var videoUrl = uniformHTTPS(res.location);
          element.updateVideoUrl(videoUrl);
          return message;
        });
      }
    }]);

    return UploadFileHandler;
  }();

  /**
   * 关联会话，管理消息的组装，收发，格式化等
   * @author Saxongao
   */

  var MessageController =
  /*#__PURE__*/
  function (_IMController) {
    _inherits(MessageController, _IMController);

    /**
     * @constructor
     * @param {SDK} tim - SDK 实例
     */
    function MessageController(tim) {
      var _this;

      _classCallCheck(this, MessageController);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(MessageController).call(this, tim));

      _this._initializeMembers();

      _this._initializeListener();

      _this._initialzeHandlers(); // 存发送文件消息的 Message 的 option, <messageID, option>


      _this.messageOptionMap = new Map();
      return _this;
    }
    /**
     * 初始化成员变量
     */


    _createClass(MessageController, [{
      key: "_initializeMembers",
      value: function _initializeMembers() {
        this.messagesList = new MessagesList({
          tim: this.tim
        });
        this.currentMessageKey = {}; // 用来记录本实例发送的消息的 random。用来解决重复发布 MESSAGE_RECEIVED 事件的问题。

        this.singlyLinkedList = new SinglyLinkedList(100);
      }
      /**
       * 初始化 handlers
       * @memberof MessageController
       */

    }, {
      key: "_initialzeHandlers",
      value: function _initialzeHandlers() {
        this.readReportHandler = new ReadReportHandler(this.tim, this);
        this.getMessageHandler = new GetMessageHandler({
          messageController: this,
          tim: this.tim
        });
        this.uploadFileHandler = new UploadFileHandler(this.tim);
      }
    }, {
      key: "reset",
      value: function reset() {
        this.messagesList.reset();
        this.currentMessageKey = {}; // 重置 getMessageHandler

        this.getMessageHandler.reset();
        this.singlyLinkedList.reset();
        this.messageOptionMap.clear();
      }
      /**
       * 设置事件监听
       */

    }, {
      key: "_initializeListener",
      value: function _initializeListener() {
        var innerEmitter = this.tim.innerEmitter;
        innerEmitter.on(TIM_INNER_EVENT.NOTICE_LONGPOLL_NEW_C2C_NOTICE, this._onReceiveC2CMessage, this);
        innerEmitter.on(TIM_INNER_EVENT.SYNC_MESSAGE_C2C_PROCESSING, this._onSyncMessagesProcessing, this);
        innerEmitter.on(TIM_INNER_EVENT.SYNC_MESSAGE_C2C_FINISHED, this._onSyncMessagesFinished, this);
        innerEmitter.on(TIM_INNER_EVENT.NOTICE_LONGPOLL_NEW_GROUP_MESSAGES, this._onReceiveGroupMessage, this);
        innerEmitter.on(TIM_INNER_EVENT.NOTICE_LONGPOLL_NEW_GROUP_TIPS, this._onReceiveGroupTips, this);
        innerEmitter.on(TIM_INNER_EVENT.NOTICE_LONGPOLL_NEW_GROUP_NOTICE, this._onReceiveSystemNotice, this);
        innerEmitter.on(TIM_INNER_EVENT.NOTICE_LONGPOLL_GROUP_MESSAGE_REVOKED, this._onReceiveGroupMessageRevokedNotice, this);
        innerEmitter.on(TIM_INNER_EVENT.NOTICE_LONGPOLL_C2C_MESSAGE_REVOKED, this._onReceiveC2CMessageRevokedNotice, this); // 会话删除时需要清理消息列表，例如：退群、解散群组、被踢出群组、调接口删除会话时，SDK 会删除会话，此时需要清理对应消息列表

        innerEmitter.on(TIM_INNER_EVENT.CONVERSATION_DELETED, this._clearConversationMessages, this);
      }
      /**
       * 发送一个消息实例
       * @param {Message} message - 消息实例
       * @returns {Promise}
       */

    }, {
      key: "sendMessageInstance",
      value: function sendMessageInstance(message) {
        var _this2 = this;

        var sumStatController = this.tim.sumStatController;
        var succesHandle = null;

        switch (message.conversationType) {
          case TYPES.CONV_C2C:
            succesHandle = this._handleOnSendC2CMessageSuccess.bind(this);
            break;

          case TYPES.CONV_GROUP:
            succesHandle = this._handleOnSendGroupMessageSuccess.bind(this);
            break;

          default:
            return IMPromise.reject(new IMError({
              code: ERROR_CODE.MESSAGE_SEND_INVALID_CONVERSATION_TYPE,
              message: ERROR_MESSAGE.MESSAGE_SEND_INVALID_CONVERSATION_TYPE
            }));
        } // 把这条消息的 random 记录下来


        this.singlyLinkedList.pushIn(message.random); // 上传成功后再发送

        var startTs; // 发消息起始时间戳，用来计算发消息耗时

        return this.uploadFileHandler.upload(message).then(function () {
          var pack = null;

          if (!message.isSendable()) {
            return IMPromise.reject({
              code: ERROR_CODE.MESSAGE_FILE_URL_IS_EMPTY,
              message: ERROR_MESSAGE.MESSAGE_FILE_URL_IS_EMPTY
            });
          } // summary stat


          sumStatController.addTotalCount(label.SEND_MESSAGE);
          startTs = Date.now();

          if (message.conversationType === TYPES.CONV_C2C) {
            pack = _this2._createC2CMessagePack(message);
          } else if (message.conversationType === TYPES.CONV_GROUP) {
            pack = _this2._createGroupMessagePack(message);
          }

          return _this2.request(pack);
        }).then(function (response) {
          // summary stat
          sumStatController.addSuccessCount(label.SEND_MESSAGE);
          sumStatController.addCost(label.SEND_MESSAGE, Math.abs(Date.now() - startTs)); // 群消息在发送成功后，需要更新 sequence、time和ID

          if (message.conversationType === TYPES.CONV_GROUP) {
            message.sequence = response.data.sequence;
            message.time = response.data.time;
            message.generateMessageID(_this2.tim.context.identifier);
          }

          _this2.messagesList.pushIn(message);

          succesHandle(message, response.data); // 清理临时变量

          _this2.messageOptionMap["delete"](message.messageID); // 发消息成功后，抛内部事件，更新/创建会话


          _this2.emitInnerEvent(TIM_INNER_EVENT.MESSAGE_SENT, {
            eventDataList: [{
              conversationID: message.conversationID,
              unreadCount: 0,
              type: message.conversationType,
              subType: message.conversationSubType,
              lastMessage: message
            }]
          });

          return new IMResponse({
            message: message
          });
        })["catch"](function (error) {
          message.status = TIM_STATUS.MESSAGE_STATUS.FAIL; // event stat

          var ssoLog = new SSOLogData();
          ssoLog.setMethod(SSOMethods.SEND_MESSAGE).setMessageType(message.type).setText("".concat(_this2._generateTjgID(message), "-").concat(message.type, "-").concat(message.from, "-").concat(message.to)) // tjg_id-type-from-to
          .setStart();

          _this2.probeNetwork().then(function (_ref) {
            var _ref2 = _slicedToArray(_ref, 2),
                bOnline = _ref2[0],
                networkType = _ref2[1];

            ssoLog.setError(error, bOnline, networkType).setEnd();
          });

          logger.error("MessageController.sendMessageInstance error:", error); // 当 error 存在且有 code 和 message 的时候，输出实际的 code 和 message
          // 否则输出 [发消息失败] 对应的 code 和 message

          return IMPromise.reject(new IMError({
            code: error && error.code ? error.code : ERROR_CODE.MESSAGE_SEND_FAIL,
            message: error && error.message ? error.message : ERROR_MESSAGE.MESSAGE_SEND_FAIL,
            data: {
              message: message
            }
          }));
        });
      }
      /**
       * 重发消息<br/>
       * 调用时机：消息发送失败时，调用该接口进行重发。
       * @param {Message} message - 消息实例
       * @returns {Promise}
       * @example
       * // 重发消息
       * let promise = tim.resendMessage(message); // 传入需要重发的消息实例
       * promise.then(function(imResponse) {
       *   // 重发成功
       *   console.log(imResponse.data.message);
       * }).catch(function(imError) {
       *   // 重发失败
       *   console.warn('resendMessage error:', imError);
       * });
       */

    }, {
      key: "resendMessage",
      value: function resendMessage(message) {
        message.isResend = true;
        message.status = TIM_STATUS.MESSAGE_STATUS.UNSEND;
        return this.sendMessageInstance(message);
      }
      /**
       * 是否为文件类消息，包含：图片、文件、语音、视频
       * @param {Message} message - 消息实例
       * @returns {Boolean}  返回true ，说明为类文件消息
       *                    返回false, 说明不是类文件消息
       */

    }, {
      key: "_isFileLikeMessage",
      value: function _isFileLikeMessage(message) {
        var fileLikeList = [TYPES.MSG_IMAGE, TYPES.MSG_FILE, TYPES.MSG_AUDIO, TYPES.MSG_VIDEO];

        if (fileLikeList.indexOf(message.type) >= 0) {
          return true;
        }

        return false;
      }
      /**
       * 重发包含二进制数据的消息，包括图片消息、文件消息、语音消息
       */

    }, {
      key: "_resendBinaryTypeMessage",
      value: function _resendBinaryTypeMessage() {}
      /**
       * 创建C2C消息包体
       * @param {MEssage} message - 消息实例
       * @returns {object}
       */

    }, {
      key: "_createC2CMessagePack",
      value: function _createC2CMessagePack(message) {
        // const pack = this.createPackage({
        //   name: 'c2cMessage',
        //   action: 'create',
        //   // 注意！tjg_id 必须在请求的url中
        //   tjgID: this._generateTjgID(message),
        //   param: {
        //     toAccount: message.to,
        //     msgBody: message.getElements(),
        //     msgSeq: message.sequence,
        //     msgRandom: message.random,
        //   },
        // });
        // return pack;
        return {
          name: 'c2cMessage',
          action: 'create',
          // 注意！tjg_id 必须在请求的url中
          tjgID: this._generateTjgID(message),
          param: {
            toAccount: message.to,
            msgBody: message.getElements(),
            msgSeq: message.sequence,
            msgRandom: message.random
          }
        };
      }
      /**
       * 私聊消息发送成功后触发的方法
       * @param {Message} message  - 消息实例
       * @param {responseData} responseData - 响应数据对象
       */

    }, {
      key: "_handleOnSendC2CMessageSuccess",
      value: function _handleOnSendC2CMessageSuccess(message, responseData) {
        message.status = TIM_STATUS.MESSAGE_STATUS.SUCCESS;
        message.time = responseData.time;
      }
      /**
       * 创建群组消息包
       * @param {Message} message - Message 实例
       * @returns {Object}
       */

    }, {
      key: "_createGroupMessagePack",
      value: function _createGroupMessagePack(message) {
        return {
          name: 'groupMessage',
          action: 'create',
          // 注意！tjg_id 必须在请求的url中
          tjgID: this._generateTjgID(message),
          param: {
            groupID: message.to,
            msgBody: message.getElements(),
            random: message.random,
            priority: message.priority,
            clientSequence: message.clientSequence // 这个字段不是透传的数据

          }
        }; // return this.createPackage({
        //   name: 'groupMessage',
        //   action: 'create',
        //   // 注意！tjg_id 必须在请求的url中
        //   tjgID: this._generateTjgID(message),
        //   param: {
        //     groupID: message.to,
        //     msgBody: message.getElements(),
        //     random: message.random,
        //     clientSequence: message.clientSequence, // 这个字段不是透传的数据
        //   },
        // });
      }
      /**
       * 当发送群消息成功时触发
       * 注意：因为群消息的ID在发送成功并收到服务端的response后才能确认，所以在收到response后，需要重置message.ID并从message中移除再重新插入。
       * @param {Message} message - 消息对象
       * @param {Object} responseData - 服务端响应包中的 data
       */

    }, {
      key: "_handleOnSendGroupMessageSuccess",
      value: function _handleOnSendGroupMessageSuccess(message, responseData) {
        // this.messagesList.remove(message); // 把这条消息从消息列表中remove
        message.sequence = responseData.sequence; // 取得这条消息的sequence，这是服务端生成的sequence

        message.time = responseData.time; // 取得此消息的服务器时间

        message.status = TIM_STATUS.MESSAGE_STATUS.SUCCESS;
      }
      /**
       * 当收到新的私聊消息
       * @param {*} event - 失败事件
       */

    }, {
      key: "_onReceiveC2CMessage",
      value: function _onReceiveC2CMessage(event) {
        logger.debug("MessageController._onReceiveC2CMessage nums=".concat(event.data.length));

        var _this$_newC2CMessageS = this._newC2CMessageStoredAndSummary({
          notifiesList: event.data,
          type: TYPES.CONV_C2C,
          C2CRemainingUnreadList: event['C2CRemainingUnreadList']
        }),
            eventDataList = _this$_newC2CMessageS.eventDataList,
            result = _this$_newC2CMessageS.result;

        if (eventDataList.length > 0) {
          this.emitInnerEvent(TIM_INNER_EVENT.MESSAGE_C2C_INSTANT_RECEIVED, {
            eventDataList: eventDataList,
            result: result
          });
        }

        if (result.length > 0) {
          this.emitOuterEvent(TIM_OUTER_EVENT.MESSAGE_RECEIVED, result);
        }
      }
      /**
       * 当收到新的群组消息，入 list 汇总，发布事件
       * @param {*} event - 事件
       */

    }, {
      key: "_onReceiveGroupMessage",
      value: function _onReceiveGroupMessage(event) {
        logger.debug("MessageController._onReceiveGroupMessage nums=".concat(event.data.length));

        var _this$newGroupMessage = this.newGroupMessageStoredAndSummary(event.data),
            eventDataList = _this$newGroupMessage.eventDataList,
            result = _this$newGroupMessage.result;

        if (eventDataList.length > 0) {
          this.emitInnerEvent(TIM_INNER_EVENT.MESSAGE_GROUP_INSTANT_RECEIVED, {
            eventDataList: eventDataList,
            result: result,
            isGroupTip: false
          });
        }

        if (result.length > 0) {
          this.emitOuterEvent(TIM_OUTER_EVENT.MESSAGE_RECEIVED, result);
        }
      }
      /**
       * 当收到新的群提示，入 list 汇总，发布事件
       * @param {*} event - 事件
       */

    }, {
      key: "_onReceiveGroupTips",
      value: function _onReceiveGroupTips(event) {
        var notifiesList = event.data;
        logger.debug("MessageController._onReceiveGroupTips nums=".concat(notifiesList.length));

        var _this$newGroupTipsSto = this.newGroupTipsStoredAndSummary(notifiesList),
            eventDataList = _this$newGroupTipsSto.eventDataList,
            result = _this$newGroupTipsSto.result;

        if (eventDataList.length > 0) {
          this.emitInnerEvent(TIM_INNER_EVENT.MESSAGE_GROUP_INSTANT_RECEIVED, {
            eventDataList: eventDataList,
            result: result,
            isGroupTip: true
          }); // 事件名无法区分ev3/ev4的群消息, 用isGroupTip区分
        }

        if (result.length > 0) {
          this.emitOuterEvent(TIM_OUTER_EVENT.MESSAGE_RECEIVED, result);
        }
      }
      /**
       * 当收到系统通知，包含群系统通知
       * @param {Object} event - 事件
       * @param {Object} event.data - 数据
       * @param {Object[]} event.data.groupSystemNotices - 群系统通知数组
       * @param {String} event.data.type - 'poll' | 'sync' 来自轮询的系统通知，还是来自同步未读的系统通知
       */

    }, {
      key: "_onReceiveSystemNotice",
      value: function _onReceiveSystemNotice(event) {
        var _event$data = event.data,
            notifiesList = _event$data.groupSystemNotices,
            type = _event$data.type;
        logger.debug("MessageController._onReceiveSystemNotice nums=".concat(notifiesList.length));

        var _this$newSystemNotice = this.newSystemNoticeStoredAndSummary({
          notifiesList: notifiesList,
          type: type
        }),
            eventDataList = _this$newSystemNotice.eventDataList,
            result = _this$newSystemNotice.result;

        if (eventDataList.length > 0) {
          this.emitInnerEvent(TIM_INNER_EVENT.MESSAGE_GROUP_SYSTEM_NOTICE_RECEIVED, {
            eventDataList: eventDataList,
            result: result,
            type: type
          });
        } // 轮询的系统通知才抛出给接入测，同步未读的系统通知不抛出。


        if (result.length > 0 && type === 'poll') {
          this.emitOuterEvent(TIM_OUTER_EVENT.MESSAGE_RECEIVED, result);
        }
      } // 收到群消息被撤回的通知

    }, {
      key: "_onReceiveGroupMessageRevokedNotice",
      value: function _onReceiveGroupMessageRevokedNotice(event) {
        var _this3 = this;

        logger.debug("MessageController._onReceiveGroupMessageRevokedNotice nums=".concat(event.data.length));
        var revokedMessageList = [];
        var tmpMessage = null;
        event.data.forEach(function (item) {
          var revokedInfos = item.elements.revokedInfos;
          revokedInfos.forEach(function (info) {
            tmpMessage = _this3.messagesList.revoke("GROUP".concat(info.groupID), info.sequence);

            if (tmpMessage) {
              revokedMessageList.push(tmpMessage);
            }
          });
        });

        if (revokedMessageList.length === 0) {
          return;
        }

        this.emitInnerEvent(TIM_INNER_EVENT.MESSAGE_REVOKED, revokedMessageList);
        this.emitOuterEvent(TIM_OUTER_EVENT.MESSAGE_REVOKED, revokedMessageList);
      } // 收到c2c消息被撤回的通知

    }, {
      key: "_onReceiveC2CMessageRevokedNotice",
      value: function _onReceiveC2CMessageRevokedNotice(event) {
        var _this4 = this;

        logger.debug("MessageController._onReceiveC2CMessageRevokedNotice nums=".concat(event.data.length));
        var revokedMessageList = [];
        var tmpMessage = null;
        event.data.forEach(function (item) {
          var revokedInfos = item.c2cMessageRevokedNotify.revokedInfos;
          revokedInfos.forEach(function (info) {
            // conversationID 为消息类型(C2C) + message.from
            // 如果当前用户 === message.from 则可以判断这条消息是同一账号的其他实例发送的消息，否则为接受对方发送的消息
            // 对于接受对方撤回消息的情况 conversationID = C2C + message.from
            // 对于多实例撤回消息，收到其他实例撤回消息的通知时 conversationID = C2C + message.to
            var conversationID = _this4.tim.context.identifier === info.from ? "C2C".concat(info.to) : "C2C".concat(info.from);
            tmpMessage = _this4.messagesList.revoke(conversationID, info.sequence, info.random);

            if (tmpMessage) {
              revokedMessageList.push(tmpMessage);
            }
          });
        });

        if (revokedMessageList.length === 0) {
          return;
        }

        this.emitInnerEvent(TIM_INNER_EVENT.MESSAGE_REVOKED, revokedMessageList);
        this.emitOuterEvent(TIM_OUTER_EVENT.MESSAGE_REVOKED, revokedMessageList);
      }
      /**
       * 从messageList 中删除某个群组的消息列表
       * @param {Object} event event.data.conversationID - 会话 ID
      */

    }, {
      key: "_clearConversationMessages",
      value: function _clearConversationMessages(event) {
        var conversationID = event.data; // 1. 清除会话消息列表

        this.messagesList.removeByConversationID(conversationID); // 2. 清除 completed 标识（一个会话有这个标识，说明已经把历史消息全部同步到消息列表中）
        // 背景: user0 若在拉完历史消息后，退群，再进群。此时调用 getMessageList 接口没有发起请求拉历史消息。预期应该是请求获取历史消息
        // 原因: 此时命中了 completed 的逻辑，认为该群组已经拉完历史消息了。
        // 解决办法: 退群后清理 completed 标识

        this.getMessageHandler.deleteCompletedItem(conversationID);
      }
      /**
       * 负责把消息推入通知数组，一条消息需要满足以下两个条件，才会推入通知数组 result :
       *  条件1：不是重复的消息，这一点，通过 this.messagesList.pushIn 来保证
       *  条件2：不是从本实例发送的消息，通过 this.messageRandomSendedList.has 来保证
       * @param { array } result - 通知结果数组
       * @param { Message } message - 消息实例
       * @returns {Boolean} 是否 push 成功
       */

    }, {
      key: "_pushIntoNoticeResult",
      value: function _pushIntoNoticeResult(result, message) {
        var isPushInSuccess = this.messagesList.pushIn(message); // 全入列，如有重复，靠pushIn去重

        var randomCheckResult = this.singlyLinkedList.has(message.random); // 如果是不是重复消息以及不是本实例发送的消息，则 push 到 result 中

        if (isPushInSuccess && randomCheckResult === false) {
          result.push(message);
          return true;
        }

        return false;
      }
      /**
       * C2C 新通知入库与生成汇总数据
       * @param {Array} options.notifiesList - 通知列表
       * @param {String} options.type - 会话类型
       * @param {Array} options.C2CRemainingUnreadList - C2C 溢出的消息数量。 C2C 未读 = 同步下的消息数量 + 该字段中的 count 值
       * @param {Boolean} options.isFromSync - 是否来自同步未读，来自同步未读的消息不入库
       * @returns {Object} 返回用于更新会话列表的配置（eventDataList）以及入库成功的消息列表（result）
       */

    }, {
      key: "_newC2CMessageStoredAndSummary",
      value: function _newC2CMessageStoredAndSummary(_ref3) {
        var notifiesList = _ref3.notifiesList,
            type = _ref3.type,
            C2CRemainingUnreadList = _ref3.C2CRemainingUnreadList,
            isFromSync = _ref3.isFromSync;
        var message = null;
        var eventDataList = [];
        var result = [];
        var indexes = {};
        var bigDataHallwayController = this.tim.bigDataHallwayController; // 大数据通道控制器
        // 先循环归类

        for (var i = 0, len = notifiesList.length; i < len; i++) {
          var item = notifiesList[i];
          item.currentUser = this.tim.context.identifier;
          item.conversationType = type;
          item.isSystemMessage = !!item.isSystemMessage;
          message = new Message(item); // 用大数据通道控制器做一下转化，把老版本发送的文件、音频、视频消息元素的 URL 拼接出来。

          item.elements = bigDataHallwayController.parseElements(item.elements, item.from);
          message.setElement(item.elements); // 同步未读的消息不入库

          if (!isFromSync) {
            var isSuccess = this._pushIntoNoticeResult(result, message); // 未入库成功的消息不需要更新会话（eventDataList 是用于更新会话列表的）


            if (!isSuccess) {
              continue;
            }
          }

          if (typeof indexes[message.conversationID] === 'undefined') {
            indexes[message.conversationID] = eventDataList.push({
              conversationID: message.conversationID,
              // 如果是自己发送的消息，不计未读
              unreadCount: message.flow === 'out' ? 0 : 1,
              type: message.conversationType,
              subType: message.conversationSubType,
              lastMessage: message
            }) - 1;
          } else {
            eventDataList[indexes[message.conversationID]].type = message.conversationType;
            eventDataList[indexes[message.conversationID]].subType = message.conversationSubType;
            eventDataList[indexes[message.conversationID]].lastMessage = message; // 如果是不是自己发的消息， 未读计数增加

            if (message.flow === 'in') {
              eventDataList[indexes[message.conversationID]].unreadCount++;
            }
          }
        } // 若有溢出的消息计数，则更新未读计数


        if (isArray(C2CRemainingUnreadList)) {
          var _loop = function _loop(_i, _len) {
            var eventData = eventDataList.find(function (_ref4) {
              var conversationID = _ref4.conversationID;
              return conversationID === "C2C".concat(C2CRemainingUnreadList[_i].from);
            });

            if (eventData) {
              eventData.unreadCount += C2CRemainingUnreadList[_i].count; // 溢出的未读消息数量
            } else {
              eventDataList.push({
                conversationID: "C2C".concat(C2CRemainingUnreadList[_i].from),
                unreadCount: C2CRemainingUnreadList[_i].count,
                type: TYPES.CONV_C2C
              });
            }
          };

          for (var _i = 0, _len = C2CRemainingUnreadList.length; _i < _len; _i++) {
            _loop(_i, _len);
          }
        }

        return {
          eventDataList: eventDataList,
          result: result
        };
      }
      /**
       * TIPS: 发现群消息和C2C消息处理逻辑不太相同，单独分出一个函数来处理入列问题，以防逻辑变得复杂
       * GROUP新通知入例与生成汇总数据
       * @param {Array} notifiesList - 通知列表
       * @returns {Object} 返回用于更新会话列表的配置（eventDataList）以及入库成功的消息列表（result）
       */

    }, {
      key: "newGroupMessageStoredAndSummary",
      value: function newGroupMessageStoredAndSummary(notifiesList) {
        var message = null;
        var eventDataList = [];
        var indexes = {};
        var result = [];
        var type = TYPES.CONV_GROUP;
        var bigDataHallwayController = this.tim.bigDataHallwayController; // 先循环归类

        for (var i = 0, len = notifiesList.length; i < len; i++) {
          var item = notifiesList[i];
          item.currentUser = this.tim.context.identifier;
          item.conversationType = type;
          item.isSystemMessage = !!item.isSystemMessage;
          message = new Message(item); // 用大数据通道控制器做一下转化，把老版本发送的文件、音频、视频消息元素的 URL 拼接出来。

          item.elements = bigDataHallwayController.parseElements(item.elements, item.from);
          message.setElement(item.elements); // 补丁逻辑：
          // 在控制台创建avchatroom并指定群主，群主通过sdk加入avchatroom后，群内其它人发的信息在群主侧会重复
          // 原因：其它人的消息不止通过get_msg下发，还从opim/longpolling下发，导致重复
          // 解决办法：从opim/longpolling收到了avchatroom的消息就丢弃

          if (this._isMessageFromAVChatroom(message)) {
            continue;
          }

          var isSuccess = this._pushIntoNoticeResult(result, message); // 未入库成功的消息不需要更新会话（eventDataList 是用于更新会话列表的）


          if (!isSuccess) {
            continue;
          }

          if (typeof indexes[message.conversationID] === 'undefined') {
            indexes[message.conversationID] = eventDataList.push({
              conversationID: message.conversationID,
              // 如果是自己发送的消息，不计未读
              unreadCount: message.flow === 'out' ? 0 : 1,
              type: message.conversationType,
              subType: message.conversationSubType,
              lastMessage: message
            }) - 1;
          } else {
            eventDataList[indexes[message.conversationID]].type = message.conversationType;
            eventDataList[indexes[message.conversationID]].subType = message.conversationSubType;
            eventDataList[indexes[message.conversationID]].lastMessage = message; // 如果是不是自己发的消息， 未读计数增加

            if (message.flow === 'in') {
              eventDataList[indexes[message.conversationID]].unreadCount++;
            }
          }
        }

        return {
          eventDataList: eventDataList,
          result: result
        };
      } // 判断open/longpolling通道收到的【群消息】，是否来自于avchatroom

    }, {
      key: "_isMessageFromAVChatroom",
      value: function _isMessageFromAVChatroom(message) {
        // conversationID 的格式 `GROUP${groupID}`
        var groupID = message.conversationID.slice(5);
        return this.tim.groupController.checkJoinedAVChatRoomByID(groupID);
      }
      /**
       * 新通知入例与生成汇总数据
       * @param {Array} notifiesList - 通知列表
       * @returns {Object} 返回用于更新会话列表的配置（eventDataList）以及入库成功的消息列表（result）
       */

    }, {
      key: "newGroupTipsStoredAndSummary",
      value: function newGroupTipsStoredAndSummary(notifiesList) {
        var message = null;
        var eventDataList = [];
        var result = [];
        var indexes = {}; // 先循环归类

        for (var i = 0, len = notifiesList.length; i < len; i++) {
          var item = notifiesList[i];
          item.currentUser = this.tim.context.identifier;
          item.conversationType = TYPES.CONV_GROUP;
          message = new Message(item);
          message.setElement({
            type: TYPES.MSG_GRP_TIP,
            content: _objectSpread2({}, item.elements, {
              groupProfile: item.groupProfile
            })
          });
          message.isSystemMessage = false; // 补丁逻辑：
          // 在控制台创建avchatroom并指定群主，群主通过sdk加入avchatroom后，群主修改群资料会收到重复的群提示
          // 原因：修改群资料，event 4，不止通过get_msg下发，还从opim/longpolling下发，导致重复
          // 解决办法：从opim/longpolling收到了avchatroom的群提示就丢弃

          if (this._isMessageFromAVChatroom(message)) {
            continue;
          }

          var isSuccess = this._pushIntoNoticeResult(result, message); // 未入库成功的消息不需要更新会话（eventDataList 是用于更新会话列表的）


          if (!isSuccess) {
            continue;
          }

          if (typeof indexes[message.conversationID] === 'undefined') {
            indexes[message.conversationID] = eventDataList.push({
              conversationID: message.conversationID,
              // 如果是自己发送的消息，不计未读
              unreadCount: message.flow === 'out' ? 0 : 1,
              type: message.conversationType,
              subType: message.conversationSubType,
              lastMessage: message
            }) - 1;
          } else {
            eventDataList[indexes[message.conversationID]].type = message.conversationType;
            eventDataList[indexes[message.conversationID]].subType = message.conversationSubType;
            eventDataList[indexes[message.conversationID]].lastMessage = message; // 如果是不是自己发的消息， 未读计数增加

            if (message.flow === 'in') {
              eventDataList[indexes[message.conversationID]].unreadCount++;
            }
          }
        }

        return {
          eventDataList: eventDataList,
          result: result
        };
      }
      /**
       * 系统通知入列
       * @param {Array} options.notifiesList - 通知列表
       * @param {String} options.type - 来源类型 'sync' || 'poll'
       * @returns {Object} 返回用于更新会话列表的配置（eventDataList）以及入库成功的消息列表（result）
       */

    }, {
      key: "newSystemNoticeStoredAndSummary",
      value: function newSystemNoticeStoredAndSummary(_ref5) {
        var notifiesList = _ref5.notifiesList,
            type = _ref5.type;
        var message = null;
        var len = notifiesList.length;
        var i = 0;
        var result = [];
        var eventData = {
          conversationID: TYPES.CONV_SYSTEM,
          unreadCount: 0,
          type: TYPES.CONV_SYSTEM,
          subType: null,
          lastMessage: null
        };

        for (i = 0; i < len; i++) {
          var item = notifiesList[i]; // 群消息已读同步的ev5不入库

          if (item.elements.operationType === GROUP_SYSTEM_NOTICE_TYPES.READED) {
            continue;
          }

          item.currentUser = this.tim.context.identifier;
          item.conversationType = TYPES.CONV_SYSTEM;
          item.conversationID = TYPES.CONV_SYSTEM; // 系统类型的会话ID只能有一个，命名固定

          message = new Message(item);
          message.setElement({
            type: TYPES.MSG_GRP_SYS_NOTICE,
            content: _objectSpread2({}, item.elements, {
              groupProfile: item.groupProfile
            })
          });
          message.isSystemMessage = true; // 在控制台或者用 RESTAPI 创建的群组，解散时（dismissGroup或控制台或restapi）收到的群系统通知 sequence 和 random 都是1
          // 通过sdk createGroup 创建的群组，解散时（dismissGroup或控制台或restapi）收到的群系统通知 sequence 和 random 都是2
          // 以上情况都会导致入库问题，于是重新生成 sequence 和 random

          if (message.sequence === 1 && message.random === 1 || message.sequence === 2 && message.random === 2) {
            message.sequence = randomInt();
            message.random = randomInt();
            message.generateMessageID(item.currentUser);
            logger.log("MessageController.newSystemNoticeStoredAndSummary sequence and random maybe duplicated, regenerate. ID=".concat(message.ID));
          }

          var isSuccess = this._pushIntoNoticeResult(result, message); // 未入库成功的消息不需要更新会话（eventDataList 是用于更新会话列表的）


          if (!isSuccess) {
            continue;
          } // 实时的ev5 增加群系统通知的未读计数


          if (type === 'poll') {
            eventData.unreadCount++;
          } else if (type === 'sync') {
            // 同步未读拉下来的系统通知为已读
            message.setIsRead(true);
          }

          eventData.subType = message.conversationSubType;
        }

        eventData.lastMessage = result[result.length - 1]; // 若遍历后 result 没有数据，则表明没有会话更新

        return {
          eventDataList: result.length > 0 ? [eventData] : [],
          result: result
        };
      }
      /**
       * 处理同步的未读消息
       * @param {Object} event - 事件
       */

    }, {
      key: "_onSyncMessagesProcessing",
      value: function _onSyncMessagesProcessing(event) {
        var _this$_newC2CMessageS2 = this._newC2CMessageStoredAndSummary({
          notifiesList: event.data,
          type: TYPES.CONV_C2C,
          isFromSync: true,
          C2CRemainingUnreadList: event['C2CRemainingUnreadList']
        }),
            eventDataList = _this$_newC2CMessageS2.eventDataList,
            result = _this$_newC2CMessageS2.result;

        this.emitInnerEvent(TIM_INNER_EVENT.MESSAGE_SYNC_PROCESSING, {
          eventDataList: eventDataList,
          result: result
        });
      }
      /**
       * 消息同步完成
       * @param {Object} event - 事件
       */

    }, {
      key: "_onSyncMessagesFinished",
      value: function _onSyncMessagesFinished(event) {
        this.triggerReady();

        var _this$_newC2CMessageS3 = this._newC2CMessageStoredAndSummary({
          notifiesList: event.data.messageList,
          type: TYPES.CONV_C2C,
          isFromSync: true,
          C2CRemainingUnreadList: event.data['C2CRemainingUnreadList']
        }),
            eventDataList = _this$_newC2CMessageS3.eventDataList,
            result = _this$_newC2CMessageS3.result;

        this.emitInnerEvent(TIM_INNER_EVENT.MESSAGE_SYNC_FINISHED, {
          eventDataList: eventDataList,
          result: result
        });
      }
      /**
       * 获取私聊和群的历史消息
       * @param {Object} options - 拉取历史通知时的配置参数
       * @param {String} options.conversationID - 会话ID
       * @param {Number} options.count - 一次获取的数量
       * @returns {IMPromise}
       */

    }, {
      key: "getHistoryMessages",
      value: function getHistoryMessages(options) {
        if (options.conversationID === TYPES.CONV_SYSTEM) {
          return IMPromise.resolve();
        }

        !options.count ? options.count = 15 : null;
        options.count > 20 ? options.count = 20 : null; // 暂时限制20条

        var message = this.messagesList.getLocalOldestMessageByConversationID(options.conversationID); // 拿暂存消息中最旧的一条消息对象
        // 如果最旧的这条消息对象为NULL，则定义好tim 、 sequence 的初始值。

        if (!message) {
          message = {};
          message.time = 0;
          message.sequence = 0; // 如果是C2C会话，给message 添加 to 属性

          if (options.conversationID.indexOf(TYPES.CONV_C2C) === 0) {
            message.to = options.conversationID.replace(TYPES.CONV_C2C, '');
            message.conversationType = TYPES.CONV_C2C; // 如果是GROUP会话，给message 添加 groupID 属性
          } else if (options.conversationID.indexOf(TYPES.CONV_GROUP) === 0) {
            message.to = options.conversationID.replace(TYPES.CONV_GROUP, '');
            message.conversationType = TYPES.CONV_GROUP;
          }
        }

        var peerAccount = '';

        switch (message.conversationType) {
          case TYPES.CONV_C2C:
            peerAccount = options.conversationID.replace(TYPES.CONV_C2C, '');
            return this.getC2CRoamMessages({
              conversationID: options.conversationID,
              peerAccount: peerAccount,
              count: options.count,
              lastMessageTime: typeof this.currentMessageKey[options.conversationID] === 'undefined' ? 0 : message.time // 如果是第一次拉取，lastMessageTime留空

            });

          case TYPES.CONV_GROUP:
            return this.getGroupRoamMessages({
              conversationID: options.conversationID,
              groupID: message.to,
              count: options.count,
              sequence: message.sequence - 1 // 拉群历史消息会包含传的seq的消息，如传 seq = 1，则拉回来的消息列表中会包含 seq = 1的消息。而这条消息已经在内存中了，所以不必要再拉。

            });

          default:
            return IMPromise.resolve();
        }
      }
      /**
       * 拉取 C2C 漫游
       * @param {Object} options  -  拉取历史通知时的配置参数
       * @param {String} options.peerAccount - 对方账号
       * @param {String} options.conversationID - 会话ID
       * @param {Number} options.count  - 一次拉取的消息条数 ， 默认为15
       * @param {Number} options.lastMessageTime - 最后一条消息的时间
       * @param {String} options.messageKey - 用于断点继拉，当count大N（自测为：37）时，需要需要用到这个属性进行续拉，续拉完成后才能返回。
       * @param {Number} times - 用户继拉记数
       * @returns {IMPromise}
       */

    }, {
      key: "getC2CRoamMessages",
      value: function getC2CRoamMessages(options) {
        var _this5 = this;

        var messageKey = typeof this.currentMessageKey[options.conversationID] !== 'undefined' ? this.currentMessageKey[options.conversationID] : '';
        logger.log("MessageController.getC2CRoamMessages toAccount=".concat(options.peerAccount, " count=").concat(options.count || 15, " lastMessageTime=").concat(options.lastMessageTime || 0, " messageKey=").concat(messageKey)); // event stat

        var ssoLog = new SSOLogData();
        ssoLog.setMethod(SSOMethods.GET_C2C_ROAMING_MESSAGES).setStart();
        return this.request({
          name: 'c2cMessage',
          action: 'query',
          param: {
            peerAccount: options.peerAccount,
            count: options.count || 15,
            lastMessageTime: options.lastMessageTime || 0,
            messageKey: messageKey
          }
        }).then(function (response) {
          var _response$data = response.data,
              complete = _response$data.complete,
              messageList = _response$data.messageList;

          if (isUndefined(messageList)) {
            logger.log("MessageController.getC2CRoamMessages ok. complete=".concat(complete, " but messageList is undefined!"));
          } else {
            logger.log("MessageController.getC2CRoamMessages ok. complete=".concat(complete, " nums=").concat(messageList.length));
          } // event stat


          ssoLog.setCode(0).setNetworkType(_this5.getNetworkType()) // peerAccount-count-lastMessageTime-messageKey-complete-messageList.length
          .setText("".concat(options.peerAccount, "-").concat(options.count || 15, "-").concat(options.lastMessageTime || 0, "-").concat(messageKey, "-").concat(complete, "-").concat(messageList ? messageList.length : 'undefined')).setEnd();

          if (complete === 1) {
            _this5.getMessageHandler.setCompleted(options.conversationID);
          }

          var messages = _this5._roamMessageStore(messageList, TYPES.CONV_C2C, options.conversationID); // 更新拉下来的历史消息的 isRead 值


          _this5.readReportHandler.updateIsRead(options.conversationID);

          _this5.currentMessageKey[options.conversationID] = response.data.messageKey;
          return messages;
        })["catch"](function (error) {
          // event stat
          _this5.probeNetwork().then(function (_ref6) {
            var _ref7 = _slicedToArray(_ref6, 2),
                bOnline = _ref7[0],
                networkType = _ref7[1];

            ssoLog.setError(error, bOnline, networkType).setText("".concat(options.peerAccount, "-").concat(options.count || 15, "-").concat(options.lastMessageTime || 0, "-").concat(messageKey)).setEnd();
          });

          logger.warn("MessageController.getC2CRoamMessages failed. ".concat(error));
          return IMPromise.reject(error);
        });
      } // 计算群最新消息的 sequence，用于拉取群漫游

    }, {
      key: "_computeLastSequence",
      value: function _computeLastSequence(options) {
        if (options.sequence >= 0) {
          return Promise.resolve(options.sequence);
        }

        return this.tim.groupController.getGroupLastSequence(options.groupID);
      }
      /**
       * 拉取GROUP漫游消息
       * @param {Object} options - 必填，配置参数
       * @param {String} options.groupID - 必填，群组ID
       * @param {String} options.count - 必填，群组ID
       * @param {Number} options.sequence - 选填，消息sequence
       * @returns {IMPromise}
       */

    }, {
      key: "getGroupRoamMessages",
      value: function getGroupRoamMessages(options) {
        var _this6 = this;

        // event stat
        var ssoLog = new SSOLogData();
        var lastSequence = 0;
        return this._computeLastSequence(options).then(function (sequence) {
          lastSequence = sequence;
          logger.log("MessageController.getGroupRoamMessages groupID=".concat(options.groupID, " lastSequence=").concat(lastSequence));
          ssoLog.setMethod(SSOMethods.GET_GROUP_ROAMING_MESSAGES).setStart();
          return _this6.request({
            name: 'groupMessage',
            action: 'query',
            param: {
              groupID: options.groupID,
              count: 21,
              // 每次传超过20，若拉到过期的漫游消息，complete = 2，标识该页的消息都是过期的。
              sequence: lastSequence
            }
          });
        }).then(function (response) {
          var _response$data2 = response.data,
              messageList = _response$data2.messageList,
              complete = _response$data2.complete;

          if (isUndefined(messageList)) {
            logger.log("MessageController.getGroupRoamMessages ok. complete=".concat(complete, " but messageList is undefined!"));
          } else {
            logger.log("MessageController.getGroupRoamMessages ok. complete=".concat(complete, " nums=").concat(messageList.length));
          } // event stat


          ssoLog.setCode(0).setNetworkType(_this6.getNetworkType()) // groupID-lastSequence-complete-messageList.length
          .setText("".concat(options.groupID, "-").concat(lastSequence, "-").concat(complete, "-").concat(messageList ? messageList.length : 'undefined')).setEnd();
          var conversationID = "GROUP".concat(options.groupID); // 1. 若 complete 为2，则说明拉到了都是过期的漫游消息，即说明群漫游消息已经拉完。
          // 2. 若返回的消息列表为空数组，则说明群漫游消息已拉完

          if (complete === 2 || isEmpty(messageList)) {
            _this6.getMessageHandler.setCompleted(conversationID);

            return [];
          }

          var messages = _this6._roamMessageStore(messageList, TYPES.CONV_GROUP, conversationID);

          _this6.readReportHandler.updateIsRead(conversationID);

          return messages;
        })["catch"](function (error) {
          // event stat
          _this6.probeNetwork().then(function (_ref8) {
            var _ref9 = _slicedToArray(_ref8, 2),
                bOnline = _ref9[0],
                networkType = _ref9[1];

            ssoLog.setError(error, bOnline, networkType).setText("".concat(options.groupID, "-").concat(lastSequence)).setEnd();
          });

          logger.warn("MessageController.getGroupRoamMessages failed. ".concat(error));
          return IMPromise.reject(error);
        });
      }
      /**
       * 漫游消息的存储，注意：群消息是升序，C2C消息是降序
       * @param {Array} messageList - 收到的消息列表
       * @param {String} conversationType - 会话类型，可取自： TYPES.CONV_GROUP 和 TYPES.CONV_C2C
       * @param {string} conversationID - 会话ID
       * @returns {[Message]} messages - 消息数组，元素为 Message 实例
       */

    }, {
      key: "_roamMessageStore",
      value: function _roamMessageStore() {
        var messageList = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
        var conversationType = arguments.length > 1 ? arguments[1] : undefined;
        var conversationID = arguments.length > 2 ? arguments[2] : undefined;
        var message = null;
        var messages = [];
        var index = 0;
        var indexEnd = messageList.length;
        var elements = null;
        var isGroup = conversationType === TYPES.CONV_GROUP;
        var bigDataHallwayController = this.tim.bigDataHallwayController;

        var initIndexStartAndIndexEnd = function initIndexStartAndIndexEnd() {
          // 如果是群组消息，从数组尾标开始
          index = isGroup ? messageList.length - 1 : 0; // 如果是群组消息，到数组0索引入结束

          indexEnd = isGroup ? 0 : messageList.length;
        };

        var indexStep = function indexStep() {
          // 如果是群组消息，index从数组最大索引开始自减，否则是从0开始自增
          isGroup ? --index : ++index;
        };

        var indexCompare = function indexCompare() {
          // 如果是群组消息，继续循环的条件是 index>=indexEnd, 如果私聊消息，继续循环的条件为index<indexEnd
          return isGroup ? index >= indexEnd : index < indexEnd;
        }; // 抠门儿: 这样写是为了避免掉 revers 操作引起的 2 x O(n) 复杂度，牺牲掉了代码可读性，性价比可能不太高，因为也只是 2 x O(n) 和 O(n) 的区别；


        for (initIndexStartAndIndexEnd(); indexCompare(); indexStep()) {
          // sequence 为1时，说明拉完群漫游消息
          // 注意：该处逻辑和下面的空消息判断的顺序不能互换，若替换了，当该群最后一条消息刚好是过期消息时，就不能准确判断 completed 标识
          if (isGroup && messageList[index].sequence === 1) {
            this.getMessageHandler.setCompleted(conversationID);
          } // 出现空消息时，例如撤回、删除、过期的消息，不入库。


          if (messageList[index].isPlaceMessage === 1) {
            continue;
          }

          message = new Message(messageList[index]);
          message.to = messageList[index].to;
          message.isSystemMessage = !!messageList[index].isSystemMessage;
          message.conversationType = conversationType;

          if (messageList[index].event === MESSAGE.JSON.TYPE.GROUP.TIP) {
            elements = {
              type: TYPES.MSG_GRP_TIP,
              content: _objectSpread2({}, messageList[index].elements, {
                groupProfile: messageList[index].groupProfile
              })
            };
          } else {
            messageList[index].elements = bigDataHallwayController.parseElements(messageList[index].elements, messageList[index].from);
            elements = messageList[index].elements;
          }

          message.setElement(elements);
          message.reInitialize(this.tim.context.identifier);
          messages.push(message);
        }

        this.messagesList.unshift(messages);
        initIndexStartAndIndexEnd = indexStep = indexCompare = null; // 释放掉

        return messages;
      }
      /**
       * 获取消息列表
       * @param {string} conversationID - 会话ID
       * @returns {array}
       */

    }, {
      key: "getLocalMessageList",
      value: function getLocalMessageList(conversationID) {
        return this.messagesList.getLocalMessageList(conversationID);
      }
      /**
       * 获取会话中某条消息
       * @param {String} conversationID - 会话ID
       * @param {String} messageID - 消息ID
       * @returns {Message|Null}
       */

    }, {
      key: "getLocalMessage",
      value: function getLocalMessage(conversationID, messageID) {
        return this.messagesList.getLocalMessage(conversationID, messageID);
      }
      /**
       * 获取内存中某会话的某条消息
       * @param {String} conversationID - 会话ID
       * @param {String} messageID - 消息ID
       * @returns {object}
       */

    }, {
      key: "hasLocalMessage",
      value: function hasLocalMessage(conversationID, messageID) {
        return this.messagesList.hasLocalMessage(conversationID, messageID);
      }
      /**
       * 删除缓存中的某条消息
       * @param {Message} message 消息实例
       */

    }, {
      key: "deleteLocalMessage",
      value: function deleteLocalMessage(message) {
        if (message instanceof Message) {
          this.messagesList.remove(message);
        }
      }
      /**
       * 撤回消息
       * @param {Message} message 消息实例
       * @returns {Promise}
       */

    }, {
      key: "revokeMessage",
      value: function revokeMessage(message) {
        var _this7 = this;

        var pack;

        if (message.conversationType === TYPES.CONV_C2C) {
          pack = {
            name: 'c2cMessageWillBeRevoked',
            action: 'create',
            param: {
              msgInfo: {
                fromAccount: message.from,
                toAccount: message.to,
                msgSeq: message.sequence,
                msgRandom: message.random,
                msgTimeStamp: message.time
              }
            }
          };
        } else if (message.conversationType === TYPES.CONV_GROUP) {
          pack = {
            name: 'groupMessageWillBeRevoked',
            action: 'create',
            param: {
              to: message.to,
              msgSeqList: [{
                msgSeq: message.sequence
              }]
            }
          };
        } // event stat


        var ssoLog = new SSOLogData();
        ssoLog.setMethod(SSOMethods.REVOKE_MESSAGE).setMessageType(message.type).setText("".concat(this._generateTjgID(message), "-").concat(message.type, "-").concat(message.from, "-").concat(message.to)) // tjg_id-type-from-to
        .setStart();
        return this.request(pack).then(function (response) {
          var recallRetList = response.data.recallRetList; // 撤回消息，有【接口私有错误码】，非常坑！
          // 撤回单聊消息 API 私有错误码 https://cloud.tencent.com/document/product/269/38980#.E9.94.99.E8.AF.AF.E7.A0.81.E8.AF.B4.E6.98.8E
          // 撤回群聊消息 API 私有错误码 https://cloud.tencent.com/document/product/269/12341#.E9.94.99.E8.AF.AF.E7.A0.81.E8.AF.B4.E6.98.8E
          // TODO: 目前只有撤回群聊消息会返回 RecallRetList，c2c 年后催促后台补上，防御接入侧撤回已过可撤回时间的消息等特殊操作

          if (!isEmpty(recallRetList) && recallRetList[0].retCode !== 0) {
            // sdk 只允许撤回单条消息（REST API 可以批量撤回），所以撤回失败的情况下数组只有一个元素
            var imError = new IMError({
              code: recallRetList[0].retCode,
              message: IMSERVER_ERROR[recallRetList[0].retCode] || ERROR_MESSAGE.MESSAGE_REVOKE_FAIL,
              data: {
                message: message
              }
            }); // event stat

            ssoLog.setCode(imError.code).setMessage(imError.message).setEnd();
            return IMPromise.reject(imError);
          }

          logger.info("MessageController.revokeMessage ok. ID=".concat(message.ID));
          message.isRevoked = true; // event stat

          ssoLog.setCode(0).setEnd();

          _this7.emitInnerEvent(TIM_INNER_EVENT.MESSAGE_REVOKED, [message]);

          return new IMResponse({
            message: message
          });
        })["catch"](function (error) {
          _this7.probeNetwork().then(function (_ref10) {
            var _ref11 = _slicedToArray(_ref10, 2),
                bOnline = _ref11[0],
                networkType = _ref11[1];

            ssoLog.setError(error, bOnline, networkType).setEnd();
          }); // 当 error 存在且有 code 和 message 的时候，输出实际的 code 和 message
          // 否则输出 [发消息失败] 对应的 code 和 message


          var imError = new IMError({
            code: error && error.code ? error.code : ERROR_CODE.MESSAGE_REVOKE_FAIL,
            message: error && error.message ? error.message : ERROR_MESSAGE.MESSAGE_REVOKE_FAIL,
            data: {
              message: message
            }
          });
          logger.warn("MessageController.revokeMessage failed. ID=".concat(message.ID, " code=").concat(imError.code, " message=").concat(imError.message));
          return IMPromise.reject(imError);
        });
      }
      /**
       * 消息已读上报
       * @param {Object} options - 参数配置
       * @param {String} options.conversationID - 会话 ID
       * @param {String} [options.messageID] - 消息 ID（暂时不暴露给上层）。将某消息之前的消息已读上报。<br/> 若不传该字段，则默认对会话中所有的消息已读上报。
       * @returns {object}
       * @memberof MessageController
       */

    }, {
      key: "setMessageRead",
      value: function setMessageRead(options) {
        var _this8 = this;

        var result = new Promise(function (resolve, reject) {
          _this8.ready(function () {
            _this8.readReportHandler.setMessageRead(options).then(resolve)["catch"](reject);
          });
        });
        return result;
      }
      /**
       * 获取会话的消息列表
       * @param {Object} options - 参数对象
       * @returns {object}
       * @memberof MessageController
       */

    }, {
      key: "getMessageList",
      value: function getMessageList(options) {
        return this.getMessageHandler.getMessageList(options);
      }
      /**
       * 创建文本消息，此函数返回一个消息实例，可以使用SDK.sendMessage()方法发送
       * @param {Object} options - 配置参数
       * @param {String} options.to - 消息接收方
       * @param {String} options.conversationType - 会话类型
       * @param {String} options.payload.text - 消息内容
       * @returns {Message}
       */

    }, {
      key: "createTextMessage",
      value: function createTextMessage(options) {
        options.currentUser = this.tim.context.identifier; // 发消息时，需要传入currentUser参数

        var message = new Message(options);
        var text = typeof options.payload === 'string' ? options.payload : options.payload.text;
        var element = new TextElement({
          text: text
        });
        message.setElement(element);
        return message;
      }
      /**
       * 创建自定义消息，此函数返回一个消息实例，可以使用SDK.sendMessage()方法发送
       * @param {object} options - 参数对象
       * @param {string} options.to - 消息的接收方
       * @param {string} options.conversationType - 会话类型
       * @param {Object} options.payload  - 自定义消息的结构
       * @param {string} options.payload.data - 自定义消息的数据字段
       * @param {string} options.payload.description - 自定义消息的说明字段
       * @param {string} options.payload.extension - 自定义消息的扩展字段
       * @returns {Message}
       */

    }, {
      key: "createCustomMessage",
      value: function createCustomMessage(options) {
        options.currentUser = this.tim.context.identifier; // 发消息时，需要传入currentUser参数

        var message = new Message(options);
        var element = new CustomElement({
          data: options.payload.data,
          description: options.payload.description,
          extension: options.payload.extension
        });
        message.setElement(element);
        return message;
      }
      /**
       * 创建一条图片消息
       * @param {*} options - 参数配置
       * @param {string} options.to - 消息的接收方
       * @param {string} options.conversationType - 会话类型
       * @param {HTMLFileElement} options.payload.file - HTMLFileElement对象，用于接收文件数据
       * @param {Function} options.onProgress - 获取上传进度的回调函数
       * @returns {Message}
       */

    }, {
      key: "createImageMessage",
      value: function createImageMessage(options) {
        options.currentUser = this.tim.context.identifier; // 发消息时，需要传入currentUser参数

        var message = new Message(options);

        if (IN_WX_MINI_APP) {
          var file = options.payload.file;

          if (isFile(file)) {
            logger.warn('微信小程序环境下调用 createImageMessage 接口时，payload.file 不支持传入 File 对象');
            return;
          }

          var selectedFilePath = file.tempFilePaths[0];
          var _file = {
            url: selectedFilePath,
            name: selectedFilePath.slice(selectedFilePath.lastIndexOf('/') + 1),
            size: file.tempFiles[0].size,
            type: selectedFilePath.slice(selectedFilePath.lastIndexOf('.') + 1).toLowerCase()
          };
          options.payload.file = _file;
        } else if (IN_BROWSER) {
          // 当 options.payload.file 的类型是 HTMLInputElement 或者 DataTransfer 时，SDK 实际上用的是其 files 属性，并只取第一个元素，即 files[0]
          // 所以 SDK 也支持直接传入 File 对象
          // 下面的代码是为了兼容已有的数据结构，减少改动
          if (isFile(options.payload.file)) {
            var tmpFile = options.payload.file;
            options.payload.file = {
              files: [tmpFile]
            };
          }
        }

        var element = new ImageElement({
          imageFormat: 'UNKNOWN',
          uuid: this._generateUUID(),
          file: options.payload.file
        });
        message.setElement(element);
        this.messageOptionMap.set(message.messageID, options);
        return message;
      }
      /**
       * 创建一条文件消息，请注意：因为微信小程序不支持选择文件的功能，所以接口在微信小程序环境不可用。
       * @param {*} options - 参数参数
       * @param {string} options.to - 消息的接收方
       * @param {string} options.conversationType - 会话类型
       * @param {HTMLFileElement} options.payload.file - HTMLFileElement对象，用于接收文件数据
       * @param {Function} options.onProgress - 获取上传进度的回调函数
       * @returns {Message}
       */

    }, {
      key: "createFileMessage",
      value: function createFileMessage(options) {
        if (IN_WX_MINI_APP) {
          logger.warn('微信小程序目前不支持选择文件， createFileMessage 接口不可用！');
          return;
        }

        if (IN_BROWSER) {
          // 当 options.payload.file 的类型是 HTMLInputElement 或者 DataTransfer 时，SDK 实际上用的是其 files 属性，并只取第一个元素，即 files[0]
          // 所以 SDK 也支持直接传入 File 对象
          // 下面的代码是为了兼容已有的数据结构，减少改动
          if (isFile(options.payload.file)) {
            var tmpFile = options.payload.file;
            options.payload.file = {
              files: [tmpFile]
            };
          }
        }

        options.currentUser = this.tim.context.identifier; // 发消息时，需要传入currentUser参数

        var message = new Message(options);
        var element = new FileElement({
          uuid: this._generateUUID(),
          file: options.payload.file
        });
        message.setElement(element);
        this.messageOptionMap.set(message.messageID, options);
        return message;
      }
      /**
       * 创建一条音频消息，请注意：因为 Web 端目前没有提供录音接口，所以暂时不能支持。
       * @param {*} options - 参数参数
       * @param {string} options.to - 消息的接收方
       * @param {string} options.conversationType - 会话类型
       * @param {Function} options.onProgress - 获取上传进度的回调函数
       * @returns {Message}
       */

    }, {
      key: "createAudioMessage",
      value: function createAudioMessage(options) {
        if (!IN_WX_MINI_APP) {
          var tips = 'createAudioMessage 目前只支持微信小程序发语音消息';
          logger.warn(tips);
          return;
        }

        var file = options.payload.file;

        if (IN_WX_MINI_APP) {
          var _file = {
            url: file.tempFilePath,
            name: file.tempFilePath.slice(file.tempFilePath.lastIndexOf('/') + 1),
            size: file.fileSize,
            second: parseInt(file.duration) / 1000,
            type: file.tempFilePath.slice(file.tempFilePath.lastIndexOf('.') + 1).toLowerCase()
          };
          options.payload.file = _file;
        }

        options.currentUser = this.tim.context.identifier; // 发消息时，需要传入currentUser参数

        var message = new Message(options);
        var element = new AudioElement({
          second: Math.floor(file.duration / 1000),
          size: file.fileSize,
          url: file.tempFilePath,
          uuid: this._generateUUID()
        });
        message.setElement(element);
        this.messageOptionMap.set(message.messageID, options);
        return message;
      }
      /**
       * 创建一条视频消息
       * @param {*} options - 参数参数
       * @param {string} options.to - 消息的接收方
       * @param {string} options.conversationType - 会话类型
       * @param {Function} options.onProgress - 获取上传进度的回调函数
       * @returns {Message}
       */

    }, {
      key: "createVideoMessage",
      value: function createVideoMessage(options) {
        options.currentUser = this.tim.context.identifier; // 发消息时，需要传入currentUser参数

        options.payload.file.thumbUrl = 'https://webim-1252463788.cos.ap-shanghai.myqcloud.com/assets/images/transparent.png';
        options.payload.file.thumbSize = 1668;
        var _videoFile = {};

        if (IN_WX_MINI_APP) {
          if (isFile(options.payload.file)) {
            logger.warn('微信小程序环境下调用 createVideoMessage 接口时，payload.file 不支持传入 File 对象');
            return;
          }

          var file = options.payload.file;
          _videoFile.url = file.tempFilePath;
          _videoFile.name = file.tempFilePath.slice(file.tempFilePath.lastIndexOf('/') + 1);
          _videoFile.size = file.size;
          _videoFile.second = file.duration;
          _videoFile.type = file.tempFilePath.slice(file.tempFilePath.lastIndexOf('.') + 1).toLowerCase();
        } else if (IN_BROWSER) {
          if (isFile(options.payload.file)) {
            var tmpFile = options.payload.file;
            options.payload.file.files = [tmpFile];
          }

          var _file2 = options.payload.file;
          _videoFile.url = window.URL.createObjectURL(_file2.files[0]);
          _videoFile.name = _file2.files[0].name;
          _videoFile.size = _file2.files[0].size;
          _videoFile.second = _file2.files[0].duration || 0;
          _videoFile.type = _file2.files[0].type.split('/')[1];
        }

        options.payload.file.videoFile = _videoFile;
        var message = new Message(options);
        var element = new VideoElement({
          videoFormat: _videoFile.type,
          videoSecond: Number(_videoFile.second.toFixed(0)),
          videoSize: _videoFile.size,
          remoteVideoUrl: '',
          videoUrl: _videoFile.url,
          videoUUID: this._generateUUID(),
          thumbUUID: this._generateUUID(),
          thumbWidth: options.payload.file.width || 200,
          thumbHeight: options.payload.file.height || 200,
          thumbUrl: options.payload.file.thumbUrl,
          thumbSize: options.payload.file.thumbSize,
          thumbFormat: options.payload.file.thumbUrl.slice(options.payload.file.thumbUrl.lastIndexOf('.') + 1).toLowerCase()
        });
        message.setElement(element);
        this.messageOptionMap.set(message.messageID, options);
        return message;
      }
      /**
       * 创建一条表情消息
       * @param {*} options - 参数配置
       * @returns {Message}
       */

    }, {
      key: "createFaceMessage",
      value: function createFaceMessage(options) {
        options.currentUser = this.tim.context.identifier; // 发消息时，需要传入currentUser参数

        var message = new Message(options);
        var element = new FaceElement(options.payload);
        message.setElement(element);
        return message;
      }
      /**
       * 生成uuid
       * 规则：SDKAppID-identifier-随机字符串
       * 使用场景：为了和终端互通，所有需要上传和下载的消息，如图片、语音、视频、文件，都需要带上uuid
       * @returns {String}
       */

    }, {
      key: "_generateUUID",
      value: function _generateUUID() {
        var context = this.tim.context;
        return "".concat(context.SDKAppID, "-").concat(context.identifier, "-").concat(randomString());
      }
      /**
       * 生成天机阁id，全链路排障用。对于同一个消息实例，调用此接口返回的值始终相同。
       * @param {Message} message 消息实例
       * @returns {String} tinyid-random
       */

    }, {
      key: "_generateTjgID",
      value: function _generateTjgID(message) {
        return this.tim.context.tinyID + '-' + message.random;
      }
      /**
       * 获取messageController下的optionMap
       * @param {*} messageID 消息 ID
       * @returns {object} messageID 对应的 option
       */

    }, {
      key: "getMessageOptionByID",
      value: function getMessageOptionByID(messageID) {
        return this.messageOptionMap.get(messageID);
      }
    }]);

    return MessageController;
  }(IMController);

  /**
   * @class GroupMember
   * @description 群成员对象，用于描述群成员具有的属性，如 ID、昵称、群内身份、入群时间等。
   * @property {String} userID 群成员 ID
   * @property {String} avatar 群成员头像 URL
   * @property {String} nick 群成员昵称
   * @property {String} role 群内身份<br/>
   * - TIM.TYPES.GRP_MBR_ROLE_OWNER（群主）
   * - TIM.TYPES.GRP_MBR_ROLE_ADMIN（群管理员）
   * - TIM.TYPES.GRP_MBR_ROLE_MEMBER（群普通成员）
   * @property {Number} joinTime 入群时间
   * @property {String} nameCard 群名片
   * @property {Number} muteUntil 禁言截止时间戳，单位: 秒<br/>
   * - 禁言状态：muteUntil 大于当前时间
   * - 未禁言状态：muteUntil 小于或等于当前时间
   * @property {Object[]} memberCustomField 群成员自定义字段
   * @property {String} memberCustomField.key 群成员自定义字段的 Key
   * @property {String} memberCustomField.value 群成员自定义字段的 Value
   */

  var GroupMember =
  /*#__PURE__*/
  function () {
    function GroupMember(options) {
      _classCallCheck(this, GroupMember);

      this.userID = '';
      this.avatar = '';
      this.nick = '';
      this.role = '';
      this.joinTime = '';
      this.lastSendMsgTime = '';
      this.nameCard = '';
      this.muteUntil = 0;
      this.memberCustomField = [];

      this._initMember(options);
    }
    /**
     * @private
     */


    _createClass(GroupMember, [{
      key: "_initMember",
      value: function _initMember(options) {
        this.updateMember(options);
      }
      /**
       * @private
       */

    }, {
      key: "updateMember",
      value: function updateMember(member) {
        var valuesIgnore = [null, undefined, '', 0, NaN];

        if (member.memberCustomField) {
          updateCustomField(this.memberCustomField, member.memberCustomField);
        }

        deepMerge(this, member, ['memberCustomField'], valuesIgnore);
      }
      /**
       * @private
       * @param {String} role
       */

    }, {
      key: "updateRole",
      value: function updateRole(role) {
        if (['Owner', 'Admin', 'Member'].indexOf(role) < 0) {
          return;
        }

        this.role = role;
      }
      /**
       * 更新群成员禁言时间
       * @private
       * @param {Number} muteTime 禁言时长，单位：秒
       */

    }, {
      key: "updateMuteUntil",
      value: function updateMuteUntil(muteTime) {
        if (isUndefined(muteTime)) {
          return;
        }

        this.muteUntil = Math.floor((Date.now() + muteTime * 1000) / 1000);
      }
      /**
       * @private
       * @param {String} nameCard 群名片
       * @memberof GroupMember
       */

    }, {
      key: "updateNameCard",
      value: function updateNameCard(nameCard) {
        if (isUndefined(nameCard)) {
          return;
        }

        this.nameCard = nameCard;
      }
      /**
       * 更新群成员自定义字段
       * @private
       * @param {Obejct[]} memberCustomField
       */

    }, {
      key: "updateMemberCustomField",
      value: function updateMemberCustomField(memberCustomField) {
        if (memberCustomField) {
          updateCustomField(this.memberCustomField, memberCustomField);
        }
      }
    }]);

    return GroupMember;
  }();

  var GroupTipsHandler =
  /*#__PURE__*/
  function () {
    function GroupTipsHandler(options) {
      _classCallCheck(this, GroupTipsHandler);

      this.tim = options.tim;
      this.groupController = options.groupController;

      this._initListeners();
    }

    _createClass(GroupTipsHandler, [{
      key: "_initListeners",
      value: function _initListeners() {
        this.tim.innerEmitter.on(TIM_INNER_EVENT.MESSAGE_GROUP_INSTANT_RECEIVED, this._onReceivedGroupTips, this);
      }
      /**
       * 收到 Event 4 的群提示消息
       * @param {Object} event
       */

    }, {
      key: "_onReceivedGroupTips",
      value: function _onReceivedGroupTips(_ref) {
        var _this = this;

        var _ref$data = _ref.data,
            groupTips = _ref$data.result,
            isGroupTip = _ref$data.isGroupTip;

        if (!isGroupTip) {
          return;
        }

        groupTips.forEach(function (groupTip) {
          switch (groupTip.payload.operationType) {
            // 有新成员进群
            case 1:
              _this._onNewMemberComeIn(groupTip);

              break;
            // 有成员退出群

            case 2:
              _this._onMemberQuit(groupTip);

              break;
            // 有成员被踢出群

            case 3:
              _this._onMemberKickedOut(groupTip);

              break;
            // 有成员被设置成管理员

            case 4:
              _this._onMemberSetAdmin(groupTip);

              break;
            // 有成员被取消管理员

            case 5:
              _this._onMemberCancelledAdmin(groupTip);

              break;
            // 群资料变更

            case 6:
              _this._onGroupProfileModified(groupTip);

              break;
            // 群成员资料变更

            case 7:
              _this._onMemberInfoModified(groupTip);

              break;

            default:
              logger.warn('GroupTipsHandler._onReceivedGroupTips Unhandled groupTips. operationType=', groupTip.payload.operationType);
              break;
          }
        });
      }
      /**
       * 有新成员进群
       * @param {Object} groupTip
       */

    }, {
      key: "_onNewMemberComeIn",
      value: function _onNewMemberComeIn(groupTip) {
        var _groupTip$payload = groupTip.payload,
            memberNum = _groupTip$payload.memberNum,
            groupID = _groupTip$payload.groupProfile.groupID;
        var group = this.groupController.getLocalGroupProfile(groupID);

        if (group && isNumber(memberNum)) {
          group.memberNum = memberNum;
        }
      }
      /**
       * 有成员退群
       * @param {Object} groupTip
       */

    }, {
      key: "_onMemberQuit",
      value: function _onMemberQuit(groupTip) {
        var _groupTip$payload2 = groupTip.payload,
            memberNum = _groupTip$payload2.memberNum,
            groupID = _groupTip$payload2.groupProfile.groupID;
        var group = this.groupController.getLocalGroupProfile(groupID);

        if (group && isNumber(memberNum)) {
          group.memberNum = memberNum;
        }

        this.groupController.deleteLocalGroupMembers(groupID, groupTip.payload.userIDList);
      }
      /**
       * 有群成员被踢出群
       * @param {Object} groupTip
       */

    }, {
      key: "_onMemberKickedOut",
      value: function _onMemberKickedOut(groupTip) {
        var _groupTip$payload3 = groupTip.payload,
            memberNum = _groupTip$payload3.memberNum,
            groupID = _groupTip$payload3.groupProfile.groupID;
        var group = this.groupController.getLocalGroupProfile(groupID);

        if (group && isNumber(memberNum)) {
          group.memberNum = memberNum;
        }

        this.groupController.deleteLocalGroupMembers(groupID, groupTip.payload.userIDList);
      }
      /**
       * 有群成员被设为管理员
       * @param {Object} groupTip
       */

    }, {
      key: "_onMemberSetAdmin",
      value: function _onMemberSetAdmin(groupTip) {
        var _this2 = this;

        var groupID = groupTip.payload.groupProfile.groupID;
        var userIDList = groupTip.payload.userIDList;
        userIDList.forEach(function (userID) {
          var member = _this2.groupController.getLocalGroupMemberInfo(groupID, userID);

          if (member) {
            member.updateRole(TYPES.GRP_MBR_ROLE_ADMIN);
          }
        });
      }
      /**
       * 有成员被取消管理员
       * @param {Object} groupTip
       */

    }, {
      key: "_onMemberCancelledAdmin",
      value: function _onMemberCancelledAdmin(groupTip) {
        var _this3 = this;

        var groupID = groupTip.payload.groupProfile.groupID;
        var userIDList = groupTip.payload.userIDList;
        userIDList.forEach(function (userID) {
          var member = _this3.groupController.getLocalGroupMemberInfo(groupID, userID);

          if (member) {
            member.updateRole(TYPES.GRP_MBR_ROLE_MEMBER);
          }
        });
      }
      /**
       * 群资料变更
       * 参考：_doc/逻辑梳理/群组逻辑/群资料变更下发.png
       * @param {Object} groupTip
       */

    }, {
      key: "_onGroupProfileModified",
      value: function _onGroupProfileModified(groupTip) {
        var _this4 = this;

        var newInfo = groupTip.payload.newGroupProfile;
        var groupID = groupTip.payload.groupProfile.groupID;
        var group = this.groupController.getLocalGroupProfile(groupID);
        Object.keys(newInfo).forEach(function (key) {
          switch (key) {
            case 'ownerID':
              _this4._ownerChaged(group, newInfo);

              break;

            default:
              group[key] = newInfo[key];
          }
        });
        this.groupController.emitGroupListUpdate(true, true);
      }
      /**
       * 群主变更
       * @param {*} groupTip
       * @param {*} newInfo
       * @memberof GroupTipsHandler
       */

    }, {
      key: "_ownerChaged",
      value: function _ownerChaged(_ref2, newInfo) {
        var groupID = _ref2.groupID;
        var group = this.groupController.getLocalGroupProfile(groupID);
        var selfID = this.tim.context.identifier; // 若新的群主是自己，则更新自己的身份

        if (selfID === newInfo.ownerID) {
          group.updateGroup({
            selfInfo: {
              role: TYPES.GRP_MBR_ROLE_OWNER
            }
          });
          var self = this.groupController.getLocalGroupMemberInfo(groupID, selfID);
          var oldOwenrID = this.groupController.getLocalGroupProfile(groupID).ownerID;
          var oldOwenr = this.groupController.getLocalGroupMemberInfo(groupID, oldOwenrID);

          if (self) {
            self.updateRole(TYPES.GRP_MBR_ROLE_OWNER);
          }

          if (oldOwenr) {
            oldOwenr.updateRole(TYPES.GRP_MBR_ROLE_MEMBER);
          }
        }
      }
      /**
       * 群成员资料变更
       * 参考：_doc/逻辑梳理/群组逻辑/群成员资料变更下发.png
       * @param {Object} groupTip
       */

    }, {
      key: "_onMemberInfoModified",
      value: function _onMemberInfoModified(groupTip) {
        var _this5 = this;

        var groupID = groupTip.payload.groupProfile.groupID;
        groupTip.payload.memberList.forEach(function (item) {
          var member = _this5.groupController.getLocalGroupMemberInfo(groupID, item.userID);

          if (member && item.muteTime) {
            // 目前只有修改 禁言时间才会下发 event4 opType 8
            member.updateMuteUntil(item.muteTime);
          }
        });
      }
    }]);

    return GroupTipsHandler;
  }();

  var GroupSystemNoticeHandler =
  /*#__PURE__*/
  function () {
    function GroupSystemNoticeHandler(options) {
      _classCallCheck(this, GroupSystemNoticeHandler);

      this.groupController = options.groupController;
      this.tim = options.tim;
      this.pendencyMap = new Map(); // Map<key(from_groupID_to), Object>

      this._initLiceners();
    }

    _createClass(GroupSystemNoticeHandler, [{
      key: "_initLiceners",
      value: function _initLiceners() {
        this.tim.innerEmitter.on(TIM_INNER_EVENT.MESSAGE_GROUP_SYSTEM_NOTICE_RECEIVED, this._onReceivedGroupSystemNotice, this); // 同步完消息后触发

        this.tim.innerEmitter.on(TIM_INNER_EVENT.SYNC_MESSAGE_C2C_FINISHED, this._clearGroupSystemNotice, this);
      }
      /**
       * 拉取 pendency 列表，将系统通知会话中已经处理过的【申请加群】删除
       * @memberof GroupSystemNoticeHandler
       */

    }, {
      key: "_clearGroupSystemNotice",
      value: function _clearGroupSystemNotice() {
        var _this = this;

        this.getPendencyList().then(function (result) {
          result.forEach(function (item) {
            _this.pendencyMap.set("".concat(item.from, "_").concat(item.groupID, "_").concat(item.to), item);
          }); // 拿到系统会话的消息列表

          var messageList = _this.tim.messageController.getLocalMessageList(TYPES.CONV_SYSTEM); // 待删除的系统通知列表


          var messageListToDelete = [];
          messageList.forEach(function (message) {
            var _message$payload = message.payload,
                operatorID = _message$payload.operatorID,
                operationType = _message$payload.operationType,
                groupProfile = _message$payload.groupProfile; // 找出申请加群的群系统通知

            if (operationType === GROUP_SYSTEM_NOTICE_TYPES.JOIN_GROUP_REQUEST) {
              var key = "".concat(operatorID, "_").concat(groupProfile.groupID, "_").concat(groupProfile.to);

              var pendency = _this.pendencyMap.get(key); // 若申请已经被处理过，则要删除掉相应的系统通知。


              if (pendency && isNumber(pendency.handled) && pendency.handled !== 0) {
                messageListToDelete.push(message);
              }
            }
          }); // 发请求删除（同时会清理本地的）已被处理过的【申请加群】通知

          _this.groupController.deleteGroupSystemNotice({
            messageList: messageListToDelete
          });
        });
      }
      /**
       * 获取当前用户下所有的【申请加群请求】列表，支持自动续拉。
       * 后端最多存50条，7天
       * @param {Object} options 请求参数
       * @param {Number} [options.startTime=0] 开始时间，第一次拉取传0
       * @param {Number} [options.limit=10] 一页拉取的个数，一次请求最多拉10条
       * @returns {Promise}
       * @memberof GroupSystemNoticeHandler
       */

    }, {
      key: "getPendencyList",
      value: function getPendencyList(options) {
        var _this2 = this;

        return this.groupController.request({
          name: 'group',
          action: 'getGroupPendency',
          param: {
            startTime: options && options.startTime ? options.startTime : 0,
            limit: options && options.limit ? options.limit : 10,
            handleAccount: this.tim.context.identifier
          }
        }).then(function (_ref) {
          var data = _ref.data;
          var result = data.pendencyList;

          if (data.nextStartTime !== 0) {
            // 自动续拉，拉完为止
            return _this2.getPendencyList({
              startTime: data.nextStartTime
            }).then(function (response) {
              return [].concat(_toConsumableArray(result), _toConsumableArray(response));
            });
          }

          return result;
        });
      }
      /**
       * 收到群系统通知
       * @private
       * @param {Array} groupSystemNotices 收到的群系统通知
       */

    }, {
      key: "_onReceivedGroupSystemNotice",
      value: function _onReceivedGroupSystemNotice(_ref2) {
        var _this3 = this;

        var _ref2$data = _ref2.data,
            groupSystemNotices = _ref2$data.result,
            type = _ref2$data.type;

        if (type === 'sync') {
          return;
        }

        groupSystemNotices.forEach(function (groupSystemNotice) {
          var operationType = groupSystemNotice.payload.operationType;

          switch (operationType) {
            // 申请加群请求（只有管理员会收到）
            case 1:
              _this3._onApplyGroupRequest(groupSystemNotice);

              break;
            // 申请加群被同意（只有申请人能够收到）

            case 2:
              _this3._onApplyGroupRequestAgreed(groupSystemNotice);

              break;
            // 申请加群被拒绝（只有申请人能够收到）

            case 3:
              _this3._onApplyGroupRequestRefused(groupSystemNotice);

              break;
            // 被管理员踢出群(只有被踢者接收到)

            case 4:
              _this3._onMemberKicked(groupSystemNotice);

              break;
            // 群被解散(全员接收)

            case 5:
              _this3._onGroupDismissed(groupSystemNotice);

              break;
            // 创建群(创建者接收, 不展示)

            case 6:
              break;
            // 邀请加群(被邀请者接收)。对于被邀请者，表示被邀请进群。

            case 7:
              _this3._onInviteGroup(groupSystemNotice);

              break;
            // 主动退群(主动退出者接收, 不展示)

            case 8:
              _this3._onQuitGroup(groupSystemNotice);

              break;
            // 设置管理员(被设置者接收)

            case 9:
              _this3._onSetManager(groupSystemNotice);

              break;
            // 取消管理员(被取消者接收)

            case 10:
              _this3._onDeleteManager(groupSystemNotice);

              break;
            // 群已被回收(全员接收, 不展示)

            case 11:
              break;
            // TODO: 12邀请加群(被邀请者需同意)

            case 12:
              break;
            // 群消息已读同步

            case 15:
              // TODO: 15群消息已读同步
              break;
            // 用户自定义通知(默认全员接收)

            case 255:
              _this3.groupController.emitOuterEvent(TIM_OUTER_EVENT.GROUP_SYSTEM_NOTICE_RECEIVED, {
                message: groupSystemNotice,
                type: GROUP_SYSTEM_NOTICE_TYPES.CUSTOM
              });

              break;
          }
        });
      }
      /**
       * @private
       * @param {Object} groupSystemNotice 收到的群通知
       * 1 申请加群请求（只有管理员会收到）
       */

    }, {
      key: "_onApplyGroupRequest",
      value: function _onApplyGroupRequest(groupSystemNotice) {
        this.groupController.emitOuterEvent(TIM_OUTER_EVENT.GROUP_SYSTEM_NOTICE_RECEIVED, {
          message: groupSystemNotice,
          type: GROUP_SYSTEM_NOTICE_TYPES.JOIN_GROUP_REQUEST
        });
      }
      /**
       * @param {Object} groupSystemNotice 收到的群通知
       * 2 申请加群被同意（只有申请人能够收到）
       */

    }, {
      key: "_onApplyGroupRequestAgreed",
      value: function _onApplyGroupRequestAgreed(groupSystemNotice) {
        var _this4 = this;

        var groupID = groupSystemNotice.payload.groupProfile.groupID;
        var hasGroup = this.groupController.hasLocalGroup(groupID);

        if (!hasGroup) {
          // 若本地没有该群组，则获取群资料更新本地 groupMap
          this.groupController.getGroupProfile({
            groupID: groupID
          }).then(function (_ref3) {
            var group = _ref3.data.group;

            if (group) {
              _this4.groupController.updateGroupMap([group]);

              _this4.groupController.emitGroupListUpdate();
            }
          });
        }

        this.groupController.emitOuterEvent(TIM_OUTER_EVENT.GROUP_SYSTEM_NOTICE_RECEIVED, {
          message: groupSystemNotice,
          type: GROUP_SYSTEM_NOTICE_TYPES.JOIN_GROUP_ACCEPT
        });
      }
      /**
       * @param {Object} groupSystemNotice 收到的群通知
       * 3 申请加群被拒绝（只有申请人能够收到）
       */

    }, {
      key: "_onApplyGroupRequestRefused",
      value: function _onApplyGroupRequestRefused(groupSystemNotice) {
        this.groupController.emitOuterEvent(TIM_OUTER_EVENT.GROUP_SYSTEM_NOTICE_RECEIVED, {
          message: groupSystemNotice,
          type: GROUP_SYSTEM_NOTICE_TYPES.JOIN_GROUP_REFUSE
        });
      }
      /**
       * @param {Object} groupSystemNotice 收到的群通知
       * 4 群成员被踢出群(只有被踢者接收到)
       */

    }, {
      key: "_onMemberKicked",
      value: function _onMemberKicked(groupSystemNotice) {
        var groupID = groupSystemNotice.payload.groupProfile.groupID;
        var hasGroup = this.groupController.hasLocalGroup(groupID);

        if (hasGroup) {
          this.groupController.deleteLocalGroupAndConversation(groupID);
        }

        this.groupController.emitOuterEvent(TIM_OUTER_EVENT.GROUP_SYSTEM_NOTICE_RECEIVED, {
          message: groupSystemNotice,
          type: GROUP_SYSTEM_NOTICE_TYPES.KICKED_OUT
        });
      }
      /**
       * @param {Object} groupSystemNotice 收到的群通知
       * 5 群被解散(全员接收)
       */

    }, {
      key: "_onGroupDismissed",
      value: function _onGroupDismissed(groupSystemNotice) {
        var groupID = groupSystemNotice.payload.groupProfile.groupID;
        var hasGroup = this.groupController.hasLocalGroup(groupID);
        var AVChatRoomHandler = this.groupController.AVChatRoomHandler;

        if (hasGroup) {
          this.groupController.deleteLocalGroupAndConversation(groupID);
        } // 若是当前加入的 AVChatRoom 被解散，则需要清理数据并停掉轮询


        if (AVChatRoomHandler.checkJoinedAVChatRoomByID(groupID)) {
          AVChatRoomHandler.reset();
        }

        this.groupController.emitOuterEvent(TIM_OUTER_EVENT.GROUP_SYSTEM_NOTICE_RECEIVED, {
          message: groupSystemNotice,
          type: GROUP_SYSTEM_NOTICE_TYPES.GROUP_DISMISSED
        });
      }
      /**
       * @param {Object} groupSystemNotice 收到的群通知
       * 7 邀请加群(被邀请者接收)。对于被邀请者，表示被邀请进群。
       */

    }, {
      key: "_onInviteGroup",
      value: function _onInviteGroup(groupSystemNotice) {
        var _this5 = this;

        var groupID = groupSystemNotice.payload.groupProfile.groupID;
        var hasGroup = this.groupController.hasLocalGroup(groupID);

        if (!hasGroup) {
          // 若本地没有该群组，则获取群资料更新本地 groupMap
          this.groupController.getGroupProfile({
            groupID: groupID
          }).then(function (_ref4) {
            var group = _ref4.data.group;

            if (group) {
              _this5.groupController.updateGroupMap([group]);

              _this5.groupController.emitGroupListUpdate();
            }
          });
        }

        this.groupController.emitOuterEvent(TIM_OUTER_EVENT.GROUP_SYSTEM_NOTICE_RECEIVED, {
          message: groupSystemNotice,
          type: GROUP_SYSTEM_NOTICE_TYPES.INVITED_JOIN_GROUP_REQUEST
        });
      }
      /**
       * @param {Object} groupSystemNotice 收到的群通知
       * 8 主动退群(主动退出者接收, 不展示)
       */

    }, {
      key: "_onQuitGroup",
      value: function _onQuitGroup(groupSystemNotice) {
        var groupID = groupSystemNotice.payload.groupProfile.groupID;
        var hasGroup = this.groupController.hasLocalGroup(groupID);

        if (hasGroup) {
          this.groupController.deleteLocalGroupAndConversation(groupID);
        }

        this.groupController.emitOuterEvent(TIM_OUTER_EVENT.GROUP_SYSTEM_NOTICE_RECEIVED, {
          message: groupSystemNotice,
          type: GROUP_SYSTEM_NOTICE_TYPES.QUIT
        });
      }
      /**
       * @param {Object} groupSystemNotice 收到的群通知
       * 9 设置管理员(被设置者接收)
       */

    }, {
      key: "_onSetManager",
      value: function _onSetManager(groupSystemNotice) {
        var _groupSystemNotice$pa = groupSystemNotice.payload.groupProfile,
            userID = _groupSystemNotice$pa.to,
            groupID = _groupSystemNotice$pa.groupID;
        var member = this.groupController.getLocalGroupMemberInfo(groupID, userID);

        if (member) {
          member.updateRole(TYPES.GRP_MBR_ROLE_ADMIN);
        }

        this.groupController.emitOuterEvent(TIM_OUTER_EVENT.GROUP_SYSTEM_NOTICE_RECEIVED, {
          message: groupSystemNotice,
          type: GROUP_SYSTEM_NOTICE_TYPES.SET_ADMIN
        });
      }
      /**
       * @param {Object} groupSystemNotice 收到的群通知
       * 10 移除管理员(被设置者接收)
       */

    }, {
      key: "_onDeleteManager",
      value: function _onDeleteManager(groupSystemNotice) {
        var _groupSystemNotice$pa2 = groupSystemNotice.payload.groupProfile,
            userID = _groupSystemNotice$pa2.to,
            groupID = _groupSystemNotice$pa2.groupID;
        var member = this.groupController.getLocalGroupMemberInfo(groupID, userID);

        if (member) {
          member.updateRole(TYPES.GRP_MBR_ROLE_MEMBER);
        }

        this.groupController.emitOuterEvent(TIM_OUTER_EVENT.GROUP_SYSTEM_NOTICE_RECEIVED, {
          message: groupSystemNotice,
          type: GROUP_SYSTEM_NOTICE_TYPES.CANCELED_ADMIN
        });
      }
    }, {
      key: "reset",
      value: function reset() {
        this.pendencyMap.clear();
      }
    }]);

    return GroupSystemNoticeHandler;
  }();

  var validEventCode = {
    3: true,
    // 普通群消息
    4: true,
    // 群提示消息，入漫游
    5: true,
    // 群系统通知
    6: true // 群提示消息，不入漫游

  };
  /**
   * AVChatRoom 轮询逻辑
   * @author rychouwei
   */

  var AVChatRoomHandler =
  /*#__PURE__*/
  function () {
    function AVChatRoomHandler(_ref) {
      var tim = _ref.tim,
          groupController = _ref.groupController;

      _classCallCheck(this, AVChatRoomHandler);

      this.tim = tim;
      this.groupController = groupController;
      this.AVChatRoomLoop = null;
      this.key = ''; // AVChatRoom 长轮询的 Key

      this.startSeq = 0; // AVChatRoom 拉消息的起始位置，默认为 0，表示第一次轮询只拉进房前最新一条消息

      this.group = {}; // 当前加入的 group 资料
    }
    /**
     * 判断是否已经加入了 AVChatRoom （是否有 AVChatRoom 的轮询在跑）
     * @returns {Boolean}
     * @memberof AVChatRoomHandler
     */


    _createClass(AVChatRoomHandler, [{
      key: "hasJoinedAVChatRoom",
      value: function hasJoinedAVChatRoom() {
        if (this.group && !isUndefined(this.group.groupID)) {
          return true;
        }

        return false;
      }
      /**
       * 判断某群是否是已加入的 AVChatRoom
       * @param {String} groupID 群ID
       * @returns {Boolean}
       * @memberof AVChatRoomHandler
       */

    }, {
      key: "checkJoinedAVChatRoomByID",
      value: function checkJoinedAVChatRoomByID(groupID) {
        if (this.group || !isUndefined(this.group.groupID)) {
          return groupID === this.group.groupID;
        }

        return false;
      }
      /**
       * 获取已加入的 AVChatRoom
       * @returns {Group|null}
       * @memberof AVChatRoomHandler
       */

    }, {
      key: "getJoinedAVChatRoom",
      value: function getJoinedAVChatRoom() {
        if (this.hasJoinedAVChatRoom()) {
          return this.group;
        }

        return null;
      }
      /**
       * 更新 Loop 的请求参数
       * @param {Object} options 请求参数
       * @param {String} options.key AVChatRoom 的 Key
       * @param {Number} options.startSeq AVChatRoom 的 startSeq
       * @memberof AVChatRoomHandler
       */

    }, {
      key: "_updateProperties",
      value: function _updateProperties(options) {
        var _this = this;

        Object.keys(options).forEach(function (key) {
          _this[key] = options[key];
        });
      }
      /**
       * 启动 AVChatRoom 的长轮询
       */

    }, {
      key: "start",
      value: function start() {
        var options = {
          key: this.key,
          startSeq: this.startSeq
        };

        if (this.AVChatRoomLoop !== null) {
          if (!this.AVChatRoomLoop.isRunning()) {
            this.AVChatRoomLoop.start();
          }

          return;
        }

        var pack = this.groupController.createTransportCapsule({
          name: 'AVChatRoom',
          action: 'startLongPoll',
          param: options
        });
        this.AVChatRoomLoop = this.tim.connectionController.createRunLoop({
          pack: pack,
          before: this._updateRequestData.bind(this),
          success: this._handleSuccess.bind(this),
          fail: this._handleFailure.bind(this),
          isAVChatRoomLoop: true // 标识是avchatroom的长轮询，和普通的长轮询超时时间不同，前者6000ms，后者30000ms

        });
        this.AVChatRoomLoop.start();
        logger.log('AVChatRoomHandler.start message channel started');
      }
      /**
       * 关掉 AVChatRoom 的轮询，但不销毁实例
       */

    }, {
      key: "stop",
      value: function stop() {
        if (this.AVChatRoomLoop !== null && this.AVChatRoomLoop.isRunning()) {
          this.AVChatRoomLoop.abort();
          this.AVChatRoomLoop.stop();
          logger.log('AVChatRoomHandler.stop message channel stopped');
        }
      }
      /**
       * 启动轮询
       * @param {Object} options 请求参数
       * @param {Object} options.longPollingKey 用于启动轮询的 key
       * @param {Group} options.group 群组资料
       * @returns {Promise}
       * @memberof AVChatRoomHandler
       */

    }, {
      key: "startRunLoop",
      value: function startRunLoop(options) {
        var _this2 = this;

        return this._precheck().then(function () {
          var longPollingKey = options.longPollingKey,
              group = options.group;

          _this2._updateProperties({
            key: longPollingKey,
            startSeq: 0,
            group: group || {}
          }); // 更新本地 groupMap


          _this2.groupController.updateGroupMap([group]); // 抛事件


          _this2.groupController.emitGroupListUpdate(true, false); // 启动轮询


          _this2.start();

          if (_this2.groupController.isLoggedIn()) {
            return IMPromise.resolve({
              status: JOIN_GROUP_STATUS.SUCCESS,
              group: group
            });
          }

          return IMPromise.resolve({
            status: JOIN_GROUP_STATUS.SUCCESS
          });
        });
      }
      /**
       * 不带登录状态加群
       * @private
       * @param {Object} options 请求参数
       * @returns {Promise}
       */

    }, {
      key: "joinWithoutAuth",
      value: function joinWithoutAuth(options) {
        var _this3 = this;

        return this.groupController.request({
          name: 'group',
          action: 'applyJoinAVChatRoom',
          param: options
        }).then(function (_ref2) {
          var longPollingKey = _ref2.data.longPollingKey;

          // longPollingKey 用于启动 AVChatRoom 轮询
          // 若回包没有 longPollingKey 则说明匿名加群的类型不是 AVChatRoom
          if (isUndefined(longPollingKey)) {
            return IMPromise.reject(new IMError({
              code: ERROR_CODE.CANNOT_JOIN_NON_AVCHATROOM_WITHOUT_LOGIN,
              message: ERROR_MESSAGE.CANNOT_JOIN_NON_AVCHATROOM_WITHOUT_LOGIN
            }));
          }

          logger.log('AVChatRoomHandler.joinWithoutAuth ok. groupID:', options.groupID); // 匿名加avchatroom不会触发sdk ready，但应该算一次pv和dau

          _this3.groupController.emitInnerEvent(TIM_INNER_EVENT.AVCHATROOM_JOIN_SUCCESS_NO_AUTH);

          _this3.groupController.emitInnerEvent(TIM_INNER_EVENT.AVCHATROOM_JOIN_SUCCESS, options.groupID);

          var group = new Group({
            groupID: options.groupID
          });

          _this3.startRunLoop({
            group: group,
            longPollingKey: longPollingKey
          }); // 匿名加群拿不到群资料，故这里不返回群资料


          return new IMResponse({
            status: JOIN_GROUP_STATUS.SUCCESS
          });
        })["catch"](function (error) {
          logger.error("AVChatRoomHandler.joinWithoutAuth error:".concat(error.message, ". groupID:").concat(options.groupID));
          return IMPromise.reject(error);
        });
      }
      /**
       * 加 AVChatRoom 前的预检，确保同时只能进一个 AVChatRoom。
       * @returns {Promise}
       */

    }, {
      key: "_precheck",
      value: function _precheck() {
        // 未加入AVChatRoom，直接返回即可
        if (!this.hasJoinedAVChatRoom()) {
          return Promise.resolve();
        } // 登录状态加群


        if (this.groupController.isLoggedIn()) {
          var isOwner = this.group.selfInfo.role === TYPES.GRP_MBR_ROLE_OWNER || this.group.ownerID === this.tim.loginInfo.identifier; // 对于群主，进其他 AVChatRoom 前，先清空本地的 AVChatRoom。因为群主不能退出 AVChatRoom

          if (isOwner) {
            this.groupController.deleteLocalGroupAndConversation(this.group.groupID);
          } else {
            // 对于普通群成员，进其他 AVChatRoom 前，先退出当前 AVChatRoom
            return this.groupController.quitGroup(this.group.groupID);
          }
        } else {
          // 匿名加群时，清理掉本地数据即可
          this.groupController.deleteLocalGroupAndConversation(this.group.groupID);
        }

        this.reset();
        return Promise.resolve();
      }
      /**
       * 一次轮询完成后 更新请求体中的 key 和 startSeq
       * @param {Object} requestData 请求参数
       */

    }, {
      key: "_updateRequestData",
      value: function _updateRequestData(requestData) {
        requestData.StartSeq = this.startSeq;
        requestData.Key = this.key; // summary stat

        this.tim.sumStatController.addTotalCount(label.LONG_POLLING_AV);
      }
      /**
       * 收到新的 AVChatRoom 消息
       * @param {Object} event 轮询的回包
       * @memberof AVChatRoomHandler
       */

    }, {
      key: "_handleSuccess",
      value: function _handleSuccess(event) {
        // summary stat
        this.tim.sumStatController.addSuccessCount(label.LONG_POLLING_AV);
        this.tim.sumStatController.addCost(label.LONG_POLLING_AV, event.data.timecost);
        this.startSeq = event.data.nextSeq;
        this.key = event.data.key;
        Array.isArray(event.data.rspMsgList) && event.data.rspMsgList.forEach(function (item) {
          item.to = item.groupID;
        });

        if (event.data.rspMsgList && event.data.rspMsgList.length > 0) {
          this._dispatchNotice(event.data.rspMsgList);
        }

        this.groupController.emitInnerEvent(TIM_INNER_EVENT.AV_LONGPOLL_RESPONSE_OK);
      }
    }, {
      key: "_handleFailure",
      value: function _handleFailure(event) {
        if (event.error) {
          // 远程主机拒绝网络连接，即请求超时
          if (event.error.code === 'ECONNABORTED' || // ajax timed out
          event.error.code === ERROR_CODE.NETWORK_TIMEOUT) {
            // wx.request timed out
            if (event.error.config) {
              var url = event.error.config.url;
              var data = event.error.config.data;
              logger.log("AVChatRoomHandler._handleFailure request timed out. url=".concat(url, " data=").concat(data));
            } else {
              logger.log("AVChatRoomHandler._handleFailure request timed out");
            }
          } else {
            logger.log("AVChatRoomHandler._handleFailure request failed due to network error");
          }
        }

        this.groupController.emitInnerEvent(TIM_INNER_EVENT.AV_LONGPOLL_REQUEST_FAILED);
      }
      /**
       * AVChatRoom 轮询消息分发
       * AVChatRoom 收到的消息不入库，发送的消息入库
       * @param {Object[]} messageOptionList 轮询下发的消息列表
       * @memberof AVChatRoomHandler
       */

    }, {
      key: "_dispatchNotice",
      value: function _dispatchNotice(messageOptionList) {
        if (!isArray(messageOptionList) || messageOptionList.length === 0) {
          return;
        }

        var tempMessage = null; // 要抛出给接入侧的消息列表

        var messageList = []; // 系统通知

        var groupSystemNoticeList = [];

        for (var i = 0; i < messageOptionList.length; i++) {
          if (!validEventCode[messageOptionList[i].event]) {
            logger.warn('AVChatRoomHandler._dispatchMessage 未处理的 event 类型：', messageOptionList[i].event);
            continue;
          }

          tempMessage = this.packMessage(messageOptionList[i], messageOptionList[i].event); // 若本地消息库已有该消息，则不抛出。该逻辑可实现多实例，同一账号的消息同步。

          if (!this.tim.messageController.hasLocalMessage(tempMessage.conversationID, tempMessage.ID)) {
            // 系统通知，通过 GROUP_SYSTEM_NOTICE_RECEIVED 事件抛出，也通过 MESSAGE_RECEIVED 抛出
            if (tempMessage.conversationType === TYPES.CONV_SYSTEM) {
              groupSystemNoticeList.push(tempMessage);
            }

            messageList.push(tempMessage);
          }
        } // AVChatRoom 的系统通知也是不入库的，所以这里不需要给 eventDataList 去更新系统通知会话


        if (groupSystemNoticeList.length > 0) {
          this.groupController.emitInnerEvent(TIM_INNER_EVENT.MESSAGE_GROUP_SYSTEM_NOTICE_RECEIVED, {
            result: groupSystemNoticeList,
            eventDataList: [],
            type: 'poll'
          });
        }

        if (messageList.length === 0) {
          return;
        } // 用于内部更新会话列表


        var conversationOptionList = this.packConversationOption(messageList);

        if (conversationOptionList.length > 0) {
          this.groupController.emitInnerEvent(TIM_INNER_EVENT.MESSAGE_GROUP_INSTANT_RECEIVED, {
            eventDataList: conversationOptionList,
            type: 'poll'
          });
        }

        logger.debug("AVChatRoomHandler._dispatchNotice nums=".concat(messageList.length));
        this.groupController.emitOuterEvent(TIM_OUTER_EVENT.MESSAGE_RECEIVED, messageList);
      }
      /**
       * 封装 Message
       * @param {Object} messageOption 后端返回消息体
       * @param {Number} eventCode 消息的 eventCode
       * @returns {Message}
       * @memberof AVChatRoomHandler
       */

    }, {
      key: "packMessage",
      value: function packMessage(messageOption, eventCode) {
        messageOption.currentUser = this.tim.context.identifier;
        messageOption.conversationType = eventCode === 5 ? TYPES.CONV_SYSTEM : TYPES.CONV_GROUP;
        messageOption.isSystemMessage = !!messageOption.isSystemMessage;
        var message = new Message(messageOption);
        var elements = this.packElements(messageOption, eventCode);
        message.setElement(elements);
        return message;
      }
      /**
       * 封装 elements
       * @param {Object} messageOption 后端返回消息体
       * @param {Number} eventCode 消息的 eventCode
       * @returns {Object[]}
       * @memberof AVChatRoomHandler
       */

    }, {
      key: "packElements",
      value: function packElements(messageOption, eventCode) {
        // 群提示消息
        // 修改群自定义字段 eventCode 是6；修改群标配字段 eventCode 是4；修改群标配字段+自定义字段 eventCode 是4；人员进群、退群 eventCode 是6
        if (eventCode === 4 || eventCode === 6) {
          return {
            type: TYPES.MSG_GRP_TIP,
            content: _objectSpread2({}, messageOption.elements, {
              groupProfile: messageOption.groupProfile
            })
          };
        } // 群系统通知


        if (eventCode === 5) {
          return {
            type: TYPES.MSG_GRP_SYS_NOTICE,
            content: _objectSpread2({}, messageOption.elements, {
              groupProfile: messageOption.groupProfile
            })
          };
        } // 普通群消息


        return this.tim.bigDataHallwayController.parseElements(messageOption.elements, messageOption.from);
      }
      /**
       * 封装 conversationOption（用于更新会话列表）
       * @param {Message[]} messageList 封装好的消息列表
       * @returns {Object[]}
       * @memberof AVChatRoomHandler
       */

    }, {
      key: "packConversationOption",
      value: function packConversationOption(messageList) {
        var conversationOptionMap = new Map(); // Map<conversationID, conversationOption>

        for (var i = 0; i < messageList.length; i++) {
          var message = messageList[i];
          var conversationID = message.conversationID;

          if (conversationOptionMap.has(conversationID)) {
            var conversationOption = conversationOptionMap.get(conversationID);
            conversationOption.lastMessage = message;

            if (message.flow === 'in') {
              conversationOption.unreadCount++;
            }
          } else {
            conversationOptionMap.set(conversationID, {
              conversationID: message.conversationID,
              // 如果是自己发送的消息，不计未读
              unreadCount: message.flow === 'out' ? 0 : 1,
              type: message.conversationType,
              subType: message.conversationSubType,
              lastMessage: message
            });
          }
        }

        return _toConsumableArray(conversationOptionMap.values());
      }
      /**
       * 退出登录时，停止AVChatRoom轮询，并且清理相关数据
       * @memberof AVChatRoomHandler
       */

    }, {
      key: "reset",
      value: function reset() {
        if (this.AVChatRoomLoop === null) {
          return;
        }

        logger.log('AVChatRoomHandler.reset');
        this.stop();
        this.AVChatRoomLoop = null;
        this.key = '';
        this.startSeq = 0;
        this.group = {};
      }
    }]);

    return AVChatRoomHandler;
  }();

  /**
   * 群组管理， 建群，加群，退群，群权限，群消息，群组资料，群成员
   * @class
   */

  var GroupController =
  /*#__PURE__*/
  function (_IMController) {
    _inherits(GroupController, _IMController);

    function GroupController(tim) {
      var _this;

      _classCallCheck(this, GroupController);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(GroupController).call(this, tim));
      _this.groupMap = new Map(); // 已加入的群组 Map(Map<groupID, Group>)

      _this.groupMemberListMap = new Map(); // Map<groupID, Map<userID, GroupMember>>

      _this.groupNoticeHandler = new GroupSystemNoticeHandler({
        tim: tim,
        groupController: _assertThisInitialized(_this)
      });
      _this.groupTipsHandler = new GroupTipsHandler({
        tim: tim,
        groupController: _assertThisInitialized(_this)
      });
      _this.AVChatRoomHandler = new AVChatRoomHandler({
        tim: tim,
        groupController: _assertThisInitialized(_this)
      });

      _this._initListeners();

      return _this;
    }
    /**
     * @param {CreateGroupOptions} options - 参数集
     * @returns {Promise}
     * @throws {IMError}
     */


    _createClass(GroupController, [{
      key: "createGroup",
      value: function createGroup(options) {
        var _this2 = this;

        var accessTypes = ['Public', 'Private', 'ChatRoom', 'AVChatRoom']; // 不合法的群类型

        if (!accessTypes.includes(options.type)) {
          var error = new IMError({
            code: ERROR_CODE.ILLEGAL_GROUP_TYPE,
            message: ERROR_MESSAGE.ILLEGAL_GROUP_TYPE
          });
          return IMPromise.reject(error);
        } // 创建 AVChatRoom 时不能添加成员


        if (isAVChatRoom(options.type) && !isUndefined(options.memberList) && options.memberList.length > 0) {
          logger.warn('GroupController.createGroup 创建AVChatRoom时不能添加群成员，自动忽略该字段');
          options.memberList = undefined;
        } // Private, ChatRoom, AVChatRoom 类型群，创建时不能设置 申请加群设置(joinOption)


        if (!isPublic(options.type) && !isUndefined(options.joinOption)) {
          logger.warn('GroupController.createGroup 创建Private/ChatRoom/AVChatRoom群时不能设置字段：joinOption，自动忽略该字段');
          options.joinOption = undefined;
        } // event stat


        var ssoLog = new SSOLogData();
        ssoLog.setMethod(SSOMethods.CREATE_GROUP).setStart();
        logger.log('GroupController.createGroup.');
        return this.request({
          name: 'group',
          action: 'create',
          param: options
        }).then(function (response) {
          // event stat
          ssoLog.setCode(0).setNetworkType(_this2.getNetworkType()).setText("groupType=".concat(options.type, " groupID=").concat(response.data.groupID)).setEnd();
          logger.log('GroupController.createGroup ok. groupID:', response.data.groupID); // AVChatRoom 创建后直接返回相关资料

          if (options.type === TYPES.GRP_AVCHATROOM) {
            return _this2.getGroupProfile({
              groupID: response.data.groupID
            });
          } // 1.更新本地群组列表


          _this2.updateGroupMap([_objectSpread2({}, options, {
            groupID: response.data.groupID
          })]); // 2.非 AVChatRoom 类型群组创建后，发送一条自定义消息
          // data=group_create, desc=undefined, ext=rychou创建群组


          var message = _this2.tim.createCustomMessage({
            to: response.data.groupID,
            conversationType: TYPES.CONV_GROUP,
            payload: {
              data: 'group_create',
              extension: "".concat(_this2.tim.context.identifier, "\u521B\u5EFA\u7FA4\u7EC4")
            }
          });

          _this2.tim.sendMessage(message); // 3. 抛事件


          _this2.emitGroupListUpdate(); // 4. 返回创建的群的信息


          return _this2.getGroupProfile({
            groupID: response.data.groupID
          });
        }).then(function (imResponse) {
          // 手动设置 messageRemindType 和 role
          var group = imResponse.data.group;
          group.selfInfo.messageRemindType = TYPES.MSG_REMIND_ACPT_AND_NOTE;
          group.selfInfo.role = TYPES.GRP_MBR_ROLE_OWNER;
          return imResponse;
        })["catch"](function (error) {
          // event stat
          ssoLog.setText("groupType=".concat(options.type));

          _this2.probeNetwork().then(function (_ref) {
            var _ref2 = _slicedToArray(_ref, 2),
                bOnline = _ref2[0],
                networkType = _ref2[1];

            ssoLog.setError(error, bOnline, networkType).setEnd();
          });

          logger.error('GroupController.createGroup error:', error);
          return IMPromise.reject(error);
        });
      }
      /**
       * 加入群组
       * 注意：Private 类型群组不支持申请加群
       * @param {Object} options 请求参数
       * @returns {Promise}
       */

    }, {
      key: "joinGroup",
      value: function joinGroup(options) {
        // 若在群中，则直接 resolve，无需发起请求
        if (this.hasLocalGroup(options.groupID)) {
          var result = {
            status: TYPES.JOIN_STATUS_ALREADY_IN_GROUP
          };
          return IMPromise.resolve(result);
        }

        if (options.type === TYPES.GRP_PRIVATE) {
          var error = new IMError({
            code: ERROR_CODE.CANNOT_JOIN_PRIVATE,
            message: ERROR_MESSAGE.CANNOT_JOIN_PRIVATE
          });
          return IMPromise.reject(error);
        }

        logger.log('GroupController.joinGroup. groupID:', options.groupID);

        if (this.isLoggedIn()) {
          return this.applyJoinGroup(options);
        } // 匿名加群


        return this.AVChatRoomHandler.joinWithoutAuth(options);
      }
      /**
       * 退出群组。群主只能退出私有群，群主退出其他类型的群只能通过解散群组的方式。
       * 通知：主动退群(Event:5 reportType:8) 有群成员退出群组(Event:4 opType: 2)
       * Private: 退群者收到 【主动退群】
       * Public: 所有群成员（除退群者）收到 【有群成员退出群组】，退群者收到 【主动退群】
       * ChatRoom: 退群者收到 【主动退群】
       * AVChatRoom: 退群者收到 【主动退群】
       * @param {String} groupID
       */

    }, {
      key: "quitGroup",
      value: function quitGroup(groupID) {
        var _this3 = this;

        logger.log('GroupController.quitGroup. groupID:', groupID);
        var isAVChatRoom = this.AVChatRoomHandler.checkJoinedAVChatRoomByID(groupID); // 未登录时退出 AVChatRoom，不发请求退群，停掉消息通道并清理数据返回即可

        if (isAVChatRoom && !this.isLoggedIn()) {
          logger.log('GroupController.quitGroup anonymously ok. groupID:', groupID);
          this.deleteLocalGroupAndConversation(groupID);
          this.AVChatRoomHandler.reset();
          return IMPromise.resolve({
            groupID: groupID
          });
        } // event stat


        var ssoLog = new SSOLogData();
        ssoLog.setMethod(SSOMethods.QUIT_GROUP).setStart();
        return this.request({
          name: 'group',
          action: 'quitGroup',
          param: {
            groupID: groupID
          }
        }).then(function () {
          // event stat
          ssoLog.setCode(0).setNetworkType(_this3.getNetworkType()).setText("groupID=".concat(groupID)).setEnd();
          logger.log('GroupController.quitGroup ok. groupID:', groupID); // 退 AVChatRoom 成功时，停掉轮询并清理数据

          if (isAVChatRoom) {
            _this3.AVChatRoomHandler.reset();
          } // 清理本地群组和会话


          _this3.deleteLocalGroupAndConversation(groupID);

          return new IMResponse({
            groupID: groupID
          });
        })["catch"](function (error) {
          // event stat
          ssoLog.setText("groupID=".concat(groupID));

          _this3.probeNetwork().then(function (_ref3) {
            var _ref4 = _slicedToArray(_ref3, 2),
                bOnline = _ref4[0],
                networkType = _ref4[1];

            ssoLog.setError(error, bOnline, networkType).setEnd();
          });

          logger.error("GroupController.quitGroup error.  error:".concat(error, ". groupID:").concat(groupID));
          return IMPromise.reject(error);
        });
      }
      /**
       * 转让群组。私有/公开/聊天室都支持。AVChatRoom不支持
       * @param {Object} options
       * @param {String} options.groupID - 待转让的群组 ID
       * @param {String} options.newOwnerID - 新群主的 ID
       */

    }, {
      key: "changeGroupOwner",
      value: function changeGroupOwner(options) {
        var _this4 = this;

        // AVChatRoom不支持
        if (this.hasLocalGroup(options.groupID) && this.getLocalGroupProfile(options.groupID).type === TYPES.GRP_AVCHATROOM) {
          return IMPromise.reject(new IMError({
            code: ERROR_CODE.CANNOT_CHANGE_OWNER_IN_AVCHATROOM,
            message: ERROR_MESSAGE.CANNOT_CHANGE_OWNER_IN_AVCHATROOM
          }));
        } // 不能转给自己


        if (options.newOwnerID === this.tim.loginInfo.identifier) {
          return IMPromise.reject(new IMError({
            code: ERROR_CODE.CANNOT_CHANGE_OWNER_TO_SELF,
            message: ERROR_MESSAGE.CANNOT_CHANGE_OWNER_TO_SELF
          }));
        } // event stat


        var ssoLog = new SSOLogData();
        ssoLog.setMethod(SSOMethods.CHANGE_GROUP_OWNER).setStart();
        logger.log('GroupController.changeGroupOwner. groupID:', options.groupID);
        return this.request({
          name: 'group',
          action: 'changeGroupOwner',
          param: options
        }).then(function () {
          // event stat
          ssoLog.setCode(0).setNetworkType(_this4.getNetworkType()).setText("groupID=".concat(options.groupID)).setEnd();
          logger.log('GroupController.changeGroupOwner ok. groupID:', options.groupID);
          var groupID = options.groupID,
              newOwnerID = options.newOwnerID; // 更新群主ID

          _this4.groupMap.get(groupID).ownerID = newOwnerID; // 更新群组成员的身份

          var groupMembers = _this4.groupMemberListMap.get(groupID);

          if (groupMembers instanceof Map) {
            var currentGroupMember = groupMembers.get(_this4.tim.loginInfo.identifier);

            if (!isUndefined(currentGroupMember)) {
              currentGroupMember.updateRole('Member');
              _this4.groupMap.get(groupID).selfInfo.role = 'Member';
            }

            var newGroupOwner = groupMembers.get(newOwnerID);

            if (!isUndefined(newGroupOwner)) {
              newGroupOwner.updateRole('Owner');
            }
          }

          _this4.emitGroupListUpdate(true, false);

          return new IMResponse({
            group: _this4.groupMap.get(groupID)
          });
        })["catch"](function (error) {
          // event stat
          ssoLog.setText("groupID=".concat(options.groupID));

          _this4.probeNetwork().then(function (_ref5) {
            var _ref6 = _slicedToArray(_ref5, 2),
                bOnline = _ref6[0],
                networkType = _ref6[1];

            ssoLog.setError(error, bOnline, networkType).setEnd();
          });

          logger.error("GroupController.changeGroupOwner error:".concat(error, ". groupID:").concat(options.groupID));
          return IMPromise.reject(error);
        });
      }
      /**
       * 解散群组
       * 私有群不能解散群组
       * @param {String} groupID - 群组 ID
       */

    }, {
      key: "dismissGroup",
      value: function dismissGroup(groupID) {
        var _this5 = this;

        // 不能解散 Private 类型的群组
        if (this.hasLocalGroup(groupID) && this.getLocalGroupProfile(groupID).type === TYPES.GRP_PRIVATE) {
          return IMPromise.reject(new IMError({
            code: ERROR_CODE.CANNOT_DISMISS_PRIVATE,
            message: ERROR_MESSAGE.CANNOT_DISMISS_PRIVATE
          }));
        } // event stat


        var ssoLog = new SSOLogData();
        ssoLog.setMethod(SSOMethods.DISMISS_GROUP).setStart();
        logger.log("GroupController.dismissGroup. groupID:".concat(groupID));
        return this.request({
          name: 'group',
          action: 'destroyGroup',
          param: {
            groupID: groupID
          }
        }).then(function () {
          // event stat
          ssoLog.setCode(0).setNetworkType(_this5.getNetworkType()).setText("groupID=".concat(groupID)).setEnd();
          logger.log("GroupController.dismissGroup ok. groupID:".concat(groupID)); // 清理本地群组和会话

          _this5.deleteLocalGroupAndConversation(groupID); // 若是解散 AVChatRoom, 停掉轮询并清理相关数据


          if (_this5.checkJoinedAVChatRoomByID(groupID)) {
            _this5.AVChatRoomHandler.reset();
          }

          return new IMResponse({
            groupID: groupID
          });
        })["catch"](function (error) {
          // event stat
          ssoLog.setText("groupID=".concat(groupID));

          _this5.probeNetwork().then(function (_ref7) {
            var _ref8 = _slicedToArray(_ref7, 2),
                bOnline = _ref8[0],
                networkType = _ref8[1];

            ssoLog.setError(error, bOnline, networkType).setEnd();
          });

          logger.error("GroupController.dismissGroup error:".concat(error, ". groupID:").concat(groupID));
          return IMPromise.reject(error);
        });
      }
      /**
       * 修改群组资料
       * @param {Object} options 配置选项
       * @returns {Promise}
       */

    }, {
      key: "updateGroupProfile",
      value: function updateGroupProfile(options) {
        var _this6 = this;

        // Private / ChatRoom / AVChatRoom 不能设置 joinOption
        if (this.hasLocalGroup(options.groupID) && !isPublic(this.getLocalGroupProfile(options.groupID).type) && !isUndefined(options.joinOption)) {
          logger.warn('GroupController.updateGroupProfile Private/ChatRoom/AVChatRoom群不能设置字段：joinOption，自动忽略该字段');
          options.joinOption = undefined;
        } // event stat


        var ssoLog = new SSOLogData();
        ssoLog.setMethod(SSOMethods.UPDATE_GROUP_PROFILE).setStart();
        ssoLog.setText("groupID=".concat(options.groupID));
        logger.log('GroupController.updateGroupProfile. groupID:', options.groupID);
        return this.request({
          name: 'group',
          action: 'updateGroupProfile',
          param: options
        }).then(function () {
          // event stat
          ssoLog.setCode(0).setNetworkType(_this6.getNetworkType()).setEnd();
          logger.log('GroupController.updateGroupProfile ok. groupID:', options.groupID); // 更新保存在内存的群组信息

          if (_this6.hasLocalGroup(options.groupID)) {
            var group = _this6.groupMap.get(options.groupID);

            group.updateGroup(options);

            _this6._setStorageGroupList();
          }

          return new IMResponse({
            group: _this6.groupMap.get(options.groupID)
          });
        })["catch"](function (error) {
          // event stat
          _this6.probeNetwork().then(function (_ref9) {
            var _ref10 = _slicedToArray(_ref9, 2),
                bOnline = _ref10[0],
                networkType = _ref10[1];

            ssoLog.setError(error, bOnline, networkType).setEnd();
          });

          logger.log("GroupController.updateGroupProfile failed. error:".concat(stringifyError(error), " groupID:").concat(options.groupID));
          return IMPromise.reject(error);
        });
      }
      /**
       * 设置群成员身份
       * @param {Object} options 请求参数
       * @param {String} options.groupID groupID
       * @param {String} options.userID userID
       * @param {String} options.role 角色
       * @returns {Promise}
       */

    }, {
      key: "setGroupMemberRole",
      value: function setGroupMemberRole(options) {
        var _this7 = this;

        var groupID = options.groupID,
            userID = options.userID,
            role = options.role;
        var group = this.groupMap.get(groupID); // 不是群主

        if (group.selfInfo.role !== TYPES.GRP_MBR_ROLE_OWNER) {
          return IMPromise.reject(new IMError({
            code: ERROR_CODE.NOT_OWNER,
            message: ERROR_MESSAGE.NOT_OWNER
          }));
        } // Private和AVChatRoom不能设置管理员


        if ([TYPES.GRP_PRIVATE, TYPES.GRP_AVCHATROOM].includes(group.type)) {
          return IMPromise.reject(new IMError({
            code: ERROR_CODE.CANNOT_SET_MEMBER_ROLE_IN_PRIVATE_AND_AVCHATROOM,
            message: ERROR_MESSAGE.CANNOT_SET_MEMBER_ROLE_IN_PRIVATE_AND_AVCHATROOM
          }));
        } // 非法的群成员类型


        if ([TYPES.GRP_MBR_ROLE_ADMIN, TYPES.GRP_MBR_ROLE_MEMBER].indexOf(role) < 0) {
          return IMPromise.reject(new IMError({
            code: ERROR_CODE.INVALID_MEMBER_ROLE,
            message: ERROR_MESSAGE.INVALID_MEMBER_ROLE
          }));
        } // 不能设置自己的群成员身份


        if (userID === this.tim.loginInfo.identifier) {
          return IMPromise.reject(new IMError({
            code: ERROR_CODE.CANNOT_SET_SELF_MEMBER_ROLE,
            message: ERROR_MESSAGE.CANNOT_SET_SELF_MEMBER_ROLE
          }));
        } // event stat


        var ssoLog = new SSOLogData();
        ssoLog.setMethod(SSOMethods.SET_GROUPMEMBER_ROLE).setStart();
        ssoLog.setText("groupID=".concat(groupID, " userID=").concat(userID, " role=").concat(role));
        logger.log("GroupController.setGroupMemberRole. groupID:".concat(groupID, ". userID: ").concat(userID));
        return this._modifyGroupMemberInfo({
          groupID: groupID,
          userID: userID,
          role: role
        }).then(function (member) {
          // event stat
          ssoLog.setCode(0).setNetworkType(_this7.getNetworkType()).setEnd();
          logger.log("GroupController.setGroupMemberRole ok. groupID:".concat(groupID, ". userID: ").concat(userID));
          return new IMResponse({
            group: group,
            member: member
          });
        })["catch"](function (error) {
          // event stat
          _this7.probeNetwork().then(function (_ref11) {
            var _ref12 = _slicedToArray(_ref11, 2),
                bOnline = _ref12[0],
                networkType = _ref12[1];

            ssoLog.setError(error, bOnline, networkType).setEnd();
          });

          logger.error("GroupController.setGroupMemberRole error:".concat(error, ". groupID:").concat(groupID, ". userID:").concat(userID));
          return IMPromise.reject(error);
        });
      }
      /**
       * 设置群组成员禁言时间
       * @param {Object} options 请求参数
       * @param {String} options.groupID 群 ID
       * @param {String} options.userID userID
       * @param {Number} options.muteTime 禁言时长，单位：秒
       * @returns {Promise}
       */

    }, {
      key: "setGroupMemberMuteTime",
      value: function setGroupMemberMuteTime(options) {
        var _this8 = this;

        var groupID = options.groupID,
            userID = options.userID,
            muteTime = options.muteTime; // 不能将自己禁言

        if (userID === this.tim.loginInfo.identifier) {
          return IMPromise.reject(new IMError({
            code: ERROR_CODE.CANNOT_MUTE_SELF,
            message: ERROR_MESSAGE.CANNOT_MUTE_SELF
          }));
        }

        logger.log("GroupController.setGroupMemberMuteTime. groupID:".concat(groupID, ". userID: ").concat(userID)); // event stat

        var ssoLog = new SSOLogData();
        ssoLog.setMethod(SSOMethods.SET_GROUPMEMBER_MUTE_TIME).setStart();
        ssoLog.setText("groupID=".concat(groupID, " userID=").concat(userID, " muteTime=").concat(muteTime));
        return this._modifyGroupMemberInfo({
          groupID: groupID,
          userID: userID,
          muteTime: muteTime
        }).then(function (member) {
          // event stat
          ssoLog.setCode(0).setNetworkType(_this8.getNetworkType()).setEnd();
          logger.log("GroupController.setGroupMemberMuteTime ok. groupID:".concat(groupID, ". userID: ").concat(userID));
          return new IMResponse({
            group: _this8.getLocalGroupProfile(groupID),
            member: member
          });
        })["catch"](function (error) {
          // event stat
          _this8.probeNetwork().then(function (_ref13) {
            var _ref14 = _slicedToArray(_ref13, 2),
                bOnline = _ref14[0],
                networkType = _ref14[1];

            ssoLog.setError(error, bOnline, networkType).setEnd();
          });

          logger.error("GroupController.setGroupMemberMuteTime error:".concat(error, ". groupID:").concat(groupID, ". userID:").concat(userID));
          return IMPromise.reject(error);
        });
      }
      /**
       * 设置群消息提示类型。只能设置自己在某个群的群消息提示类型
       * @param {Object} options
       */

    }, {
      key: "setMessageRemindType",
      value: function setMessageRemindType(options) {
        var _this9 = this;

        logger.log("GroupController.setMessageRemindType. groupID:".concat(options.groupID, ". userID: ").concat(options.userID || this.tim.loginInfo.identifier));
        var groupID = options.groupID,
            messageRemindType = options.messageRemindType;
        return this._modifyGroupMemberInfo({
          groupID: groupID,
          messageRemindType: messageRemindType,
          userID: this.tim.loginInfo.identifier
        }).then(function () {
          logger.log("GroupController.setMessageRemindType ok. groupID:".concat(options.groupID, ". userID: ").concat(options.userID || _this9.tim.loginInfo.identifier));

          var group = _this9.getLocalGroupProfile(options.groupID);

          if (group) {
            group.selfInfo.messageRemindType = messageRemindType;
          }

          return new IMResponse({
            group: group
          });
        })["catch"](function (error) {
          logger.error("GroupController.setMessageRemindType error:".concat(error, ". groupID:").concat(options.groupID, ". userID:").concat(options.userID || _this9.tim.loginInfo.identifier));
          return IMPromise.reject(error);
        });
      }
      /**
       * 设置群成员名片
       * @param {Object} options 请求参数
       * @returns {Promise}
       */

    }, {
      key: "setGroupMemberNameCard",
      value: function setGroupMemberNameCard(options) {
        var _this10 = this;

        var groupID = options.groupID,
            _options$userID = options.userID,
            userID = _options$userID === void 0 ? this.tim.loginInfo.identifier : _options$userID,
            nameCard = options.nameCard;
        logger.log("GroupController.setGroupMemberNameCard. groupID:".concat(groupID, ". userID: ").concat(userID)); // event stat

        var ssoLog = new SSOLogData();
        ssoLog.setMethod(SSOMethods.SET_GROUPMEMBER_NAME_CARD).setStart();
        ssoLog.setText("groupID=".concat(groupID, " userID=").concat(userID, " nameCard=").concat(nameCard));
        return this._modifyGroupMemberInfo({
          groupID: groupID,
          userID: userID,
          nameCard: nameCard
        }).then(function (member) {
          logger.log("GroupController.setGroupMemberNameCard ok. groupID:".concat(groupID, ". userID: ").concat(userID)); // event stat

          ssoLog.setCode(0).setNetworkType(_this10.getNetworkType()).setEnd(); // 若是修改自身的群名片，则更新selfInfo

          var group = _this10.getLocalGroupProfile(groupID);

          if (userID === _this10.tim.loginInfo.identifier && group) {
            group.setSelfNameCard(nameCard);
          }

          return new IMResponse({
            group: group,
            member: member
          });
        })["catch"](function (error) {
          // event stat
          _this10.probeNetwork().then(function (_ref15) {
            var _ref16 = _slicedToArray(_ref15, 2),
                bOnline = _ref16[0],
                networkType = _ref16[1];

            ssoLog.setError(error, bOnline, networkType).setEnd();
          });

          logger.error("GroupController.setGroupMemberNameCard error:".concat(error, ". groupID:").concat(groupID, ". userID:").concat(userID));
          return IMPromise.reject(error);
        });
      }
      /**
       * 设置群成员维度自定义字段，由于自定义字段的权限是可以自定义的，是由客户控制的，所以这个接口不做权限校验
       * @param {Object} options
       */

    }, {
      key: "setGroupMemberCustomField",
      value: function setGroupMemberCustomField(options) {
        var _this11 = this;

        var groupID = options.groupID,
            _options$userID2 = options.userID,
            userID = _options$userID2 === void 0 ? this.tim.loginInfo.identifier : _options$userID2,
            memberCustomField = options.memberCustomField;
        logger.log("GroupController.setGroupMemberCustomField. groupID:".concat(groupID, ". userID: ").concat(userID)); // event stat

        var ssoLog = new SSOLogData();
        ssoLog.setMethod(SSOMethods.SET_GROUPMEMBER_CUSTOM_FIELD).setStart();
        ssoLog.setText("groupID=".concat(groupID, " userID=").concat(userID, " memberCustomField=").concat(memberCustomField));
        return this._modifyGroupMemberInfo({
          groupID: groupID,
          userID: userID,
          memberCustomField: memberCustomField
        }).then(function (member) {
          // event stat
          ssoLog.setCode(0).setNetworkType(_this11.getNetworkType()).setEnd();
          logger.log("GroupController.setGroupMemberCustomField ok. groupID:".concat(groupID, ". userID: ").concat(userID));
          return new IMResponse({
            group: _this11.groupMap.get(groupID),
            member: member
          });
        })["catch"](function (error) {
          // event stat
          _this11.probeNetwork().then(function (_ref17) {
            var _ref18 = _slicedToArray(_ref17, 2),
                bOnline = _ref18[0],
                networkType = _ref18[1];

            ssoLog.setError(error, bOnline, networkType).setEnd();
          });

          logger.error("GroupController.setGroupMemberCustomField error:".concat(error, ". groupID:").concat(groupID, ". userID:").concat(userID));
          return IMPromise.reject(error);
        });
      }
      /**
       * 获取用户加入的群组列表
       * @param {Object} options 请求参数
       * @param {String[]} [options.groupProfileFilter] 该接口默认只会拉取这些资料：群类型、群名称、群头像、最后一条消息的时间、nextMessageSeq。<br/>
       * 若想获取更多资料，可填写该字段配置。支持额外拉取的资料字段如下：
       * - ['ownerID','createTime','lastInfoTime','memberNum','maxMemberNum','joinOption','introduction','notification']
       * @memberof GroupController
       * @returns {Promise}
       */

    }, {
      key: "getGroupList",
      value: function getGroupList(options) {
        var _this12 = this;

        // event stat
        var ssoLog = new SSOLogData();
        ssoLog.setMethod(SSOMethods.GET_GROUP_LIST).setStart();
        logger.log('GroupController.getGroupList'); // 转换配置，key 是前端字段，value 是后端字段。

        var map = {
          introduction: 'Introduction',
          notification: 'Notification',
          createTime: 'CreateTime',
          ownerID: 'Owner_Account',
          lastInfoTime: 'LastInfoTime',
          memberNum: 'MemberNum',
          maxMemberNum: 'MaxMemberNum',
          joinOption: 'ApplyJoinOption'
        }; // 默认拉取这些字段

        var groupBaseInfoFilter = ['Type', 'Name', 'FaceUrl', 'NextMsgSeq', 'LastMsgTime']; // 支持拉取额外的资料字段

        if (options && options.groupProfileFilter) {
          options.groupProfileFilter.forEach(function (key) {
            if (map[key]) {
              groupBaseInfoFilter.push(map[key]);
            }
          });
        }

        return this.request({
          name: 'group',
          action: 'list',
          param: {
            responseFilter: {
              groupBaseInfoFilter: groupBaseInfoFilter,
              selfInfoFilter: ['Role', // 群内身份
              'JoinTime', // 入群时间
              'MsgFlag' // 消息屏蔽类型
              ]
            }
          }
        }).then(function (_ref19) {
          var groups = _ref19.data.groups;
          // event stat
          ssoLog.setCode(0).setNetworkType(_this12.getNetworkType()).setText(groups.length).setEnd();
          logger.log("GroupController.getGroupList ok. nums=".concat(groups.length)); // 1. 清空现有的群组列表中多出的部分

          _this12._groupListTreeShaking(groups); // 2. 更新群组列表


          _this12.updateGroupMap(groups);

          if (_this12.tempConversationList) {
            // 检查是否有暂存的待更新的会话列表，有则更新对应群组的lastMessage
            logger.log("GroupController.getGroupList update last message with tempConversationList, nums=".concat(_this12.tempConversationList.length));

            _this12._handleUpdateGroupLastMessage({
              data: _this12.tempConversationList
            });

            _this12.tempConversationList = null;
          }

          _this12.emitGroupListUpdate();

          return new IMResponse({
            groupList: _this12.getLocalGroups()
          });
        })["catch"](function (error) {
          // event stat
          _this12.probeNetwork().then(function (_ref20) {
            var _ref21 = _slicedToArray(_ref20, 2),
                bOnline = _ref21[0],
                networkType = _ref21[1];

            ssoLog.setError(error, bOnline, networkType).setEnd();
          });

          logger.error('GroupController.getGroupList error: ', error);
          return IMPromise.reject(error);
        });
      }
      /**
       * 获取群成员列表
       * @param {Object} options 请求参数
       * @param {String} options.groupID 群组的 ID
       * @param {Number} [options.count=15] 需要拉取的数量。最大值：100，避免回包过大导致请求失败。若传入超过100，则只拉取前100个。
       * @param {Number} [options.offset=0] 偏移量，默认从0开始拉取
       * @returns {Promise}
       */

    }, {
      key: "getGroupMemberList",
      value: function getGroupMemberList(_ref22) {
        var _this13 = this;

        var groupID = _ref22.groupID,
            _ref22$offset = _ref22.offset,
            offset = _ref22$offset === void 0 ? 0 : _ref22$offset,
            _ref22$count = _ref22.count,
            count = _ref22$count === void 0 ? 15 : _ref22$count;
        logger.log("GroupController.getGroupMemberList groupID: ".concat(groupID, " offset: ").concat(offset, " count: ").concat(count));
        var memberList = [];
        return this.request({
          name: 'group',
          action: 'getGroupMemberList',
          param: {
            groupID: groupID,
            offset: offset,
            limit: count > 100 ? 100 : count,
            // 超过 100 则取 100
            memberInfoFilter: ['Role', 'NameCard']
          }
        }).then(function (_ref23) {
          var _ref23$data = _ref23.data,
              members = _ref23$data.members,
              memberNum = _ref23$data.memberNum;

          if (!isArray(members) || members.length === 0) {
            return Promise.resolve([]);
          } // 1.更新 memberNum


          if (_this13.hasLocalGroup(groupID)) {
            _this13.getLocalGroupProfile(groupID).memberNum = memberNum;
          } // 2.更新群成员列表


          memberList = _this13._updateLocalGroupMemberMap(groupID, members); // 3.更新群成员的 nick 和 avatar

          return _this13.tim.getUserProfile({
            userIDList: members.map(function (item) {
              return item.userID;
            }),
            tagList: [STANDARD_IM_PROFILE.NICK, STANDARD_IM_PROFILE.AVATAR]
          });
        }).then(function (_ref24) {
          var data = _ref24.data;

          if (!isArray(data) || data.length === 0) {
            return IMPromise.resolve({
              memberList: []
            });
          }

          var options = data.map(function (item) {
            return {
              userID: item.userID,
              nick: item.nick,
              avatar: item.avatar
            };
          });

          _this13._updateLocalGroupMemberMap(groupID, options);

          logger.log("GroupController.getGroupMemberList ok.");
          return new IMResponse({
            memberList: memberList
          });
        })["catch"](function (error) {
          logger.error('GroupController.getGroupMemberList error: ', error);
          return IMPromise.reject(error);
        });
      }
      /**
       * 获取群组列表
       * @returns {Group[]}
       * @memberof GroupController
       */

    }, {
      key: "getLocalGroups",
      value: function getLocalGroups() {
        return _toConsumableArray(this.groupMap.values());
      }
      /**
       * 获取某个群组信息
       * @param {String} groupID 群 ID
       * @returns {Group}
       */

    }, {
      key: "getLocalGroupProfile",
      value: function getLocalGroupProfile(groupID) {
        return this.groupMap.get(groupID);
      }
      /**
       * 判断本地 groupMap 是否有群组
       * @param {String} groupID 群 ID
       * @returns {Group}
       */

    }, {
      key: "hasLocalGroup",
      value: function hasLocalGroup(groupID) {
        return this.groupMap.has(groupID);
      }
      /**
       * 获取本地的群成员信息
       * @param {String} groupID 群 ID
       * @param {String} userID userID
       * @returns {GroupMember|Null}
       */

    }, {
      key: "getLocalGroupMemberInfo",
      value: function getLocalGroupMemberInfo(groupID, userID) {
        if (this.groupMemberListMap.has(groupID)) {
          return this.groupMemberListMap.get(groupID).get(userID);
        }

        return null;
      }
      /**
       * 写入本地群成员 Map
       * @param {String} groupID 群 ID
       * @param {GroupMember} member 群成员Model
       */

    }, {
      key: "setLocalGroupMember",
      value: function setLocalGroupMember(groupID, member) {
        if (this.groupMemberListMap.has(groupID)) {
          this.groupMemberListMap.get(groupID).set(member.userID, member);
        } else {
          var groupMemberMap = new Map().set(member.userID, member);
          this.groupMemberListMap.set(groupID, groupMemberMap);
        }
      }
      /**
       * 判断本地 groupMemberListMap 是否有群成员
       * @param {String} groupID 群 ID
       * @param {String} userID userID
       * @returns {Boolean}
       */

    }, {
      key: "hasLocalGroupMember",
      value: function hasLocalGroupMember(groupID, userID) {
        return this.groupMemberListMap.has(groupID) && this.groupMemberListMap.get(groupID).has(userID);
      }
      /**
       * 判断本地是否有某个群组的群成员列表
       * @param {String} groupID 群ID
       * @returns {Boolean}
       */

    }, {
      key: "hasLocalGroupMemberMap",
      value: function hasLocalGroupMemberMap(groupID) {
        return this.groupMemberListMap.has(groupID);
      }
      /**
       * 获取完整的群资料，这里获取的群资料和群成员资料都是完整的
       * 后端接口的行为表现：
       * a. 对于 AVChatRoom，若群成员未进群，可以调用该接口查询。
       * b. 对于其他类型的群，必须进群才能查询。
       * @param {Object} options 请求参数
       * @param {String} options.groupID 群组ID
       * @returns {Promise}
       * @memberof GroupController
       */

    }, {
      key: "getGroupProfile",
      value: function getGroupProfile(options) {
        var _this14 = this;

        logger.log('GroupController.getGroupProfile. groupID:', options.groupID);
        var groupID = options.groupID,
            groupCustomFieldFilter = options.groupCustomFieldFilter;
        var groupProfileOptions = {
          groupIDList: [groupID],
          responseFilter: {
            groupBaseInfoFilter: ['Type', 'Name', 'Introduction', 'Notification', 'FaceUrl', 'Owner_Account', 'CreateTime', 'InfoSeq', 'LastInfoTime', 'LastMsgTime', 'MemberNum', 'MaxMemberNum', 'ApplyJoinOption', 'NextMsgSeq'],
            groupCustomFieldFilter: groupCustomFieldFilter
          }
        }; // 1. 调用高级接口获取群资料

        return this.getGroupProfileAdvance(groupProfileOptions).then(function (_ref25) {
          var _ref25$data = _ref25.data,
              groups = _ref25$data.successGroupList,
              failureGroupList = _ref25$data.failureGroupList;
          logger.log('GroupController.getGroupProfile ok. groupID:', options.groupID);

          if (failureGroupList.length > 0) {
            return IMPromise.reject(failureGroupList[0]);
          }

          var group; // 1. 更新本地 groupMap
          // 若查询一个未加入的 AVChatRoom，则不更新本地 groupMap。因为 groupMap 存的是已加入的群组。

          if (isAVChatRoom(groups[0].type) && !_this14.hasLocalGroup(groupID)) {
            group = new Group(groups[0]);
          } else {
            _this14.updateGroupMap(groups);

            group = _this14.getLocalGroupProfile(groupID);
          } // 2. 若 selfInfo 没有 nameCard，则更新 selfInfo


          if (group && group.selfInfo && !group.selfInfo.nameCard) {
            return _this14.updateSelfInfo(group).then(function (group) {
              return new IMResponse({
                group: group
              });
            });
          }

          return new IMResponse({
            group: group
          });
        })["catch"](function (error) {
          logger.error("GroupController.getGroupProfile error:".concat(error, ". groupID:").concat(options.groupID));
          return IMPromise.reject(error);
        });
      }
      /**
       * 获取完整的群成员资料
       * @param {Object} options 请求参数
       * @param {String} options.groupID 群组 ID
       * @param {String[]} options.userIDList 要查询的群成员用户 ID 列表。最大50
       * @param {String[]} options.memberCustomFieldFilter 群成员自定义字段筛选
       * @returns {Promise} 返回Promise对象
       */

    }, {
      key: "getGroupMemberProfile",
      value: function getGroupMemberProfile(options) {
        var _this15 = this;

        logger.log("GroupController.getGroupMemberProfile groupID:".concat(options.groupID, " userIDList:").concat(options.userIDList.join(',')));

        if (options.userIDList.length > 50) {
          options.userIDList = options.userIDList.slice(0, 50);
        }

        var groupID = options.groupID,
            userIDList = options.userIDList;
        return this._getGroupMemberProfileAdvance(_objectSpread2({}, options, {
          userIDList: userIDList
        })).then(function (_ref26) {
          var members = _ref26.data.members;

          if (!isArray(members) || members.length === 0) {
            return IMPromise.resolve([]);
          }

          _this15._updateLocalGroupMemberMap(groupID, members); // 更新群成员的 nick 和 avatar


          return _this15.tim.getUserProfile({
            userIDList: members.map(function (_ref27) {
              var userID = _ref27.userID;
              return userID;
            }),
            tagList: [STANDARD_IM_PROFILE.NICK, STANDARD_IM_PROFILE.AVATAR]
          });
        }).then(function (_ref28) {
          var data = _ref28.data;
          var userProfiles = data.map(function (_ref29) {
            var userID = _ref29.userID,
                nick = _ref29.nick,
                avatar = _ref29.avatar;
            return {
              userID: userID,
              nick: nick,
              avatar: avatar
            };
          });

          _this15._updateLocalGroupMemberMap(groupID, userProfiles); // 返回查到的数据，没查到的不返回


          var result = userIDList.filter(function (userID) {
            return _this15.hasLocalGroupMember(groupID, userID);
          }).map(function (userID) {
            return _this15.getLocalGroupMemberInfo(groupID, userID);
          });
          return new IMResponse({
            memberList: result
          });
        });
      }
      /**
       * 获取指定的群成员资料
       * @private
       * @param {Object} options 请求参数
       * @param {String} options.groupID 群 ID
       * @param {String[]} options.userIDList userIDList
       * @param {String[]} [options.memberInfoFilter=['Role','JoinTime','NameCard','ShutUpUntil']] 要获取的群成员资料，
       * 支持 ['Role','JoinTime','NameCard','ShutUpUntil'], 不传则默认拉取全部资料
       * @returns {Promise}
       */

    }, {
      key: "_getGroupMemberProfileAdvance",
      value: function _getGroupMemberProfileAdvance(options) {
        return this.request({
          name: 'group',
          action: 'getGroupMemberProfile',
          param: _objectSpread2({}, options, {
            memberInfoFilter: options.memberInfoFilter ? options.memberInfoFilter : ['Role', 'JoinTime', 'NameCard', 'ShutUpUntil']
          })
        });
      }
      /**
       * 更新 group.selfInfo
       * @param {Group} group 待更新的 groupModel
       * @returns {Promise}
       */

    }, {
      key: "updateSelfInfo",
      value: function updateSelfInfo(group) {
        var groupID = group.groupID;
        logger.log('GroupController.updateSelfInfo groupID:', groupID);
        var options = {
          groupID: groupID,
          userIDList: [this.tim.loginInfo.identifier]
        };
        return this.getGroupMemberProfile(options).then(function (_ref30) {
          var memberList = _ref30.data.memberList;
          logger.log('GroupController.updateSelfInfo ok. groupID:', groupID);

          if (group && memberList.length !== 0) {
            group.updateSelfInfo(memberList[0]);
          }

          return group;
        });
      }
      /**
       * 添加群成员
       * 这里不做权限校验，为客户保留App管理员调用的权限
       * App管理员添加群成员: 通知: 群组有新成员加入（Event:4 opType:1，），被添加进群组（Event: 5 reportType: 7）
       * Private: 所有用户都收不到以上两个事件
       * Public: 所有群成员收到 【群组有新成员加入】，被添加的成员收到 【群组有新成员加入】和【被添加进群组】。设置Silence=1，则情况和ChatRoom相同
       * ChatRoom: 只有被添加成员收到 【被添加进群组】
       * @param {Object} options
       */

    }, {
      key: "addGroupMember",
      value: function addGroupMember(options) {
        var group = this.getLocalGroupProfile(options.groupID); // AVChatRoom不支持添加群成员

        if (isAVChatRoom(group.type)) {
          var error = new IMError({
            code: ERROR_CODE.CANNOT_ADD_MEMBER_IN_AVCHATROOM,
            message: ERROR_MESSAGE.CANNOT_ADD_MEMBER_IN_AVCHATROOM
          });
          return IMPromise.reject(error);
        }

        options.userIDList = options.userIDList.map(function (userID) {
          return {
            userID: userID
          };
        });
        logger.log('GroupController.addGroupMember. groupID:', options.groupID);
        return this.request({
          name: 'group',
          action: 'addGroupMember',
          param: options
        }).then(function (_ref31) {
          var members = _ref31.data.members;
          logger.log('GroupController.addGroupMember ok. groupID:', options.groupID);
          var successUserIDList = members.filter(function (item) {
            return item.result === 1;
          }).map(function (item) {
            return item.userID;
          });
          var failureUserIDList = members.filter(function (member) {
            return member.result === 0;
          }).map(function (item) {
            return item.userID;
          });
          var existedUserIDList = members.filter(function (member) {
            return member.result === 2;
          }).map(function (item) {
            return item.userID;
          });

          if (successUserIDList.length === 0) {
            return new IMResponse({
              successUserIDList: successUserIDList,
              failureUserIDList: failureUserIDList,
              existedUserIDList: existedUserIDList
            });
          }

          group.memberNum += successUserIDList.length;
          return new IMResponse({
            successUserIDList: successUserIDList,
            failureUserIDList: failureUserIDList,
            existedUserIDList: existedUserIDList,
            group: group
          });
        })["catch"](function (error) {
          logger.error("GroupController.addGroupMember error:".concat(error, ", groupID:").concat(options.groupID));
          return IMPromise.reject(error);
        });
      }
      /**
       * 删除群成员
       * 通知：群中有成员被踢（Event:4 opType:3） 被踢出群（Event:5 reportType:4）
       * Private: 所有群成员都收不到通知
       * Public: 所有群成员收到【群中有成员被踢】，被踢的用户收到【被踢出群】
       * ChatRoom: 只有被踢的用户收到【被踢出群】
       * @param {Object} options
       */

    }, {
      key: "deleteGroupMember",
      value: function deleteGroupMember(options) {
        var _this16 = this;

        logger.log("GroupController.deleteGroupMember groupID:".concat(options.groupID, " userIDList:").concat(options.userIDList));
        var group = this.getLocalGroupProfile(options.groupID);

        if (group.type === TYPES.GRP_AVCHATROOM) {
          return IMPromise.reject(new IMError({
            code: ERROR_CODE.CANNOT_KICK_MEMBER_IN_AVCHATROOM,
            message: ERROR_MESSAGE.CANNOT_KICK_MEMBER_IN_AVCHATROOM
          }));
        }

        return this.request({
          name: 'group',
          action: 'deleteGroupMember',
          param: options
        }).then(function () {
          logger.log('GroupController.deleteGroupMember ok');
          group.memberNum--;

          _this16.deleteLocalGroupMembers(options.groupID, options.userIDList);

          return new IMResponse({
            group: group,
            userIDList: options.userIDList
          });
        })["catch"](function (error) {
          logger.error("GroupController.deleteGroupMember error:".concat(error.code, ", groupID:").concat(options.groupID));
          return IMPromise.reject(error);
        });
      }
      /**
       * 通过 groupID 搜索群组
       * Private 类型的群组不允许搜索
       * @param {String} groupID
       */

    }, {
      key: "searchGroupByID",
      value: function searchGroupByID(groupID) {
        var options = {
          groupIDList: [groupID]
        };
        logger.log("GroupController.searchGroupByID. groupID:".concat(groupID));
        return this.request({
          name: 'group',
          action: 'searchGroupByID',
          param: options
        }).then(function (_ref32) {
          var groupProfile = _ref32.data.groupProfile;

          if (groupProfile[0].errorCode !== TIM_STATUS.REQUEST.SUCCESS) {
            throw new IMError({
              code: groupProfile[0].errorCode,
              message: groupProfile[0].errorInfo
            });
          }

          logger.log("GroupController.searchGroupByID ok. groupID:".concat(groupID));
          return new IMResponse({
            group: new Group(groupProfile[0])
          });
        })["catch"](function (error) {
          logger.warn("GroupController.searchGroupByID error:".concat(stringifyError(error), ", groupID:").concat(groupID));
          return IMPromise.reject(error);
        });
      }
      /**
       * 申请加群
       * 通知：有新用户进群（Event:4 opType:1） 申请加群被同意（Event:5 reportType:2）
       * Private：不允许申请加群，只能通过群成员添加群成员的方式
       * 当申请被同意时：
       * Public: 所有群成员收到 【有新用户进群】 申请者收到 【申请加群被同意】
       * ChatRoom: 申请者收到 【申请加群被同意】
       * AVChatRoom: 申请者收到 【申请加群被同意】
       * @param {Object} options
       */

    }, {
      key: "applyJoinGroup",
      value: function applyJoinGroup(options) {
        var _this17 = this;

        // event stat
        var ssoLog = new SSOLogData();
        ssoLog.setMethod(SSOMethods.APPLY_JOIN_GROUP).setStart();
        return this.request({
          name: 'group',
          action: 'applyJoinGroup',
          param: options
        }).then(function (_ref33) {
          var _ref33$data = _ref33.data,
              joinedStatus = _ref33$data.joinedStatus,
              longPollingKey = _ref33$data.longPollingKey;
          // event stat
          ssoLog.setCode(0).setNetworkType(_this17.getNetworkType()).setText("groupID=".concat(options.groupID, " joinedStatus=").concat(joinedStatus)).setEnd();
          logger.log('GroupController.joinGroup ok. groupID:', options.groupID);

          switch (joinedStatus) {
            case JOIN_GROUP_STATUS.WAIT_APPROVAL:
              return new IMResponse({
                status: JOIN_GROUP_STATUS.WAIT_APPROVAL
              });

            case JOIN_GROUP_STATUS.SUCCESS:
              // 获取群资料
              return _this17.getGroupProfile({
                groupID: options.groupID
              }).then(function (_ref34) {
                var group = _ref34.data.group;
                var result = {
                  status: JOIN_GROUP_STATUS.SUCCESS,
                  group: group
                }; // 若加的群是 AVChatRoom 类型，会返回 longPollingKey，用于启动 AVChatRoom 轮询

                if (!isUndefined(longPollingKey)) {
                  _this17.emitInnerEvent(TIM_INNER_EVENT.AVCHATROOM_JOIN_SUCCESS, options.groupID);

                  return _this17.AVChatRoomHandler.startRunLoop({
                    longPollingKey: longPollingKey,
                    group: group
                  });
                }

                return new IMResponse(result);
              });

            default:
              {
                var error = new IMError({
                  code: ERROR_CODE.JOIN_GROUP_FAIL,
                  message: ERROR_MESSAGE.JOIN_GROUP_FAIL
                });
                logger.error("GroupController.joinGroup error:".concat(error, ". groupID:").concat(options.groupID));
                return IMPromise.reject(error);
              }
          }
        })["catch"](function (error) {
          // event stat
          ssoLog.setText("groupID=".concat(options.groupID));

          _this17.probeNetwork().then(function (_ref35) {
            var _ref36 = _slicedToArray(_ref35, 2),
                bOnline = _ref36[0],
                networkType = _ref36[1];

            ssoLog.setError(error, bOnline, networkType).setEnd();
          });

          logger.error("GroupController.joinGroup error:".concat(error, ". groupID:").concat(options.groupID));
          return IMPromise.reject(error);
        });
      }
      /**
       * 申请加入 AVChatRoom
       * @param {Object} options 请求参数
       * @returns {Promise}
       */

    }, {
      key: "applyJoinAVChatRoom",
      value: function applyJoinAVChatRoom(options) {
        return this.AVChatRoomHandler.applyJoinAVChatRoom(options);
      }
      /**
       * 处理加群请求
       * 通知：收到加群请求(Event:5 reportType:1)、加群被同意(Event:5 reportType:2)、加群被拒绝(Event:5 reportType:3)、有新用户进群（Event:4 opType:1）
       * Private: 私有群不允许申请加群，故该类通知
       * ChatRoom: 处理前：群主和管理员收到 【收到加群请求】，处理后：申请人收到 【加群被同意】 / 【加群被拒绝】
       * Public: 处理前：群主和管理员收到 【收到加群请求】，处理后：申请人收到 【加群被同意】和 【有新用户进群】 / 【加群被拒绝】，所有群成员收到 【有新用户进群】
       * @param {Object} options 请求参数
       * @returns {Promise}
       */

    }, {
      key: "handleGroupApplication",
      value: function handleGroupApplication(options) {
        var _this18 = this;

        var _options$message$payl = options.message.payload,
            groupID = _options$message$payl.groupProfile.groupID,
            authentication = _options$message$payl.authentication,
            messageKey = _options$message$payl.messageKey,
            applicant = _options$message$payl.operatorID;
        logger.log('GroupController.handleApplication. groupID:', groupID);
        return this.request({
          name: 'group',
          action: 'handleApplyJoinGroup',
          param: _objectSpread2({}, options, {
            applicant: applicant,
            groupID: groupID,
            authentication: authentication,
            messageKey: messageKey
          })
        }).then(function () {
          logger.log('GroupController.handleApplication ok. groupID:', groupID); // 处理完删除相应的【申请加群】系统通知

          _this18.deleteGroupSystemNotice({
            messageList: [options.message]
          });

          return new IMResponse({
            group: _this18.getLocalGroupProfile(groupID)
          });
        })["catch"](function (error) {
          logger.error("GroupController.handleApplication error.  error:".concat(error, ". groupID:").concat(groupID));
          return IMPromise.reject(error);
        });
      }
      /**
       * 删除群系统通知，SDK 内部使用
       * @private
       * @param {Obejct} options 请求参数
       * @param {Message[]} options.messageList 待删除的群系统通知列表
       * @returns {Promise}
       */

    }, {
      key: "deleteGroupSystemNotice",
      value: function deleteGroupSystemNotice(options) {
        var _this19 = this;

        if (!isArray(options.messageList) || options.messageList.length === 0) {
          return IMPromise.resolve();
        }

        logger.log('GroupController.deleteGroupSystemNotice ' + options.messageList.map(function (message) {
          return message.ID;
        }));
        return this.request({
          name: 'group',
          action: 'deleteGroupSystemNotice',
          param: {
            messageListToDelete: options.messageList.map(function (message) {
              return {
                from: TYPES.CONV_SYSTEM,
                messageSeq: message.clientSequence,
                messageRandom: message.random
              };
            })
          }
        }).then(function () {
          logger.log('GroupController.deleteGroupSystemNotice ok'); // 删除本地系统消息

          options.messageList.forEach(function (message) {
            _this19.tim.messageController.deleteLocalMessage(message);
          });
          return new IMResponse();
        })["catch"](function (error) {
          logger.error('GroupController.deleteGroupSystemNotice error:', error);
          return IMPromise.reject(error);
        });
      }
      /**
       * 获取群资料
       * @param {Object} options
       * @param {String[]} options.groupIDList - 需要拉取的群组列表，数组元素值为群组的ID。最大 50 个，超出时只拉前50个，其余丢弃
       * @param {Object} [options.responseFilter] - 包含三个过滤器：GroupBaseInfoFilter，MemberInfoFilter，AppDefinedDataFilter_Group，分别是基础信息字段过滤器，成员信息字段过滤器，群组维度的自定义字段过滤器
       * @param {String[]} [options.responseFilter.groupBaseInfoFilter] - 基础信息字段过滤器，指定需要获取的基础信息字段，详情请参阅 {@link https://cloud.tencent.com/document/product/269/1502#.E7.BE.A4.E5.9F.BA.E7.A1.80.E8.B5.84.E6.96.99 群基础资料}
       * @param {String[]} [options.responseFilter.memberInfoFilter] - 成员信息字段过滤器，指定需要获取的成员信息字段，详情请参阅 {@link https://cloud.tencent.com/document/product/269/1502#.E7.BE.A4.E6.88.90.E5.91.98.E8.B5.84.E6.96.99 群成员资料}
       * @param {String[]} [options.responseFilter.groupCustomFieldFilter] - 群组维度的自定义字段过滤器，指定需要获取的群组维度的自定义字段，详情请参阅 {@link https://cloud.tencent.com/document/product/269/1502#.E8.87.AA.E5.AE.9A.E4.B9.89.E5.AD.97.E6.AE.B5 自定义字段}
       * @param {String[]} [options.responseFilter.memberCustomFieldFilter] - 群成员维度的自定义字段过滤器，指定需要获取的群成员维度的自定义字段，详情请参阅 {@link https://cloud.tencent.com/document/product/269/1502#.E8.87.AA.E5.AE.9A.E4.B9.89.E5.AD.97.E6.AE.B5 自定义字段}
       * @memberof GroupController
       * @returns {Promise}
       */

    }, {
      key: "getGroupProfileAdvance",
      value: function getGroupProfileAdvance(options) {
        if (isArray(options.groupIDList) && options.groupIDList.length > 50) {
          logger.warn('GroupController.getGroupProfileAdvance 获取群资料的数量不能超过50个');
          options.groupIDList.length = 50;
        }

        logger.log('GroupController.getGroupProfileAdvance. groupIDList:', options.groupIDList);
        return this.request({
          name: 'group',
          action: 'query',
          param: options
        }).then(function (response) {
          logger.log('GroupController.getGroupProfileAdvance ok.');
          var groups = response.data.groups;
          var successGroupList = groups.filter(function (item) {
            return isUndefined(item.errorCode) || item.errorCode === TIM_STATUS.REQUEST.SUCCESS;
          });
          var failureGroupList = groups.filter(function (item) {
            return item.errorCode && item.errorCode !== TIM_STATUS.REQUEST.SUCCESS;
          }).map(function (item) {
            return new IMError({
              code: Number("500".concat(item.errorCode)),
              message: item.errorInfo,
              data: {
                groupID: item.groupID
              }
            });
          });
          return new IMResponse({
            successGroupList: successGroupList,
            failureGroupList: failureGroupList
          });
        })["catch"](function (error) {
          logger.error("GroupController.getGroupProfileAdvance error:".concat(error, ". groupID:").concat(options.groupID));
          return IMPromise.reject(error);
        });
      }
      /**
       * 删除本地群组
       * @private
       * @param {String} groupID
       * @returns {Boolean} 是否删除成功
       */

    }, {
      key: "_deleteLocalGroup",
      value: function _deleteLocalGroup(groupID) {
        // 1.删除群
        this.groupMap["delete"](groupID); // 2.删除群成员列表

        this.groupMemberListMap["delete"](groupID); // 3.同步更新本地缓存

        this._setStorageGroupList();

        return this.groupMap.has(groupID) && this.groupMemberListMap.has(groupID);
      }
      /**
       * 初始化groupList
       * 初始化SDK时从Storage中取出更新内存的 groupMap
       * @private
       * @memberof GroupController
       */

    }, {
      key: "_initGroupList",
      value: function _initGroupList() {
        var _this20 = this;

        // event stat
        var ssoLog = new SSOLogData();
        ssoLog.setMethod(SSOMethods.GET_GROUP_LIST_IN_STORAGE).setStart();
        logger.time(label.INIT_GROUP_LIST);
        logger.log('GroupController._initGroupList');

        var storageGroupList = this._getStorageGroupList();

        if (isArray(storageGroupList) && storageGroupList.length > 0) {
          storageGroupList.forEach(function (group) {
            _this20.groupMap.set(group.groupID, new Group(group));
          });
          this.emitGroupListUpdate(true, false); // event stat

          ssoLog.setCode(0).setNetworkType(this.getNetworkType()).setText(this.groupMap.size).setEnd();
        } else {
          // event stat
          ssoLog.setCode(0).setNetworkType(this.getNetworkType()).setText(0).setEnd(); // it means we have no cache
        }

        this.triggerReady();
        logger.log("GroupController._initGroupList ok. initCost=".concat(logger.timeEnd(label.INIT_GROUP_LIST), "ms"));
        this.getGroupList();
      }
    }, {
      key: "_initListeners",
      value: function _initListeners() {
        var innerEmitter = this.tim.innerEmitter; // 登录态变更时触发，登录成功必触发一次

        innerEmitter.once(TIM_INNER_EVENT.CONTEXT_A2KEY_AND_TINYID_UPDATED, this._initGroupList, this);
        innerEmitter.on(TIM_INNER_EVENT.CONVERSATION_LIST_UPDATED, this._handleUpdateGroupLastMessage, this); // 收到群新消息推送， 包括普通消息和群提示消息

        innerEmitter.on(TIM_INNER_EVENT.MESSAGE_GROUP_INSTANT_RECEIVED, this._handleReceivedGroupMessage, this); // 自己或好友资料变更，需更新群成员资料

        innerEmitter.on(TIM_INNER_EVENT.PROFILE_UPDATED, this._handleProfileUpdated, this);
      }
      /**
       * 抛群组更新事件
       * @param {Boolean} outer 是否抛外部事件
       * @param {Boolean} inner 是否抛内部事件
       */

    }, {
      key: "emitGroupListUpdate",
      value: function emitGroupListUpdate() {
        var outer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
        var inner = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
        var groupList = this.getLocalGroups();
        inner && this.emitInnerEvent(TIM_INNER_EVENT.GROUP_LIST_UPDATED, groupList);
        outer && this.emitOuterEvent(TIM_OUTER_EVENT.GROUP_LIST_UPDATED, groupList);
      }
      /**
       * 收到群消息
       * @private
       * @param {Object} event
       */

    }, {
      key: "_handleReceivedGroupMessage",
      value: function _handleReceivedGroupMessage(_ref37) {
        var _this21 = this;

        var eventDataList = _ref37.data.eventDataList;

        // 1. 更新群的nextMessageSeq, lastSequence在更新会话时更新
        if (Array.isArray(eventDataList)) {
          eventDataList.forEach(function (item) {
            var groupID = item.conversationID.replace(TYPES.CONV_GROUP, '');

            if (_this21.groupMap.has(groupID)) {
              _this21.groupMap.get(groupID).nextMessageSeq = item.lastMessage.sequence + 1;
            }
          });
        }
      }
      /**
       * 收到 群提示消息 或 群系统通知
       * @private
       * @param {Object} event
       */

    }, {
      key: "_onReceivedGroupSystemNotice",
      value: function _onReceivedGroupSystemNotice(_ref38) {
        var groupTips = _ref38.data;

        this.groupNoticeHandler._onReceivedGroupNotice(groupTips);
      }
      /**
       * 当会话列表更新时，需要更新群组的 lastMessage
       * @private
       * @param {Object} event event.data - conversationList
       * @memberof GroupController
       */

    }, {
      key: "_handleUpdateGroupLastMessage",
      value: function _handleUpdateGroupLastMessage(event) {
        var conversationList = event.data;
        logger.log("GroupController._handleUpdateGroupLastMessage convNums=".concat(conversationList.length, " groupNums=").concat(this.groupMap.size));

        if (this.groupMap.size === 0) {
          this.tempConversationList = conversationList; // 若有会话列表更新，但本地没有群组，则将更新的会话列表暂存，后续同步群组列表或者调用 getGroupList 接口时再更新

          return;
        } // 是否有群组的 lastMessage 更新


        var hasGroupUpdated = false;
        var conversation;
        var groupID;
        var group;

        for (var i = 0, length = conversationList.length; i < length; i++) {
          conversation = conversationList[i];

          if (!conversation.conversationID || conversation.type === TYPES.CONV_GROUP) {
            continue;
          }

          groupID = conversation.conversationID.split(/^GROUP/)[1];
          group = this.getLocalGroupProfile(groupID);

          if (group) {
            group.lastMessage = conversation.lastMessage;
            hasGroupUpdated = true;
          }
        } // 若有更新则需要排序群组列表


        if (hasGroupUpdated) {
          // 根据最后一条消息时间戳排序群组
          this.groupMap = this._sortLocalGroupList(this.groupMap);
          this.emitGroupListUpdate(true, false);
        }
      }
      /**
       * 对群组列表排序
       * @private
       * @param {Map} groupMap
       */

    }, {
      key: "_sortLocalGroupList",
      value: function _sortLocalGroupList(groupMap) {
        var tempGroups = _toConsumableArray(groupMap).filter(function (_ref39) {
          var _ref40 = _slicedToArray(_ref39, 2),
              key = _ref40[0],
              value = _ref40[1];

          return !isEmpty(value.lastMessage);
        }); // 1.筛选出有 lastMessage的群组


        tempGroups.sort(function (a, b) {
          return b[1].lastMessage.lastTime - a[1].lastMessage.lastTime;
        });
        return new Map([].concat(_toConsumableArray(tempGroups), _toConsumableArray(groupMap)));
      }
      /**
       * 获取本地缓存的groupList
       * @private
       * @returns {Array}
       * @memberof GroupController
       */

    }, {
      key: "_getStorageGroupList",
      value: function _getStorageGroupList() {
        return this.tim.storage.getItem('groupMap');
      }
      /**
       * 更新本地缓存
       * @private
       * @param {Object} groupMap
       * @memberof GroupController
       */

    }, {
      key: "_setStorageGroupList",
      value: function _setStorageGroupList() {
        var localGroupList = this.getLocalGroups(); // 本地只缓存20个群组，AVChatRoom 类型不缓存

        var tempGroupList = localGroupList.filter(function (_ref41) {
          var type = _ref41.type;
          return !isAVChatRoom(type);
        }).slice(0, 20).map(function (_ref42) {
          var groupID = _ref42.groupID,
              name = _ref42.name,
              avatar = _ref42.avatar,
              type = _ref42.type;
          return {
            groupID: groupID,
            name: name,
            avatar: avatar,
            type: type
          };
        });
        this.tim.storage.setItem('groupMap', tempGroupList);
      }
      /**
       * 更新 groupMap
       * @private
       * @param {Array} groups 后端返回的group数组
       * @memberof GroupController
       */

    }, {
      key: "updateGroupMap",
      value: function updateGroupMap(groups) {
        var _this22 = this;

        groups.forEach(function (group) {
          if (_this22.groupMap.has(group.groupID)) {
            _this22.groupMap.get(group.groupID).updateGroup(group);
          } else {
            _this22.groupMap.set(group.groupID, new Group(group));
          }
        });

        this._setStorageGroupList();
      }
      /**
       * 更新本地 groupMemberMap
       * @param {String} groupID 群 ID
       * @param {Object[]} members 后端返回的群成员数组
       * @returns {GroupMember[]}
       * @memberof GroupController
       */

    }, {
      key: "_updateLocalGroupMemberMap",
      value: function _updateLocalGroupMemberMap(groupID, members) {
        var _this23 = this;

        if (!isArray(members) || members.length === 0) {
          return [];
        }

        var result = members.map(function (member) {
          // 1. 更新member
          if (_this23.hasLocalGroupMember(groupID, member.userID)) {
            _this23.getLocalGroupMemberInfo(groupID, member.userID).updateMember(member);
          } else {
            // 2. 本地无群成员，则新增member
            _this23.setLocalGroupMember(groupID, new GroupMember(member));
          }

          return _this23.getLocalGroupMemberInfo(groupID, member.userID);
        });
        return result;
      }
      /**
       * 批量删除内存中的群成员
       * @param {String} groupID 群 ID
       * @param {string[]} userIDList 用户 ID 列表
       */

    }, {
      key: "deleteLocalGroupMembers",
      value: function deleteLocalGroupMembers(groupID, userIDList) {
        var groupMemberMap = this.groupMemberListMap.get(groupID);

        if (groupMemberMap) {
          userIDList.forEach(function (userID) {
            groupMemberMap["delete"](userID);
          });
        }
      }
      /**
       * 修改群成员资料接口
       * 内部使用，有几个接口是基于该接口实现的。
       * @private
       * @param {Object} options
       */

    }, {
      key: "_modifyGroupMemberInfo",
      value: function _modifyGroupMemberInfo(options) {
        var _this24 = this;

        var groupID = options.groupID,
            userID = options.userID;
        return this.request({
          name: 'group',
          action: 'modifyGroupMemberInfo',
          param: options
        }).then(function () {
          // 本地有 Member 则更新本地
          if (_this24.hasLocalGroupMember(groupID, userID)) {
            var member = _this24.getLocalGroupMemberInfo(groupID, userID);

            if (!isUndefined(options.muteTime)) {
              member.updateMuteUntil(options.muteTime);
            }

            if (!isUndefined(options.role)) {
              member.updateRole(options.role);
            }

            if (!isUndefined(options.nameCard)) {
              member.updateNameCard(options.nameCard);
            }

            if (!isUndefined(options.memberCustomField)) {
              member.updateMemberCustomField(options.memberCustomField);
            }

            return member;
          } // 本地没有 Member，则拉取群成员资料


          return _this24.getGroupMemberProfile({
            groupID: groupID,
            userIDList: [userID]
          }).then(function (_ref43) {
            var _ref43$data$memberLis = _slicedToArray(_ref43.data.memberList, 1),
                member = _ref43$data$memberLis[0];

            return member;
          });
        });
      }
      /**
       * 去除本地 groupMap 中比远端多出的group
       * 不直接清空群组列表是因为群组中维护了 lastMessage 字段，拉取远端群组列表后是没有该字段的，直接清空会导致该字段丢失
       * @param {Object[]} nextGroups
       */

    }, {
      key: "_groupListTreeShaking",
      value: function _groupListTreeShaking(nextGroups) {
        var tempGroupList = new Map(_toConsumableArray(this.groupMap));

        for (var i = 0, len = nextGroups.length; i < len; i++) {
          tempGroupList["delete"](nextGroups[i].groupID);
        } // 后端返回的群组列表不包括 已加入（正在轮询的）的AVChatRoom，故需忽略


        if (this.AVChatRoomHandler.hasJoinedAVChatRoom()) {
          tempGroupList["delete"](this.AVChatRoomHandler.group.groupID);
        }

        var groupsToDelete = _toConsumableArray(tempGroupList.keys());

        for (var _i = 0, _len = groupsToDelete.length; _i < _len; _i++) {
          this.groupMap["delete"](groupsToDelete[_i]);
        }
      }
      /**
       * 资料变更时更新群组中群成员的nick & avatar
       * 包括自己资料变更和好友资料变更
       */

    }, {
      key: "_handleProfileUpdated",
      value: function _handleProfileUpdated(_ref44) {
        var _this25 = this;

        var profiles = _ref44.data;

        var _loop = function _loop(i) {
          var profile = profiles[i];

          _this25.groupMemberListMap.forEach(function (groupMemberMap) {
            if (groupMemberMap.has(profile.userID)) {
              groupMemberMap.get(profile.userID).updateMember({
                nick: profile.nick,
                avatar: profile.avatar
              });
            }
          });
        };

        for (var i = 0; i < profiles.length; i++) {
          _loop(i);
        }
      }
      /**
       * 获取已加入的AVChatRoom
       * @returns {Group|null}
       */

    }, {
      key: "getJoinedAVChatRoom",
      value: function getJoinedAVChatRoom() {
        return this.AVChatRoomHandler.getJoinedAVChatRoom();
      }
      /**
       * 清理本地群组和会话
       * @param {String} groupID 群 ID
       */

    }, {
      key: "deleteLocalGroupAndConversation",
      value: function deleteLocalGroupAndConversation(groupID) {
        // 1. 删除本地的群组
        this._deleteLocalGroup(groupID); // 2. 删除对应的群组会话


        this.tim.conversationController.deleteLocalConversation("GROUP".concat(groupID)); // 3. 抛外部事件

        this.emitGroupListUpdate(true, false);
      }
      /**
       * 判断某群是否是已加入的 AVChatRoom
       * @param {String} groupID 群ID
       * @returns {Boolean}
       * @memberof GroupController
       */

    }, {
      key: "checkJoinedAVChatRoomByID",
      value: function checkJoinedAVChatRoomByID(groupID) {
        return this.AVChatRoomHandler.checkJoinedAVChatRoomByID(groupID);
      }
      /**
       * 获取某个群的 lastSequence 字段
       * @param {String} groupID 群 ID
       * @returns {Promise}
       * @memberof GroupController
       */

    }, {
      key: "getGroupLastSequence",
      value: function getGroupLastSequence(groupID) {
        var _this26 = this;

        var ssoLog = new SSOLogData();
        ssoLog.setMethod(SSOMethods.GET_GROUP_LAST_SEQUENCE).setStart();
        var lastSequence = 0; // 1.优先从本地群组列表获取

        if (this.hasLocalGroup(groupID)) {
          var group = this.getLocalGroupProfile(groupID);

          if (group.lastMessage.lastSequence > 0) {
            lastSequence = group.lastMessage.lastSequence;
            logger.log("GroupController.getGroupLastSequence got lastSequence=".concat(lastSequence, " from local group profile[lastMessage.lastSequence]. groupID=").concat(groupID));
            ssoLog.setCode(0).setNetworkType(this.getNetworkType()).setText("got lastSequence=".concat(lastSequence, " from local group profile[lastMessage.lastSequence]. groupID=").concat(groupID)).setEnd();
            return Promise.resolve(lastSequence);
          }

          if (group.nextMessageSeq > 1) {
            lastSequence = group.nextMessageSeq - 1;
            logger.log("GroupController.getGroupLastSequence got lastSequence=".concat(lastSequence, " from local group profile[nextMessageSeq]. groupID=").concat(groupID));
            ssoLog.setCode(0).setNetworkType(this.getNetworkType()).setText("got lastSequence=".concat(lastSequence, " from local group profile[nextMessageSeq]. groupID=").concat(groupID)).setEnd();
            return Promise.resolve(lastSequence);
          }
        } // 2.其次从会话列表中获取


        var conversationID = "GROUP".concat(groupID);
        var conversation = this.tim.conversationController.getLocalConversation(conversationID);

        if (conversation && conversation.lastMessage.lastSequence) {
          lastSequence = conversation.lastMessage.lastSequence;
          logger.log("GroupController.getGroupLastSequence got lastSequence=".concat(lastSequence, " from local conversation profile[lastMessage.lastSequence]. groupID=").concat(groupID));
          ssoLog.setCode(0).setNetworkType(this.getNetworkType()).setText("got lastSequence=".concat(lastSequence, " from local conversation profile[lastMessage.lastSequence]. groupID=").concat(groupID)).setEnd();
          return Promise.resolve(lastSequence);
        } // 3.本地找不到 lastSequnce 时，从后台拉取


        var groupProfileOptions = {
          groupIDList: [groupID],
          responseFilter: {
            groupBaseInfoFilter: ['NextMsgSeq']
          }
        };
        return this.getGroupProfileAdvance(groupProfileOptions).then(function (_ref45) {
          var successGroupList = _ref45.data.successGroupList;

          if (isEmpty(successGroupList)) {
            logger.log("GroupController.getGroupLastSequence successGroupList is empty. groupID=".concat(groupID));
          } else {
            lastSequence = successGroupList[0].nextMessageSeq - 1;
            logger.log("GroupController.getGroupLastSequence got lastSequence=".concat(lastSequence, " from getGroupProfileAdvance. groupID=").concat(groupID));
          }

          ssoLog.setCode(0).setNetworkType(_this26.getNetworkType()).setText("got lastSequence=".concat(lastSequence, " from getGroupProfileAdvance. groupID=").concat(groupID)).setEnd();
          return lastSequence;
        })["catch"](function (error) {
          // event stat
          _this26.probeNetwork().then(function (_ref46) {
            var _ref47 = _slicedToArray(_ref46, 2),
                bOnline = _ref47[0],
                networkType = _ref47[1];

            ssoLog.setError(error, bOnline, networkType).setText("get lastSequence failed from getGroupProfileAdvance. groupID=".concat(groupID)).setEnd();
          });

          logger.warn("GroupController.getGroupLastSequence failed. ".concat(error));
          return IMPromise.reject(error);
        });
      }
    }, {
      key: "reset",
      value: function reset() {
        this.groupMap.clear();
        this.groupMemberListMap.clear();
        this.resetReady();
        this.groupNoticeHandler.reset();
        this.AVChatRoomHandler.reset(); // 退出登录时，停止AVChatRoom轮询，并且清理相关数据

        this.tim.innerEmitter.once(TIM_INNER_EVENT.CONTEXT_A2KEY_AND_TINYID_UPDATED, this._initGroupList, this);
      }
    }]);

    return GroupController;
  }(IMController);

  /**
   * SDK运行状态
   */

  var StatusController =
  /*#__PURE__*/
  function (_IMController) {
    _inherits(StatusController, _IMController);

    /**
     * 构造函数
     * @param {SDK} tim - SDK 实例
     */
    function StatusController(tim) {
      var _this;

      _classCallCheck(this, StatusController);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(StatusController).call(this, tim)); // 实时消息超时时间，毫秒，服务端为2分钟，为了保险起见，这里配置为1分50秒

      _this.REALTIME_MESSAGE_TIMEOUT = 110000; // longpollingID 超时时间，毫秒，服务端配置为5分钟

      _this.LONGPOLLING_ID_TIMEOUT = 300000; // 默认已连上网

      _this._currentState = TYPES.NET_STATE_CONNECTED;
      _this._status = {
        OPENIM: {
          // openim 指的是普通长轮询通道，
          lastResponseReceivedTime: 0,
          // 上一次SDK收到response的时间戳
          jitterCount: 0,
          // 网络抖动次数
          failedCount: 0 // 失败次数

        },
        AVCHATROOM: {
          // 指的是 avchatrooom 群里的长轮询
          lastResponseReceivedTime: 0,
          jitterCount: 0,
          failedCount: 0
        }
      };
      var innerEmitter = _this.tim.innerEmitter;
      innerEmitter.on(TIM_INNER_EVENT.NOTICE_LONGPOLL_GET_ID_FAILED, _this._onGetLongPollIDFailed, _assertThisInitialized(_this)); // openim

      innerEmitter.on(TIM_INNER_EVENT.NOTICE_LONGPOLL_RESPONSE_OK, _this._onOpenIMResponseOK, _assertThisInitialized(_this));
      innerEmitter.on(TIM_INNER_EVENT.NOTICE_LONGPOLL_REQUEST_FAILED, _this._onOpenIMRequestFailed, _assertThisInitialized(_this)); // avchatroom

      innerEmitter.on(TIM_INNER_EVENT.AV_LONGPOLL_RESPONSE_OK, _this._onAVChatroomResponseOK, _assertThisInitialized(_this));
      innerEmitter.on(TIM_INNER_EVENT.AV_LONGPOLL_REQUEST_FAILED, _this._onAVChatroomRequestFailed, _assertThisInitialized(_this));
      return _this;
    } // 获取 longpollID 失败时将状态切换为 disconnected，因为此时 sdk 已经无法正常收消息了
    // disconnected 可以提醒接入侧检查网络情况，重新走登录流程


    _createClass(StatusController, [{
      key: "_onGetLongPollIDFailed",
      value: function _onGetLongPollIDFailed() {
        if (this._currentState !== TYPES.NET_STATE_DISCONNECTED) {
          this._emitNetStateChangeEvent(TYPES.NET_STATE_DISCONNECTED);
        }
      }
    }, {
      key: "_onOpenIMResponseOK",
      value: function _onOpenIMResponseOK() {
        this._onResponseOK('OPENIM');
      }
    }, {
      key: "_onOpenIMRequestFailed",
      value: function _onOpenIMRequestFailed() {
        this._onRequestFailed('OPENIM');
      }
    }, {
      key: "_onAVChatroomResponseOK",
      value: function _onAVChatroomResponseOK() {
        // 处于登录态时的网络状态变更，由OPENIM驱动，忽略AVCHATROOM
        // 匿名进入avchatroom的场景，则由AVCHATROOM驱动，因为此时没有OPENIM
        if (this.isLoggedIn()) {
          return;
        }

        this._onResponseOK('AVCHATROOM');
      }
    }, {
      key: "_onAVChatroomRequestFailed",
      value: function _onAVChatroomRequestFailed() {
        // 处于登录态时的网络状态变更，由OPENIM驱动，忽略AVCHATROOM
        // 匿名进入avchatroom的场景，则由AVCHATROOM驱动，因为此时没有OPENIM
        if (this.isLoggedIn()) {
          return;
        }

        this._onRequestFailed('AVCHATROOM');
      } // 收到正常response

    }, {
      key: "_onResponseOK",
      value: function _onResponseOK(key) {
        var data = this._status[key];
        var now = Date.now();

        if (data.lastResponseReceivedTime === 0) {
          data.lastResponseReceivedTime = now;
          return;
        }

        var interval = now - data.lastResponseReceivedTime;
        logger.debug("StatusController._onResponseOK key=".concat(key, " currentState=").concat(this._currentState, " interval=").concat(interval, " failedCount=").concat(data.failedCount, " jitterCount=").concat(data.jitterCount)); // response ok，则_failedCount清零

        if (data.failedCount > 0) {
          data.failedCount = 0; // 说明有网络抖动，即“时好时坏”，抖动次数+1

          data.jitterCount += 1;

          if (this._currentState !== TYPES.NET_STATE_CONNECTED) {
            this._emitNetStateChangeEvent(TYPES.NET_STATE_CONNECTED);
          }
        }

        if (interval <= this.REALTIME_MESSAGE_TIMEOUT) {
          if (data.jitterCount >= 3) {
            // event stat
            var ssoLog = new SSOLogData();
            ssoLog.setMethod(SSOMethods.NETWORK_JITTER).setStart();
            ssoLog.setCode(0).setText("".concat(key, "-").concat(interval, "-").concat(data.jitterCount)).setNetworkType(this.getNetworkType()).setEnd();
            data.jitterCount = 0;
          }
        } else if (interval >= this.REALTIME_MESSAGE_TIMEOUT && interval < this.LONGPOLLING_ID_TIMEOUT) {
          // event stat
          var _ssoLog = new SSOLogData();

          _ssoLog.setMethod(SSOMethods.FAST_START).setStart();

          _ssoLog.setCode(0).setText("".concat(key, "-").concat(interval)).setNetworkType(this.getNetworkType()).setEnd(); // 快启动，即停掉当前轮询，走同步未读重启长轮询


          logger.warn("StatusController._onResponseOK, fast start. key=".concat(key, " interval=").concat(interval, " ms"));
          this.emitInnerEvent(TIM_INNER_EVENT.NOTICE_LONGPOLL_FAST_START);
        } else if (interval >= this.LONGPOLLING_ID_TIMEOUT) {
          // event stat
          var _ssoLog2 = new SSOLogData();

          _ssoLog2.setMethod(SSOMethods.SLOW_START).setStart();

          _ssoLog2.setCode(0).setText("".concat(key, "-").concat(interval)).setNetworkType(this.getNetworkType()).setEnd(); // 慢启动，即停掉当前轮询，走登录重新启动长轮询


          logger.warn("StatusController._onResponseOK, slow start. key=".concat(key, " interval=").concat(interval, " ms"));
          this.emitInnerEvent(TIM_INNER_EVENT.NOTICE_LONGPOLL_SLOW_START);
        }

        data.lastResponseReceivedTime = now;
      } // 请求失败

    }, {
      key: "_onRequestFailed",
      value: function _onRequestFailed(key) {
        var _this2 = this;

        var data = this._status[key]; // 距离上次成功收到response已经过去5min，sdk的主动重试很可能无法恢复长轮询通道的正常运行了
        // 通知给接入侧，接入侧可根据这个事件检查网络或者重新走登录流程

        var now = Date.now();

        if (now - data.lastResponseReceivedTime >= this.LONGPOLLING_ID_TIMEOUT) {
          if (this._currentState !== TYPES.NET_STATE_DISCONNECTED) {
            logger.warn("StatusController._onRequestFailed, disconnected, longpolling unavailable more than 5min. key=".concat(key, " networkType=").concat(this.getNetworkType()));

            this._emitNetStateChangeEvent(TYPES.NET_STATE_DISCONNECTED);
          }

          return;
        }

        data.failedCount += 1; // 连续5次失败（实际上不止5次，比如一个请求如果失败，会自动重试两次）

        if (data.failedCount > 5) {
          // 探测下此时的网络情况
          this.probeNetwork().then(function (_ref) {
            var _ref2 = _slicedToArray(_ref, 2),
                bOnline = _ref2[0],
                networkType = _ref2[1];

            if (bOnline) {
              // 能联网，但是 longpolling 请求失败（往往是因为超时），这种认为是网络抖动
              if (_this2._currentState !== TYPES.NET_STATE_CONNECTING) {
                _this2._emitNetStateChangeEvent(TYPES.NET_STATE_CONNECTING);
              }

              logger.warn("StatusController._onRequestFailed, connecting, network jitter. key=".concat(key, " networkType=").concat(networkType));
            } else {
              if (_this2._currentState !== TYPES.NET_STATE_DISCONNECTED) {
                _this2._emitNetStateChangeEvent(TYPES.NET_STATE_DISCONNECTED);
              }

              logger.warn("StatusController._onRequestFailed, disconnected, longpolling unavailable. key=".concat(key, " networkType=").concat(networkType));
            }

            data.failedCount = 0; // 派发事件后清零

            data.jitterCount = 0;
          });
        } else {
          // 请求失败时，当前状态是 'connected' 才能转变成 'connecting'，避免重复派发和状态的错误反转
          if (this._currentState === TYPES.NET_STATE_CONNECTED) {
            this._emitNetStateChangeEvent(TYPES.NET_STATE_CONNECTING);
          }
        }
      }
    }, {
      key: "_emitNetStateChangeEvent",
      value: function _emitNetStateChangeEvent(latestState) {
        logger.log("StatusController._emitNetStateChangeEvent net state changed from ".concat(this._currentState, " to ").concat(latestState));
        this._currentState = latestState;
        this.emitOuterEvent(TIM_OUTER_EVENT.NET_STATE_CHANGE, {
          state: latestState
        });
      }
    }, {
      key: "reset",
      value: function reset() {
        logger.log('StatusController.reset');
        this._currentState = TYPES.NET_STATE_CONNECTED;
        this._status = {
          OPENIM: {
            // openim 指的是普通长轮询通道，
            lastResponseReceivedTime: 0,
            // 上一次SDK收到response的时间戳
            jitterCount: 0,
            // 网络抖动次数
            failedCount: 0 // 失败次数

          },
          AVCHATROOM: {
            // 指的是 avchatrooom 群里的长轮询
            lastResponseReceivedTime: 0,
            jitterCount: 0,
            failedCount: 0
          }
        };
      }
    }]);

    return StatusController;
  }(IMController);

  function emptyFunction() {
    return null;
  }
  /**
   * Storage类，兼容Web端和WX小程序端
   * 使用方法：该实例挂载在tim实例下，可以通过this.tim.storage.getItem(key)调用。
   * @class Storage
   * @author rychouwei
   */


  var Storage =
  /*#__PURE__*/
  function () {
    function Storage(tim) {
      _classCallCheck(this, Storage);

      this.tim = tim;
      this.isWX = IN_WX_MINI_APP;
      this.storageQueue = new Map(); // 存储队列，结构为Map<string, *>

      this.checkTimes = 0;
      this.checkTimer = setInterval(this._onCheckTimer.bind(this), 1000);

      this._errorTolerantHandle();
    }
    /**
     * 容错处理
     * 不支持localstorage的浏览器则用空函数替代
     * @memberof Storage
     */


    _createClass(Storage, [{
      key: "_errorTolerantHandle",
      value: function _errorTolerantHandle() {
        if (!this.isWX && isUndefined(window.localStorage)) {
          this.getItem = emptyFunction;
          this.setItem = emptyFunction;
          this.removeItem = emptyFunction;
          this.clear = emptyFunction;
        }
      }
    }, {
      key: "_onCheckTimer",
      value: function _onCheckTimer() {
        this.checkTimes++; // 每20s检查一次

        if (this.checkTimes % 20 === 0) {
          if (this.storageQueue.size === 0) {
            return;
          }

          this._doFlush();
        }
      } // 将存储队列的消息写入本地缓存，并清空存储队列

    }, {
      key: "_doFlush",
      value: function _doFlush() {
        try {
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            for (var _iterator = this.storageQueue[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var _step$value = _slicedToArray(_step.value, 2),
                  key = _step$value[0],
                  value = _step$value[1];

              if (this.isWX) {
                wx.setStorageSync(this._getKey(key), value);
              } else {
                localStorage.setItem(this._getKey(key), JSON.stringify(value));
              }
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                _iterator["return"]();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }

          this.storageQueue.clear();
        } catch (error) {
          logger.warn('Storage._doFlush error', error);
        }
      }
    }, {
      key: "_getPrefix",
      value: function _getPrefix() {
        var _this$tim$loginInfo = this.tim.loginInfo,
            SDKAppID = _this$tim$loginInfo.SDKAppID,
            identifier = _this$tim$loginInfo.identifier;
        return "TIM_".concat(SDKAppID, "_").concat(identifier, "_");
      }
      /**
       * 获取storage中的一条数据
       * @param {String} key
       * @param {Boolean} withPrefix 是否需要拼接 prefix 和 key，默认为 true，即需要拼接。
       * @returns 返回指定key的数据
       * @memberof StorageController
       */

    }, {
      key: "getItem",
      value: function getItem(key) {
        var withPrefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

        try {
          var realKey = withPrefix ? this._getKey(key) : key;

          if (this.isWX) {
            return wx.getStorageSync(realKey);
          }

          return JSON.parse(localStorage.getItem(realKey));
        } catch (error) {
          logger.warn('Storage.getItem error:', error);
        }
      }
      /**
       * 设置storage中的一条数据。若key已存在，则会覆盖已有数据。
       * @param {String} key
       * @param {*} value - 任何可JSON序列化的数据
       * @param {Boolean} bFlushAtOnce - true 立即写入本地缓存；false 定时写入，默认 false
       * @param {Boolean} withPrefix 是否需要拼接 prefix 和 key，默认为 true，即需要拼接。
       * @memberof StorageController
       */

    }, {
      key: "setItem",
      value: function setItem(key, value) {
        var bFlushAtOnce = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var withPrefix = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;

        if (!bFlushAtOnce) {
          // 定时写入的数据先存到队列
          this.storageQueue.set(key, value);
        } else {
          var realKey = withPrefix ? this._getKey(key) : key;

          if (this.isWX) {
            wx.setStorageSync(realKey, value);
          } else {
            localStorage.setItem(realKey, JSON.stringify(value));
          }
        }
      }
      /**
       * 清除缓存数据
       * @memberof StorageController
       */

    }, {
      key: "clear",
      value: function clear() {
        try {
          if (this.isWX) {
            wx.clearStorageSync();
          } else {
            localStorage.clear();
          }
        } catch (error) {
          logger.warn('Storage.clear error:', error);
        }
      }
      /**
       * 删除指定key的数据
       * @param {String} key
       * @param {Boolean} withPrefix 是否需要拼接 prefix 和 key，默认为 true，即需要拼接。
       * @memberof StorageController
       */

    }, {
      key: "removeItem",
      value: function removeItem(key) {
        var withPrefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

        try {
          var realKey = withPrefix ? this._getKey(key) : key;

          if (this.isWX) {
            wx.removeStorageSync(realKey);
          } else {
            localStorage.removeItem(realKey);
          }
        } catch (error) {
          logger.warn('Storage.removeItem error:', error);
        }
      }
      /**
       * 获取本地已用缓存大小。计算规则：key的占用加上value的占用
       * @param {String} [key] - 需要查询哪个key空间占用，不传则不区分key
       * @param {String} [unit] - 单位，默认为b，可选值有：b,kb,mb
       * @returns {Object} 返回查询结果对象
       * @memberof Storage
       * @example
       * const result = app.storage.getSize('conversationList')
       *
       * //返回
       * result:{ // 默认单位都是Byte
       *  size: 100, // 空间占用
       *  limitSize: 5242880, // 最大缓存空间大小
       *  leftSize: 5242780 // 剩余可用大小
       * }
       */

    }, {
      key: "getSize",
      value: function getSize(key) {
        var _this = this;

        var unit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'b';

        try {
          var result = {
            size: 0,
            limitSize: 5 * 1024 * 1024,
            unit: unit
          };
          Object.defineProperty(result, 'leftSize', {
            enumerable: true,
            get: function get() {
              return result.limitSize - result.size;
            }
          }); // 小程序环境则设置limitSize

          if (this.isWX) {
            result.limitSize = wx.getStorageInfoSync().limitSize * 1024;
          } // 单独计算某个key的占用


          if (key) {
            result.size = JSON.stringify(this.getItem(key)).length + this._getKey(key).length;
          } else {
            // 计算全部占用
            if (this.isWX) {
              // 计算微信小程序环境的全部占用
              var _wx$getStorageInfoSyn = wx.getStorageInfoSync(),
                  keys = _wx$getStorageInfoSyn.keys;

              keys.forEach(function (_key) {
                result.size += JSON.stringify(wx.getStorageSync(_key)).length + _this._getKey(_key).length;
              });
            } else {
              // 计算Web环境全部占用
              for (var item in localStorage) {
                if (localStorage.hasOwnProperty(item)) {
                  result.size += localStorage.getItem(item).length + item.length;
                }
              }
            }
          }

          return this._convertUnit(result);
        } catch (error) {
          logger.warn('Storage.getSize error:', error);
        }
      }
      /**
       * 单位转换器
       * @private
       * @param {Object} object
       * @param {String} unit - b/kb/mb
       * @returns {Object} 转换后的对象
       * @memberof Storage
       *
       */

    }, {
      key: "_convertUnit",
      value: function _convertUnit(object) {
        var result = {};
        var unit = object.unit;
        result['unit'] = unit;

        for (var key in object) {
          if (typeof object[key] !== 'number') continue;

          if (unit.toLowerCase() === 'kb') {
            result[key] = Math.round(object[key] / 1024);
          } else if (unit.toLowerCase() === 'mb') {
            result[key] = Math.round(object[key] / 1024 / 1024);
          } else {
            result[key] = object[key];
          }
        }

        return result;
      }
      /**
       * 拼接key
       * @private
       * @param {String} key
       * @returns {String}
       * @memberof Storage
       */

    }, {
      key: "_getKey",
      value: function _getKey(key) {
        return "".concat(this._getPrefix()).concat(key);
      }
    }, {
      key: "reset",
      value: function reset() {
        this._doFlush();

        this.checkTimes = 0;
      }
    }]);

    return Storage;
  }();

  var eventemitter3 = createCommonjsModule(function (module) {

  var has = Object.prototype.hasOwnProperty
    , prefix = '~';

  /**
   * Constructor to create a storage for our `EE` objects.
   * An `Events` instance is a plain object whose properties are event names.
   *
   * @constructor
   * @private
   */
  function Events() {}

  //
  // We try to not inherit from `Object.prototype`. In some engines creating an
  // instance in this way is faster than calling `Object.create(null)` directly.
  // If `Object.create(null)` is not supported we prefix the event names with a
  // character to make sure that the built-in object properties are not
  // overridden or used as an attack vector.
  //
  if (Object.create) {
    Events.prototype = Object.create(null);

    //
    // This hack is needed because the `__proto__` property is still inherited in
    // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.
    //
    if (!new Events().__proto__) prefix = false;
  }

  /**
   * Representation of a single event listener.
   *
   * @param {Function} fn The listener function.
   * @param {*} context The context to invoke the listener with.
   * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
   * @constructor
   * @private
   */
  function EE(fn, context, once) {
    this.fn = fn;
    this.context = context;
    this.once = once || false;
  }

  /**
   * Add a listener for a given event.
   *
   * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
   * @param {(String|Symbol)} event The event name.
   * @param {Function} fn The listener function.
   * @param {*} context The context to invoke the listener with.
   * @param {Boolean} once Specify if the listener is a one-time listener.
   * @returns {EventEmitter}
   * @private
   */
  function addListener(emitter, event, fn, context, once) {
    if (typeof fn !== 'function') {
      throw new TypeError('The listener must be a function');
    }

    var listener = new EE(fn, context || emitter, once)
      , evt = prefix ? prefix + event : event;

    if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
    else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
    else emitter._events[evt] = [emitter._events[evt], listener];

    return emitter;
  }

  /**
   * Clear event by name.
   *
   * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
   * @param {(String|Symbol)} evt The Event name.
   * @private
   */
  function clearEvent(emitter, evt) {
    if (--emitter._eventsCount === 0) emitter._events = new Events();
    else delete emitter._events[evt];
  }

  /**
   * Minimal `EventEmitter` interface that is molded against the Node.js
   * `EventEmitter` interface.
   *
   * @constructor
   * @public
   */
  function EventEmitter() {
    this._events = new Events();
    this._eventsCount = 0;
  }

  /**
   * Return an array listing the events for which the emitter has registered
   * listeners.
   *
   * @returns {Array}
   * @public
   */
  EventEmitter.prototype.eventNames = function eventNames() {
    var names = []
      , events
      , name;

    if (this._eventsCount === 0) return names;

    for (name in (events = this._events)) {
      if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
    }

    if (Object.getOwnPropertySymbols) {
      return names.concat(Object.getOwnPropertySymbols(events));
    }

    return names;
  };

  /**
   * Return the listeners registered for a given event.
   *
   * @param {(String|Symbol)} event The event name.
   * @returns {Array} The registered listeners.
   * @public
   */
  EventEmitter.prototype.listeners = function listeners(event) {
    var evt = prefix ? prefix + event : event
      , handlers = this._events[evt];

    if (!handlers) return [];
    if (handlers.fn) return [handlers.fn];

    for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
      ee[i] = handlers[i].fn;
    }

    return ee;
  };

  /**
   * Return the number of listeners listening to a given event.
   *
   * @param {(String|Symbol)} event The event name.
   * @returns {Number} The number of listeners.
   * @public
   */
  EventEmitter.prototype.listenerCount = function listenerCount(event) {
    var evt = prefix ? prefix + event : event
      , listeners = this._events[evt];

    if (!listeners) return 0;
    if (listeners.fn) return 1;
    return listeners.length;
  };

  /**
   * Calls each of the listeners registered for a given event.
   *
   * @param {(String|Symbol)} event The event name.
   * @returns {Boolean} `true` if the event had listeners, else `false`.
   * @public
   */
  EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
    var evt = prefix ? prefix + event : event;

    if (!this._events[evt]) return false;

    var listeners = this._events[evt]
      , len = arguments.length
      , args
      , i;

    if (listeners.fn) {
      if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);

      switch (len) {
        case 1: return listeners.fn.call(listeners.context), true;
        case 2: return listeners.fn.call(listeners.context, a1), true;
        case 3: return listeners.fn.call(listeners.context, a1, a2), true;
        case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
        case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
        case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
      }

      for (i = 1, args = new Array(len -1); i < len; i++) {
        args[i - 1] = arguments[i];
      }

      listeners.fn.apply(listeners.context, args);
    } else {
      var length = listeners.length
        , j;

      for (i = 0; i < length; i++) {
        if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);

        switch (len) {
          case 1: listeners[i].fn.call(listeners[i].context); break;
          case 2: listeners[i].fn.call(listeners[i].context, a1); break;
          case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;
          case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;
          default:
            if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {
              args[j - 1] = arguments[j];
            }

            listeners[i].fn.apply(listeners[i].context, args);
        }
      }
    }

    return true;
  };

  /**
   * Add a listener for a given event.
   *
   * @param {(String|Symbol)} event The event name.
   * @param {Function} fn The listener function.
   * @param {*} [context=this] The context to invoke the listener with.
   * @returns {EventEmitter} `this`.
   * @public
   */
  EventEmitter.prototype.on = function on(event, fn, context) {
    return addListener(this, event, fn, context, false);
  };

  /**
   * Add a one-time listener for a given event.
   *
   * @param {(String|Symbol)} event The event name.
   * @param {Function} fn The listener function.
   * @param {*} [context=this] The context to invoke the listener with.
   * @returns {EventEmitter} `this`.
   * @public
   */
  EventEmitter.prototype.once = function once(event, fn, context) {
    return addListener(this, event, fn, context, true);
  };

  /**
   * Remove the listeners of a given event.
   *
   * @param {(String|Symbol)} event The event name.
   * @param {Function} fn Only remove the listeners that match this function.
   * @param {*} context Only remove the listeners that have this context.
   * @param {Boolean} once Only remove one-time listeners.
   * @returns {EventEmitter} `this`.
   * @public
   */
  EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
    var evt = prefix ? prefix + event : event;

    if (!this._events[evt]) return this;
    if (!fn) {
      clearEvent(this, evt);
      return this;
    }

    var listeners = this._events[evt];

    if (listeners.fn) {
      if (
        listeners.fn === fn &&
        (!once || listeners.once) &&
        (!context || listeners.context === context)
      ) {
        clearEvent(this, evt);
      }
    } else {
      for (var i = 0, events = [], length = listeners.length; i < length; i++) {
        if (
          listeners[i].fn !== fn ||
          (once && !listeners[i].once) ||
          (context && listeners[i].context !== context)
        ) {
          events.push(listeners[i]);
        }
      }

      //
      // Reset the array, or remove it completely if we have no more listeners.
      //
      if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
      else clearEvent(this, evt);
    }

    return this;
  };

  /**
   * Remove all listeners, or those of the specified event.
   *
   * @param {(String|Symbol)} [event] The event name.
   * @returns {EventEmitter} `this`.
   * @public
   */
  EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
    var evt;

    if (event) {
      evt = prefix ? prefix + event : event;
      if (this._events[evt]) clearEvent(this, evt);
    } else {
      this._events = new Events();
      this._eventsCount = 0;
    }

    return this;
  };

  //
  // Alias methods names because people roll like that.
  //
  EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
  EventEmitter.prototype.addListener = EventEmitter.prototype.on;

  //
  // Expose the prefix.
  //
  EventEmitter.prefixed = prefix;

  //
  // Allow `EventEmitter` to be imported as module namespace.
  //
  EventEmitter.EventEmitter = EventEmitter;

  //
  // Expose the module.
  //
  {
    module.exports = EventEmitter;
  }
  });

  var accessLayer = function accessLayer(tim) {
    return {
      create: null,
      query: {
        serverName: SERVER.NAME.WEB_IM,
        cmd: SERVER.CMD.ACCESS_LAYER,
        channel: SERVER.CHANNEL.XHR,
        protocol: PROTOCOL_TYPE.JSON,
        method: 'POST',
        queryString: {
          platform: SDK.PLATFORM,
          identifier: tim.context.identifier,
          usersig: tim.context.userSig,
          contentType: tim.context.contentType,
          apn: tim.context !== null ? tim.context.apn : 1,
          websdkappid: SDK.APPID,
          v: SDK.VERSION
        },
        requestData: {}
      },
      update: null,
      "delete": null
    };
  };

  var login = function login(tim) {
    var keyMaps = {
      request: {
        tinyID: 'tinyId'
      },
      response: {
        TinyId: 'tinyID'
      }
    };
    return {
      create: null,
      query: {
        serverName: SERVER.NAME.OPEN_IM,
        cmd: SERVER.CMD.LOGIN,
        channel: SERVER.CHANNEL.XHR,
        protocol: PROTOCOL_TYPE.JSON,
        method: 'POST',
        queryString: {
          websdkappid: SDK.APPID,
          v: SDK.VERSION,
          platform: SDK.PLATFORM,
          identifier: tim.loginInfo.identifier,
          usersig: tim.loginInfo.userSig,
          sdkappid: tim.loginInfo.SDKAppID,
          accounttype: tim.loginInfo.accountType,
          contentType: tim.context !== null ? tim.context.contentType : 0,
          apn: tim.context !== null ? tim.context.apn : 1,
          reqtime: +new Date() / 1000
        },
        requestData: {
          state: 'Online'
        },
        keyMaps: keyMaps
      },
      update: null,
      "delete": null
    };
  };

  var logout = function logout(tim) {
    return {
      create: null,
      query: {
        serverName: SERVER.NAME.OPEN_IM,
        cmd: SERVER.CMD.LOGOUT_ALL,
        channel: SERVER.CHANNEL.XHR,
        protocol: PROTOCOL_TYPE.JSON,
        method: 'POST',
        queryString: {
          websdkappid: SDK.APPID,
          v: SDK.VERSION,
          platform: SDK.PLATFORM,
          a2: tim.context !== null ? tim.context.a2Key : '',
          tinyid: tim.context !== null ? tim.context.tinyID : '',
          sdkappid: tim.loginInfo !== null ? tim.loginInfo.SDKAppID : 0,
          contentType: tim.context !== null ? tim.context.contentType : 0,
          apn: tim.context !== null ? tim.context.apn : '',
          reqtime: +new Date() / 1000
        },
        requestData: {}
      },
      update: null,
      "delete": null
    };
  };

  var longPollLogout = function longPollLogout(tim) {
    var keyMaps = {
      request: {
        longPollID: 'LongPollingId'
      }
    };
    return {
      create: null,
      query: {
        serverName: SERVER.NAME.OPEN_IM,
        cmd: SERVER.CMD.LOGOUT_LONG_POLL,
        channel: SERVER.CHANNEL.XHR,
        protocol: PROTOCOL_TYPE.JSON,
        method: 'POST',
        queryString: {
          websdkappid: SDK.APPID,
          v: SDK.VERSION,
          platform: SDK.PLATFORM,
          a2: tim.context !== null ? tim.context.a2Key : '',
          tinyid: tim.context !== null ? tim.context.tinyID : 0,
          sdkappid: tim.context !== null ? tim.context.SDKAppID : 0,
          contentType: tim.context !== null ? tim.context.contentType : 0,
          apn: tim.context !== null ? tim.context.apn : 1,
          reqtime: function reqtime() {
            return Date.now();
          }
        },
        requestData: {
          longPollID: ''
        },
        keyMaps: keyMaps
      },
      update: null,
      "delete": null
    };
  };

  var commonQueryString = function commonQueryString(tim) {
    var a2;
    var tinyid;
    var sdkappid;
    var contentType;
    var apn;

    if (!isEmpty(tim.context)) {
      a2 = tim.context.a2Key;
      tinyid = tim.context.tinyID;
      sdkappid = tim.context.SDKAppID;
      contentType = tim.context.contentType;
      apn = tim.context.apn;
    } else {
      a2 = '';
      tinyid = 0;
      sdkappid = 0;
      contentType = 0;
      apn = 1;
    }

    return {
      platform: SDK.PLATFORM,
      websdkappid: SDK.APPID,
      v: SDK.VERSION,
      a2: a2,
      tinyid: tinyid,
      sdkappid: sdkappid,
      contentType: contentType,
      apn: apn,
      reqtime: function reqtime() {
        return +new Date();
      }
    };
  };

  var conf = function conf(tim) {
    var queryString = commonQueryString(tim);
    var serverName = SERVER.NAME.PROFILE;
    var channel = SERVER.CHANNEL.XHR;
    var protocol = PROTOCOL_TYPE.JSON;
    var requestMethod = 'POST'; // 同时拉取标准资料字段和自定义资料字段

    var keyMaps = {
      request: {
        toAccount: 'To_Account',
        standardSequence: 'StandardSequence',
        customSequence: 'CustomSequence'
      }
    };
    return {
      query: {
        serverName: serverName,
        cmd: SERVER.CMD.PORTRAIT_GET,
        channel: channel,
        protocol: protocol,
        method: requestMethod,
        queryString: queryString,
        requestData: {
          fromAccount: '',
          userItem: []
        },
        keyMaps: keyMaps
      },
      update: {
        serverName: serverName,
        cmd: SERVER.CMD.PORTRAIT_SET,
        channel: channel,
        protocol: protocol,
        method: requestMethod,
        queryString: queryString,
        requestData: {
          fromAccount: '',
          profileItem: [{
            tag: STANDARD_IM_PROFILE.NICK,
            value: ''
          }, // - 昵称
          {
            tag: STANDARD_IM_PROFILE.GENDER,
            value: ''
          }, // - 性别
          {
            tag: STANDARD_IM_PROFILE.ALLOWTYPE,
            value: ''
          }, // - 允许加好友的类型
          {
            tag: STANDARD_IM_PROFILE.AVATAR,
            value: ''
          } // - 头像地址
          ]
        }
      }
    };
  };

  var conf$1 = function conf(tim) {
    var queryString = {
      websdkappid: SDK.APPID,
      v: SDK.VERSION,
      platform: SDK.PLATFORM,
      a2: tim.context !== null && tim.context.a2Key ? tim.context.a2Key : undefined,
      tinyid: tim.context !== null && tim.context.tinyID ? tim.context.tinyID : undefined,
      sdkappid: tim.context !== null ? tim.context.SDKAppID : 0,
      contentType: tim.context !== null ? tim.context.contentType : 0,
      accounttype: tim.context !== null ? tim.context.accountType : 0
    };
    var keyMaps = {
      request: {
        ownerID: 'Owner_Account',
        userID: 'Member_Account',
        newOwnerID: 'NewOwner_Account',
        maxMemberNum: 'MaxMemberCount',
        groupCustomField: 'AppDefinedData',
        memberCustomField: 'AppMemberDefinedData',
        groupCustomFieldFilter: 'AppDefinedDataFilter_Group',
        memberCustomFieldFilter: 'AppDefinedDataFilter_GroupMember',
        messageRemindType: 'MsgFlag',
        userIDList: 'MemberList',
        groupIDList: 'GroupIdList',
        applyMessage: 'ApplyMsg',
        muteTime: 'ShutUpTime',
        joinOption: 'ApplyJoinOption'
      },
      response: {
        GroupIdList: 'groups',
        MsgFlag: 'messageRemindType',
        AppDefinedData: 'groupCustomField',
        AppMemberDefinedData: 'memberCustomField',
        AppDefinedDataFilter_Group: 'groupCustomFieldFilter',
        AppDefinedDataFilter_GroupMember: 'memberCustomFieldFilter',
        InfoSeq: 'infoSequence',
        MemberList: 'members',
        GroupInfo: 'groups',
        ShutUpUntil: 'muteUntil',
        ApplyJoinOption: 'joinOption'
      }
    };
    return {
      create: {
        serverName: SERVER.NAME.GROUP,
        cmd: SERVER.CMD.CREATE_GROUP,
        channel: SERVER.CHANNEL.XHR,
        protocol: PROTOCOL_TYPE.JSON,
        queryString: queryString,
        requestData: {
          type: TYPES.GRP_PRIVATE,
          name: undefined,
          groupID: undefined,
          ownerID: tim.loginInfo.identifier,
          introduction: undefined,
          notification: undefined,
          avatar: undefined,
          maxMemberNum: undefined,
          joinOption: undefined,
          memberList: undefined,
          groupCustomField: undefined
        },
        keyMaps: keyMaps
      },
      list: {
        serverName: SERVER.NAME.GROUP,
        cmd: SERVER.CMD.GET_JOINED_GROUPS,
        channel: SERVER.CHANNEL.XHR,
        protocol: PROTOCOL_TYPE.JSON,
        queryString: queryString,
        requestData: {
          userID: tim.loginInfo.identifier,
          limit: undefined,
          // 拉取多少个，不填表示拉取全部
          offset: undefined,
          // 从第多少个开始拉取
          groupType: undefined,
          // 拉取哪种群组形态，不填为拉取所有
          responseFilter: undefined
        },
        keyMaps: keyMaps
      },
      query: {
        serverName: SERVER.NAME.GROUP,
        cmd: SERVER.CMD.GET_GROUP_INFO,
        channel: SERVER.CHANNEL.XHR,
        protocol: PROTOCOL_TYPE.JSON,
        queryString: queryString,
        requestData: {
          groupIDList: undefined,
          responseFilter: undefined
        },
        keyMaps: keyMaps
      },
      getGroupMemberProfile: {
        serverName: SERVER.NAME.GROUP,
        cmd: SERVER.CMD.GET_GROUP_MEMBER_INFO,
        channel: SERVER.CHANNEL.XHR,
        protocol: PROTOCOL_TYPE.JSON,
        queryString: queryString,
        requestData: {
          groupID: undefined,
          userIDList: undefined,
          memberInfoFilter: undefined,
          memberCustomFieldFilter: undefined
        },
        keyMaps: {
          request: _objectSpread2({}, keyMaps.request, {
            userIDList: 'Member_List_Account'
          }),
          response: keyMaps.response
        }
      },
      getGroupMemberList: {
        serverName: SERVER.NAME.GROUP,
        cmd: SERVER.CMD.GET_GROUP_MEMBER_LIST,
        channel: SERVER.CHANNEL.XHR,
        protocol: PROTOCOL_TYPE.JSON,
        queryString: queryString,
        requestData: {
          groupID: undefined,
          limit: 0,
          offset: 0,
          memberRoleFilter: undefined,
          memberInfoFilter: undefined
        },
        keyMaps: keyMaps
      },
      quitGroup: {
        serverName: SERVER.NAME.GROUP,
        cmd: SERVER.CMD.QUIT_GROUP,
        channel: SERVER.CHANNEL.XHR,
        protocol: PROTOCOL_TYPE.JSON,
        queryString: queryString,
        requestData: {
          groupID: undefined
        }
      },
      changeGroupOwner: {
        serverName: SERVER.NAME.GROUP,
        cmd: SERVER.CMD.CHANGE_GROUP_OWNER,
        channel: SERVER.CHANNEL.XHR,
        protocol: PROTOCOL_TYPE.JSON,
        queryString: queryString,
        requestData: {
          groupID: undefined,
          newOwnerID: undefined
        },
        keyMaps: keyMaps
      },
      destroyGroup: {
        serverName: SERVER.NAME.GROUP,
        cmd: SERVER.CMD.DESTROY_GROUP,
        channel: SERVER.CHANNEL.XHR,
        protocol: PROTOCOL_TYPE.JSON,
        queryString: queryString,
        requestData: {
          groupID: undefined
        }
      },
      updateGroupProfile: {
        serverName: SERVER.NAME.GROUP,
        cmd: SERVER.CMD.MODIFY_GROUP_INFO,
        channel: SERVER.CHANNEL.XHR,
        protocol: PROTOCOL_TYPE.JSON,
        queryString: queryString,
        requestData: {
          groupID: undefined,
          name: undefined,
          introduction: undefined,
          notification: undefined,
          avatar: undefined,
          maxMemberNum: undefined,
          joinOption: undefined,
          groupCustomField: undefined
        },
        keyMaps: {
          request: _objectSpread2({}, keyMaps.request, {
            groupCustomField: 'AppDefinedData'
          }),
          response: keyMaps.response
        }
      },
      modifyGroupMemberInfo: {
        serverName: SERVER.NAME.GROUP,
        cmd: SERVER.CMD.MODIFY_GROUP_MEMBER_INFO,
        channel: SERVER.CHANNEL.XHR,
        protocol: PROTOCOL_TYPE.JSON,
        queryString: queryString,
        requestData: {
          groupID: undefined,
          userID: undefined,
          messageRemindType: undefined,
          nameCard: undefined,
          role: undefined,
          memberCustomField: undefined,
          muteTime: undefined
        },
        keyMaps: keyMaps
      },
      addGroupMember: {
        serverName: SERVER.NAME.GROUP,
        cmd: SERVER.CMD.ADD_GROUP_MEMBER,
        channel: SERVER.CHANNEL.XHR,
        protocol: PROTOCOL_TYPE.JSON,
        queryString: queryString,
        requestData: {
          groupID: undefined,
          silence: undefined,
          userIDList: undefined
        },
        keyMaps: keyMaps
      },
      deleteGroupMember: {
        serverName: SERVER.NAME.GROUP,
        cmd: SERVER.CMD.DELETE_GROUP_MEMBER,
        channel: SERVER.CHANNEL.XHR,
        protocol: PROTOCOL_TYPE.JSON,
        queryString: queryString,
        requestData: {
          groupID: undefined,
          userIDList: undefined,
          reason: undefined
        },
        keyMaps: {
          request: {
            userIDList: 'MemberToDel_Account'
          }
        }
      },
      searchGroupByID: {
        serverName: SERVER.NAME.GROUP,
        cmd: SERVER.CMD.SEARCH_GROUP_BY_ID,
        channel: SERVER.CHANNEL.XHR,
        protocol: PROTOCOL_TYPE.JSON,
        queryString: queryString,
        requestData: {
          groupIDList: undefined,
          responseFilter: {
            groupBasePublicInfoFilter: ['Type', 'Name', 'Introduction', 'Notification', 'FaceUrl', 'CreateTime', 'Owner_Account', 'LastInfoTime', 'LastMsgTime', 'NextMsgSeq', 'MemberNum', 'MaxMemberNum', 'ApplyJoinOption']
          }
        },
        keyMaps: {
          request: {
            groupIDList: 'GroupIdList'
          }
        }
      },
      applyJoinGroup: {
        serverName: SERVER.NAME.GROUP,
        cmd: SERVER.CMD.APPLY_JOIN_GROUP,
        channel: SERVER.CHANNEL.XHR,
        protocol: PROTOCOL_TYPE.JSON,
        queryString: queryString,
        requestData: {
          groupID: undefined,
          applyMessage: undefined,
          userDefinedField: undefined
        },
        keyMaps: keyMaps
      },
      applyJoinAVChatRoom: {
        serverName: SERVER.NAME.BIG_GROUP_NO_AUTH,
        cmd: SERVER.CMD.APPLY_JOIN_GROUP,
        channel: SERVER.CHANNEL.XHR,
        protocol: PROTOCOL_TYPE.JSON,
        queryString: {
          websdkappid: SDK.APPID,
          v: SDK.VERSION,
          platform: SDK.PLATFORM,
          sdkappid: tim.context !== null ? tim.context.SDKAppID : 0,
          contentType: tim.context !== null ? tim.context.contentType : 0,
          accounttype: tim.context !== null ? tim.context.accountType : 0
        },
        requestData: {
          groupID: undefined,
          applyMessage: undefined,
          userDefinedField: undefined
        },
        keyMaps: keyMaps
      },
      handleApplyJoinGroup: {
        serverName: SERVER.NAME.GROUP,
        cmd: SERVER.CMD.HANDLE_APPLY_JOIN_GROUP,
        channel: SERVER.CHANNEL.XHR,
        protocol: PROTOCOL_TYPE.JSON,
        queryString: queryString,
        requestData: {
          groupID: undefined,
          applicant: undefined,
          handleAction: undefined,
          handleMessage: undefined,
          authentication: undefined,
          messageKey: undefined,
          userDefinedField: undefined
        },
        keyMaps: {
          request: {
            applicant: 'Applicant_Account',
            handleAction: 'HandleMsg',
            handleMessage: 'ApprovalMsg',
            messageKey: 'MsgKey'
          },
          response: {
            MsgKey: 'messageKey'
          }
        }
      },
      deleteGroupSystemNotice: {
        serverName: SERVER.NAME.OPEN_IM,
        cmd: SERVER.CMD.DELETE_GROUP_SYSTEM_MESSAGE,
        channel: SERVER.CHANNEL.XHR,
        protocol: PROTOCOL_TYPE.JSON,
        queryString: queryString,
        requestData: {
          messageListToDelete: undefined
        },
        keyMaps: {
          request: {
            messageListToDelete: 'DelMsgList',
            messageSeq: 'MsgSeq',
            messageRandom: 'MsgRandom'
          }
        }
      },
      getGroupPendency: {
        serverName: SERVER.NAME.GROUP,
        cmd: SERVER.CMD.GET_GROUP_PENDENCY,
        channel: SERVER.CHANNEL.XHR,
        protocol: PROTOCOL_TYPE.JSON,
        queryString: queryString,
        requestData: {
          startTime: undefined,
          limit: undefined,
          handleAccount: undefined
        },
        keyMaps: {
          request: {
            handleAccount: 'Handle_Account'
          }
        }
      }
    };
  };

  var conf$2 = function conf(tim) {
    return {
      create: {},
      query: {
        serverName: SERVER.NAME.OPEN_IM,
        cmd: SERVER.CMD.GET_LONG_POLL_ID,
        channel: SERVER.CHANNEL.XHR,
        protocol: PROTOCOL_TYPE.JSON,
        queryString: {
          websdkappid: SDK.APPID,
          v: SDK.VERSION,
          platform: SDK.PLATFORM,
          a2: tim.context !== null ? tim.context.a2Key : '',
          tinyid: tim.context !== null ? tim.context.tinyID : 0,
          sdkappid: tim.context !== null ? tim.context.SDKAppID : 0,
          contentType: tim.context !== null ? tim.context.contentType : 0,
          apn: tim.context !== null ? tim.context.apn : 1,
          reqtime: +new Date() / 1000
        },
        requestData: {},
        keyMaps: {
          response: {
            LongPollingId: 'longPollingID'
          }
        }
      },
      update: {},
      "delete": {}
    };
  };

  var conf$3 = function conf(tim) {
    var queryString = {
      websdkappid: SDK.APPID,
      v: SDK.VERSION,
      platform: SDK.PLATFORM,
      a2: tim.context !== null ? tim.context.a2Key : '',
      tinyid: tim.context !== null ? tim.context.tinyID : 0,
      sdkappid: tim.context !== null ? tim.context.SDKAppID : 0,
      contentType: tim.context !== null ? tim.context.contentType : 0,
      accounttype: tim.context !== null ? tim.loginInfo.accountType : 0,
      apn: tim.context !== null ? tim.context.apn : 1,
      reqtime: Math.ceil(+new Date() / 1000)
    };
    var keyMaps = {
      response: {
        C2cMsgArray: 'C2CMessageArray',
        GroupMsgArray: 'groupMessageArray',
        GroupTips: 'groupTips',
        C2cNotifyMsgArray: 'C2CNotifyMessageArray',
        ClientSeq: 'clientSequence',
        MsgPriority: 'priority',
        NoticeSeq: 'noticeSequence',
        MsgContent: 'content',
        MsgType: 'type',
        MsgBody: 'elements',
        ToGroupId: 'to',
        Desc: 'description',
        Ext: 'extension'
      }
    };
    return {
      create: {},
      query: {
        serverName: SERVER.NAME.OPEN_IM,
        cmd: SERVER.CMD.LONG_POLL,
        channel: SERVER.CHANNEL.AUTO,
        // 由ConnectionController决定用什么方式进行请求
        protocol: PROTOCOL_TYPE.JSON,
        queryString: queryString,
        requestData: {
          timeout: null,
          cookie: {
            notifySeq: 0,
            noticeSeq: 0,
            longPollingID: 0
          }
        },
        keyMaps: keyMaps
      },
      update: {},
      "delete": {}
    };
  };

  var conf$4 = function conf(tim) {
    var queryString = commonQueryString(tim);
    var serverName = SERVER.NAME.FRIEND;
    var channel = SERVER.CHANNEL.XHR;
    var protocol = PROTOCOL_TYPE.JSON;
    return {
      create: {
        serverName: serverName,
        cmd: SERVER.CMD.FRIEND_ADD,
        channel: channel,
        protocol: protocol,
        queryString: queryString,
        requestData: {
          fromAccount: '',
          addFriendItem: []
        }
      },
      get: {
        serverName: serverName,
        cmd: SERVER.CMD.GET_PENDENCY,
        channel: channel,
        protocol: protocol,
        queryString: queryString,
        requestData: {
          fromAccount: '',
          pendencyType: 'Pendency_Type_ComeIn'
        }
      },
      update: {
        serverName: serverName,
        cmd: SERVER.CMD.RESPONSE_PENDENCY,
        channel: channel,
        protocol: protocol,
        queryString: queryString,
        requestData: {
          fromAccount: '',
          responseFriendItem: []
        }
      },
      "delete": {
        serverName: serverName,
        cmd: SERVER.CMD.DELETE_PENDENCY,
        channel: channel,
        protocol: protocol,
        queryString: queryString,
        requestData: {
          fromAccount: '',
          toAccount: [],
          pendencyType: 'Pendency_Type_ComeIn'
        }
      }
    };
  };

  var conf$5 = function conf(tim) {
    var queryString = commonQueryString(tim);
    var serverName = SERVER.NAME.FRIEND;
    var channel = SERVER.CHANNEL.XHR;
    var protocol = PROTOCOL_TYPE.JSON;
    var requestMethod = 'POST';
    return {
      get: {
        serverName: serverName,
        cmd: SERVER.CMD.FRIEND_GET_ALL,
        channel: channel,
        protocol: protocol,
        method: requestMethod,
        queryString: queryString,
        requestData: {
          fromAccount: '',
          timeStamp: 0,
          startIndex: 0,
          getCount: 100,
          lastStandardSequence: 0,
          tagList: ['Tag_Profile_IM_Nick', 'Tag_SNS_IM_Remark']
        },
        keyMaps: {
          request: {},
          // 请求转换Map表
          response: {} // 响应转换Map表

        }
      },
      "delete": {
        serverName: serverName,
        cmd: SERVER.CMD.FRIEND_DELETE,
        channel: channel,
        protocol: protocol,
        method: requestMethod,
        queryString: queryString,
        requestData: {
          fromAccount: '',
          toAccount: [],
          deleteType: 'Delete_Type_Single'
        }
      }
    };
  };

  var conf$6 = function conf(tim) {
    var queryString = commonQueryString(tim);
    return {
      create: {
        serverName: SERVER.NAME.FRIEND,
        cmd: SERVER.CMD.ADD_BLACKLIST,
        channel: SERVER.CHANNEL.XHR,
        protocol: PROTOCOL_TYPE.JSON,
        method: 'POST',
        queryString: queryString,
        requestData: {
          fromAccount: '',
          toAccount: []
        }
      },
      get: {
        serverName: SERVER.NAME.FRIEND,
        cmd: SERVER.CMD.GET_BLACKLIST,
        channel: SERVER.CHANNEL.XHR,
        protocol: PROTOCOL_TYPE.JSON,
        method: 'POST',
        queryString: queryString,
        requestData: {
          fromAccount: '',
          startIndex: 0,
          maxLimited: 30,
          lastSequence: 0
        }
      },
      "delete": {
        serverName: SERVER.NAME.FRIEND,
        cmd: SERVER.CMD.DELETE_BLACKLIST,
        channel: SERVER.CHANNEL.XHR,
        protocol: PROTOCOL_TYPE.JSON,
        method: 'POST',
        queryString: queryString,
        requestData: {
          fromAccount: '',
          toAccount: []
        }
      },
      update: {}
    };
  };

  var c2cMessage = function c2cMessage(tim) {
    var queryString = {
      platform: SDK.PLATFORM,
      websdkappid: SDK.APPID,
      v: SDK.VERSION,
      a2: tim.context !== null ? tim.context.a2Key : '',
      tinyid: tim.context !== null ? tim.context.tinyID : 0,
      sdkappid: tim.context !== null ? tim.context.SDKAppID : 0,
      contentType: tim.context !== null ? tim.context.contentType : 0,
      apn: tim.context !== null ? tim.context.apn : 1,
      reqtime: function reqtime() {
        return +new Date();
      }
    };
    var keyMaps = {
      request: {
        fromAccount: 'From_Account',
        toAccount: 'To_Account',
        msgTimeStamp: 'MsgTimeStamp',
        msgSeq: 'MsgSeq',
        msgRandom: 'MsgRandom',
        msgBody: 'MsgBody',
        count: 'MaxCnt',
        lastMessageTime: 'LastMsgTime',
        messageKey: 'MsgKey',
        peerAccount: 'Peer_Account',
        data: 'Data',
        description: 'Desc',
        extension: 'Ext',
        type: 'MsgType',
        content: 'MsgContent',
        sizeType: 'Type',
        uuid: 'UUID',
        // url: 'URL',
        imageUrl: 'URL',
        fileUrl: 'Url',
        remoteAudioUrl: 'Url',
        remoteVideoUrl: 'VideoUrl',
        thumbUUID: 'ThumbUUID',
        videoUUID: 'VideoUUID',
        videoUrl: '',
        downloadFlag: 'Download_Flag'
      },
      response: {
        MsgContent: 'content',
        MsgTime: 'time',
        Data: 'data',
        Desc: 'description',
        Ext: 'extension',
        MsgKey: 'messageKey',
        MsgType: 'type',
        MsgBody: 'elements',
        Download_Flag: 'downloadFlag',
        ThumbUUID: 'thumbUUID',
        VideoUUID: 'videoUUID'
      }
    };
    return {
      create: {
        serverName: SERVER.NAME.OPEN_IM,
        cmd: SERVER.CMD.SEND_MESSAGE,
        channel: SERVER.CHANNEL.XHR,
        protocol: PROTOCOL_TYPE.JSON,
        method: 'POST',
        queryString: queryString,
        requestData: {
          fromAccount: tim.loginInfo.identifier,
          toAccount: '',
          msgTimeStamp: Math.ceil(+new Date() / 1000),
          msgSeq: 0,
          msgRandom: 0,
          msgBody: [] // offlinePushInfo: {
          //   pushFlag: 0,
          //   desc: '',
          //   ext: '',
          //   dndroidInfo: {
          //     sound: 'android.mp3'
          //   },
          //   apnsInfo: {
          //     sound: 'apns.mp3',
          //     badgeMode: 1
          //   }
          // }

        },
        keyMaps: keyMaps
      },
      // 消息查询，用于获取 C2C 历史消息，同步消息请使用sync-message
      query: {
        serverName: SERVER.NAME.OPEN_IM,
        cmd: SERVER.CMD.GET_C2C_ROAM_MESSAGES,
        channel: SERVER.CHANNEL.XHR,
        protocol: PROTOCOL_TYPE.JSON,
        method: 'POST',
        queryString: queryString,
        requestData: {
          peerAccount: '',
          // 对方的账号
          count: 15,
          // 一次拉取多少条历史
          lastMessageTime: 0,
          // 最后一条消息的时间, 默认0
          messageKey: '',
          // 用于继拉历史消息的key
          withRecalledMsg: 1 // 表示可以拉取到已被撤回的漫游消息

        },
        keyMaps: keyMaps
      },
      update: null,
      "delete": null
    };
  };

  var c2cMessageWillBeRevoked = function c2cMessageWillBeRevoked(tim) {
    var queryString = {
      platform: SDK.PLATFORM,
      websdkappid: SDK.APPID,
      v: SDK.VERSION,
      a2: tim.context !== null ? tim.context.a2Key : '',
      tinyid: tim.context !== null ? tim.context.tinyID : 0,
      sdkappid: tim.context !== null ? tim.context.SDKAppID : 0,
      contentType: tim.context !== null ? tim.context.contentType : 0,
      apn: tim.context !== null ? tim.context.apn : 1,
      reqtime: function reqtime() {
        return +new Date();
      }
    };
    var keyMaps = {
      request: {
        msgInfo: 'MsgInfo',
        fromAccount: 'From_Account',
        toAccount: 'To_Account',
        msgTimeStamp: 'MsgTimeStamp',
        msgSeq: 'MsgSeq',
        msgRandom: 'MsgRandom',
        msgBody: 'MsgBody'
      }
    };
    return {
      create: {
        serverName: SERVER.NAME.OPEN_IM,
        cmd: SERVER.CMD.REVOKE_C2C_MESSAGE,
        channel: SERVER.CHANNEL.XHR,
        protocol: PROTOCOL_TYPE.JSON,
        method: 'POST',
        queryString: queryString,
        requestData: {
          msgInfo: {
            fromAccount: '',
            toAccount: '',
            msgTimeStamp: Math.ceil(+new Date() / 1000),
            msgSeq: 0,
            msgRandom: 0
          }
        },
        keyMaps: keyMaps
      }
    };
  };

  var groupMesage = function groupMesage(tim) {
    var queryString = {
      platform: SDK.PLATFORM,
      websdkappid: SDK.APPID,
      v: SDK.VERSION,
      a2: tim.context !== null ? tim.context.a2Key : '',
      tinyid: tim.context !== null ? tim.context.tinyID : 0,
      sdkappid: tim.context !== null ? tim.context.SDKAppID : 0,
      contentType: tim.context !== null ? tim.context.contentType : 0,
      apn: tim.context !== null ? tim.context.apn : 1,
      reqtime: function reqtime() {
        return +new Date();
      }
    };
    var keyMaps = {
      request: {
        to: 'GroupId',
        extension: 'Ext',
        data: 'Data',
        description: 'Desc',
        random: 'Random',
        sequence: 'ReqMsgSeq',
        count: 'ReqMsgNumber',
        type: 'MsgType',
        priority: 'MsgPriority',
        // 消息优先级
        content: 'MsgContent',
        elements: 'MsgBody',
        sizeType: 'Type',
        uuid: 'UUID',
        // url: 'URL',
        imageUrl: 'URL',
        fileUrl: 'Url',
        remoteAudioUrl: 'Url',
        remoteVideoUrl: 'VideoUrl',
        thumbUUID: 'ThumbUUID',
        videoUUID: 'VideoUUID',
        videoUrl: '',
        downloadFlag: 'Download_Flag',
        clientSequence: 'ClientSeq'
      },
      response: {
        // GroupId: 'to',
        Random: 'random',
        MsgTime: 'time',
        MsgSeq: 'sequence',
        ReqMsgSeq: 'sequence',
        RspMsgList: 'messageList',
        IsPlaceMsg: 'isPlaceMessage',
        // 占位消息，0-正常消息 1-空消息 2-被撤回的消息
        IsSystemMsg: 'isSystemMessage',
        ToGroupId: 'to',
        EnumFrom_AccountType: 'fromAccountType',
        EnumTo_AccountType: 'toAccountType',
        GroupCode: 'groupCode',
        MsgPriority: 'priority',
        MsgBody: 'elements',
        MsgType: 'type',
        MsgContent: 'content',
        IsFinished: 'complete',
        Download_Flag: 'downloadFlag',
        ClientSeq: 'clientSequence',
        ThumbUUID: 'thumbUUID',
        VideoUUID: 'videoUUID'
      }
    };
    return {
      create: {
        serverName: SERVER.NAME.GROUP,
        cmd: SERVER.CMD.SEND_GROUP_MESSAGE,
        channel: SERVER.CHANNEL.XHR,
        protocol: PROTOCOL_TYPE.JSON,
        method: 'POST',
        queryString: queryString,
        requestData: {
          groupID: '',
          fromAccount: tim.loginInfo.identifier,
          random: 0,
          clientSequence: 0,
          priority: '',
          msgBody: []
        },
        keyMaps: keyMaps
      },
      query: {
        serverName: SERVER.NAME.GROUP,
        cmd: SERVER.CMD.GET_GROUP_ROAM_MESSAGES,
        channel: SERVER.CHANNEL.XHR,
        protocol: PROTOCOL_TYPE.JSON,
        method: 'POST',
        queryString: queryString,
        requestData: {
          withRecalledMsg: 1,
          // 表示可以拉取到已被撤回的漫游消息
          groupID: '',
          // 对方的账号
          count: 15,
          // 一次拉取多少条历史
          sequence: '' // 用于继拉群历史消息的序号

        },
        keyMaps: keyMaps
      },
      update: null,
      "delete": null
    };
  };

  var groupMesageWillBeRevoked = function groupMesageWillBeRevoked(tim) {
    var queryString = {
      platform: SDK.PLATFORM,
      websdkappid: SDK.APPID,
      v: SDK.VERSION,
      a2: tim.context !== null ? tim.context.a2Key : '',
      tinyid: tim.context !== null ? tim.context.tinyID : 0,
      sdkappid: tim.context !== null ? tim.context.SDKAppID : 0,
      contentType: tim.context !== null ? tim.context.contentType : 0,
      apn: tim.context !== null ? tim.context.apn : 1,
      reqtime: function reqtime() {
        return +new Date();
      }
    };
    var keyMaps = {
      request: {
        to: 'GroupId',
        msgSeqList: 'MsgSeqList',
        msgSeq: 'MsgSeq'
      }
    };
    return {
      create: {
        serverName: SERVER.NAME.GROUP,
        cmd: SERVER.CMD.REVOKE_GROUP_MESSAGE,
        channel: SERVER.CHANNEL.XHR,
        protocol: PROTOCOL_TYPE.JSON,
        method: 'POST',
        queryString: queryString,
        requestData: {
          to: '',
          msgSeqList: []
        },
        keyMaps: keyMaps
      }
    };
  };

  var conf$7 = function conf(tim) {
    var queryString = {
      platform: SDK.PLATFORM,
      websdkappid: SDK.APPID,
      v: SDK.VERSION,
      a2: tim.context !== null ? tim.context.a2Key : '',
      tinyid: tim.context !== null ? tim.context.tinyID : 0,
      sdkappid: tim.context !== null ? tim.context.SDKAppID : 0,
      contentType: tim.context !== null ? tim.context.contentType : 0,
      apn: tim.context !== null ? tim.context.apn : 1
    };
    return {
      query: {
        serverName: SERVER.NAME.RECENT_CONTACT,
        cmd: SERVER.CMD.GET_CONVERSATION_LIST,
        channel: SERVER.CHANNEL.XHR,
        protocol: PROTOCOL_TYPE.JSON,
        method: 'POST',
        queryString: queryString,
        requestData: {
          fromAccount: tim.loginInfo.identifier,
          count: 0
        },
        keyMaps: {
          request: {},
          // 请求转换Map表
          response: {
            SessionItem: 'conversations',
            ToAccount: 'groupID',
            To_Account: 'userID',
            UnreadMsgCount: 'unreadCount',
            MsgGroupReadedSeq: 'messageReadSeq'
          } // 响应转换Map表

        }
      },
      pagingQuery: {
        serverName: SERVER.NAME.RECENT_CONTACT,
        cmd: SERVER.CMD.PAGING_GET_CONVERSATION_LIST,
        channel: SERVER.CHANNEL.XHR,
        protocol: PROTOCOL_TYPE.JSON,
        method: 'POST',
        queryString: queryString,
        requestData: {
          fromAccount: undefined,
          timeStamp: undefined,
          orderType: undefined
        },
        keyMaps: {
          request: {},
          // 请求转换Map表
          response: {
            SessionItem: 'conversations',
            ToAccount: 'groupID',
            To_Account: 'userID',
            UnreadMsgCount: 'unreadCount',
            MsgGroupReadedSeq: 'messageReadSeq'
          } // 响应转换Map表

        }
      },
      "delete": {
        serverName: SERVER.NAME.RECENT_CONTACT,
        cmd: SERVER.CMD.DELETE_CONVERSATION,
        channel: SERVER.CHANNEL.XHR,
        protocol: PROTOCOL_TYPE.JSON,
        method: 'POST',
        queryString: queryString,
        requestData: {
          fromAccount: tim.loginInfo.identifier,
          toAccount: undefined,
          type: 1,
          toGroupID: undefined
        },
        keyMaps: {
          request: {
            toGroupID: 'ToGroupid'
          }
        }
      },
      setC2CMessageRead: {
        serverName: SERVER.NAME.OPEN_IM,
        cmd: SERVER.CMD.SET_C2C_MESSAGE_READ,
        channel: SERVER.CHANNEL.XHR,
        protocol: PROTOCOL_TYPE.JSON,
        method: 'POST',
        queryString: queryString,
        requestData: {
          C2CMsgReaded: undefined
        },
        keyMaps: {
          request: {
            lastMessageTime: 'LastedMsgTime'
          }
        }
      },
      setGroupMessageRead: {
        serverName: SERVER.NAME.GROUP,
        cmd: SERVER.CMD.SET_GROUP_MESSAGE_READ,
        channel: SERVER.CHANNEL.XHR,
        protocol: PROTOCOL_TYPE.JSON,
        method: 'POST',
        queryString: queryString,
        requestData: {
          groupID: undefined,
          messageReadSeq: undefined
        },
        keyMaps: {
          request: {
            messageReadSeq: 'MsgReadedSeq'
          }
        }
      }
    };
  };

  var syncMessage = function syncMessage(tim) {
    var queryString = {
      platform: SDK.PLATFORM,
      websdkappid: SDK.APPID,
      v: SDK.VERSION,
      a2: tim.context !== null ? tim.context.a2Key : '',
      tinyid: tim.context !== null ? tim.context.tinyID : 0,
      sdkappid: tim.context !== null ? tim.context.SDKAppID : 0,
      contentType: tim.context !== null ? tim.context.contentType : 0,
      apn: tim.context !== null ? tim.context.apn : 1,
      reqtime: function reqtime() {
        return [Math.ceil(+new Date()), Math.random()].join('');
      }
    };
    var keyMaps = {
      request: {
        fromAccount: 'From_Account',
        toAccount: 'To_Account',
        from: 'From_Account',
        to: 'To_Account',
        time: 'MsgTimeStamp',
        sequence: 'MsgSeq',
        random: 'MsgRandom',
        elements: 'MsgBody'
      },
      response: {
        MsgList: 'messageList',
        SyncFlag: 'syncFlag',
        To_Account: 'to',
        From_Account: 'from',
        ClientSeq: 'clientSequence',
        MsgSeq: 'sequence',
        NoticeSeq: 'noticeSequence',
        NotifySeq: 'notifySequence',
        MsgRandom: 'random',
        MsgTimeStamp: 'time',
        MsgContent: 'content',
        ToGroupId: 'groupID',
        MsgKey: 'messageKey',
        GroupTips: 'groupTips',
        MsgBody: 'elements',
        MsgType: 'type',
        C2CRemainingUnreadCount: 'C2CRemainingUnreadList' // 溢出的C2C未读消息的计数列表

      }
    };
    return {
      create: null,
      query: {
        serverName: SERVER.NAME.OPEN_IM,
        cmd: SERVER.CMD.GET_MESSAGES,
        channel: SERVER.CHANNEL.XHR,
        protocol: PROTOCOL_TYPE.JSON,
        method: 'POST',
        queryString: queryString,
        requestData: {
          cookie: '',
          syncFlag: 0,
          needAbstract: 1 // 为 1 时，同步未读请求会返回溢出的C2C未读消息计数

        },
        keyMaps: keyMaps
      },
      update: null,
      "delete": null
    };
  };

  var avChatRoom = function avChatRoom(tim) {
    return {
      startLongPoll: {
        serverName: SERVER.NAME.BIG_GROUP_LONG_POLLING_NO_AUTH,
        cmd: SERVER.CMD.AVCHATROOM_LONG_POLL,
        channel: SERVER.CHANNEL.XHR,
        protocol: PROTOCOL_TYPE.JSON,
        method: 'POST',
        queryString: {
          websdkappid: SDK.APPID,
          v: SDK.VERSION,
          platform: SDK.PLATFORM,
          sdkappid: tim.loginInfo.SDKAppID,
          accounttype: '792',
          apn: tim.context !== null ? tim.context.apn : 1,
          reqtime: function reqtime() {
            return +new Date();
          }
        },
        requestData: {
          USP: 1,
          startSeq: 1,
          holdTime: 90,
          key: undefined
        },
        keyMaps: {
          request: {
            USP: 'USP'
          },
          response: {
            ToGroupId: 'groupID',
            MsgPriority: 'priority'
          }
        }
      }
    };
  };

  var cosUpload = function cosUpload(tim) {
    var queryString = {
      platform: SDK.PLATFORM,
      websdkappid: SDK.APPID,
      v: SDK.VERSION,
      a2: tim.context !== null ? tim.context.a2Key : '',
      tinyid: tim.context !== null ? tim.context.tinyID : 0,
      sdkappid: tim.context !== null ? tim.context.SDKAppID : 0,
      contentType: tim.context !== null ? tim.context.contentType : 0,
      apn: tim.context !== null ? tim.context.apn : 1,
      reqtime: function reqtime() {
        return Date.now();
      }
    };
    var keyMaps = {
      request: {},
      response: {}
    };
    return {
      create: {
        serverName: SERVER.NAME.OPEN_IM,
        cmd: SERVER.CMD.FILE_UPLOAD,
        channel: SERVER.CHANNEL.XHR,
        protocol: PROTOCOL_TYPE.JSON,
        method: 'POST',
        queryString: queryString,
        requestData: {
          appVersion: '2.1',
          fromAccount: '',
          toAccount: '',
          sequence: 0,
          time: function time() {
            return Math.ceil(Date.now() / 1000);
          },
          random: function random() {
            return randomInt();
          },
          fileStrMd5: '',
          fileSize: '',
          serverVer: 1,
          authKey: '',
          busiId: 1,
          pkgFlag: 1,
          sliceOffset: 0,
          sliceSize: 0,
          sliceData: '',
          contentType: 'application/x-www-form-urlencoded'
        },
        keyMaps: keyMaps
      },
      update: null,
      "delete": null
    };
  };

  var cosSig = function cosSig(tim) {
    var queryString = {
      sdkappid: function sdkappid() {
        return tim.loginInfo.SDKAppID;
      },
      identifier: function identifier() {
        return tim.loginInfo.identifier;
      },
      userSig: function userSig() {
        return tim.context.userSig;
      } // --- 分隔线 ----
      // platform: SDK.PLATFORM,
      // v: SDK.VERSION,
      // // a2: tim.context !== null ? tim.context.a2Key : '',
      // a2: function(){
      //   return tim.context.a2Key || '';
      // },
      // // tinyid: tim.context !== null ? tim.context.tinyID : 0,
      // tinyid: function(){
      //   return tim.context.tinyID || null;
      // },
      // contentType: tim.context !== null ? tim.context.contentType : 0,
      // apn: tim.context !== null ? tim.context.apn : 1,
      // reqtime: function() {return Date.now();}

    };
    var keyMaps = {
      request: {
        userSig: 'usersig',
        subCmd: 'sub_cmd',
        cmd: 'cmd',
        duration: 'duration',
        version: 'version'
      },

      /*
      appid: xxx
      bucket_name: "xxxx"
      error_code: 0
      error_msg: ""
      expired_time: xxxx
      session_token: "xxxx"
      tmp_secret_id: "xxxx"
      tmp_secret_key: "xxxx"
      */
      response: {
        expired_time: 'expiredTime',
        bucket_name: 'bucketName',
        session_token: 'sessionToken',
        tmp_secret_id: 'secretId',
        tmp_secret_key: 'secretKey'
      }
    };
    return {
      create: null,
      query: {
        serverName: SERVER.NAME.IM_COS_SIGN,
        cmd: SERVER.CMD.COS_SIGN,
        channel: SERVER.CHANNEL.XHR,
        protocol: PROTOCOL_TYPE.JSON,
        method: 'POST',
        queryString: queryString,
        requestData: {
          cmd: 'open_im_cos_svc',
          subCmd: 'get_cos_token',
          duration: 300,
          // 不设置的话，默认只给 5 分钟
          version: 2
        },
        keyMaps: keyMaps
      },
      update: null,
      "delete": null
    };
  };

  var bigDataHallwayAuthKey = function bigDataHallwayAuthKey(tim) {
    return {
      create: null,
      query: {
        serverName: SERVER.NAME.OPEN_IM,
        cmd: SERVER.CMD.BIG_DATA_HALLWAY_AUTH_KEY,
        channel: SERVER.CHANNEL.XHR,
        protocol: PROTOCOL_TYPE.JSON,
        method: 'POST',
        queryString: {
          websdkappid: SDK.APPID,
          v: SDK.VERSION,
          platform: SDK.PLATFORM,
          sdkappid: tim.loginInfo.SDKAppID,
          accounttype: '792',
          apn: tim.context !== null ? tim.context.apn : 1,
          reqtime: function reqtime() {
            return +new Date();
          }
        },
        requestData: {}
      }
    };
  };

  var conf$8 = function conf(tim) {
    var queryString = {
      // 未登录也可以上报到 sso，只带以下两个参数即可。所以这个时候应该用 loginInfo 而不要用 context
      sdkappid: tim.loginInfo.SDKAppID,
      reqtime: Math.ceil(+new Date() / 1000)
    };
    var keyMaps = {
      request: {
        table: 'table',
        report: 'report',
        SDKAppID: 'sdkappid',
        version: 'version',
        tinyID: 'tinyid',
        userID: 'userid',
        platform: 'platform',
        method: 'method',
        time: 'time',
        start: 'start',
        // 旧版统计字段，安全起见不删
        end: 'end',
        // 旧版统计字段，安全起见不删
        cost: 'cost',
        // 旧版统计字段，安全起见不删
        status: 'status',
        // 已废弃
        codeint: 'codeint',
        message: 'message',
        pointer: 'pointer',
        // 已废弃
        text: 'text',
        msgType: 'msgtype',
        networkType: 'networktype',
        startts: 'startts',
        endts: 'endts',
        timespan: 'timespan'
      }
    };
    return {
      create: {
        serverName: SERVER.NAME.IM_OPEN_STAT,
        cmd: SERVER.CMD.TIM_WEB_REPORT,
        channel: SERVER.CHANNEL.AUTO,
        // 由ConnectionController决定用什么方式进行请求
        protocol: PROTOCOL_TYPE.JSON,
        queryString: queryString,
        requestData: {
          table: '',
          report: []
        },
        keyMaps: keyMaps
      },
      query: {},
      update: {},
      "delete": {}
    };
  };

  var conf$9 = function conf(tim) {
    var queryString = null;

    if (tim.context !== null) {
      // 未登录也可以上报到 sso，只带以下两个参数即可
      queryString = {
        sdkappid: tim.context.SDKAppID,
        reqtime: Math.ceil(+new Date() / 1000)
      };
    }

    var keyMaps = {
      request: {
        table: 'table',
        report: 'report',
        SDKAppID: 'sdkappid',
        version: 'version',
        tinyID: 'tinyid',
        userID: 'userid',
        item: 'item',
        lpID: 'lpid',
        platform: 'platform',
        networkType: 'networktype',
        total: 'total',
        successRate: 'successrate',
        avg: 'avg',
        timespan: 'timespan',
        time: 'time'
      }
    };
    return {
      create: {
        serverName: SERVER.NAME.IM_OPEN_STAT,
        cmd: SERVER.CMD.TIM_WEB_REPORT,
        channel: SERVER.CHANNEL.AUTO,
        // 由ConnectionController决定用什么方式进行请求
        protocol: PROTOCOL_TYPE.JSON,
        queryString: queryString,
        requestData: {
          table: '',
          report: []
        },
        keyMaps: keyMaps
      },
      query: {},
      update: {},
      "delete": {}
    };
  };

  /**
   * 此类用于生成请求包
   * @class
   */

  var PackageConfig =
  /*#__PURE__*/
  function () {
    function PackageConfig(tim) {
      _classCallCheck(this, PackageConfig);

      this.tim = tim;
      this.tim.innerEmitter.on(TIM_INNER_EVENT.CONTEXT_UPDATED, this._update, this);
      this.tim.innerEmitter.on(TIM_INNER_EVENT.CONTEXT_RESET, this._update, this);
      this.tim.innerEmitter.on(TIM_INNER_EVENT.SPECIFIED_CONFIG_UPDATED, this._updateSpecifiedConfig, this);

      this._initConfig();
    }
    /**
     * 用于更新成员和 `self.config` 配置，因为有些参数无法构造时就取得，比如 `tim.context` 参数，所以可以在`tim.context` 完成初始化后再调用此方法。
     * @param {*} event
     */


    _createClass(PackageConfig, [{
      key: "_update",
      value: function _update(event) {
        // TODO: 每一次 Context 的键值对更新，就要重新初始化config，开销有点大
        this._initConfig();
      } // 更新指定的配置 event.data 是 [{key,value}, {key,value}, ...]

    }, {
      key: "_updateSpecifiedConfig",
      value: function _updateSpecifiedConfig(event) {
        var _this = this;

        event.data.forEach(function (options) {
          _this._set(options);
        });
      }
      /**
       * 获取接口的 packageConfig 配置
       * @param {Object} options
       * @param {String} options.name - package 名称
       * @param {String} options.action - package 操作
       * @param {Object} [options.param] - 其它的POST参数
       * @returns {Object}
       */

    }, {
      key: "get",
      value: function get(options) {
        var name = options.name,
            action = options.action,
            param = options.param,
            tjgID = options.tjgID;

        if (isUndefined(this.config[name]) || isUndefined(this.config[name][action])) {
          throw new IMError({
            code: ERROR_CODE.NETWORK_PACKAGE_UNDEFINED,
            message: "".concat(ERROR_MESSAGE.NETWORK_PACKAGE_UNDEFINED, ": PackageConfig.").concat(name)
          });
        }

        var packageOption = clone(this.config[name][action]); // 转json 方式复制一份。

        packageOption.requestData = this._initRequestData(param, packageOption);
        packageOption.encode = this._initEncoder(packageOption);
        packageOption.decode = this._initDecoder(packageOption);
        tjgID && (packageOption.queryString.tjg_id = tjgID); // tjg_id 用于消息全链路监控，在请求的url带上

        return packageOption;
      }
      /**
       * 用来配置个别packageConfig选项，因为有些配置无法在初始化时就同步加载，比如`packageConfig.longPoll.requestData.Cookie.LongPollID`，LongPollID需要API请求后才能取得，只有在取得后才能去配置
       * @param {Object} options
       * @param {String} options.key
       * @param {*} options.value
       * @example
       * let packageConfig = new PackageConfig(tim);
       * packageConfig.setPackageConfig({
       *  key: 'longPoll.qeury.requestData.Cookie.LongPollID',
       *  value: 88888888
       * })
       */

    }, {
      key: "_set",
      value: function _set(options) {
        var key = options.key,
            value = options.value;

        if (!!key === false) {
          return;
        }

        var keys = key.split('.');

        if (keys.length <= 0) {
          return;
        }

        var packageConfigSetter = function packageConfigSetter(packageConfig, keys, startKeyIndex, value) {
          var key = keys[startKeyIndex];

          if (_typeof(packageConfig[key]) === 'object') {
            packageConfigSetter(packageConfig[key], keys, startKeyIndex + 1, value);
          } else {
            packageConfig[key] = value;
            return;
          }
        };

        packageConfigSetter(this.config, keys, 0, value);
      }
    }, {
      key: "_initConfig",
      value: function _initConfig() {
        this.config = {};
        this.config['accessLayer'] = accessLayer(this.tim);
        this.config['login'] = login(this.tim);
        this.config['logout'] = logout(this.tim);
        this.config['longPollLogout'] = longPollLogout(this.tim);
        this.config['profile'] = conf(this.tim);
        this.config['group'] = conf$1(this.tim);
        this.config['longPollID'] = conf$2(this.tim);
        this.config['longPoll'] = conf$3(this.tim);
        this.config['applyC2C'] = conf$4(this.tim);
        this.config['friend'] = conf$5(this.tim);
        this.config['blacklist'] = conf$6(this.tim);
        this.config['c2cMessage'] = c2cMessage(this.tim);
        this.config['c2cMessageWillBeRevoked'] = c2cMessageWillBeRevoked(this.tim);
        this.config['groupMessage'] = groupMesage(this.tim);
        this.config['groupMessageWillBeRevoked'] = groupMesageWillBeRevoked(this.tim);
        this.config['conversation'] = conf$7(this.tim);
        this.config['syncMessage'] = syncMessage(this.tim);
        this.config['AVChatRoom'] = avChatRoom(this.tim);
        this.config['cosUpload'] = cosUpload(this.tim);
        this.config['cosSig'] = cosSig(this.tim);
        this.config['bigDataHallwayAuthKey'] = bigDataHallwayAuthKey(this.tim);
        this.config['ssoEventStat'] = conf$8(this.tim);
        this.config['ssoSumStat'] = conf$9(this.tim);
      }
      /**
       * 初始化 reqeustData (form-data) 参数
       * @param {Object} param - 传入的 form-data
       * @param {Object} packageOption - 默认的 form-data
       */

    }, {
      key: "_initRequestData",
      value: function _initRequestData(param, packageOption) {
        if (typeof param === 'undefined') {
          var result = convertRequestParam(packageOption.requestData, this._getRequestMap(packageOption), this.tim);
          return result;
        }

        var requestData = packageOption.requestData;
        var data = Object.create(null);

        for (var p in requestData) {
          if (Object.prototype.hasOwnProperty.call(requestData, p)) {
            // 如果是function 类型的成员，则执行一下，否则直接赋值。
            data[p] = typeof requestData[p] === 'function' ? requestData[p]() : requestData[p];

            if (typeof param[p] === 'undefined') {
              continue;
            }

            data[p] = param[p];
          }
        }

        data = convertRequestParam(data, this._getRequestMap(packageOption), this.tim); // 转换请求参数的key

        return data;
      }
      /**
       * 获取接口的keyMaps.request配置
       *
       * @param {Object} packageOption
       * @returns {Object|undefined} 若对应接口有配置则返回配置，否则返回undefined
       * @memberof PackageConfig
       */

    }, {
      key: "_getRequestMap",
      value: function _getRequestMap(packageOption) {
        if (packageOption.keyMaps) {
          if (packageOption.keyMaps.request) {
            if (Object.keys(packageOption.keyMaps.request).length > 0) {
              return packageOption.keyMaps.request;
            }
          }
        }
      }
      /**
       * 初始化encode编码函数
       * @param {*} packageOption
       */

    }, {
      key: "_initEncoder",
      value: function _initEncoder(packageOption) {
        switch (packageOption.protocol) {
          case PROTOCOL_TYPE.JSON:
            return function (responseData) {
              var type = _typeof(responseData);

              if (type === 'string') {
                try {
                  return JSON.parse(responseData); // 如果无法用无法转化为JSON则直接赋值给 packageOption.responseData
                } catch (error) {
                  return responseData;
                }
              }

              return responseData;
            };

          case PROTOCOL_TYPE.PROTOBUF:
            return function (responseData) {
              return responseData;
            };

          default:
            return function (responseData) {
              logger.warn('PackageConfig._initEncoder(), unknow response type, data: ', JSON.stringify(responseData));
              return responseData;
            };
        }
      }
      /**
       * 初始化decode解码函数
       * @param {Object} packageOption
       * @param {Object} father
       * @returns {Function} function (responseData){
       *    //...
       * }
       */

    }, {
      key: "_initDecoder",
      value: function _initDecoder(packageOption) {
        switch (packageOption.protocol) {
          case PROTOCOL_TYPE.JSON:
            return function (responseData) {
              var type = _typeof(responseData);

              if (type === 'string') {
                try {
                  return JSON.parse(responseData); // 如果无法用无法转化为JSON则直接赋值给 packageOption.responseData
                } catch (error) {
                  return responseData;
                }
              }

              return responseData;
            };

          case PROTOCOL_TYPE.PROTOBUF:
            return function (responseData) {
              return responseData;
            };

          default:
            return function (responseData) {
              logger.warn('PackageConfig._initDecoder(), unknow response type, data: ', responseData);
              return responseData;
            };
        }
      }
    }]);

    return PackageConfig;
  }();

  /**
   * @name boolsToStr
   * @description 输入一组 任意类型的参数，转化成 由 0 和 1，或其它整型数值拼接的字符串，用于扁平化条件嵌套。
   * @param {arguments} arguments - 接收任意数量、任意类型的参数，
   * @description _请注意 ：在参数集中，最后一个参数如果是长度为1的字符串，则会当做分隔符来处理_
   * @example
   * // 对象、数据或其它非整数类型
   * let a = {test: 'test'};
   * let b = [1,2,3];
   * let condition = boolsToStr(a, b);
   * console.log(condition); // 输出 11
   *
   * @example
   * // 对象、数据或其它非整数类型，其中有数据为null
   * let a = {test: 'test'};
   * let b = null;
   * let condition = boolsToStr(a, b);
   * console.log(condition); // 输出 10
   *
   * @example
   * // 有数据为整形
   * let a = {test: 'test'};
   * let b = 9;
   * let condition = boolsToStr(a, b);
   * console.log(condition); // 输出 19
   *
   * @example
   * // 有数据为 undefined
   * let a = {test: 'test'};
   * let condition = boolsToStr(a, b);  // b 未定义
   * console.log(condition); // 输出 10
   *
   * @example
   * // 需要自定义分隔符
   * let a = {test: 'test'};
   * let b = null;
   * let condition = boolsToStr(a, b, ',');
   * console.log(condition); // 输出 1,1
   *
   * @returns {string}
   */
  var boolsToStr = function boolsToStr() {
    var tmp = [];
    var separate = getSeparator(arguments);

    for (var i = 0; i < arguments.length; i++) {
      // 如果是整数型，直接 push 到 tmp 中
      if (Number.isInteger(arguments[i])) {
        tmp.push(arguments[i]);
        continue;
      }

      tmp.push(!!arguments[i] === true ? '1' : '0'); // 如果是非 boolean 数据，使用 !! 运算做转换
    }

    return tmp.join(separate);
  };
  /**
   * 用于获取分隔符
   * @param {*} datas - 要获取分隔符的数据
   * @returns {String}
   */


  var getSeparator = function getSeparator(datas) {
    var len = datas.length;
    var data = datas[len - 1]; // 如果不是字符串，不会当做分隔符处理

    if (typeof data !== 'string') {
      return '';
    } // 如果字符串的长度大于1，则不会当做分隔符处理


    if (data.length > 1) {
      return '';
    }

    var sp = datas[len - 1];
    delete datas[len - 1];
    datas.length -= len === datas.length ? 1 : 0;
    return sp; // 直接弹出最后一个分隔符
  };

  var payloadNames = {
    C2CMessageArray: 1,
    // C2C 消息通知
    groupMessageArray: 1,
    // 群消息通知
    groupTips: 1,
    // 群提示通知
    C2CNotifyMessageArray: 1,
    // C2C事件通知，1.C2C已读通知  2.系统日志提取  3.多终端互踢
    profileModify: 1,
    // 资料更新通知
    friendListMod: 1 // 好友列表更新通知

  };

  var NotificationController =
  /*#__PURE__*/
  function (_IMController) {
    _inherits(NotificationController, _IMController);

    function NotificationController(tim) {
      var _this;

      _classCallCheck(this, NotificationController);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(NotificationController).call(this, tim));

      _this._initialization();

      return _this;
    }
    /**
     * 初始化
     */


    _createClass(NotificationController, [{
      key: "_initialization",
      value: function _initialization() {
        this._syncOffset = '';
        this._syncNoticeList = []; // 暂存消息同步结果

        this._syncEventArray = []; // 暂存群系统通知同步结果

        this._syncMessagesIsRunning = false;
        this._syncMessagesFinished = false;
        this._isLongPoll = false;
        this._longPollID = 0;
        this._noticeSequence = 0;

        this._initializeListener();

        this._runLoop = null;

        this._initShuntChannels();
      }
      /**
       *初始化通知分流通道
       */

    }, {
      key: "_initShuntChannels",
      value: function _initShuntChannels() {
        this._shuntChannels = Object.create(null); // 通知分流通道配置 无原型对象
        // C2C 消息通知通道

        this._shuntChannels.C2CMessageArray = this._C2CMessageArrayChannel.bind(this); // GROUP 消息通知通道

        this._shuntChannels.groupMessageArray = this._groupMessageArrayChannel.bind(this); // GROUP 提示通知通道

        this._shuntChannels.groupTips = this._groupTipsChannel.bind(this); // C2C事件通知通道

        this._shuntChannels.C2CNotifyMessageArray = this._C2CNotifyMessageArrayChannel.bind(this); // 资料系统通知通道

        this._shuntChannels.profileModify = this._profileModifyChannel.bind(this); // 好友系统通知通道

        this._shuntChannels.friendListMod = this._friendListModChannel.bind(this);
      }
      /**
       * C2C 消息，通知通道
       *
       * @param {Number} event - 事件类型
       * @param {Object} notice - 通知
       * @param {String} type - 通知来源类型 消息同步:sync 或 实时消息:poll
       */

    }, {
      key: "_C2CMessageArrayChannel",
      value: function _C2CMessageArrayChannel(event, notice, type) {
        this.emitInnerEvent(TIM_INNER_EVENT.NOTICE_LONGPOLL_NEW_C2C_NOTICE, notice);
      }
      /**
       * GROUP 消息，通知通道
       *
       * @param {Number} event - 事件类型
       * @param {Object} notice - 通知
       * @param {String} type - 通知来源类型 消息同步:sync 或 实时消息:poll
       */

    }, {
      key: "_groupMessageArrayChannel",
      value: function _groupMessageArrayChannel(event, notice, type) {
        this.emitInnerEvent(TIM_INNER_EVENT.NOTICE_LONGPOLL_NEW_GROUP_MESSAGES, notice);
      }
      /**
       * GROUP 提示 通知通道
       *
       * @param {Number} event - 事件类型
       * @param {Object} notice - 通知
       * @param {String} type - 通知来源类型 消息同步:sync 或 实时消息:poll
       */

    }, {
      key: "_groupTipsChannel",
      value: function _groupTipsChannel(event, notice, type) {
        var _this2 = this;

        switch (event) {
          case 4:
            // 修改群标配字段 event 是4；修改群标配字段+自定义字段 event 是4
            this.emitInnerEvent(TIM_INNER_EVENT.NOTICE_LONGPOLL_NEW_GROUP_TIPS, notice);
            break;

          case 6:
            // 修改群自定义字段 event 是6
            // avchatroom 人员进群、退群，event 是6
            this.emitInnerEvent(TIM_INNER_EVENT.NOTICE_LONGPOLL_NEW_GROUP_TIPS, notice);
            break;

          case 5:
            notice.forEach(function (item) {
              // 群成员撤回消息 FIXME: 数据结构可以优化下
              if (isArray(item.elements.revokedInfos)) {
                _this2.emitInnerEvent(TIM_INNER_EVENT.NOTICE_LONGPOLL_GROUP_MESSAGE_REVOKED, notice);
              } else {
                _this2.emitInnerEvent(TIM_INNER_EVENT.NOTICE_LONGPOLL_NEW_GROUP_NOTICE, {
                  groupSystemNotices: notice,
                  type: type
                });
              }
            });
            break;

          default:
            logger.log("NotificationController._groupTipsChannel unknown event=".concat(event, " type=").concat(type), notice);
        }
      }
      /**
       * C2C 事件 通知通道
       *
       * @param {Number} event - 事件类型
       * @param {Object} notice - 通知
       * @param {String} type - 通知来源类型 消息同步:sync 或 实时消息:poll
       */

    }, {
      key: "_C2CNotifyMessageArrayChannel",
      value: function _C2CNotifyMessageArrayChannel(event, notice, type) {
        if (this._isKickedoutNotice(notice)) {
          // 判断是否为多终端互踢
          this.emitInnerEvent(TIM_INNER_EVENT.NOTICE_LONGPOLL_MUTIPLE_DEVICE_KICKED_OUT);
        } else if (this._isSysCmdMsgNotify(notice)) {
          // 判断是否为后台系统指令
          this.emitInnerEvent(TIM_INNER_EVENT.NOTICE_LONGPOLL_RECEIVE_SYSTEM_ORDERS);
        } else if (this._isC2CMessageRevokedNotify(notice)) {
          this.emitInnerEvent(TIM_INNER_EVENT.NOTICE_LONGPOLL_C2C_MESSAGE_REVOKED, notice);
        } // TODO: 消息已读通知尚未处理

      }
      /**
       * 资料系统 通知通道
       *
       * @param {Number} event - 事件类型
       * @param {Object} notice - 通知
       * @param {String} type - 通知来源类型 消息同步:sync 或 实时消息:poll
       */

    }, {
      key: "_profileModifyChannel",
      value: function _profileModifyChannel(event, notice, type) {
        this.emitInnerEvent(TIM_INNER_EVENT.NOTICE_LONGPOLL_PROFILE_MODIFIED, notice);
      }
      /**
       * 关系链系统 通知通道
       *
       * @param {Number} event - 事件类型
       * @param {Object} notice - 通知
       * @param {String} type - 通知来源类型 消息同步:sync 或 实时消息:poll
       */

    }, {
      key: "_friendListModChannel",
      value: function _friendListModChannel(event, notice, type) {
        this.emitInnerEvent(TIM_INNER_EVENT.NOTICE_LONGPOLL_NEW_FRIEND_MESSAGES, notice);
      }
      /**
       * 解构出通知并按通道分发
       * @param {Array} eventArray - 通知列表
       * @param {String} type 通知的来源类型 sync / poll
       */

    }, {
      key: "_dispatchNotice",
      value: function _dispatchNotice(eventArray) {
        var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'poll';

        if (!isArray(eventArray)) {
          return;
        }

        var eventItem = null; // 事件元素

        var notice = null; // 通知载体

        var payloadName = ''; // 通知载体名称

        var errorCode = ''; // 错误码

        var errorMessage = ''; // 错误信息

        var event = 0; // 通知事件码

        for (var i = 0, len = eventArray.length; i < len; i++) {
          eventItem = eventArray[i]; // 取出 event

          event = eventItem.event; // 取得消息载体的名称

          payloadName = Object.keys(eventItem).find(function (key) {
            return typeof payloadNames[key] !== 'undefined';
          }); // 到 _shuntChannels 中判断 载体名称是不存在，不存在则报错

          if (isFunction(this._shuntChannels[payloadName])) {
            // 载体存在，开始按通道配置分发
            notice = eventItem[payloadName]; // 只有 longpolling 才需要更新 noticeSequence 的逻辑

            if (type === 'poll') {
              this._updatenoticeSequence(notice);
            }

            this._shuntChannels[payloadName](event, notice, type);

            continue;
          } // longpolling 载体不存在，noticeSequence 自增，避免重复拉取，这样就不会导致重复轮询相同的 noticeSequence


          if (type === 'poll') {
            this._updatenoticeSequence();
          }

          errorCode = "".concat(ERROR_CODE.NOTICE_RUNLOOP_UNEXPECTED_CONDITION);
          errorMessage = "".concat(ERROR_MESSAGE.NOTICE_RUNLOOP_UNEXPECTED_CONDITION, ": ").concat(event, ", ").concat(payloadName);
          this.emitInnerEvent(TIM_INNER_EVENT.ERROR_DETECTED, new IMError({
            code: errorCode,
            message: errorMessage,
            data: {
              payloadName: payloadName,
              event: event
            }
          }));
          errorCode = '';
          errorMessage = '';
        }
      }
      /**
       * 获取消息通道ID：longPollID
       *
       * @returns {string}
       * @memberof NotificationController
       */

    }, {
      key: "getLongPollID",
      value: function getLongPollID() {
        return this._longPollID;
      }
      /**
       * 控制器准备就绪时，调用此方法
       */

    }, {
      key: "_IAmReady",
      value: function _IAmReady() {
        this.triggerReady();
      }
      /**
       * 重置
       */

    }, {
      key: "reset",
      value: function reset() {
        this._noticeSequence = 0;

        this._resetSync();

        this.closeNoticeChannel();
      }
      /**
       * 重置 同步参数
       */

    }, {
      key: "_resetSync",
      value: function _resetSync() {
        this._syncOffset = '';
        this._syncNoticeList = [];
        this._syncEventArray = [];
        this._syncMessagesIsRunning = false;
        this._syncMessagesFinished = false;
      }
      /**
       * 重新设置请求包体的中 NoticeSeq
       * @param {Object} requestData - 请求数据
       */

    }, {
      key: "_setNoticeSeqInRequestData",
      value: function _setNoticeSeqInRequestData(requestData) {
        requestData.Cookie.NoticeSeq = this._noticeSequence; // summary stat

        this.tim.sumStatController.addTotalCount(label.LONG_POLLING);
      }
      /**
       * 更新一下最新的 _noticeSequence
       * @param {Array} noticeList - 通知列表
       */

    }, {
      key: "_updatenoticeSequence",
      value: function _updatenoticeSequence(noticeList) {
        if (!noticeList) {
          this._noticeSequence++;
          return;
        }

        var newNoticeSequence = noticeList[noticeList.length - 1].noticeSequence; // noticeSequence 存放的位置有差别，防万一
        // newNoticeSequence 不存在 或 不是number 或 小于_noticeSequence

        if (!newNoticeSequence || typeof newNoticeSequence !== 'number') {
          this._noticeSequence++;
          return;
        }

        if (newNoticeSequence <= this._noticeSequence) {
          return;
        }

        this._noticeSequence = newNoticeSequence;
      }
      /**
       * 初始化事件订阅
       */

    }, {
      key: "_initializeListener",
      value: function _initializeListener() {
        var innerEmitter = this.tim.innerEmitter; // 当 context 更新完成时，开始同步消息

        innerEmitter.on(TIM_INNER_EVENT.CONTEXT_A2KEY_AND_TINYID_UPDATED, this._startSyncMessages, this);
        innerEmitter.on(TIM_INNER_EVENT.SIGN_LOGOUT_SUCCESS, this.closeNoticeChannel, this);
        innerEmitter.on(TIM_INNER_EVENT.NOTICE_LONGPOLL_FAST_START, this._onFastStart, this);
      }
      /**
       * 启动实时消息通道，首先要取得 longPollID
       */

    }, {
      key: "openNoticeChannel",
      value: function openNoticeChannel() {
        logger.log('NotificationController.openNoticeChannel');

        this._getLongPollID();
      }
      /**
       * 停止实时消息通道
       */

    }, {
      key: "closeNoticeChannel",
      value: function closeNoticeChannel() {
        logger.log('NotificationController.closeNoticeChannel');

        if (this._runLoop instanceof XHRRunLoop || this._runLoop instanceof WXRunLoop) {
          this._runLoop.abort();

          this._runLoop.stop();
        }

        this._longPollID = 0;
        this._isLongPoll = false;
      }
      /**
       * 获取 longPollID
       */

    }, {
      key: "_getLongPollID",
      value: function _getLongPollID() {
        var _this3 = this;

        // 如果已经取得了long poll id 则不重复获取 。 直接发布EVENT.LONG_POLL.GET_LONG_POLL_ID.SUCCESS事件
        if (this._longPollID !== 0) {
          this._onGetLongPollIDSuccess(this._longPollID);

          return;
        } // event stat


        var ssoLog = new SSOLogData();
        ssoLog.setMethod(SSOMethods.GET_LONGPOLL_ID).setStart();
        var result = this.request({
          name: 'longPollID',
          action: 'query'
        });
        result.then(function (response) {
          var longPollingID = response.data.longPollingID;

          _this3._onGetLongPollIDSuccess(longPollingID); // event stat


          ssoLog.setCode(0).setText("longPollingID=".concat(longPollingID)).setNetworkType(_this3.getNetworkType()).setEnd();
        })["catch"](function (error) {
          var imError = new IMError({
            code: error.code || ERROR_CODE.GET_LONGPOLL_ID_FAILED,
            message: error.message || ERROR_MESSAGE.GET_LONGPOLL_ID_FAILED
          });

          _this3.emitInnerEvent(TIM_INNER_EVENT.NOTICE_LONGPOLL_GET_ID_FAILED);

          _this3.emitInnerEvent(TIM_INNER_EVENT.ERROR_DETECTED, imError); // event stat


          _this3.probeNetwork().then(function (_ref) {
            var _ref2 = _slicedToArray(_ref, 2),
                bOnline = _ref2[0],
                networkType = _ref2[1];

            ssoLog.setError(imError, bOnline, networkType).setEnd();
          });
        });
      } // 当成功取得longPollId 时，开始轮询

    }, {
      key: "_onGetLongPollIDSuccess",
      value: function _onGetLongPollIDSuccess(longPollingID) {
        this.emitInnerEvent(TIM_INNER_EVENT.SPECIFIED_CONFIG_UPDATED, [{
          key: 'long_poll_logout.query.requestData.longPollingID',
          value: longPollingID
        }, {
          key: 'longPoll.query.requestData.cookie.longPollingID',
          value: longPollingID
        }]);
        this._longPollID = longPollingID;

        this._startLongPoll();

        this._IAmReady(); // 控制器准备就绪
        // summary stat


        this.tim.sumStatController.recordLongPollingID(this._longPollID);
      }
      /**
       * 开始轮询
       */

    }, {
      key: "_startLongPoll",
      value: function _startLongPoll() {
        if (this._isLongPoll === true) {
          logger.log('NotificationController._startLongPoll is running...');
          return;
        }

        logger.log('NotificationController._startLongPoll...');
        var connectionController = this.tim.connectionController;
        var pack = this.createTransportCapsule({
          name: 'longPoll',
          action: 'query'
        });
        this._isLongPoll = true;
        this._runLoop = connectionController.createRunLoop({
          pack: pack,
          before: this._setNoticeSeqInRequestData.bind(this),
          // 发送前回调
          success: this._onNoticeReceived.bind(this),
          // 成功回调
          fail: this._onNoticeFail.bind(this) // 失败回调

        });

        this._runLoop.start();
      } // 快启动重新启动长轮询

    }, {
      key: "_onFastStart",
      value: function _onFastStart() {
        // 停掉当前的 runLoop
        this.closeNoticeChannel(); // 重新启动消息同步，消息同步完成后，会发布 事件，消息通道便会启动

        this.syncMessage();
      }
      /**
       * 取得新的实时消息时的回调
       * @param {Object} event - 通知事件
       */

    }, {
      key: "_onNoticeReceived",
      value: function _onNoticeReceived(event) {
        var data = event.data;

        if (data.errorCode !== TIM_STATUS.REQUEST.SUCCESS) {
          // event stat
          var ssoLog = new SSOLogData();
          ssoLog.setMethod(SSOMethods.LONG_POLLING_ERROR).setStart();
          ssoLog.setMessage(data.errorInfo).setCode(data.errorCode).setNetworkType(this.getNetworkType()).setEnd();

          this._onResponseError(data);
        } else {
          // 收到正常response
          this.emitInnerEvent(TIM_INNER_EVENT.NOTICE_LONGPOLL_RESPONSE_OK);
        } // summary stat


        this.tim.sumStatController.addSuccessCount(label.LONG_POLLING);
        this.tim.sumStatController.addCost(label.LONG_POLLING, data.timecost);

        if (!event.data.eventArray) {
          // 如果 eventArray 为 null 说明没有新消息 此时不需要做 ssoLog 上报
          return;
        }

        this._dispatchNotice(event.data.eventArray); // 消息分发

      }
    }, {
      key: "_onResponseError",
      value: function _onResponseError(error) {
        switch (error.errorCode) {
          // 多实例被踢
          case ERROR_CODE.LONG_POLL_KICK_OUT:
            logger.warn("NotificationController._onResponseError, longPollingID=".concat(this._longPollID, " was kicked out"));
            this.emitInnerEvent(TIM_INNER_EVENT.NOTICE_LONGPOLL_KICKED_OUT);
            this.closeNoticeChannel();
            break;
          // usersig 过期

          case ERROR_CODE.MESSAGE_A2KEY_EXPIRED:
          case ERROR_CODE.ACCOUNT_A2KEY_EXPIRED:
            this.emitInnerEvent(TIM_INNER_EVENT.SIGN_A2KEY_EXPIRED);
            break;

          default:
            this.emitInnerEvent(TIM_INNER_EVENT.ERROR_DETECTED, new IMError({
              code: error.errorCode,
              message: error.errorInfo
            }));
            break;
        }
      }
    }, {
      key: "_onNoticeFail",
      value: function _onNoticeFail(event) {
        if (event.error) {
          // 远程主机拒绝网络连接，即请求超时
          if (event.error.code === 'ECONNABORTED' || // ajax timed out
          event.error.code === ERROR_CODE.NETWORK_TIMEOUT) {
            // wx.request timed out
            if (event.error.config) {
              var url = event.error.config.url;
              var data = event.error.config.data;
              logger.log("NotificationController._onNoticeFail request timed out. url=".concat(url, " data=").concat(data));
            } else {
              logger.log("NotificationController._onNoticeFail request timed out.");
            }
          } else {
            logger.log("NotificationController._onNoticeFail request failed due to network error");
          }
        }

        this.emitInnerEvent(TIM_INNER_EVENT.NOTICE_LONGPOLL_REQUEST_FAILED);
      }
      /**
       * 判断是否为多终端互踢的通知
       * @param {object} C2CNotifyMessageArray - 通知数据
       * @returns {boolean}
       */

    }, {
      key: "_isKickedoutNotice",
      value: function _isKickedoutNotice(C2CNotifyMessageArray) {
        var noticeData = C2CNotifyMessageArray[0];

        if (noticeData.hasOwnProperty('kickoutMsgNotify')) {
          return true;
        }

        return false;
      }
      /**
       *是否为后台系统指令
       *@param {object} C2CNotifyMessageArray - 通知数据
       * @memberof NotificationController
       * @returns {boolean}
       * @private
       */

    }, {
      key: "_isSysCmdMsgNotify",
      value: function _isSysCmdMsgNotify(C2CNotifyMessageArray) {
        if (!C2CNotifyMessageArray[0]) {
          return false;
        }

        var noticeData = C2CNotifyMessageArray[0]; // 'SysCmdMsgNotify'

        if (Object.prototype.hasOwnProperty.call(noticeData, 'sysCmdMsgNotify')) {
          return true;
        }

        return false;
      }
    }, {
      key: "_isC2CMessageRevokedNotify",
      value: function _isC2CMessageRevokedNotify(C2CNotifyMessageArray) {
        var noticeData = C2CNotifyMessageArray[0];

        if (Object.prototype.hasOwnProperty.call(noticeData, 'c2cMessageRevokedNotify')) {
          return true;
        }

        return false;
      }
      /**
       * 启动同步消息通知消息功能
       * @param {object} event - 事件
       */

    }, {
      key: "_startSyncMessages",
      value: function _startSyncMessages(event) {
        if (this._syncMessagesFinished === true) return; // 如果已经完成同步，不需要两次执行
        // 当 a2key 和 tinyID 都就绪了，就开始同步

        this.syncMessage();
      }
      /**
       * 开始同步通知（C2C未读消息?）
       * @param {string} cookie - 用于续拉， 不需要传入。
       * @param {string} syncFlag - 同步标志位
       * @throws {IMError}
       */

    }, {
      key: "syncMessage",
      value: function syncMessage() {
        var _this4 = this;

        var cookie = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
        var syncFlag = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        // TODO: 函数太长了，分解优化一下。
        this._syncMessagesIsRunning = true;
        this.request({
          name: 'syncMessage',
          action: 'query',
          param: {
            cookie: cookie,
            syncFlag: syncFlag
          }
        }).then(function (response) {
          var data = response.data;
          var condition = boolsToStr(data.cookie, data.syncFlag);

          switch (condition) {
            case '00': // 同步任务开启时，没拿到 _syncOffset 触发异常事件

            case '01':
              // 同步任务进行期间，没拿到 _syncOffset 触发异常事件
              _this4.emitInnerEvent(TIM_INNER_EVENT.ERROR_DETECTED, {
                code: ERROR_CODE.NOTICE_RUNLOOP_OFFSET_LOST,
                message: ERROR_MESSAGE.NOTICE_RUNLOOP_OFFSET_LOST
              });

              break;
            // 同步刚开启，记录下 _syncOffset 后继也许可以用于继传，此时已经取得了第一个分片

            case '10':
              if (data.eventArray) {
                _this4._dispatchNotice(data.eventArray, 'sync');
              }

              _this4._syncNoticeList = _this4._syncNoticeList.concat(data.messageList); // 当有消息时才抛事件

              _this4.emitInnerEvent(TIM_INNER_EVENT.SYNC_MESSAGE_C2C_PROCESSING, {
                data: data.messageList,
                C2CRemainingUnreadList: data['C2CRemainingUnreadList']
              });

              _this4._syncOffset = data.cookie;

              _this4.syncMessage(data.cookie, data.syncFlag);

              break;
            // 同步进行中，持续接取分片

            case '11':
              if (data.eventArray) {
                _this4._dispatchNotice(data.eventArray, 'sync');
              }

              _this4._syncNoticeList = _this4._syncNoticeList.concat(data.messageList);

              _this4.emitInnerEvent(TIM_INNER_EVENT.SYNC_MESSAGE_C2C_PROCESSING, {
                data: data.messageList,
                C2CRemainingUnreadList: data['C2CRemainingUnreadList']
              });

              _this4._syncOffset = data.cookie;

              _this4.syncMessage(data.cookie, data.syncFlag);

              break;
            // 同步任务结束, 取得最后一个分片

            case '12':
              if (data.eventArray) {
                _this4._dispatchNotice(data.eventArray, 'sync');
              }

              _this4.openNoticeChannel(); // 消息同步完成时，开始 long poll


              _this4._syncNoticeList = _this4._syncNoticeList.concat(data.messageList); // 当有消息时才抛事件

              _this4.emitInnerEvent(TIM_INNER_EVENT.SYNC_MESSAGE_C2C_FINISHED, {
                messageList: data.messageList,
                C2CRemainingUnreadList: data['C2CRemainingUnreadList']
              });

              _this4._syncOffset = data.cookie;
              _this4._syncNoticeList = []; // 置空

              _this4._syncMessagesIsRunning = false;
              _this4._syncMessagesFinished = true;
              break;
          }
        })["catch"](function (error) {
          _this4._syncMessagesIsRunning = false;
          logger.error("NotificationController.syncMessage failed. error:".concat(error));
        });
      }
    }]);

    return NotificationController;
  }(IMController);

  // import Axios from 'axios';

  /**
   * 用于文件上传控制
   * @author saxongao
   */

  var UploadController =
  /*#__PURE__*/
  function (_IMController) {
    _inherits(UploadController, _IMController);

    function UploadController(tim) {
      var _this;

      _classCallCheck(this, UploadController);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(UploadController).call(this, tim)); // 0.登录前，SDK需要registerPlugin
      // 1.先监听事件，登录成功 context 更新后才能初始化

      _this._initializeListener();

      return _this;
    }
    /**
     * 初始化基本参数
     * @param {*} options - 配置参数
     */


    _createClass(UploadController, [{
      key: "_initializeMembers",
      value: function _initializeMembers(options) {
        this.expiredTimeLimit = 300; // 签名的超时时间，单位为秒

        this.appid = options.appid || '';
        this.bucketName = options.bucketName || '';
        this.ciUrl = options.ciUrl || ''; // 数据万象域名，用于生成缩略图

        this.directory = options.directory || ''; // 上传路径

        this.downloadUrl = options.downloadUrl || ''; // 下载地址

        this.uploadUrl = options.uploadUrl || ''; // 上传地址

        this.expiredTimeOut = options.expiredTimeOut || this.expiredTimeLimit; // 超时计时，单位为秒

        this.region = 'ap-shanghai';
        this.cos = null;
        this.cosOptions = {
          secretId: options.secretId,
          secretKey: options.secretKey,
          sessionToken: options.sessionToken,
          expiredTime: options.expiredTime
        };

        this._initUploaderMethod();
      }
      /**
       * coskey过期计时器，COS key过期时并没有自动去取，所以还得自己动手
       */

    }, {
      key: "_expiredTimer",
      value: function _expiredTimer() {
        var _this2 = this;

        var checkRate = 10; // 检测频率 单位为秒

        var timeSecond = 0;
        var seed = setInterval(function () {
          timeSecond = Math.ceil(Date.now() / 1000);

          if (timeSecond >= _this2.cosOptions.expiredTime - 2 * checkRate) {
            _this2._isReady = false;

            _this2._getAuthorizationKey();

            clearInterval(seed);
          }
        }, checkRate * 1000);
      }
      /**
       * 配置事件订阅
       */

    }, {
      key: "_initializeListener",
      value: function _initializeListener() {
        this.tim.innerEmitter.on(TIM_INNER_EVENT.CONTEXT_A2KEY_AND_TINYID_UPDATED, this._initialization, this);
      }
      /**
       * 初始化: 初始化成员、获取COS KEY ， 初始化上传方法
       */

    }, {
      key: "_initialization",
      value: function _initialization() {
        // 1.通过tim.getPlugin 获取 cos sdk 类 ,如果获取不到，则不进行初始化
        this._initCOSSDKPlugin();

        if (this.COSSDK) {
          // 2.获取到cos sdk 继续进行初始化， cos sdk 挂载到 this
          this._initializeMembers({});

          this._getAuthorizationKey();
        } else {
          logger.warn('UploadController._initialization 没有检测到上传插件，将无法发送图片、音频、视频、文件等类型的消息。详细请参考 https://imsdk-1252463788.file.myqcloud.com/IM_DOC/Web/SDK.html#registerPlugin');
        }
      }
      /**
       * 获取COS签名的接口
       */

    }, {
      key: "_getAuthorizationKey",
      value: function _getAuthorizationKey() {
        var _this3 = this;

        var requestTime = Math.ceil(Date.now() / 1000);
        this.request({
          name: 'cosSig',
          action: 'query',
          param: {
            duration: this.expiredTimeLimit
          }
        }).then(function (response) {
          var timeout = response.data.expiredTime - requestTime;
          response.data.expiredTimeOut = timeout;
          logger.log("UploadController._getAuthorizationKey timeout=".concat(timeout, "s"));

          _this3._initializeMembers(response.data); // 设置基本配置


          _this3._expiredTimer();

          _this3._initUploaderMethod();
        })["catch"](function (error) {
          logger.warn('UploadController._getAuthorizationKey. error:', error);
        });
      }
      /**
       * 初始化COS SDK
       */

    }, {
      key: "_initCOSSDKPlugin",
      value: function _initCOSSDKPlugin() {
        var sdkName = IN_WX_MINI_APP ? 'cos-wx-sdk' : 'cos-js-sdk';
        this.COSSDK = this.tim.getPlugin(sdkName);
      }
      /**
       * 初始化上传方法
       */

    }, {
      key: "_initUploaderMethod",
      value: function _initUploaderMethod() {
        var _this4 = this;

        if (!this.appid) {
          return;
        }

        if (IN_WX_MINI_APP) {
          this.cos = new this.COSSDK({
            ForcePathStyle: true,
            getAuthorization: this._getAuthorization.bind(this)
          });
        } else {
          this.cos = new this.COSSDK({
            getAuthorization: this._getAuthorization.bind(this)
          });
        }

        if (IN_WX_MINI_APP) {
          this._cosUploadMethod = function (options, callback) {
            _this4.cos.postObject(options, callback);
          };
        } else {
          this._cosUploadMethod = function (options, callback) {
            _this4.cos.uploadFiles(options, callback); // this.cos.putObject(options, callback); // 这函数按说明调不了 ...

          };
        }

        this.triggerReady(); // 控制器 ready
      }
      /**
       *
       * @param {*} options - COS SDK 需要的options参数，暂时不知道有什么用， 但一定要有，否则不能正常callback
       * @param {*} callback - COS SDK 会使用这个callback来获取
       */

    }, {
      key: "_getAuthorization",
      value: function _getAuthorization(options, callback) {
        callback({
          TmpSecretId: this.cosOptions.secretId,
          TmpSecretKey: this.cosOptions.secretKey,
          XCosSecurityToken: this.cosOptions.sessionToken,
          ExpiredTime: this.cosOptions.expiredTime // SDK 在 ExpiredTime 时间前，不会再次调用 getAuthorization

        });
      }
      /**
       * 上传图片类型WX
       * @param {object} options - 配置参数
       * @param {HTMLInputElement} options.file - 在web端运行时，为Input<type=file> 的 DOM 对象。
       * @param {Object} options.file - 在微信小程序运行时，为包含了上传文件信息的对象，可以通过 `wx.chooseImage()` 方法来获取此对象
       * @returns {Promise}
       * @example
       * // WEB端
       * html:
       * ```html
       * <input type='file' id='uploadInput'/>
       * ```
       * javascript:
       * ```javascript
       * this.tim.uploadController.uploadImage({
       *  file: document.querySelector('input#uploadInput')
       * })
       * ```
       *
       * // 微信小程序
       * ```javascript
       * wx.chooseImage(function(res){
       *
       * });
       * ```
       */

    }, {
      key: "uploadImage",
      value: function uploadImage(options) {
        if (!options.file) {
          return IMPromise.reject(new IMError({
            code: ERROR_CODE.MESSAGE_IMAGE_SELECT_FILE_FIRST,
            message: ERROR_MESSAGE.MESSAGE_IMAGE_SELECT_FILE_FIRST
          }));
        } // 判断图片类型


        var typeCheck = this._checkImageType(options.file);

        if (typeCheck !== true) {
          return typeCheck;
        } // 判断文件MIME ， 以防鱼目混珠，待实现


        var MIMECheck = this._checkImageMime(options.file);

        if (MIMECheck !== true) {
          return MIMECheck;
        } // 判断文件大小


        var sizeCheck = this._checkImageSize(options.file);

        if (sizeCheck !== true) {
          return sizeCheck;
        }

        return this.upload(options); // TODO: 图片压缩（优图，与cos有合作）,已实现，年前先不上，注释掉
        // let uploadResult = null;
        // return this.upload(options)
        //   .then((response) => {
        //     uploadResult = response;
        //     // 获取图片信息, 优图接口：https://cloud.tencent.com/document/product/460/6927
        //     return Axios.get(`https://${response.location}?imageInfo`);
        //   })
        //   .then((info) => {
        //     uploadResult.locationLarge = this._genThumbUrl(uploadResult.location, info.data.width);
        //     uploadResult.locationSmall = this._genThumbUrl(uploadResult.location, info.data.width, 400);
        //     return Promise.resolve(uploadResult);
        //   });
      } // TODO: 图片压缩（优图，与cos有合作）,已实现，年前先不上，注释掉
      // _genThumbUrl(originUrl, originWidth, widthLimit = 800) {
      //   const sWidth = parseInt(originWidth);
      //   let tWidth = 0;
      //   if (sWidth > widthLimit) {
      //     tWidth = widthLimit;
      //   } else {
      //     // 小于 widthLimit，不需要压缩
      //     return `${originUrl}`;
      //   }
      //   // 生成缩略图地址，优图接口：https://cloud.tencent.com/document/product/460/6929
      //   return `${originUrl}?imageView2/w/${tWidth}`;
      // }

      /**
       * 检测图片类型，目前仅通过后缀名检测，后期需要升级为MIME检测
       * @param {*} file - 文件对象
       * @returns {IMPromise}
       */

    }, {
      key: "_checkImageType",
      value: function _checkImageType(file) {
        var fileType = '';

        if (IN_WX_MINI_APP) {
          fileType = file.url.slice(file.url.lastIndexOf('.') + 1);
        } else {
          fileType = file.files[0].name.slice(file.files[0].name.lastIndexOf('.') + 1);
        }

        if (UPLOAD_IMAGE_TYPES_LIMIT.indexOf(fileType.toLowerCase()) >= 0) {
          return true;
        }

        return IMPromise.reject(new IMError({
          coe: ERROR_CODE.MESSAGE_IMAGE_TYPES_LIMIT,
          message: ERROR_MESSAGE.MESSAGE_IMAGE_TYPES_LIMIT
        }));
      }
      /**
       * 检测图片的mime，防止改后缀后进行鱼目混珠
       * @param {*} file - 文件对象
       * @returns {boolean}
       */

    }, {
      key: "_checkImageMime",
      value: function _checkImageMime(file) {
        // TODO: 检测图片的mime，防止改后缀后进行鱼目混珠, 待实现，注：此方法需要浏览器支持blob对象，小程序不支持
        // 如果是小程序环境，直接返回true ， 因为小程序不支持blob
        if (IN_WX_MINI_APP) {
          return true;
        }

        return true;
      }
      /**
       * 检测文件大小
       * @param {*} file - 文件对象
       * @returns {boolean}
       */

    }, {
      key: "_checkImageSize",
      value: function _checkImageSize(file) {
        var fileSize = 0;

        if (IN_WX_MINI_APP) {
          fileSize = file.size;
        } else {
          fileSize = file.files[0].size;
        }

        if (fileSize === 0) {
          return IMPromise.reject(new IMError({
            code: ERROR_CODE.MESSAGE_FILE_IS_EMPTY,
            message: "".concat(ERROR_MESSAGE.MESSAGE_FILE_IS_EMPTY)
          }));
        }

        if (fileSize < UPLOAD_IMAGE_SIZE_LIMIT) {
          return true;
        }

        return IMPromise.reject(new IMError({
          coe: ERROR_CODE.MESSAGE_IMAGE_SIZE_LIMIT,
          message: "".concat(ERROR_MESSAGE.MESSAGE_IMAGE_SIZE_LIMIT)
        }));
      }
      /**
       * 上传文件类型
       * @param {object} options - 配置参数
       * @returns {IMPromise}
       */

    }, {
      key: "uploadFile",
      value: function uploadFile(options) {
        var imError = null;

        if (!options.file) {
          imError = new IMError({
            code: ERROR_CODE.MESSAGE_FILE_SELECT_FILE_FIRST,
            message: ERROR_MESSAGE.MESSAGE_FILE_SELECT_FILE_FIRST
          });
          return IMPromise.reject(imError);
        } // 检测文件大小 不能大于 UPLOAD_FILE_SIZE_LIMIT 的限制


        if (options.file.files[0].size > UPLOAD_FILE_SIZE_LIMIT) {
          imError = new IMError({
            code: ERROR_CODE.MESSAGE_FILE_SIZE_LIMIT,
            message: ERROR_MESSAGE.MESSAGE_FILE_SIZE_LIMIT
          });
          return IMPromise.reject(imError);
        } // 检测文件大小 不能为0


        if (options.file.files[0].size === 0) {
          imError = new IMError({
            code: ERROR_CODE.MESSAGE_FILE_IS_EMPTY,
            message: "".concat(ERROR_MESSAGE.MESSAGE_FILE_IS_EMPTY)
          });
          return IMPromise.reject(imError);
        }

        return this.upload(options);
      }
      /**
       * 上传视频类型
       * @param {object} options - 配置参数
       * @returns {IMPromise}
       */

    }, {
      key: "uploadVideo",
      value: function uploadVideo(options) {
        if (options.file.videoFile.size > UPLOAD_VIDEO_SIZE_LIMIT) {
          return IMPromise.reject(new IMError({
            code: ERROR_CODE.MESSAGE_VIDEO_SIZE_LIMIT,
            message: "".concat(ERROR_MESSAGE.MESSAGE_VIDEO_SIZE_LIMIT)
          }));
        }

        if (options.file.videoFile.size === 0) {
          return IMPromise.reject(new IMError({
            code: ERROR_CODE.MESSAGE_FILE_IS_EMPTY,
            message: "".concat(ERROR_MESSAGE.MESSAGE_FILE_IS_EMPTY)
          }));
        }

        if (UPLOAD_VIDEO_TYPES_LIMIT.indexOf(options.file.videoFile.type) === -1) {
          return IMPromise.reject(new IMError({
            code: ERROR_CODE.MESSAGE_VIDEO_TYPES_LIMIT,
            message: "".concat(ERROR_MESSAGE.MESSAGE_VIDEO_TYPES_LIMIT)
          }));
        }

        if (IN_WX_MINI_APP) {
          return this.handleVideoUpload({
            file: options.file.videoFile
          });
        }

        if (IN_BROWSER) {
          return this.handleVideoUpload(options);
        }
      } // 视频发送失败后重试一次

    }, {
      key: "handleVideoUpload",
      value: function handleVideoUpload(videoOptions) {
        var _this5 = this;

        return new Promise(function (resolve, reject) {
          _this5.upload(videoOptions).then(function (res) {
            resolve(res);
          })["catch"](function () {
            _this5.upload(videoOptions).then(function (res) {
              resolve(res);
            })["catch"](function () {
              reject(new IMError({
                code: ERROR_CODE.MESSAGE_VIDEO_UPLOAD_FAIL,
                message: ERROR_MESSAGE.MESSAGE_VIDEO_UPLOAD_FAIL
              }));
            });
          });
        });
      }
      /**
       * 上传音频类型
       * @param {object} options - 配置参数
       * @returns {IMPromise}
       */

    }, {
      key: "uploadAudio",
      value: function uploadAudio(options) {
        if (!options.file) {
          return IMPromise.reject(new IMError({
            code: ERROR_CODE.MESSAGE_AUDIO_UPLOAD_FAIL,
            message: ERROR_MESSAGE.MESSAGE_AUDIO_UPLOAD_FAIL
          }));
        }

        if (options.file.size > UPLOAD_AUDIO_SIZE_LIMIT) {
          return IMPromise.reject(new IMError({
            code: ERROR_CODE.MESSAGE_AUDIO_SIZE_LIMIT,
            message: "".concat(ERROR_MESSAGE.MESSAGE_AUDIO_SIZE_LIMIT)
          }));
        } // 检测文件大小 不能为0


        if (options.file.size === 0) {
          return IMPromise.reject(new IMError({
            code: ERROR_CODE.MESSAGE_FILE_IS_EMPTY,
            message: "".concat(ERROR_MESSAGE.MESSAGE_FILE_IS_EMPTY)
          }));
        }

        return this.upload(options);
      }
      /**
       * 上传
       * @param {File} options - 上传参数配置
       * @returns {Promise}
       */

    }, {
      key: "upload",
      value: function upload(options) {
        var _this6 = this;

        if (!isFunction(this._cosUploadMethod)) {
          logger.warn('UploadController.upload 没有检测到上传插件，将无法发送图片、音频、视频、文件等类型的消息。详细请参考 https://imsdk-1252463788.file.myqcloud.com/IM_DOC/Web/SDK.html#registerPlugin');
          return IMPromise.reject(new IMError({
            code: ERROR_CODE.COS_UNDETECTED,
            message: ERROR_MESSAGE.COS_UNDETECTED
          }));
        } // event stat


        var ssoLog = new SSOLogData();
        ssoLog.setMethod(SSOMethods.UPLOAD).setStart();
        logger.time(label.UPLOAD);
        var file = IN_WX_MINI_APP ? options.file : options.file.files[0];
        return new Promise(function (revolve, reject) {
          var cosUploadOptions = IN_WX_MINI_APP ? _this6._createCosOptionsWXMiniApp(options) // 小程序配置
          : _this6._createCosOptionsWeb(options); // web 配置

          var self = _this6;

          _this6._cosUploadMethod(cosUploadOptions, function (error, data) {
            var result = Object.create(null);

            if (data) {
              // 检测上传错误
              if (_this6._isUploadError(data, error)) {
                // ！！！上传失败时 error 为 null
                reject(data.files[0].error);
                logger.warn("UploadController.upload failed, network error:".concat(data.files[0].error.error)); // event stat

                ssoLog.setCode(ERROR_CODE.MESSAGE_FILE_UPLOAD_FAIL).setMessage(ERROR_MESSAGE.MESSAGE_FILE_UPLOAD_FAIL).setEnd();
                return;
              }

              result['fileName'] = file.name;
              result['fileSize'] = file.size;
              result['fileType'] = file.type.slice(file.type.indexOf('/') + 1).toLowerCase();

              if (IN_WX_MINI_APP) {
                // 小程序 SDK 返回值中，不带 files
                result['location'] = data.Location;
              } else {
                result['location'] = data.files[0].data.Location;
              }

              var time = logger.timeEnd(label.UPLOAD);

              var size = self._formatFileSize(file.size);

              var speed = self._formatSpeed(file.size * 1000 / time);

              var strStat = "size=".concat(size, ",time=").concat(time, "ms,speed=").concat(speed);
              logger.log("UploadController.upload success name=".concat(file.name, ",").concat(strStat));
              revolve(result); // event stat

              ssoLog.setCode(0).setNetworkType(_this6.getNetworkType()).setText(strStat).setEnd();
              return;
            } // event stat


            ssoLog.setCode(ERROR_CODE.MESSAGE_FILE_UPLOAD_FAIL).setMessage(ERROR_MESSAGE.MESSAGE_FILE_UPLOAD_FAIL).setEnd();
            logger.warn("UploadController.upload failed, error:".concat(error));
            reject(error);
          });
        });
      }
      /**
       * 检测上传是否成功
       * @param {object} data - 反馈数据
       * @param {object} error - 反馈错误
       * @returns {boolean}
       */

    }, {
      key: "_isUploadError",
      value: function _isUploadError(data, error) {
        if (IN_WX_MINI_APP) {
          return error ? true : false;
        }

        if (data.files[0].error !== null) {
          return true;
        }

        return false;
      }
    }, {
      key: "_formatFileSize",
      value: function _formatFileSize(size) {
        if (size < 1024) {
          // <1KB
          return size + 'B';
        }

        if (size < 1048576) {
          // 1KB <= size < 1MB
          return Math.floor(size / 1024) + 'KB';
        } // >= 1MB


        return Math.floor(size / 1048576) + 'MB';
      } // B/s转为KB/s或MB/s

    }, {
      key: "_formatSpeed",
      value: function _formatSpeed(speed) {
        if (speed <= 1048576) {
          var _temp = speed / 1024;

          return _temp.toFixed(1) + 'KB/s';
        }

        var temp = speed / 1048576;
        return temp.toFixed(1) + 'MB/s';
      }
      /**
       * 创建WEB COS上传配置
       * @param {object} options - 配置参数
       * @returns {object}
       */

    }, {
      key: "_createCosOptionsWeb",
      value: function _createCosOptionsWeb(options) {
        var from = this.tim.context.identifier;

        var fileName = this._genFileName(from, options.to, options.file.files[0].name);

        return {
          files: [{
            Bucket: "".concat(this.bucketName, "-").concat(this.appid),
            Region: this.region,
            Key: "".concat(this.directory, "/").concat(fileName),
            Body: options.file.files[0]
          }],
          SliceSize: 1024 * 1024,
          onProgress: function onProgress(info) {
            if (typeof options.onProgress === 'function') {
              try {
                options.onProgress(info.percent);
              } catch (userError) {
                logger.warn('onProgress callback error:');
                logger.error(userError);
              }
            }
          },
          onFileFinish: function onFileFinish(err, data, options) {// logger.log(options.Key + ' cos upload ' + (err ? 'fail' : 'success'));
          }
        };
      }
      /**
       * 创建微信小程序 COS 上传配置
       * @param {object} options - 配置参数
       * @returns {object}
       */

    }, {
      key: "_createCosOptionsWXMiniApp",
      value: function _createCosOptionsWXMiniApp(options) {
        var from = this.tim.context.identifier;

        var fileName = this._genFileName(from, options.to, options.file.name);

        var url = options.file.url;
        return {
          Bucket: "".concat(this.bucketName, "-").concat(this.appid),
          Region: this.region,
          Key: "".concat(this.directory, "/").concat(fileName),
          FilePath: url,
          onProgress: function onProgress(info) {
            logger.log(JSON.stringify(info));

            if (typeof options.onProgress === 'function') {
              try {
                options.onProgress(info.percent);
              } catch (userError) {
                logger.warn('onProgress callback error:');
                logger.error(userError);
              }
            }
          }
        };
      }
    }, {
      key: "_genFileName",
      value: function _genFileName(from, to, baseName) {
        return "".concat(from, "-").concat(to, "-").concat(randomInt(99999), "-").concat(baseName);
      }
    }]);

    return UploadController;
  }(IMController);

  /**
   * BDH（大数据通道 Big Data Hallway 内部命名）控制器，职能是：
   * 1. 登录成功时获取鉴权 key，因为 key 的有效期是 7 天，不需要自动去获取
   * 2. 在 downLoadFlg !== 2 的情况下，拼接下载 URL
   * 用于兼容老版本 SDK 发出的文件、音频、视频消息
   * @class BigDataHallwayController
   */

  var BigDataHallwayController =
  /*#__PURE__*/
  function (_IMController) {
    _inherits(BigDataHallwayController, _IMController);

    function BigDataHallwayController(tim) {
      var _this;

      _classCallCheck(this, BigDataHallwayController);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(BigDataHallwayController).call(this, tim));
      _this.FILETYPE = {
        SOUND: 2106,
        FILE: 2107,
        VIDEO: 2113
      };
      _this._bdh_download_server = 'grouptalk.c2c.qq.com'; // 文件下载域名，注：原只用于音频文件下载，经后端协调，现在也可用于文件与视频下载

      _this._BDHBizID = 10001; // 下载文件业务ID

      _this._authKey = ''; // BDH 鉴权 key 。

      _this._expireTime = 0;

      _this.tim.innerEmitter.on(TIM_INNER_EVENT.CONTEXT_A2KEY_AND_TINYID_UPDATED, _this._getAuthKey, _assertThisInitialized(_this));

      return _this;
    }

    _createClass(BigDataHallwayController, [{
      key: "_getAuthKey",
      value: function _getAuthKey() {
        var _this2 = this;

        this.request({
          name: 'bigDataHallwayAuthKey',
          action: 'query'
        }).then(function (response) {
          if (response.data.authKey) {
            _this2._authKey = response.data.authKey;
            _this2._expireTime = parseInt(response.data.expireTime);
          }
        });
      }
      /**
       * 判断消息是否由旧版本的 im 发出。
       * @memberof BigDataHallwayController
       * @param {object} element - 消息元素
       * @returns {boolean}
       */

    }, {
      key: "_isFromOlderVersion",
      value: function _isFromOlderVersion(element) {
        // element.content.downloadFlag 不为 2 即标识消息由旧版本的 im 发出
        if (element.content.downloadFlag !== 2) {
          return true;
        }

        return false;
      }
      /**
       * 供外部调用：当传入的音频、视频、文件消息元素为老版本发送的，使用 DBH 的 鉴权key + element.uuid 拼接出文件地址，并赋给 element.url 属性
       *
       * @param {Array} elements - 消息元素
       * @param {String} from - 消息发送方
       * @returns {Array}
       * @memberof BigDataHallwayController
       */

    }, {
      key: "parseElements",
      value: function parseElements(elements, from) {
        if (!isArray(elements) || !from) {
          return [];
        }

        var ret = [];
        var element = null;

        for (var i = 0; i < elements.length; i++) {
          element = elements[i];

          if (this._needParse(element)) {
            ret.push(this._parseElement(element, from));
          } else {
            ret.push(elements[i]);
          }
        }

        return ret;
      } // 旧版im（走大数据通道不走COS的版本）发的语音、文件、视频消息才需要解析

    }, {
      key: "_needParse",
      value: function _needParse(element) {
        if (this._isFromOlderVersion(element) && (element.type === TYPES.MSG_AUDIO || element.type === TYPES.MSG_FILE || element.type === TYPES.MSG_VIDEO)) {
          return true;
        }

        return false;
      } // 开始转化逻辑

    }, {
      key: "_parseElement",
      value: function _parseElement(element, from) {
        switch (element.type) {
          case TYPES.MSG_AUDIO:
            return this._parseAudioElement(element, from);

          case TYPES.MSG_FILE:
            return this._parseFileElement(element, from);

          case TYPES.MSG_VIDEO:
            return this._parseVideoElement(element, from);
        }
      }
      /**
       *把老版本消息发送来的 audioElement 转化
       *
       * @memberof BigDataHallwayController
       * @param {object} element - 消息元素
       * @param {string} from - 消息的发送方
       * @returns {object}
       */

    }, {
      key: "_parseAudioElement",
      value: function _parseAudioElement(element, from) {
        element.content.url = this._genAudioUrl(element.content.uuid, from);
        return element;
      }
      /**
       *把老版本消息发送来的 fileElement 转化
       *
       * @memberof BigDataHallwayController
       * @param {object} element - 消息元素
       * @param {string} from - 消息的发送方
       * @param {string} fileName - 文件显示的名称
       * @returns {object}
       */

    }, {
      key: "_parseFileElement",
      value: function _parseFileElement(element, from) {
        element.content.url = this._genFileUrl(element.content.uuid, from, element.content.fileName);
        return element;
      }
      /**
       *把老版本消息发送来的 fileElement 转化
       *
       * @memberof BigDataHallwayController
       * @param {object} element - 消息元素
       * @param {string} from - 消息的发送方
       * @returns {object}
       */

    }, {
      key: "_parseVideoElement",
      value: function _parseVideoElement(element, from) {
        element.content.url = this._genVideoUrl(element.content.uuid, from);
        return element;
      }
      /**
       *当 audioElement 中的 downLoadFlag !==2 时，使用此方法生成音频文件地址
       *
       * @memberof BigDataHallwayController
       * @param {string} uuid - 大数据通道中的唯一标识符
       * @param {string} from - 消息发送者
       * @returns {string}
       */

    }, {
      key: "_genAudioUrl",
      value: function _genAudioUrl(uuid, from) {
        if (this._authKey === '') {
          logger.warn('BigDataHallwayController._genAudioUrl no authKey!');
          return '';
        }

        return "https://".concat(this._bdh_download_server, "/asn.com/stddownload_common_file?authkey=").concat(this._authKey, "&bid=").concat(this._BDHBizID, "&subbid=").concat(this.tim.context.SDKAppID, "&fileid=").concat(uuid, "&filetype=").concat(this.FILETYPE.SOUND, "&openid=").concat(from, "&ver=0");
      }
      /**
       * 当 fileElement 中的 downLoadFlag !==2 时，使用此方法生成文件地址
       *
       * @memberof BigDataHallwayController
       * @param {string} uuid - 大数据通道中的唯一标识符
       * @param {string} from - 消息发送者
       * @param {string} [fileName] - 文件名称,不传的话，会使用毫秒时间+随机数命名
       * @returns {string}
       */

    }, {
      key: "_genFileUrl",
      value: function _genFileUrl(uuid, from, fileName) {
        if (this._authKey === '') {
          logger.warn('BigDataHallwayController._genFileUrl no authKey!');
          return '';
        }

        if (!fileName) {
          fileName = "".concat(Math.floor(100000 * Math.random()), "-").concat(Date.now());
        } // _dbh_download_server 也可以用于下载文件与视频


        return "https://".concat(this._bdh_download_server, "/asn.com/stddownload_common_file?authkey=").concat(this._authKey, "&bid=").concat(this._BDHBizID, "&subbid=").concat(this.tim.context.SDKAppID, "&fileid=").concat(uuid, "&filetype=").concat(this.FILETYPE.FILE, "&openid=").concat(from, "&ver=0&filename=").concat(encodeURIComponent(fileName));
      }
      /**
       * 当 videoElement 中的 downLoadFlag !==2  时，使用此方法生成视频地址
       *
       * @memberof BigDataHallwayController
       * @param {string} uuid - 大数据通道中的唯一标识符
       * @param {string} from - 消息发送者
       * @returns {string}
       */

    }, {
      key: "_genVideoUrl",
      value: function _genVideoUrl(uuid, from) {
        if (this._authKey === '') {
          logger.warn('BigDataHallwayController._genVideoUrl no authKey!');
          return '';
        } // _dbh_download_server 也可以用于下载文件与视频


        return "https://".concat(this._bdh_download_server, "/asn.com/stddownload_common_file?authkey=").concat(this._authKey, "&bid=").concat(this._BDHBizID, "&subbid=").concat(this.tim.context.SDKAppID, "&fileid=").concat(uuid, "&filetype=").concat(this.FILETYPE.VIDEO, "&openid=").concat(from, "&ver=0");
      }
    }, {
      key: "reset",
      value: function reset() {
        this._authKey = '';
        this.expireTime = 0;
      }
    }]);

    return BigDataHallwayController;
  }(IMController);

  var MTA_CONFIG={app_id:"",event_id:"",api_base:"https://pingtas.qq.com/pingd",prefix:"_mta_",version:"1.3.9",stat_share_app:!1,stat_pull_down_fresh:!1,stat_reach_bottom:!1,stat_param:!0};function getNetworkType(a){wx.getNetworkType({success:function(b){a(b.networkType);}});}
  function getSystemInfo(){var a=wx.getSystemInfoSync();return {adt:encodeURIComponent(a.model),scl:a.pixelRatio,scr:a.windowWidth+"x"+a.windowHeight,lg:a.language,fl:a.version,jv:encodeURIComponent(a.system),tz:encodeURIComponent(a.platform)}}function getUID(){try{return wx.getStorageSync(MTA_CONFIG.prefix+"auid")}catch(a){}}function setUID(){try{var a=getRandom();wx.setStorageSync(MTA_CONFIG.prefix+"auid",a);return a}catch(b){}}
  function getSID(){try{return wx.getStorageSync(MTA_CONFIG.prefix+"ssid")}catch(a){}}function setSID(){try{var a="s"+getRandom();wx.setStorageSync(MTA_CONFIG.prefix+"ssid",a);return a}catch(b){}}function getRandom(a){for(var b=[0,1,2,3,4,5,6,7,8,9],c=10;1<c;c--){var d=Math.floor(10*Math.random()),f=b[d];b[d]=b[c-1];b[c-1]=f;}for(c=d=0;5>c;c++)d=10*d+b[c];return (a||"")+(d+""+ +new Date)}
  function getPagePath(){try{var a=getCurrentPages(),b="/";0<a.length&&(b=a.pop().__route__);return b}catch(c){console.log("get current page path error:"+c);}}function getMainInfo(){var a={dm:"wechat.apps.xx",url:encodeURIComponent(getPagePath()+getQuery(MTA.Data.pageQuery)),pvi:"",si:"",ty:0};a.pvi=function(){var b=getUID();b||(b=setUID(),a.ty=1);return b}();a.si=function(){var a=getSID();a||(a=setSID());return a}();return a}
  function getBasicInfo(){var a=getSystemInfo();getNetworkType(function(a){try{wx.setStorageSync(MTA_CONFIG.prefix+"ntdata",a);}catch(c){}});a.ct=wx.getStorageSync(MTA_CONFIG.prefix+"ntdata")||"4g";return a}function getExtentInfo(){var a=MTA.Data.userInfo;var b=[],c;for(c in a)a.hasOwnProperty(c)&&b.push(c+"="+a[c]);a=b.join(";");return {r2:MTA_CONFIG.app_id,r4:"wx",ext:"v="+MTA_CONFIG.version+(null!==a&&""!==a?";ui="+encodeURIComponent(a):"")}}
  function getQuery(a){if(!MTA_CONFIG.stat_param||!a)return "";a=ignoreParams(a);var b=[],c;for(c in a)b.push(c+"="+a[c]);return 0<b.length?"?"+b.join("&"):""}function ignoreParams(a){if(1>MTA_CONFIG.ignore_params.length)return a;var b={},c;for(c in a)0<=MTA_CONFIG.ignore_params.indexOf(c)||(b[c]=a[c]);return b}
  function initOnload(){var a=Page;Page=function(b){var c=b.onLoad;b.onLoad=function(a){c&&c.call(this,a);MTA.Data.lastPageQuery=MTA.Data.pageQuery;MTA.Data.pageQuery=a;MTA.Data.lastPageUrl=MTA.Data.pageUrl;MTA.Data.pageUrl=getPagePath();MTA.Data.show=!1;MTA.Page.init();};a(b);};}
  var MTA={App:{init:function(a){"appID"in a&&(MTA_CONFIG.app_id=a.appID);"eventID"in a&&(MTA_CONFIG.event_id=a.eventID);"statShareApp"in a&&(MTA_CONFIG.stat_share_app=a.statShareApp);"statPullDownFresh"in a&&(MTA_CONFIG.stat_pull_down_fresh=a.statPullDownFresh);"statReachBottom"in a&&(MTA_CONFIG.stat_reach_bottom=a.statReachBottom);"ignoreParams"in a&&(MTA_CONFIG.ignore_params=a.ignoreParams);"statParam"in a&&(MTA_CONFIG.stat_param=a.statParam);setSID();try{"lauchOpts"in a&&(MTA.Data.lanchInfo=a.lauchOpts,
    MTA.Data.lanchInfo.landing=1);}catch(b){}"autoReport"in a&&a.autoReport&&initOnload();}},Page:{init:function(){var a=getCurrentPages()[getCurrentPages().length-1];a.onShow&&!function(){var b=a.onShow;a.onShow=function(){if(!0===MTA.Data.show){var a=MTA.Data.lastPageQuery;MTA.Data.lastPageQuery=MTA.Data.pageQuery;MTA.Data.pageQuery=a;MTA.Data.lastPageUrl=MTA.Data.pageUrl;MTA.Data.pageUrl=getPagePath();}MTA.Data.show=!0;MTA.Page.stat();b.apply(this,arguments);};}();MTA_CONFIG.stat_pull_down_fresh&&a.onPullDownRefresh&&
  !function(){var b=a.onPullDownRefresh;a.onPullDownRefresh=function(){MTA.Event.stat(MTA_CONFIG.prefix+"pulldownfresh",{url:a.__route__});b.apply(this,arguments);};}();MTA_CONFIG.stat_reach_bottom&&a.onReachBottom&&!function(){var b=a.onReachBottom;a.onReachBottom=function(){MTA.Event.stat(MTA_CONFIG.prefix+"reachbottom",{url:a.__route__});b.apply(this,arguments);};}();MTA_CONFIG.stat_share_app&&a.onShareAppMessage&&!function(){var b=a.onShareAppMessage;a.onShareAppMessage=function(){MTA.Event.stat(MTA_CONFIG.prefix+
    "shareapp",{url:a.__route__});return b.apply(this,arguments)};}();},multiStat:function(a,b){if(1==b)MTA.Page.stat(a),!0;else{var c=getCurrentPages()[getCurrentPages().length-1];c.onShow&&!function(){var b=c.onShow;c.onShow=function(){MTA.Page.stat(a);b.call(this,arguments);};}();}},stat:function(a){if(""!=MTA_CONFIG.app_id){var b=[],c=getExtentInfo();a&&(c.r2=a);a=[getMainInfo(),c,getBasicInfo()];if(MTA.Data.lanchInfo){a.push({ht:MTA.Data.lanchInfo.scene});MTA.Data.pageQuery&&MTA.Data.pageQuery._mta_ref_id&&
  a.push({rarg:MTA.Data.pageQuery._mta_ref_id});try{1==MTA.Data.lanchInfo.landing&&(c.ext+=";lp=1",MTA.Data.lanchInfo.landing=0);}catch(e){}}a.push({rdm:"/",rurl:0>=MTA.Data.lastPageUrl.length?MTA.Data.pageUrl+getQuery(MTA.Data.lastPageQuery):encodeURIComponent(MTA.Data.lastPageUrl+getQuery(MTA.Data.lastPageQuery))});a.push({rand:+new Date});c=0;for(var d=a.length;c<d;c++)for(var f in a[c])a[c].hasOwnProperty(f)&&b.push(f+"="+("undefined"==typeof a[c][f]?"":a[c][f]));wx.request({url:MTA_CONFIG.api_base+
  "?"+b.join("&").toLowerCase()});}}},Event:{stat:function(a,b){if(""!=MTA_CONFIG.event_id){var c=[],d=getMainInfo(),f=getExtentInfo();d.dm="wxapps.click";d.url=a;f.r2=MTA_CONFIG.event_id;var e="undefined"===typeof b?{}:b;var k=[],g;for(g in e)e.hasOwnProperty(g)&&k.push(encodeURIComponent(g)+"="+encodeURIComponent(e[g]));e=k.join(";");f.r5=e;e=0;d=[d,f,getBasicInfo(),{rand:+new Date}];for(f=d.length;e<f;e++)for(var h in d[e])d[e].hasOwnProperty(h)&&c.push(h+"="+("undefined"==typeof d[e][h]?"":d[e][h]));
    wx.request({url:MTA_CONFIG.api_base+"?"+c.join("&").toLowerCase()});}}},Data:{userInfo:null,lanchInfo:null,pageQuery:null,lastPageQuery:null,pageUrl:"",lastPageUrl:"",show:!1}};var mtaWechatAnalysis=MTA;

  /**
   * 封装 MTA SDK，兼容 Web 和 小程序
   * {@link https://mta.qq.com/docs/h5.html MTA Web接入}
   * {@link https://mta.qq.com/docs/wechat_mini_program.html MTA 小程序接入}
   * @class MTA
   * @author rychouwei
   */

  var MTA$1 =
  /*#__PURE__*/
  function () {
    function MTA() {
      _classCallCheck(this, MTA);

      this.cache = []; // 缓存队列。Web端的MTA是异步加载的，若 MTA 没加载完成，触发了 report，则先进入缓存队列。下次 report 时再上报。

      this.MtaWX = null;

      this._init();
    }
    /**
     * 手动上报事件，具体配置参考
     * {@link https://mta.qq.com/h5/visitor/ctr_custom_param_config?custom_id=246778&app_id=500690998 Web}
     * {@link https://mta.qq.com/wechat_mini/custom/ctr_custom_param_config?app_id=500690995&custom_id=246775 小程序}
     * @param {String} name
     * @param {Object} param
     * @memberof MTA
     * @example
     * tim.mta.report('sendmessage', { send: true })
     */


    _createClass(MTA, [{
      key: "report",
      value: function report(name, param) {
        var _this = this;

        try {
          // Web
          if (IN_BROWSER) {
            if (window.MtaH5) {
              window.MtaH5.clickStat(name, param); // 上报缓存队列的事件

              this.cache.forEach(function (_ref) {
                var name = _ref.name,
                    param = _ref.param;
                window.MtaH5.clickStat(name, param);

                _this.cache.shift();
              });
            } else {
              // 将事件缓存
              this.cache.push({
                name: name,
                param: param
              });
            }
          } else if (IN_WX_MINI_APP) {
            // 小程序
            if (this.MtaWX) {
              this.MtaWX.Event.stat(name, param); // 上报缓存队列的事件

              this.cache.forEach(function (_ref2) {
                var name = _ref2.name,
                    param = _ref2.param;

                _this.MtaWX.stat(name, param);

                _this.cache.shift();
              });
            } else {
              // 将事件缓存
              this.cache.push({
                name: name,
                param: param
              });
            }
          }
        } catch (error) {} // 拦截错误即可，不做处理

      }
      /**
       * 统计上报，统计PV等数据
       * @memberof MTA
       */

    }, {
      key: "stat",
      value: function stat() {
        try {
          if (IN_BROWSER && window.MtaH5) {
            window.MtaH5.pgv();
          } else if (IN_WX_MINI_APP && this.MtaWX) {
            this.MtaWX.Page.stat();
          }
        } catch (error) {} // 拦截错误即可，不做处理

      }
      /**
       * 初始化
       * @private
       * @memberof MTA
       */

    }, {
      key: "_init",
      value: function _init() {
        try {
          if (IN_BROWSER) {
            window._mtac = {
              autoReport: 0
            };
            var mta = document.createElement('script');
            var proto = getPageProtocol();
            mta.src = "".concat(proto, "//pingjs.qq.com/h5/stats.js?v2.0.4");
            mta.setAttribute('name', 'MTAH5');
            mta.setAttribute('sid', '500690998');
            mta.setAttribute('cid', '500691017');
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(mta, s);
          } else if (IN_WX_MINI_APP) {
            this.MtaWX = mtaWechatAnalysis;
            this.MtaWX.App.init({
              appID: '500690995',
              eventID: '500691014',
              // 高级功能-自定义事件统计ID，配置开通后在初始化处填写
              autoReport: false,
              statParam: true
            });
          }
        } catch (error) {}
      }
    }]);

    return MTA;
  }();

  /**
   * 上报控制器，基于 MTA
   * @class ReporterController
   * @extends {IMController}
   * @author rychouwei
   */

  var MTAReportController =
  /*#__PURE__*/
  function (_IMController) {
    _inherits(MTAReportController, _IMController);

    function MTAReportController(tim) {
      var _this;

      _classCallCheck(this, MTAReportController);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(MTAReportController).call(this, tim));
      _this.MTA = new MTA$1();
      var innerEmitter = _this.tim.innerEmitter;
      innerEmitter.on(TIM_INNER_EVENT.SDK_READY, _this._stat, _assertThisInitialized(_this));
      innerEmitter.on(TIM_INNER_EVENT.AVCHATROOM_JOIN_SUCCESS_NO_AUTH, _this._stat, _assertThisInitialized(_this));
      return _this;
    }

    _createClass(MTAReportController, [{
      key: "_stat",
      value: function _stat() {
        // 统计 SDK appID
        this.MTA.report('sdkappid', {
          value: this.tim.context.SDKAppID
        }); // 统计版本号

        this.MTA.report('version', {
          value: TIM.VERSION
        }); // 统计 PV

        this.MTA.stat();
      }
    }]);

    return MTAReportController;
  }(IMController);

  var SSOLogBody =
  /*#__PURE__*/
  function () {
    function SSOLogBody(options) {
      _classCallCheck(this, SSOLogBody);

      this._table = 'timwebii'; // 对应 ELK 表名： imsdk-timweb-*

      this._report = [];
    }
    /**
     * 缓存日志数据
     * @param {SSOLogData} logData - 一行日志数据
     */


    _createClass(SSOLogBody, [{
      key: "pushIn",
      value: function pushIn(logData) {
        logger.debug('SSOLogBody.pushIn', this._report.length, logData);

        this._report.push(logData);
      }
      /**
       * 回填，从头部插入日志数据
       * @param {Array.<SSOLogData>} logDatas 日志数据数组
       */

    }, {
      key: "backfill",
      value: function backfill(logDatas) {
        var _this$_report;

        if (!isArray(logDatas) || logDatas.length === 0) {
          return;
        }

        logger.debug('SSOLogBody.backfill', this._report.length, logDatas.length);

        (_this$_report = this._report).unshift.apply(_this$_report, _toConsumableArray(logDatas));
      }
      /**
       * 当前已缓存的日志数量
       * @returns {Number}
       */

    }, {
      key: "getLogsNumInMemory",
      value: function getLogsNumInMemory() {
        return this._report.length;
      }
    }, {
      key: "isEmpty",
      value: function isEmpty() {
        return this._report.length === 0;
      }
    }, {
      key: "_reset",
      value: function _reset() {
        this._report.length = 0;
        this._report = [];
      }
    }, {
      key: "getTable",
      value: function getTable() {
        return this._table;
      }
      /**
       * 获取已缓存的 logs 用于上报，并清空内存缓存。这些logs是 this._report 的copy
       * @returns {Array}
       */

    }, {
      key: "getLogsInMemory",
      value: function getLogsInMemory() {
        var ret = this._report.slice();

        this._reset();

        return ret;
      }
    }]);

    return SSOLogBody;
  }();

  /**
   * 事件统计控制器。
   * 事件统计用于低频操作，如登录、拉取群组列表、发消息失败等。
   * 汇总统计用于高频操作，如 longpolling sendMessage 等。两个是不同的统计、上报方式，分别在不同的 controller 实现
   */

  var EventStatController =
  /*#__PURE__*/
  function (_IMController) {
    _inherits(EventStatController, _IMController);

    function EventStatController(tim) {
      var _this;

      _classCallCheck(this, EventStatController);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(EventStatController).call(this, tim));
      _this.TAG = 'im-ssolog-event';
      _this._reportBody = new SSOLogBody(); // 缓冲区

      _this._version = version ;
      _this.MIN_THRESHOLD = 20; // 缓存日志数量超过此值可上报

      _this.MAX_THRESHOLD = 100; // 最大缓存日志数量，超过此值后需清空缓存日志

      _this.WAITING_TIME = 60000; // 默认等待 60 秒

      _this.INTERVAL = 20000; // 每20s检测一次

      _this._timerID = 0; // 计时器ID

      _this._resetLastReportTime(); // 重置上报时间，首次重置时，为实例创建的时间


      _this._startReportTimer(); // 初始化上报计时器


      _this._retryCount = 0; // 上报失败时的重试次数

      _this.MAX_RETRY_COUNT = 3; // 上报失败时的最大重试次数

      _this.tim.innerEmitter.on(TIM_INNER_EVENT.SIGN_LOGIN_SUCCESS, _this._onLoginSuccess, _assertThisInitialized(_this));

      return _this;
    }
    /**
     * 立即上报，遇到登陆失败等情况下调用
     */


    _createClass(EventStatController, [{
      key: "reportAtOnce",
      value: function reportAtOnce() {
        logger.debug('EventStatController.reportAtOnce');

        this._report();
      } // 登录成功后从缓存中读取ssolog

    }, {
      key: "_onLoginSuccess",
      value: function _onLoginSuccess() {
        var _this2 = this;

        var storage = this.tim.storage; // 注意！写入的时候没有拼接 prefix 和 key，读取和删除的时候也不用拼接

        var logsInStorage = storage.getItem(this.TAG, false);

        if (isEmpty(logsInStorage)) {
          return;
        }

        logger.log('EventStatController._onLoginSuccess get ssolog in storage, nums=' + logsInStorage.length);
        logsInStorage.forEach(function (data) {
          _this2._reportBody.pushIn(data);
        }); // 读取到内存缓存后删除本地缓存，避免重复上报

        storage.removeItem(this.TAG, false);
      }
      /**
       *把日志推入数组
       *
       * @param {SSOLogData} data - 日志实例
       * @memberof EventStatController
       */

    }, {
      key: "pushIn",
      value: function pushIn(data) {
        if (!(data instanceof SSOLogData)) {
          return;
        }

        data.setCommonInfo(this.tim.context.SDKAppID, this._version, this.tim.context.tinyID, this.tim.loginInfo.identifier, this.getPlatform());

        this._reportBody.pushIn(data);

        if (this._reportBody.getLogsNumInMemory() >= this.MIN_THRESHOLD) {
          this._report();
        }
      } // 重置最后一次上报的时间

    }, {
      key: "_resetLastReportTime",
      value: function _resetLastReportTime() {
        this._lastReportTime = Date.now();
      }
    }, {
      key: "_startReportTimer",
      value: function _startReportTimer() {
        var _this3 = this;

        this._timerID = setInterval(function () {
          // 如果当时时间没达到 _lastReportTime + _waitTime 的值，则不触发上报
          if (Date.now() < _this3._lastReportTime + _this3.WAITING_TIME) {
            return;
          }

          if (!_this3._reportBody.isEmpty()) {
            _this3._report();
          }
        }, this.INTERVAL);
      }
    }, {
      key: "_stopReportTimer",
      value: function _stopReportTimer() {
        if (this._timerID > 0) {
          clearInterval(this._timerID);
          this._timerID = 0;
        }
      } // 上报，失败后会尝试几次，直到超过最大值，超过后缓存日志到本地

    }, {
      key: "_report",
      value: function _report() {
        var _this4 = this;

        if (this._reportBody.isEmpty()) {
          return;
        }

        var logsInMemory = this._reportBody.getLogsInMemory();

        this.request({
          name: 'ssoEventStat',
          action: 'create',
          param: {
            table: this._reportBody.getTable(),
            report: logsInMemory
          }
        }).then(function () {
          _this4._resetLastReportTime(); // 上报成功后，更新计时


          if (_this4._retryCount > 0) {
            logger.debug('EventStatController.report retry success');
            _this4._retryCount = 0;
          }
        })["catch"](function (error) {
          logger.warn("EventStatController.report, online:".concat(_this4.getNetworkType(), " error:").concat(error)); // 上传失败时回填 logs，避免丢失

          _this4._reportBody.backfill(logsInMemory);

          var tmpNum = _this4._reportBody.getLogsNumInMemory(); // 日志积压超过最大阀值 或 达到最大重试次数 或 定时器已停（用户登出时），把数据写入缓存


          if (tmpNum > _this4.MAX_THRESHOLD || _this4._retryCount === _this4.MAX_RETRY_COUNT || _this4._timerID === 0) {
            _this4._retryCount = 0;

            _this4._flushAtOnce();

            return;
          }

          _this4._retryCount += 1;
        });
      } // 立即写 ssolog 到本地缓存

    }, {
      key: "_flushAtOnce",
      value: function _flushAtOnce() {
        // 先读后写，避免覆盖（最多存储100条日志到本地，超出就覆盖式更新）
        // 注意！写入的时候没有拼接 prefix 和 key，读取和删除的时候也不用拼接
        var storage = this.tim.storage;
        var logsInStorage = storage.getItem(this.TAG, false);

        var logsInMemory = this._reportBody.getLogsInMemory();

        if (isEmpty(logsInStorage)) {
          logger.log('EventStatController._flushAtOnce nums=' + logsInMemory.length);
          storage.setItem(this.TAG, logsInMemory, true, false);
        } else {
          var tmpArray = logsInMemory.concat(logsInStorage);

          if (tmpArray.length > this.MAX_THRESHOLD) {
            tmpArray = tmpArray.slice(0, this.MAX_THRESHOLD);
          }

          logger.log('EventStatController._flushAtOnce nums=' + tmpArray.length);
          storage.setItem(this.TAG, tmpArray, true, false);
        }
      }
    }, {
      key: "reset",
      value: function reset() {
        logger.log('EventStatController.reset');

        this._stopReportTimer();

        this._report(); // reset时马上触发一次上报，防止 _threshold 和 _waitTime 内没有上报的日志数据丢失。

      }
    }]);

    return EventStatController;
  }(IMController);

  var NetworkType = {
    'WIFI': 'wifi',
    '2G': '2g',
    '3G': '3g',
    '4G': '4g',
    'UNKNOWN': 'unknown',
    // Android 下不常见的网络类型
    'NONE': 'none',
    // 无网络
    'ONLINE': 'online' // 标识 h5 环境下已接入网络

  };

  /**
   * 监测网络状态的工具类
   */

  var NetMonitor =
  /*#__PURE__*/
  function () {
    function NetMonitor() {
      _classCallCheck(this, NetMonitor);

      this._networkType = ''; // 网络类型

      this.maxWaitTime = 3000; // 探测联网最大等待时间
    }
    /**
     * 开始探测联网状态
     */


    _createClass(NetMonitor, [{
      key: "start",
      value: function start() {
        var _this = this;

        if (IN_WX_MINI_APP) {
          wx.getNetworkType({
            success: function success(res) {
              _this._networkType = res.networkType;

              if (res.networkType === NetworkType.NONE) {
                logger.warn('NetMonitor no network, please check!');
              } else {
                logger.info("NetMonitor networkType:".concat(res.networkType));
              }
            }
          });
          wx.onNetworkStatusChange(this._onWxNetworkStatusChange.bind(this));
        } else {
          this._networkType = NetworkType.ONLINE; // default value
        }
      }
    }, {
      key: "_onWxNetworkStatusChange",
      value: function _onWxNetworkStatusChange(res) {
        this._networkType = res.networkType;

        if (res.isConnected) {
          logger.info("NetMonitor networkType:".concat(res.networkType));
        } else {
          logger.warn('NetMonitor no network, please check!');
        }
      }
      /**
       * 探测网络接入情况。Promise状态始终是resolved。
       * @example
       * // bOnline true->已接入网络，false->未接入网络
       * // networkType 已接入的网络的类型，未接入网络时值为 NetworkType.NONE
       * netMonitor.probe().then([bOnline, networkType]) => {
       *   console.log('netmonitor info:', bOnline, networkType);
       * })
       *
       * @returns {Promise}
       */

    }, {
      key: "probe",
      value: function probe() {
        var _this2 = this;

        return new Promise(function (resolve, reject) {
          if (IN_WX_MINI_APP) {
            // probe mp
            wx.getNetworkType({
              success: function success(res) {
                _this2._networkType = res.networkType;

                if (res.networkType === NetworkType.NONE) {
                  logger.warn('NetMonitor no network, please check!');
                  resolve([false, res.networkType]);
                } else {
                  logger.info("NetMonitor networkType:".concat(res.networkType));
                  resolve([true, res.networkType]);
                }
              }
            });
          } else {
            // probe web
            // 浏览器支持 fetch 接口优先用 fetch，不支持的话用 XMLHttpRequest
            // see: https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Using_Fetch
            if (window && window.fetch) {
              fetch("".concat(getPageProtocol(), "//webim-1252463788.file.myqcloud.com/assets/test/speed.xml?random=").concat(Math.random())).then(function (res) {
                if (res.ok) {
                  resolve([true, NetworkType.ONLINE]); // 表示 h5 环境下已接入网络
                } else {
                  resolve([false, NetworkType.NONE]);
                }
              })["catch"](function (error) {
                resolve([false, NetworkType.NONE]);
              });
            } else {
              var xhr = new XMLHttpRequest();
              var noResponseTimer = setTimeout(function () {
                logger.warn('NetMonitor fetch timeout. Probably no network, please check!');
                xhr.abort();
                _this2._networkType = NetworkType.NONE;
                resolve([false, NetworkType.NONE]);
              }, _this2.maxWaitTime);

              xhr.onreadystatechange = function () {
                if (xhr.readyState !== 4) {
                  return;
                }

                clearTimeout(noResponseTimer);

                if (xhr.status === 200 || xhr.status === 304) {
                  this._networkType = NetworkType.ONLINE;
                  resolve([true, NetworkType.ONLINE]); // 表示 h5 环境下已接入网络
                } else {
                  logger.warn("NetMonitor fetch status:".concat(xhr.status, ". Probably no network, please check!"));
                  this._networkType = NetworkType.NONE;
                  resolve([false, NetworkType.NONE]);
                }
              };

              xhr.open('GET', "".concat(getPageProtocol(), "//webim-1252463788.file.myqcloud.com/assets/test/speed.xml?random=").concat(Math.random()));
              xhr.send();
            }
          }
        });
      }
      /**
       * 当前网络类型
       * @returns {String}
       */

    }, {
      key: "getNetworkType",
      value: function getNetworkType() {
        return this._networkType;
      }
    }, {
      key: "reset",
      value: function reset() {
        this._networkType = '';
      }
    }]);

    return NetMonitor;
  }();

  /**
   * 平均值计算器
   */

  var AverageCalculator =
  /*#__PURE__*/
  function () {
    function AverageCalculator(keys) {
      var _this = this;

      _classCallCheck(this, AverageCalculator);

      if (!isArray(keys)) {
        logger.warn('AverageCalculator.constructor need keys');
        return;
      }

      this._map = new Map();
      keys.forEach(function (key) {
        _this._map.set(key, []);
      });
    }
    /**
     * 存入数据
     * @param {String} key 统计项
     * @param {Number} cost 耗时. 单位毫秒
     * @returns {Boolean} true->存入成功 false->存入失败
     */


    _createClass(AverageCalculator, [{
      key: "push",
      value: function push(key, cost) {
        if (isUndefined(key) || !this._map.has(key) || !isNumber(cost)) {
          return false;
        }

        this._map.get(key).push(cost);

        return true;
      }
      /**
       * 获取缓存的数量
       * @param {String} key 统计项
       * @returns {Number} 整数。-1 表示获取失败
       */

    }, {
      key: "getSize",
      value: function getSize(key) {
        if (isUndefined(key) || !this._map.has(key)) {
          return -1;
        }

        return this._map.get(key).length;
      }
      /**
       * 计算平均值。注意！计算完平均值，内部数组将会清空
       * @param {String} key 统计项
       * @returns {Number} 取整，不保留小数点。-1 表示获取失败
       */

    }, {
      key: "getAvg",
      value: function getAvg(key) {
        if (isUndefined(key) || !this._map.has(key)) {
          return -1;
        }

        var tmpArr = this._map.get(key);

        var length = tmpArr.length;

        if (length === 0) {
          return 0;
        }

        var sum = 0;
        tmpArr.forEach(function (value) {
          sum += value;
        });
        tmpArr.length = 0;

        this._map.set(key, []);

        return parseInt(sum / length);
      }
      /**
       * 取出最大值
       * @param {String} key 统计项
       * @returns {Number} -1 表示获取失败
       */

    }, {
      key: "getMax",
      value: function getMax(key) {
        if (isUndefined(key) || !this._map.has(key)) {
          return -1;
        }

        return Math.max.apply(null, this._map.get(key));
      }
      /**
       * 取出最小值
       * @param {String} key 统计项
       * @returns {Number} -1 表示获取失败
       */

    }, {
      key: "getMin",
      value: function getMin(key) {
        if (isUndefined(key) || !this._map.has(key)) {
          return -1;
        }

        return Math.min.apply(null, this._map.get(key));
      }
    }, {
      key: "reset",
      value: function reset() {
        this._map.forEach(function (tmpArr) {
          tmpArr.length = 0;
        });
      }
    }]);

    return AverageCalculator;
  }();

  /**
   * 成功率计算器
   */

  var SuccessRateCalculator =
  /*#__PURE__*/
  function () {
    function SuccessRateCalculator(keys) {
      var _this = this;

      _classCallCheck(this, SuccessRateCalculator);

      if (!isArray(keys)) {
        logger.warn('SuccessRateCalculator.constructor need keys');
        return;
      }

      this._map = new Map();
      keys.forEach(function (key) {
        _this._map.set(key, {
          totalCount: 0,
          successCount: 0
        });
      });
    }
    /**
     * 总数 +1
     * @param {String} key 统计项
     * @returns {Boolean} true->操作成功 false->操作失败
     */


    _createClass(SuccessRateCalculator, [{
      key: "addTotalCount",
      value: function addTotalCount(key) {
        if (isUndefined(key) || !this._map.has(key)) {
          return false;
        }

        this._map.get(key).totalCount += 1;
        return true;
      }
      /**
       * 成功数 +1
       * @param {String} key 统计项
       * @returns {Boolean} true->操作成功 false->操作失败
       */

    }, {
      key: "addSuccessCount",
      value: function addSuccessCount(key) {
        if (isUndefined(key) || !this._map.has(key)) {
          return false;
        }

        this._map.get(key).successCount += 1;
        return true;
      }
      /**
       * 计算成功率。注意！计算成功率后，totalCount 和 successCount 会被清零
       * @param {String} key 统计项
       * @returns {Number} 保留小数点后2位。-1 表示获取失败
       */

    }, {
      key: "getSuccessRate",
      value: function getSuccessRate(key) {
        if (isUndefined(key) || !this._map.has(key)) {
          return -1;
        }

        var tmpObj = this._map.get(key);

        if (tmpObj.totalCount === 0) {
          return 1;
        }

        var ret = parseFloat((tmpObj.successCount / tmpObj.totalCount).toFixed(2));
        tmpObj.totalCount = tmpObj.successCount = 0;
        return ret;
      }
      /**
       * 获取总数
       * @param {String} key 统计项
       * @returns {Number} 整数。-1 表示获取失败
       */

    }, {
      key: "getTotalCount",
      value: function getTotalCount(key) {
        if (isUndefined(key) || !this._map.has(key)) {
          return -1;
        }

        return this._map.get(key).totalCount;
      }
    }, {
      key: "reset",
      value: function reset() {
        this._map.forEach(function (tmpObj) {
          tmpObj.totalCount = 0;
          tmpObj.successCount = 0;
        });
      }
    }]);

    return SuccessRateCalculator;
  }();

  /**
   * 汇总统计控制器
   * 事件统计用于低频操作，如登录、拉取群组列表、发消息失败等。
   * 汇总统计用于高频操作，如 longpolling sendMessage 等。两个是不同的统计、上报方式，分别在不同的 controller 实现
   */

  var SumStatController =
  /*#__PURE__*/
  function (_IMController) {
    _inherits(SumStatController, _IMController);

    function SumStatController(tim) {
      var _this;

      _classCallCheck(this, SumStatController);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(SumStatController).call(this, tim)); // 上报的表名

      _this.TABLE = 'timwebsum';
      _this.TAG = 'im-ssolog-sumstat'; // 汇总统计项

      _this._items = [label.LONG_POLLING, label.LONG_POLLING_AV, label.SEND_MESSAGE]; // 不同统计项对应的阈值不同。这里的阈值是成功次数的阈值，并不是总数的阈值
      // 比如发消息，发送成功15条才会上报，如果中间有发消息失败的情况，则发消息总数会大于15

      _this._thresholdMap = new Map();

      _this._thresholdMap.set(label.LONG_POLLING, 100);

      _this._thresholdMap.set(label.LONG_POLLING_AV, 150);

      _this._thresholdMap.set(label.SEND_MESSAGE, 15); // longpolling id


      _this._lpID = ''; // 平台

      _this._platform = _this.getPlatform(); // 上次上报时间

      _this._lastReportTime = 0; // 存储上报信息数组

      _this._statInfoArr = []; // 重试次数

      _this._retryCount = 0; // 计算平均值

      _this._avgCalc = new AverageCalculator(_this._items); // 计算成功率

      _this._successRateCalc = new SuccessRateCalculator(_this._items);

      _this.tim.innerEmitter.on(TIM_INNER_EVENT.SIGN_LOGIN_SUCCESS, _this._onLoginSuccess, _assertThisInitialized(_this));

      return _this;
    } // 登录成功后从缓存中读取sumstat


    _createClass(SumStatController, [{
      key: "_onLoginSuccess",
      value: function _onLoginSuccess() {
        var _this2 = this;

        var storage = this.tim.storage; // 注意！写入的时候没有拼接 prefix 和 key，读取和删除的时候也不用拼接

        var logsInStorage = storage.getItem(this.TAG, false);

        if (isEmpty(logsInStorage)) {
          return;
        }

        logger.log('SumStatController._onLoginSuccess get sumstatlog in storage, nums=' + logsInStorage.length);
        logsInStorage.forEach(function (data) {
          _this2._statInfoArr.pushIn(data);
        }); // 读取到内存缓存后删除本地缓存，避免重复上报

        storage.removeItem(this.TAG, false);
      }
    }, {
      key: "recordLongPollingID",
      value: function recordLongPollingID(id) {
        this._lpID = id;
      }
      /**
       * 总数 +1
       * @param {String} key 枚举值见const/timer-label.js
       */

    }, {
      key: "addTotalCount",
      value: function addTotalCount(key) {
        if (!this._successRateCalc.addTotalCount(key)) {
          logger.warn('SumStatController.addTotalCount invalid key:', key);
          return;
        } // 开始统计的时间认为是“上次上报时间”，用来计算上报的时间间隔


        if (this._successRateCalc.getTotalCount(key) === 1) {
          this._lastReportTime = Date.now(); // 开始计时
        }
      }
      /**
       * 成功数 +1
       * @param {String} key 枚举值见const/timer-label.js
       */

    }, {
      key: "addSuccessCount",
      value: function addSuccessCount(key) {
        if (!this._successRateCalc.addSuccessCount(key)) {
          logger.warn('SumStatController.addSuccessCount invalid key:', key);
        }
      }
      /**
       * 记录耗时
       * @param {String} key 枚举值见const/timer-label.js
       * @param {Number} cost 耗时. 单位毫秒
       */

    }, {
      key: "addCost",
      value: function addCost(key, cost) {
        if (!this._avgCalc.push(key, cost)) {
          logger.warn('SumStatController.addCost invalid key or cost:', key, cost);
          return;
        }

        logger.debug('SumStatController.addCost', key, cost, this._avgCalc.getSize(key));

        if (this._avgCalc.getSize(key) >= this._thresholdMap.get(key)) {
          this._report(key);
        }
      } // 上报项对应的数值 客户端定义，1->longpolling 2->sendMessage 3->ws

    }, {
      key: "_getItemNum",
      value: function _getItemNum(key) {
        switch (key) {
          case label.LONG_POLLING:
            return 1;

          case label.LONG_POLLING_AV:
            return 2;

          case label.SEND_MESSAGE:
            return 3;

          default:
            // unknown item
            return 100;
        }
      }
    }, {
      key: "_getStatInfo",
      value: function _getStatInfo(key) {
        var ret = null;

        if (this._avgCalc.getSize(key) > 0) {
          ret = {
            SDKAppID: "".concat(this.tim.context.SDKAppID),
            version: "".concat(version),
            tinyID: this.tim.context.tinyID,
            userID: this.tim.loginInfo.identifier,
            item: this._getItemNum(key),
            lpID: key === label.LONG_POLLING ? this._lpID : '',
            platform: this._platform,
            networkType: this.getNetworkType(),
            total: this._successRateCalc.getTotalCount(key),
            successRate: this._successRateCalc.getSuccessRate(key),
            avg: this._avgCalc.getAvg(key),
            timespan: Date.now() - this._lastReportTime,
            time: date2ISOString()
          };
        }

        return ret;
      } // 当传入参数时，表明上报指定项的汇总数据。不传参数则上报所有项的汇总数据

    }, {
      key: "_report",
      value: function _report(itemToReport) {
        var _this3 = this;

        var tmpStatInfoArr = [];
        var tmpStatInfo = null;

        if (isUndefined(itemToReport)) {
          this._items.forEach(function (item) {
            tmpStatInfo = _this3._getStatInfo(item);

            if (tmpStatInfo !== null) {
              tmpStatInfoArr.push(tmpStatInfo);
            }
          });
        } else {
          tmpStatInfo = this._getStatInfo(itemToReport);

          if (tmpStatInfo !== null) {
            tmpStatInfoArr.push(tmpStatInfo);
          }
        }

        logger.debug('SumStatController._report', tmpStatInfoArr); // 合并内存缓存中的数据

        if (this._statInfoArr.length > 0) {
          tmpStatInfoArr = tmpStatInfoArr.concat(this.statInfoArr);
          this._statInfoArr = [];
        }

        this._doReport(tmpStatInfoArr);
      }
    }, {
      key: "_doReport",
      value: function _doReport(statInfoArr) {
        var _this4 = this;

        if (isEmpty(statInfoArr)) {
          logger.warn('SumStatController._doReport statInfoArr is empty, do nothing');
          return;
        }

        this.request({
          name: 'ssoSumStat',
          action: 'create',
          param: {
            table: this.TABLE,
            report: statInfoArr
          }
        }).then(function () {
          _this4._lastReportTime = Date.now();

          if (_this4._retryCount > 0) {
            logger.debug('SumStatController._doReport retry success');
            _this4._retryCount = 0;
          }
        })["catch"](function (error) {
          logger.warn("SumStatController._doReport, online:".concat(_this4.getNetworkType(), " error:"), error, statInfoArr); // 失败时过 5s 再重试，最多重试一次

          if (_this4._retryCount <= 1) {
            setTimeout(function () {
              logger.info('SumStatController._doReport retry', statInfoArr);
              _this4._retryCount += 1;

              _this4._doReport(statInfoArr);
            }, 5000);
          } else {
            _this4._retryCount = 0;
            _this4._statInfoArr = _this4._statInfoArr.concat(statInfoArr);

            _this4._flusgAtOnce();
          }
        });
      }
    }, {
      key: "_flushAtOnce",
      value: function _flushAtOnce() {
        // 先读后写，避免覆盖（最多存储10条日志到本地，超出就覆盖式更新）
        // 注意！写入的时候没有拼接 prefix 和 key，读取和删除的时候也不用拼接
        var storage = this.tim.storage;
        var logsInStorage = storage.getItem(this.TAG, false);
        var logsInMemory = this._statInfoArr;

        if (isEmpty(logsInStorage)) {
          logger.log('SumStatController._flushAtOnce nums=' + logsInMemory.length);
          storage.setItem(this.TAG, logsInMemory, true, false);
        } else {
          var tmpArray = logsInMemory.concat(logsInStorage);

          if (tmpArray.length > 10) {
            tmpArray = tmpArray.slice(0, 10);
          }

          logger.log('SumStatController._flushAtOnce nums=' + tmpArray.length);
          storage.setItem(this.TAG, tmpArray, true, false);
        }

        this._statInfoArr = []; // 清空
      }
    }, {
      key: "reset",
      value: function reset() {
        logger.info('SumStatController.reset'); // logout 时主动上报所有统计项的汇总信息

        this._report();

        this._avgCalc.reset();

        this._successRateCalc.reset();
      }
    }]);

    return SumStatController;
  }(IMController);

  /**
   * 用于安全回调封装
   *
   * @class SafetyCallback
   */

  var SafetyCallback =
  /*#__PURE__*/
  function () {
    function SafetyCallback() {
      _classCallCheck(this, SafetyCallback);

      this._funcMap = new Map();
    }
    /**
     * 对用户输入的函数做安全封装
     *
     * @param {String} eventName - 必填，事件名称
     * @param {Function} func - 必填，推荐使用具名函数
     * @param {Object} [context] - 选填，回调函数的执行作用域，默认为 undefined
     * @returns {Function | null}
     *  Function: 说明封装成功;
     *  null: 说明封装失败，请检查入参;
     * @memberof SafetyCallback
     */


    _createClass(SafetyCallback, [{
      key: "defense",
      value: function defense(eventName, func) {
        var context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;

        if (typeof eventName !== 'string') {
          return null;
        }

        if (eventName.length === 0) {
          return null;
        }

        if (typeof func !== 'function') {
          return null;
        } // 如果此函数已经存在，返回原函数


        if (this._funcMap.has(eventName) && this._funcMap.get(eventName).has(func)) {
          return this._funcMap.get(eventName).get(func);
        }

        if (!this._funcMap.has(eventName)) {
          this._funcMap.set(eventName, new Map());
        }

        var safeFunc = null; // 如果已经封装过一次了，不需要重复封装

        if (this._funcMap.get(eventName).has(func)) {
          safeFunc = this._funcMap.get(eventName).get(func);
        } else {
          safeFunc = this._pack(func, context);

          this._funcMap.get(eventName).set(func, safeFunc);
        }

        return safeFunc;
      }
      /**
       * 对用户输入的函数做安全封装，此处为一次性封装，不存map，用于 TIM.once 函数
       *
       * @param {Function} func - 必填，推荐使用具名函数
       * @param {Object} [context] - 选填，回调函数的执行作用域，默认为 undefined
       * @returns {Function | null}
       *  Function: 说明封装成功;
       *  null: 说明封装失败，请检查入参;
       * @memberof SafetyCallback
       */

    }, {
      key: "defenseOnce",
      value: function defenseOnce(func) {
        var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

        if (typeof func !== 'function') {
          return null;
        }

        return this._pack(func, context);
      }
      /**
       * 通过事件名称和源回调，查找某个安全回调
       *
       * @param {String} eventName - 必填，事件名称
       * @param {Function} func - 必填，具名函数
       * @returns {Function | null}
       *  Function: 说明查找成功;
       *  null: 说明没找到，请检查入参，或确认回调是否正确绑定;
       * @memberof SafetyCallback
       */

    }, {
      key: "find",
      value: function find(eventName, func) {
        if (typeof eventName !== 'string' || eventName.length === 0) {
          return null;
        }

        if (typeof func !== 'function') {
          return null;
        }

        if (!this._funcMap.has(eventName)) {
          logger.log("SafetyCallback.find: \u627E\u4E0D\u5230 eventName-".concat(eventName, " \u5BF9\u5E94\u7684 func"));
          return null;
        }

        if (!this._funcMap.get(eventName).has(func)) {
          logger.log("SafetyCallback.find: \u627E\u4E0D\u5230 func \u2014\u2014 ".concat(eventName, "/").concat(func.name !== '' ? func.name : '[anonymous]'));
          return null;
        }

        return this._funcMap.get(eventName).get(func);
      }
      /**
       * 从 map 中删除函数
       *
       * @param {String} eventName - 必填，事件名称
       * @param {Function} func - 必填，推荐使用具名函数
       * @returns {Boolean}
       * @memberof SafetyCallback
       */

    }, {
      key: "delete",
      value: function _delete(eventName, func) {
        if (typeof func !== 'function') {
          return false;
        }

        if (!this._funcMap.has(eventName)) {
          return false;
        }

        if (!this._funcMap.get(eventName).has(func)) {
          return false;
        }

        this._funcMap.get(eventName)["delete"](func); // 如果此 eventName 下的Map 已经是空的，则删除此节点


        if (this._funcMap.get(eventName).size === 0) {
          this._funcMap["delete"](eventName);
        }

        return true;
      }
      /**
       * 安全封装
       *
       * @param {Function} func - 具名回调函数
       * @param {Object} [context] - 回调函数的执行上下文，默认为 undefined
       * @returns {Function}
       */

    }, {
      key: "_pack",
      value: function _pack(func, context) {
        return function () {
          try {
            func.apply(context, Array.from(arguments));
          } catch (err) {
            console.error(err);
          }
        };
      }
    }]);

    return SafetyCallback;
  }();

  var SDK$1 =
  /*#__PURE__*/
  function () {
    /**
     * ### 即时通信 IM SDK 基本概念：
     * | 基本概念 | 说明 |
     * | :--- | :---- |
     * | Message（消息） | IM SDK 中 [Message](https://imsdk-1252463788.file.myqcloud.com/IM_DOC/Web/Message.html) 表示要发送给对方的内容，消息包括若干属性，例如自己是否为发送者，发送人帐号以及消息产生时间等。 |
     * | Conversation（会话） | IM SDK 中 [Conversation](https://imsdk-1252463788.file.myqcloud.com/IM_DOC/Web/Conversation.html) 分为两种：<li> C2C（Client to Client）会话，表示单聊情况，自己与对方建立的对话。</li><li> GROUP（群）会话，表示群聊情况下群内成员组成的会话。 |
     * | Profile（资料） | IM SDK 中 [Profile](https://imsdk-1252463788.file.myqcloud.com/IM_DOC/Web/Profile.html) 描述个人的常用基本信息，例如昵称、性别、个性签名以及头像地址等。 |
     * | Group（群组） | IM SDK 中 [Group](https://imsdk-1252463788.file.myqcloud.com/IM_DOC/Web/Group.html) 表示一个支持多人聊天的通信系统，支持私有群、公开群、聊天室以及音视频聊天室。 |
     * | GroupMember（群成员） | IM SDK 中 [GroupMember](https://imsdk-1252463788.file.myqcloud.com/IM_DOC/Web/GroupMember.html) 描述群内成员的常用基本信息，例如 ID、昵称、群内身份以及入群时间等。 |
     * | 群提示消息 | 当有用户被邀请加入群组或被移出群组等事件发生时，群内会产生提示消息，接入侧可以根据实际需求展示给群组用户或忽略。<br/>群提示消息有多种类型，详细描述请参见  [Message.GroupTipPayload](https://imsdk-1252463788.file.myqcloud.com/IM_DOC/Web/Message.html#.GroupTipPayload)。  |
     * | 群系统通知消息 | 当有用户申请加群等事件发生时，管理员会收到申请加群等系统消息。管理员同意或拒绝加群申请，IM SDK 会通过群系统通知消息将申请加群等相应消息发送给接入侧，由接入侧展示给用户。<br/>群系统通知消息有多种类型，详细描述请参见 [Message.GroupSystemNoticePayload](https://imsdk-1252463788.file.myqcloud.com/IM_DOC/Web/Message.html#.GroupSystemNoticePayload)。  |
     * | 消息上屏 | 用户单击发送后，事先输入的文字或选择的图片等信息显示在用户电脑屏幕或手机屏幕上的过程。 |<br/>
     *
     * ### 支持的平台：<br/>
     * - IM SDK 支持 IE 9+、Chrome、微信、手机QQ、QQ 浏览器、FireFox、Opera 和 Safari。
     *
     * ### Web项目集成 SDK
     * | 集成方式 | 示例 |
     * | :--- | :---- |
     * | NPM 集成 | // IM Web SDK<br/>npm install tim-js-sdk --save<br/>// 发送图片、文件等消息需要的 COS SDK<br/>npm install cos-js-sdk-v5 --save<br/> |
     * | Script 集成 | 在您的项目中使用 script 标签引入 SDK，并初始化<br/>IM Web SDK 下载地址：[IM Web SDK](https://github.com/tencentyun/TIMSDK/tree/master/H5)<br/>腾讯云 COS JS SDK 源码下载地址：[腾讯云 COS JS SDK](https://github.com/tencentyun/cos-js-sdk-v5)|
     *
     * ### 微信小程序项目集成 SDK
     * | 集成方式 | 示例 |
     * | :--- | :---- |
     * | NPM 集成 | // IM 小程序 SDK<br/>npm install tim-wx-sdk --save<br/>// 发送图片、文件等消息需要的 COS SDK<br/>npm install cos-wx-sdk-v5 --save<br/> |
     * @constructs
     * @param { Object } options - 应用配置
     * @param { Number } options.SDKAppID - 云通信应用的 `SDKAppID`
     * @example
     * import TIM from 'tim-js-sdk';
     * // import TIM from 'tim-wx-sdk'; // 微信小程序环境请取消本行注释，并注释掉 import TIM from 'tim-js-sdk';
     * import COS from 'cos-js-sdk-v5';
     * // import COS from 'cos-wx-sdk-v5'; // 微信小程序环境请取消本行注释，并注释掉 import COS from 'cos-js-sdk-v5';
     *
     * // 创建 SDK 实例，TIM.create() 方法对于同一个 SDKAppID 只会返回同一份实例
     * let options = {
     *   SDKAppID: 0 // 接入时需要将0替换为您的即时通信应用的 SDKAppID
     * };
     * let tim = TIM.create(options); // SDK 实例通常用 tim 表示
     * // 设置 SDK 日志输出级别，详细分级请参见 setLogLevel 接口的说明
     * tim.setLogLevel(0); // 普通级别，日志量较多，接入时建议使用
     * // tim.setLogLevel(1); // release级别，SDK 输出关键信息，生产环境时建议使用
     *
     * // 将腾讯云对象存储服务 SDK （以下简称 COS SDK）注册为插件，IM SDK 发送文件、图片等消息时，需要用到腾讯云的[ COS 服务]{@link https://cloud.tencent.com/document/product/436/6268}
     * // HTML5 环境，注册 COS SDK
     * tim.registerPlugin({'cos-js-sdk': COS});
     *
     * // 微信小程序环境，注册 COS SDK
     * //tim.registerPlugin({'cos-wx-sdk': COS}); // 微信小程序环境请取消本行注释，并注释掉 tim.registerPlugin({'cos-js-sdk': COS});
     *
     * // 监听事件，如：
     * tim.on(TIM.EVENT.SDK_READY, function(event) {
     *   // 收到离线消息和会话列表同步完毕通知，接入侧可以调用 sendMessage 等需要鉴权的接口
     *   // event.name - TIM.EVENT.SDK_READY
     * });
     *
     * tim.on(TIM.EVENT.MESSAGE_RECEIVED, function(event) {
     *   // 收到推送的单聊、群聊、群提示、群系统通知的新消息，可通过遍历 event.data 获取消息列表数据并渲染到页面
     *   // event.name - TIM.EVENT.MESSAGE_RECEIVED
     *   // event.data - 存储 Message 对象的数组 - [Message]
     * });
     *
     * tim.on(TIM.EVENT.MESSAGE_REVOKED, function(event) {
     *   // 收到消息被撤回的通知。使用前需要将SDK版本升级至v2.4.0或以上。
     *   // event.name - TIM.EVENT.MESSAGE_REVOKED
     *   // event.data - 存储 Message 对象的数组 - [Message] - 每个 Message 对象的 isRevoked 属性值为 true
     * });
     *
     * tim.on(TIM.EVENT.CONVERSATION_LIST_UPDATED, function(event) {
     *   // 收到会话列表更新通知，可通过遍历 event.data 获取会话列表数据并渲染到页面
     *   // event.name - TIM.EVENT.CONVERSATION_LIST_UPDATED
     *   // event.data - 存储 Conversation 对象的数组 - [Conversation]
     * });
     *
     * tim.on(TIM.EVENT.GROUP_LIST_UPDATED, function(event) {
     *   // 收到群组列表更新通知，可通过遍历 event.data 获取群组列表数据并渲染到页面
     *   // event.name - TIM.EVENT.GROUP_LIST_UPDATED
     *   // event.data - 存储 Group 对象的数组 - [Group]
     * });
     *
     * tim.on(TIM.EVENT.PROFILE_UPDATED, function(event) {
     *   // 收到自己或好友的资料变更通知
     *   // event.name - TIM.EVENT.PROFILE_UPDATED
     *   // event.data - 存储 Profile 对象的数组 - [Profile]
     * });
     *
     * tim.on(TIM.EVENT.BLACKLIST_UPDATED, function(event) {
     *   // 收到黑名单列表更新通知
     *   // event.name - TIM.EVENT.BLACKLIST_UPDATED
     *   // event.data - 存储 userID 的数组 - [userID]
     * });
     *
     * tim.on(TIM.EVENT.ERROR, function(event) {
     *   // 收到 SDK 发生错误通知，可以获取错误码和错误信息
     *   // event.name - TIM.EVENT.ERROR
     *   // event.data.code - 错误码
     *   // event.data.message - 错误信息
     * });
     *
     * tim.on(TIM.EVENT.SDK_NOT_READY, function(event) {
     *   // 收到 SDK 进入 not ready 状态通知，此时 SDK 无法正常工作
     *   // event.name - TIM.EVENT.SDK_NOT_READY
     * });
     *
     * tim.on(TIM.EVENT.KICKED_OUT, function(event) {
     *   // 收到被踢下线通知
     *   // event.name - TIM.EVENT.KICKED_OUT
     *   // event.data.type - 被踢下线的原因，例如 :
     *   //   - TIM.TYPES.KICKED_OUT_MULT_ACCOUNT 多实例登录被踢
     *   //   - TIM.TYPES.KICKED_OUT_MULT_DEVICE 多终端登录被踢
     *   //   - TIM.TYPES.KICKED_OUT_USERSIG_EXPIRED 签名过期被踢（v2.4.0起支持）。
     * });
     *
     * tim.on(TIM.EVENT.NET_STATE_CHANGE, function(event) {
     *   // 网络状态发生改变（v2.5.0 起支持）。
     *   // event.name - TIM.EVENT.NET_STATE_CHANGE
     *   // event.data.state 当前网络状态，枚举值及说明如下：
     *   //   - TIM.TYPES.NET_STATE_CONNECTED - 已接入网络
     *   //   - TIM.TYPES.NET_STATE_CONNECTING - 连接中。很可能遇到网络抖动，SDK 在重试。接入侧可根据此状态提示“当前网络不稳定”或“连接中”
     *   //   - TIM.TYPES.NET_STATE_DISCONNECTED - 未接入网络。接入侧可根据此状态提示“当前网络不可用”。SDK 仍会继续重试，若用户网络恢复，SDK 会自动同步消息
     * });
     *
     * // 开始登录
     * tim.login({userID: 'your userID', userSig: 'your userSig'});
     */
    function SDK(options) {
      _classCallCheck(this, SDK);

      // event stat
      var ssoLog = new SSOLogData();
      ssoLog.setMethod(SSOMethods.SDK_CONSTRUCT).setStart();
      ReadyStatus.mixin(this);

      this._initOptions(options); // 初始化实例配置


      this._initMemberVariables(); // 初始化成员变量


      this._initControllers(); // 加载控制器


      this._initListener(); // event stat
      // 将 EventStatController 的引用挂到 SSOLogData 的原型链上，便于向 EventStatController 传递 SSOLogData 对象


      SSOLogData.bindController(this.eventStatController);
      ssoLog.setCode(0).setText("mp=".concat(IN_WX_MINI_APP, "-ua=").concat(USER_AGENT)).setEnd(); // 由于日志上报需求， 这两行日志输出移到所有初始化函数运行后执行

      logger.info("SDK inWxMiniApp:".concat(IN_WX_MINI_APP, ", SDKAppID:").concat(options.SDKAppID, ", UserAgent:").concat(USER_AGENT));
      this._safetyCallbackFactory = new SafetyCallback();
    } //   ______   __            __                  __
    //  /      \ |  \          |  \                |  \
    // |  $$$$$$\| $$  ______  | $$____    ______  | $$
    // | $$ __\$$| $$ /      \ | $$    \  |      \ | $$
    // | $$|    \| $$|  $$$$$$\| $$$$$$$\  \$$$$$$\| $$
    // | $$ \$$$$| $$| $$  | $$| $$  | $$ /      $$| $$
    // | $$__| $$| $$| $$__/ $$| $$__/ $$|  $$$$$$$| $$
    //  \$$    $$| $$ \$$    $$| $$    $$ \$$    $$| $$
    //   \$$$$$$  \$$  \$$$$$$  \$$$$$$$   \$$$$$$$ \$$
    //
    //  Global 登录、登出、事件监听

    /**
     * @description 使用 用户ID(userID) 和 签名串(userSig) 登录即时通信 IM，登录流程有若干个异步执行的步骤，使用返回的 Promise 对象处理登录成功或失败。<br/>
     * >注意1：登录成功，需等待 sdk 处于 ready 状态后（监听事件 [TIM.EVENT.SDK_READY](https://imsdk-1252463788.file.myqcloud.com/IM_DOC/Web/module-EVENT.html#.SDK_READY)）才能调用 [sendMessage](https://imsdk-1252463788.file.myqcloud.com/IM_DOC/Web/SDK.html#sendMessage) 等需要鉴权的接口。<br/>
     * >注意2：默认情况下，不支持多实例登录，即如果此帐号已在其他页面登录，若继续在当前页面登录成功，有可能会将其他页面踢下线。用户被踢下线时会触发事件`TIM.EVENT.KICKED_OUT`，用户可在监听到事件后做相应处理。<br/>
     * 如需支持多实例登录（允许在多个网页中同时登录同一帐号），请到 [即时通信 IM 控制台](https://console.cloud.tencent.com/avc)，找到相应 SDKAppID，【应用配置】 > 【功能配置】> 【Web端实例同时在线】配置实例个数。配置将在50分钟内生效。
     * @param {Object} options - 登录配置
     * @param {String} options.userID 用户 ID
     * @param {String} options.userSig 用户登录即时通信 IM 的密码，其本质是对 UserID 等信息加密后得到的密文。<br/>具体生成方法请参见{@link https://cloud.tencent.com/document/product/269/32688 生成 UserSig}。
     * @returns {Promise}
     * @example
     * let promise = tim.login({userID: 'your userID', userSig: 'your userSig'});
     * promise.then(function(imResponse) {
     *   console.log(imResponse.data); // 登录成功
     *   if (imResponse.data.repeatLogin === true) {
     *     // 标识账号已登录，本次登录操作为重复登录。v2.5.1 起支持
     *     console.log(imResponse.data.errorInfo);
     *   }
     * }).catch(function(imError) {
     *   console.warn('login error:', imError); // 登录失败的相关信息
     * });
     */


    _createClass(SDK, [{
      key: "login",
      value: function login(options) {
        logger.time(label.SDK_READY); // event stat

        this._ssoLog = new SSOLogData();

        this._ssoLog.setMethod(SSOMethods.SDK_READY).setStart();

        this.netMonitor.start(); // 开始监测网络
        // 对外接口描述及参数用userID或userIDList，sdk内部仍然用identifier。identifier和userID所指相同，即用户的唯一标识

        this.loginInfo.identifier = options.identifier || options.userID;
        this.loginInfo.userSig = options.userSig;
        return this.signController.login(this.loginInfo);
      }
      /**
       * @description 登出即时通信 IM，通常在切换帐号的时候调用，清除登录态以及内存中的所有数据。<br/>
       * 注意！
       * 1. 调用此接口的实例会发布 [`SDK_NOT_READY`](https://imsdk-1252463788.file.myqcloud.com/IM_DOC/Web/module-EVENT.html#.SDK_NOT_READY) 事件，此时该实例下线，无法收、发消息。
       * 2. 如果您在[即时通信 IM 控制台](https://console.cloud.tencent.com/im)配置的“Web端实例同时在线个数”大于 1，且同一账号登录了`a1`和`a2`两个实例（含小程序端），当执行`a1.logout()`后，`a1`会下线，无法收、发消息。而`a2`实例不会受影响。
       * 3. 多实例被踢：基于第 2 点，如果“Web端实例同时在线个数”配置为 2，且您的某一账号已经登录了 `a1`，`a2`两个实例，当使用此账号成功登录第三个实例`a3`时，`a1`或`a2`中的一个实例会被踢下线（通常是最先处在登录态的实例会触发），这种情况称之为**“多实例被踢”**。假设`a1`实例被踢下线，`a1`实例内部会执行登出流程，然后抛出[`KICKED_OUT`](https://imsdk-1252463788.file.myqcloud.com/IM_DOC/Web/module-EVENT.html#.KICKED_OUT)事件，接入侧可以监听此事件，并在触发时跳转到登录页。此时`a1`实例下线，而`a2`、`a3`实例可以正常运行。
       * @returns {Promise}
       * @example
       * let promise = tim.logout();
       * promise.then(function(imResponse) {
       *   console.log(imResponse.data); // 登出成功
       * }).catch(function(imError) {
       *   console.warn('logout error:', imError);
       * });
       */

    }, {
      key: "logout",
      value: function logout() {
        var result = this.signController.logout();
        this.resetSDK();
        return result;
      }
      /**
       * @description 监听事件。
       * >注意：请在调用 [login](https://imsdk-1252463788.file.myqcloud.com/IM_DOC/Web/SDK.html#login) 接口前调用此接口监听事件，避免漏掉 SDK 派发的事件。
       * @param {String} eventName
       *        事件名称。所有的事件名称都存放在 `TIM.EVENT` 变量中，如需要查看可以使用 `console.log(TIM.EVENT)` 把所有的事件显示出来。{@link module:EVENT 事件列表}
       * @param {Function} handler
       *        处理事件的方法，当事件触发时，会调用此handler进行处理。
       * @param {*} [context] 期望 handler 执行时的上下文
       * @example
       * let onMessageReceived = function(event) {
       *   // 收到推送的单聊、群聊、群提示、群系统通知的新消息，可通过遍历 event.data 获取消息列表数据并渲染到页面
       *   // event.name - TIM.EVENT.MESSAGE_RECEIVED
       *   // event.data - 存储 Message 对象的数组 - [Message]
       * };
       * tim.on(TIM.EVENT.MESSAGE_RECEIVED, onMessageReceived);
       */

    }, {
      key: "on",
      value: function on(eventName, handler, context) {
        if (eventName === TIM_OUTER_EVENT.GROUP_SYSTEM_NOTICE_RECEIVED) {
          logger.warn('！！！TIM.EVENT.GROUP_SYSTEM_NOTICE_RECEIVED v2.6.0起弃用，为了更好的体验，请在 TIM.EVENT.MESSAGE_RECEIVED 事件回调内接收处理群系统通知，详细请参考：https://imsdk-1252463788.file.myqcloud.com/IM_DOC/Web/Message.html#.GroupSystemNoticePayload');
        }

        logger.debug('on', "eventName:".concat(eventName));
        this.outerEmitter.on(eventName, this._safetyCallbackFactory.defense(eventName, handler, context), context);
      }
      /**
       * @description 事件监听函数只执行一次。
       * @param {String} eventName
       *        事件名称。所有的事件名称都存放在 `TIM.EVENT` 变量中，如需要查看可以使用 `console.log(TIM.EVENT)` 把所有的事件显示出来。{@link module:EVENT 事件列表}
       * @param {Function} handler
       *        处理事件的方法，当事件触发时，会调用此handler进行处理。
       * @param {*} [context] 期望 handler 执行时的上下文
       * @private
       */

    }, {
      key: "once",
      value: function once(eventName, handler, context) {
        logger.debug('once', "eventName:".concat(eventName));
        this.outerEmitter.once(eventName, this._safetyCallbackFactory.defenseOnce(handler, context), context || this);
      }
      /**
       * @description 取消监听事件。
       * @param {String} eventName
       *        事件名称。所有的事件名称都存放在 `TIM.EVENT` 变量中，如需要查看可以使用 `console.log(TIM.EVENT)` 把所有的事件显示出来。{@link module:EVENT 事件列表}
       * @param {Function} handler
       *        处理事件的方法，当事件触发时，会调用此handler进行处理。
       * @param {*} [context] 期望 handler 执行时的上下文
       * @param {Boolean} [once]
       * @example
       * let onMessageReceived = function(event) {
       *   // 收到推送的单聊、群聊、群提示、群系统通知的新消息，可通过遍历 event.data 获取消息列表数据并渲染到页面
       *   // event.name - TIM.EVENT.MESSAGE_RECEIVED
       *   // event.data - 存储 Message 对象的数组 - [Message]
       * };
       * tim.off(TIM.EVENT.MESSAGE_RECEIVED, onMessageReceived);
       */

    }, {
      key: "off",
      value: function off(eventName, handler, context, once) {
        logger.debug('off', "eventName:".concat(eventName));

        var safeFunc = this._safetyCallbackFactory.find(eventName, handler);

        if (safeFunc !== null) {
          this.outerEmitter.off(eventName, safeFunc, context, once);

          this._safetyCallbackFactory["delete"](eventName, handler);
        }
      }
      /**
       * @description 注册插件。<br>
       * 插件是一种遵循一定规范的应用程序接口编写出来的程序。在即时通信 IM SDK，发送图片、文件消息需要先将图片、文件上传到腾讯云对象存储，发送文本消息则不用，<br/>
       * 且在 HTML5 和小程序环境，上传图片、文件需要用到不同的文件上传 SDK 。因此我们将此功能设计成插件机制，方便您根据实际需要做定制化开发。
       * @param {Object} optoins 插件配置
       * @param {String} optoins.key 插件名称，目前支持的插件名称有：
       * - cos-wx-sdk 腾讯云对象存储{@link https://cloud.tencent.com/document/product/436/31953 小程序上传SDK}
       * - cos-js-sdk 腾讯云对象存储{@link https://cloud.tencent.com/document/product/436/11459 JavaScript上传SDK}，适用于HTML5环境
       * @param {Class} optoins.value 插件类
       * @example
       * // 微信小程序环境
       * import COS from 'cos-wx-sdk-v5';
       * tim.registerPlugin({'cos-wx-sdk': COS}); // 在 login 前调用，以支持文件上传腾讯云对象存储
       * tim.login({userID: 'your userID', userSig: 'your userSig'});
       *
       * @example
       * // HTML5 环境
       * import COS from 'cos-js-sdk-v5';
       * tim.registerPlugin({'cos-js-sdk': COS}); // 在 login 前调用，以支持文件上传腾讯云对象存储
       * tim.login({userID: 'your userID', userSig: 'your userSig'});
       */

    }, {
      key: "registerPlugin",
      value: function registerPlugin(optoins) {
        var _this = this;

        if (!this.plugins) {
          this.plugins = {};
        }

        Object.keys(optoins).forEach(function (item) {
          _this.plugins[item] = optoins[item];
        });
      }
      /**
       * 获取插件类。
       * @param {*} name
       * @private
       */

    }, {
      key: "getPlugin",
      value: function getPlugin(name) {
        return this.plugins[name] || undefined;
      }
      /**
       * @description 设置日志级别，低于 level 的日志将不会输出。
       * @param {Number} level - 日志级别
       * - 0 普通级别，日志量较多，接入时建议使用
       * - 1 release级别，SDK 输出关键信息，生产环境时建议使用
       * - 2 告警级别，SDK 只输出告警和错误级别的日志
       * - 3 错误级别，SDK 只输出错误级别的日志
       * - 4 无日志级别，SDK 将不打印任何日志
       * @example
       * tim.setLogLevel(0);
       */

    }, {
      key: "setLogLevel",
      value: function setLogLevel(level) {
        if (level <= 0) {
          var asciiArt = ['', ' ________  ______  __       __  __       __  ________  _______', '|        \\|      \\|  \\     /  \\|  \\  _  |  \\|        \\|       \\', ' \\$$$$$$$$ \\$$$$$$| $$\\   /  $$| $$ / \\ | $$| $$$$$$$$| $$$$$$$\\', '   | $$     | $$  | $$$\\ /  $$$| $$/  $\\| $$| $$__    | $$__/ $$', '   | $$     | $$  | $$$$\\  $$$$| $$  $$$\\ $$| $$  \\   | $$    $$', '   | $$     | $$  | $$\\$$ $$ $$| $$ $$\\$$\\$$| $$$$$   | $$$$$$$\\', '   | $$    _| $$_ | $$ \\$$$| $$| $$$$  \\$$$$| $$_____ | $$__/ $$', '   | $$   |   $$ \\| $$  \\$ | $$| $$$    \\$$$| $$     \\| $$    $$', '    \\$$    \\$$$$$$ \\$$      \\$$ \\$$      \\$$ \\$$$$$$$$ \\$$$$$$$', '', ''];
          console.log(asciiArt.join('\n'));
          console.log('%cIM 智能客服，随时随地解决您的问题 →_→ https://cloud.tencent.com/act/event/smarty-service?from=im-doc', 'color:#ff0000');
          var docsGuide = ['', '参考以下文档，会更快解决问题哦！(#^.^#)\n', 'SDK 更新日志: https://cloud.tencent.com/document/product/269/38492\n', 'SDK 接口文档: https://imsdk-1252463788.file.myqcloud.com/IM_DOC/Web/SDK.html\n', '常见问题: https://imsdk-1252463788.file.myqcloud.com/IM_DOC/Web/tutorial-01-faq.html\n', '反馈问题？戳我提 issue: https://github.com/tencentyun/TIMSDK/issues\n', '如果您需要在生产环境关闭上面的日志，请 tim.setLogLevel(1)\n'];
          console.log(docsGuide.join('\n'));
        }

        logger.setLevel(level);
      }
      /**
       * 保存sdk缓存的日志信息到本地文件，文件名字格式：TIM-年-月-日-SDKAppID-userID.txt
       * > 不支持微信小程序和移动端浏览器环境
       * @example
       * tim.downloadLog();
       * @private
       */

    }, {
      key: "downloadLog",
      value: function downloadLog() {
        var link = document.createElement('a');
        var date = new Date();
        var blob = new Blob(this.getLog());
        link.download = 'TIM-' + date.getFullYear() + '-' + (date.getMonth() + 1) + '-' + date.getDate() + '-' + this.loginInfo.SDKAppID + '-' + this.context.identifier + '.txt';
        link.href = URL.createObjectURL(blob);
        link.click();
        URL.revokeObjectURL(blob);
      }
      /**
       * @private
       * @description 销毁 SDK 实例，管理多实例时用
       * @example
       * tim.destroy();
       */

    }, {
      key: "destroy",
      value: function destroy() {
        this.logout();
        this.outerEmitter.emit(TIM_OUTER_EVENT.SDK_DESTROY, {
          SDKAppID: this.loginInfo.SDKAppID
        }); // TODO: 解绑所有事件
      }
      /**
       * @typedef Promise
       * @property {function} then - 正常回调，参数为： {@link IMResponse}
       * @property {function} catch - 异常回调，参数为： {@link IMError}
       */

      /**
       * @typedef IMResponse
       * @property {String} code - 返回码, 值为0
       * @property {*} data - API 相关数据
       */

      /**
       * @typedef IMError
       * @description 错误对象
       * @property {String} code - 错误码
       * @property {String} message - 错误信息
       * @property {Object} stack - 错误堆栈信息
       */

      /**
       * @typedef IMEvent
       * @description 事件对象类型，在监听函数响应时返回
       * @property {String} name - 事件名称
       * @property {*} data - 事件数据
       */
      //  __       __
      // |  \     /  \
      // | $$\   /  $$  ______    _______   _______   ______    ______    ______
      // | $$$\ /  $$$ /      \  /       \ /       \ |      \  /      \  /      \
      // | $$$$\  $$$$|  $$$$$$\|  $$$$$$$|  $$$$$$$  \$$$$$$\|  $$$$$$\|  $$$$$$\
      // | $$\$$ $$ $$| $$    $$ \$$    \  \$$    \  /      $$| $$  | $$| $$    $$
      // | $$ \$$$| $$| $$$$$$$$ _\$$$$$$\ _\$$$$$$\|  $$$$$$$| $$__| $$| $$$$$$$$
      // | $$  \$ | $$ \$$     \|       $$|       $$ \$$    $$ \$$    $$ \$$     \
      //  \$$      \$$  \$$$$$$$ \$$$$$$$  \$$$$$$$   \$$$$$$$ _\$$$$$$$  \$$$$$$$
      //                                                      |  \__| $$
      //                                                       \$$    $$
      //                                                        \$$$$$$
      // Message 发送消息，同步消息

      /**
       * 创建文本消息的接口，此接口返回一个消息实例，可以在需要发送文本消息时调用 [发送消息](https://imsdk-1252463788.file.myqcloud.com/IM_DOC/Web/SDK.html#sendMessage) 接口发送消息。
       * @param {Object} options
       * @param {String} options.to - 消息接收方的 userID 或 groupID
       * @param {String} options.conversationType - 会话类型，取值`TIM.TYPES.CONV_C2C`（端到端会话） 或 `TIM.TYPES.CONV_GROUP`（群组会话）
       * @param {Object} options.payload - 消息内容的容器
       * @param {String} options.payload.text - 消息文本内容
       * @returns {Message} 消息实例
       * @example
       * // 发送文本消息，Web 端与小程序端相同
       * // 1. 创建消息实例，接口返回的实例可以上屏
       * let message = tim.createTextMessage({
       *   to: 'user1',
       *   conversationType: TIM.TYPES.CONV_C2C,
       *   // 消息优先级，用于群聊（v2.4.2起支持）。如果某个群的消息超过了频率限制，后台会优先下发高优先级的消息，详细请参考：https://cloud.tencent.com/document/product/269/3663#.E6.B6.88.E6.81.AF.E4.BC.98.E5.85.88.E7.BA.A7.E4.B8.8E.E9.A2.91.E7.8E.87.E6.8E.A7.E5.88.B6)
       *   // 支持的枚举值：TIM.TYPES.MSG_PRIORITY_HIGH, TIM.TYPES.MSG_PRIORITY_NORMAL（默认）, TIM.TYPES.MSG_PRIORITY_LOW, TIM.TYPES.MSG_PRIORITY_LOWEST
       *   // priority: TIM.TYPES.MSG_PRIORITY_NORMAL,
       *   payload: {
       *     text: 'Hello world!'
       *   }
       * });
       * // 2. 发送消息
       * let promise = tim.sendMessage(message);
       * promise.then(function(imResponse) {
       *   // 发送成功
       *   console.log(imResponse);
       * }).catch(function(imError) {
       *   // 发送失败
       *   console.warn('sendMessage error:', imError);
       * });
       */

    }, {
      key: "createTextMessage",
      value: function createTextMessage(options) {
        return this.messageController.createTextMessage(options);
      }
      /**
       * 创建图片消息的接口，此接口返回一个消息实例，可以在需要发送图片消息时调用 [发送消息](https://imsdk-1252463788.file.myqcloud.com/IM_DOC/Web/SDK.html#sendMessage) 接口发送消息。
       * >注意：v2.3.1版本开始支持传入 File 对象，使用前需要将SDK升级至v2.3.1或以上。
       * @param {Object} options
       * @param {String} options.to - 消息接收方的 userID 或 groupID
       * @param {String} options.conversationType - 会话类型，取值`TIM.TYPES.CONV_C2C`（端到端会话） 或 `TIM.TYPES.CONV_GROUP`（群组会话）
       * @param {Object} options.payload
       * @param {HTMLInputElement|File|Object} options.payload.file 用于选择图片的 DOM 节点（Web）或者 File 对象（Web）或者微信小程序 `wx.chooseImage` 接口的 `success` 回调参数。SDK 会读取其中的数据并上传图片。
       * @param {Function} options.onProgress - 获取上传进度的回调函数
       * @returns {Message} 消息实例
       * @example
       * // Web 端发送图片消息示例1 - 传入 DOM 节点
       * // 1. 创建消息实例，接口返回的实例可以上屏
       * let message = tim.createImageMessage({
       *   to: 'user1',
       *   conversationType: TIM.TYPES.CONV_C2C,
       *   // 消息优先级，用于群聊（v2.4.2起支持）。如果某个群的消息超过了频率限制，后台会优先下发高优先级的消息，详细请参考：https://cloud.tencent.com/document/product/269/3663#.E6.B6.88.E6.81.AF.E4.BC.98.E5.85.88.E7.BA.A7.E4.B8.8E.E9.A2.91.E7.8E.87.E6.8E.A7.E5.88.B6)
       *   // 支持的枚举值：TIM.TYPES.MSG_PRIORITY_HIGH, TIM.TYPES.MSG_PRIORITY_NORMAL（默认）, TIM.TYPES.MSG_PRIORITY_LOW, TIM.TYPES.MSG_PRIORITY_LOWEST
       *   // priority: TIM.TYPES.MSG_PRIORITY_NORMAL,
       *   payload: {
       *     file: document.getElementById('imagePicker'),
       *   },
       *   onProgress: function(event) { console.log('file uploading:', event) }
       * });
       *
       * // 2. 发送消息
       * let promise = tim.sendMessage(message);
       * promise.then(function(imResponse) {
       *   // 发送成功
       *   console.log(imResponse);
       * }).catch(function(imError) {
       *   // 发送失败
       *   console.warn('sendMessage error:', imError);
       * });
       *
       * @example
       * // Web 端发送图片消息示例2- 传入 File 对象
       * // 先在页面上添加一个 id 为 "testPasteInput" 的消息输入框，如 <input type="text" id="testPasteInput" placeholder="截图后粘贴到输入框中" size="30" />
       * document.getElementById('testPasteInput').addEventListener('paste', function(e) {
       *   let clipboardData = e.clipboardData;
       *   let file;
       *   let fileCopy;
       *   if (clipboardData && clipboardData.files && clipboardData.files.length > 0) {
       *     file = clipboardData.files[0];
       *     // 图片消息发送成功后，file 指向的内容可能被浏览器清空，如果接入侧有额外的渲染需求，可以提前复制一份数据
       *     fileCopy = file.slice();
       *   }
       *
       *   if (typeof file === 'undefined') {
       *     console.warn('file 是 undefined，请检查代码或浏览器兼容性！');
       *     return;
       *   }
       *
       *   // 1. 创建消息实例，接口返回的实例可以上屏
       *   let message = tim.createImageMessage({
       *     to: 'user1',
       *     conversationType: TIM.TYPES.CONV_C2C,
       *     payload: {
       *       file: file
       *     },
       *     onProgress: function(event) { console.log('file uploading:', event) }
       *   });
       *
       *   // 2. 发送消息
       *   let promise = tim.sendMessage(message);
       *   promise.then(function(imResponse) {
       *     // 发送成功
       *     console.log(imResponse);
       *   }).catch(function(imError) {
       *     // 发送失败
       *     console.warn('sendMessage error:', imError);
       *   });
       * });
       *
       * @example
       * // 小程序端发送图片
       * // 1. 选择图片
       * wx.chooseImage({
       *   sourceType: ['album'], // 从相册选择
       *   count: 1, // 只选一张，目前 SDK 不支持一次发送多张图片
       *   success: function (res) {
       *     // 2. 创建消息实例，接口返回的实例可以上屏
       *     let message = tim.createImageMessage({
       *       to: 'user1',
       *       conversationType: TIM.TYPES.CONV_C2C,
       *       payload: { file: res },
       *       onProgress: function(event) { console.log('file uploading:', event) }
       *     });
       *     // 3. 发送图片
       *     let promise = tim.sendMessage(message);
       *     promise.then(function(imResponse) {
       *       // 发送成功
       *       console.log(imResponse);
       *     }).catch(function(imError) {
       *       // 发送失败
       *       console.warn('sendMessage error:', imError);
       *     });
       *   }
       * })
       */

    }, {
      key: "createImageMessage",
      value: function createImageMessage(options) {
        return this.messageController.createImageMessage(options);
      }
      /**
       * @description 创建音频消息实例的接口，此接口返回一个消息实例，可以在需要发送音频消息时调用 [发送消息](https://imsdk-1252463788.file.myqcloud.com/IM_DOC/Web/SDK.html#sendMessage) 接口发送消息。
       * 目前 createAudioMessage 只支持在微信小程序环境使用。
       * @param {Object} options
       * @param {String} options.to - 消息接收方的 userID 或 groupID
       * @param {String} options.conversationType - 会话类型，取值`TIM.TYPES.CONV_C2C`(端到端会话) 或 `TIM.TYPES.CONV_GROUP`(群组会话)
       * @param {Object} options.payload
       * @param {Object} options.payload.file - 录音后得到的文件信息
       * @returns {Message} 消息实例
       * @example
       * // 示例：使用微信官方的 RecorderManager 进行录音，参考 https://developers.weixin.qq.com/minigame/dev/api/media/recorder/RecorderManager.start.html
       * // 1. 获取全局唯一的录音管理器 RecorderManager
       * const recorderManager = wx.getRecorderManager();
       *
       * // 录音部分参数
       * const recordOptions = {
       *   duration: 60000, // 录音的时长，单位 ms，最大值 600000（10 分钟）
       *   sampleRate: 44100, // 采样率
       *   numberOfChannels: 1, // 录音通道数
       *   encodeBitRate: 192000, // 编码码率
       *   format: 'aac' // 音频格式，选择此格式创建的音频消息，可以在即时通信 IM 全平台（Android、iOS、微信小程序和Web）互通
       * };
       *
       * // 2.1 监听录音错误事件
       * recorderManager.onError(function(errMsg) {
       *   console.warn('recorder error:', errMsg);
       * });
       * // 2.2 监听录音结束事件，录音结束后，调用 createAudioMessage 创建音频消息实例
       * recorderManager.onStop(function(res) {
       *   console.log('recorder stop', res);
       *
       *   // 4. 创建消息实例，接口返回的实例可以上屏
       *   const message = tim.createAudioMessage({
       *     to: 'user1',
       *     conversationType: TIM.TYPES.CONV_C2C,
       *     // 消息优先级，用于群聊（v2.4.2起支持）。如果某个群的消息超过了频率限制，后台会优先下发高优先级的消息，详细请参考：https://cloud.tencent.com/document/product/269/3663#.E6.B6.88.E6.81.AF.E4.BC.98.E5.85.88.E7.BA.A7.E4.B8.8E.E9.A2.91.E7.8E.87.E6.8E.A7.E5.88.B6)
       *     // 支持的枚举值：TIM.TYPES.MSG_PRIORITY_HIGH, TIM.TYPES.MSG_PRIORITY_NORMAL（默认）, TIM.TYPES.MSG_PRIORITY_LOW, TIM.TYPES.MSG_PRIORITY_LOWEST
       *     // priority: TIM.TYPES.MSG_PRIORITY_NORMAL,
       *     payload: {
       *       file: res
       *     }
       *   });
       *
       *   // 5. 发送消息
       *   let promise = tim.sendMessage(message);
       *   promise.then(function(imResponse) {
       *     // 发送成功
       *     console.log(imResponse);
       *   }).catch(function(imError) {
       *     // 发送失败
       *     console.warn('sendMessage error:', imError);
       *   });
       * });
       *
       * // 3. 开始录音
       * recorderManager.start(recordOptions);
       */

    }, {
      key: "createAudioMessage",
      value: function createAudioMessage(options) {
        return this.messageController.createAudioMessage(options);
      }
      /**
       * @description 创建视频消息实例的接口，此接口返回一个消息实例，可以在需要发送视频消息时调用 [发送消息](https://imsdk-1252463788.file.myqcloud.com/IM_DOC/Web/SDK.html#sendMessage) 接口发送消息。
       * >注意1：使用该接口前，需要将SDK版本升级至v2.2.0或以上。<br/>
       * >注意2：createVideoMessage 支持在微信小程序环境使用，从v2.6.0起，支持在 Web 环境使用。<br/>
       * >注意3：微信小程序录制视频，或者从相册选择视频文件，没有返回视频缩略图信息。为了更好的体验，sdk 在创建视频消息时会设置默认的缩略图信息。如果接入侧不想展示默认的缩略图，可在渲染的时候忽略缩图相关信息，自主处理。<br/>
       * >注意4：全平台互通视频消息，移动端请升级使用 [最新的 TUIKit 或 SDK](https://cloud.tencent.com/document/product/269/36887)。
       * @param {Object} options
       * @param {String} options.to - 消息接收方的 userID 或 groupID
       * @param {String} options.conversationType - 会话类型，取值`TIM.TYPES.CONV_C2C`(端到端会话) 或 `TIM.TYPES.CONV_GROUP`(群组会话)
       * @param {Object} options.payload
       * @param {HTMLInputElement|File|Object} options.payload.file - 用于选择视频文件的 DOM 节点（Web）或者 File 对象（Web），或微信小程序录制或者从相册选择的视频文件。SDK 会读取其中的数据并上传
       * @returns {Message} 消息实例
       * @example
       * // 小程序端发送视频消息示例：
       * // 1. 调用小程序接口选择视频，接口详情请查阅 https://developers.weixin.qq.com/miniprogram/dev/api/media/video/wx.chooseVideo.html
       * wx.chooseVideo({
       *   sourceType: ['album', 'camera'], // 来源相册或者拍摄
       *   maxDuration: 60, // 设置最长时间60s
       *   camera: 'back', // 后置摄像头
       *   success (res) {
       *     // 2. 创建消息实例，接口返回的实例可以上屏
       *     let message = tim.createVideoMessage({
       *       to: 'user1',
       *       conversationType: TIM.TYPES.CONV_C2C,
       *       // 消息优先级，用于群聊（v2.4.2起支持）。如果某个群的消息超过了频率限制，后台会优先下发高优先级的消息，详细请参考：https://cloud.tencent.com/document/product/269/3663#.E6.B6.88.E6.81.AF.E4.BC.98.E5.85.88.E7.BA.A7.E4.B8.8E.E9.A2.91.E7.8E.87.E6.8E.A7.E5.88.B6)
       *       // 支持的枚举值：TIM.TYPES.MSG_PRIORITY_HIGH, TIM.TYPES.MSG_PRIORITY_NORMAL（默认）, TIM.TYPES.MSG_PRIORITY_LOW, TIM.TYPES.MSG_PRIORITY_LOWEST
       *       // priority: TIM.TYPES.MSG_PRIORITY_NORMAL,
       *       payload: {
       *         file: res
       *       }
       *     })
       *     // 3. 发送消息
       *     let promise = tim.sendMessage(message);
       *     promise.then(function(imResponse) {
       *       // 发送成功
       *       console.log(imResponse);
       *     }).catch(function(imError) {
       *       // 发送失败
       *       console.warn('sendMessage error:', imError);
       *     });
       *   }
       * })
       * @example
       * // web 端发送视频消息示例（v2.6.0起支持）：
       * // 1. 获取视频：传入 DOM 节点
       * // 2. 创建消息实例
       * const message = tim.createVideoMessage({
       *   to: 'user1',
       *   conversationType: TIM.TYPES.CONV_C2C,
       *   payload: {
       *     file: document.getElementById('videoPicker') // 或者用event.target
       *   },
       *   onProgress: function(event) { console.log('file uploading:', event) }
       * });
       * // 3. 发送消息
       * let promise = tim.sendMessage(message);
       * promise.then(function(imResponse) {
       *   // 发送成功
       *   console.log(imResponse);
       * }).catch(function(imError) {
       *   // 发送失败
       *   console.warn('sendMessage error:', imError);
       * });
       */

    }, {
      key: "createVideoMessage",
      value: function createVideoMessage(options) {
        return this.messageController.createVideoMessage(options);
      }
      /**
       * @description 创建自定义消息实例的接口，此接口返回一个消息实例，可以在需要发送自定义消息时调用 [发送消息](https://imsdk-1252463788.file.myqcloud.com/IM_DOC/Web/SDK.html#sendMessage) 接口发送消息。
       * 当 SDK 提供的能力不能满足您的需求时，可以使用自定义消息进行个性化定制，例如投骰子功能。
       * @param {Object} options
       * @param {String} options.to - 消息接收方的 userID 或 groupID
       * @param {String} options.conversationType - 会话类型，取值`TIM.TYPES.CONV_C2C`(端到端会话) 或 `TIM.TYPES.CONV_GROUP`(群组会话)
       * @param {Object} options.payload
       * @param {String} options.payload.data - 自定义消息的数据字段
       * @param {String} options.payload.description - 自定义消息的说明字段
       * @param {String} options.payload.extension - 自定义消息的扩展字段
       * @returns {Message} 消息实例
       * @example
       * // 示例：利用自定义消息实现投骰子功能
       * // 1. 定义随机函数
       * function random(min, max) {
       *   return Math.floor(Math.random() * (max - min + 1) + min);
       * }
       * // 2. 创建消息实例，接口返回的实例可以上屏
       * let message = tim.createCustomMessage({
       *   to: 'user1',
       *   conversationType: TIM.TYPES.CONV_C2C,
       *   // 消息优先级，用于群聊（v2.4.2起支持）。如果某个群的消息超过了频率限制，后台会优先下发高优先级的消息，详细请参考：https://cloud.tencent.com/document/product/269/3663#.E6.B6.88.E6.81.AF.E4.BC.98.E5.85.88.E7.BA.A7.E4.B8.8E.E9.A2.91.E7.8E.87.E6.8E.A7.E5.88.B6)
       *   // 支持的枚举值：TIM.TYPES.MSG_PRIORITY_HIGH, TIM.TYPES.MSG_PRIORITY_NORMAL（默认）, TIM.TYPES.MSG_PRIORITY_LOW, TIM.TYPES.MSG_PRIORITY_LOWEST
       *   // priority: TIM.TYPES.MSG_PRIORITY_HIGH,
       *   payload: {
       *     data: 'dice', // 用于标识该消息是骰子类型消息
       *     description: String(random(1,6)), // 获取骰子点数
       *     extension: ''
       *   }
       * });
       * // 3. 发送消息
       * let promise = tim.sendMessage(message);
       * promise.then(function(imResponse) {
       *   // 发送成功
       *   console.log(imResponse);
       * }).catch(function(imError) {
       *   // 发送失败
       *   console.warn('sendMessage error:', imError);
       * });
       */

    }, {
      key: "createCustomMessage",
      value: function createCustomMessage(options) {
        return this.messageController.createCustomMessage(options);
      }
      /**
       * @description 创建表情消息实例的接口，此接口返回一个消息实例，可以在需要发送表情消息时调用 [发送消息](https://imsdk-1252463788.file.myqcloud.com/IM_DOC/Web/SDK.html#sendMessage) 接口发送消息。
       * >注意：使用该接口前，需要将SDK版本升级至v2.3.1或以上。
       * @param {Object} options
       * @param {String} options.to 消息接收方的 userID 或 groupID
       * @param {String} options.conversationType 会话类型，取值`TIM.TYPES.CONV_C2C`(端到端会话) 或 `TIM.TYPES.CONV_GROUP`(群组会话)
       * @param {Object} options.payload
       * @param {Number} options.payload.index 表情索引，用户自定义
       * @param {String} options.payload.data 额外数据
       * @returns {Message} 消息实例
       * @example
       * // 发送表情消息，Web端与小程序端相同。
       * // 1. 创建消息实例，接口返回的实例可以上屏
       * let message = tim.createFaceMessage({
       *   to: 'user1',
       *   conversationType: TIM.TYPES.CONV_C2C,
       *   // 消息优先级，用于群聊（v2.4.2起支持）。如果某个群的消息超过了频率限制，后台会优先下发高优先级的消息，详细请参考：https://cloud.tencent.com/document/product/269/3663#.E6.B6.88.E6.81.AF.E4.BC.98.E5.85.88.E7.BA.A7.E4.B8.8E.E9.A2.91.E7.8E.87.E6.8E.A7.E5.88.B6)
       *   // 支持的枚举值：TIM.TYPES.MSG_PRIORITY_HIGH, TIM.TYPES.MSG_PRIORITY_NORMAL（默认）, TIM.TYPES.MSG_PRIORITY_LOW, TIM.TYPES.MSG_PRIORITY_LOWEST
       *   // priority: TIM.TYPES.MSG_PRIORITY_NORMAL,
       *   payload: {
       *     index: 1, // Number 表情索引，用户自定义
       *     data: 'tt00' // String 额外数据
       *   }
       * });
       * // 2. 发送消息
       * let promise = tim.sendMessage(message);
       * promise.then(function(imResponse) {
       *   // 发送成功
       *   console.log(imResponse);
       * }).catch(function(imError) {
       *   // 发送失败
       *   console.warn('sendMessage error:', imError);
       * });
       */

    }, {
      key: "createFaceMessage",
      value: function createFaceMessage(options) {
        return this.messageController.createFaceMessage(options);
      }
      /**
       * 创建文件消息的接口，此接口返回一个消息实例，可以在需要发送文件消息时调用 [发送消息](https://imsdk-1252463788.file.myqcloud.com/IM_DOC/Web/SDK.html#sendMessage) 接口发送消息。
       * >注意1：v2.3.1版本开始支持传入 File 对象，使用前需要将SDK升级至v2.3.1或以上。<br/>
       * >注意2：v2.4.0版本起，上传文件大小最大值调整为100M。<br/>
       * >注意3：微信小程序目前不支持选择文件的功能，故该接口暂不支持微信小程序端。<br/>
       * @param {Object} options
       * @param {String} options.to - 消息接收方的 userID 或 groupID
       * @param {String} options.conversationType - 会话类型，取值`TIM.TYPES.CONV_C2C`（端到端会话） 或 `TIM.TYPES.CONV_GROUP`（群组会话）
       * @param {Object} options.payload
       * @param {HTMLInputElement|File} options.payload.file 用于选择文件的 DOM 节点（Web）或者 File 对象（Web），SDK 会读取其中的数据并上传文件。
       * @param {Function} options.onProgress - 获取上传进度的回调函数
       * @returns {Message} 消息实例
       * @example
       * // Web 端发送文件消息示例1 - 传入 DOM 节点
       * // 1. 创建文件消息实例，接口返回的实例可以上屏
       * let message = tim.createFileMessage({
       *   to: 'user1',
       *   conversationType: TIM.TYPES.CONV_C2C,
       *   // 消息优先级，用于群聊（v2.4.2起支持）。如果某个群的消息超过了频率限制，后台会优先下发高优先级的消息，详细请参考：https://cloud.tencent.com/document/product/269/3663#.E6.B6.88.E6.81.AF.E4.BC.98.E5.85.88.E7.BA.A7.E4.B8.8E.E9.A2.91.E7.8E.87.E6.8E.A7.E5.88.B6)
       *   // 支持的枚举值：TIM.TYPES.MSG_PRIORITY_HIGH, TIM.TYPES.MSG_PRIORITY_NORMAL（默认）, TIM.TYPES.MSG_PRIORITY_LOW, TIM.TYPES.MSG_PRIORITY_LOWEST
       *   // priority: TIM.TYPES.MSG_PRIORITY_NORMAL,
       *   payload: {
       *     file: document.getElementById('filePicker'),
       *   },
       *   onProgress: function(event) { console.log('file uploading:', event) }
       * });
       *
       * // 2. 发送消息
       * let promise = tim.sendMessage(message);
       * promise.then(function(imResponse) {
       *   // 发送成功
       *   console.log(imResponse);
       * }).catch(function(imError) {
       *   // 发送失败
       *   console.warn('sendMessage error:', imError);
       * });
       *
       * @example
       * // Web 端发送文件消息示例2- 传入 File 对象
       * // 先在页面上添加一个 id 为 "testPasteInput" 的消息输入框，如 <input type="text" id="testPasteInput" placeholder="截图后粘贴到输入框中" size="30" />
       * document.getElementById('testPasteInput').addEventListener('paste', function(e) {
       *   let clipboardData = e.clipboardData;
       *   let file;
       *   let fileCopy;
       *   if (clipboardData && clipboardData.files && clipboardData.files.length > 0) {
       *     file = clipboardData.files[0];
       *     // 图片消息发送成功后，file 指向的内容可能被浏览器清空，如果接入侧有额外的渲染需求，可以提前复制一份数据
       *     fileCopy = file.slice();
       *   }
       *
       *   if (typeof file === 'undefined') {
       *     console.warn('file 是 undefined，请检查代码或浏览器兼容性！');
       *     return;
       *   }
       *
       *   // 1. 创建消息实例，接口返回的实例可以上屏
       *   let message = tim.createFileMessage({
       *     to: 'user1',
       *     conversationType: TIM.TYPES.CONV_C2C,
       *     payload: {
       *       file: file
       *     },
       *     onProgress: function(event) { console.log('file uploading:', event) }
       *   });
       *
       *   // 2. 发送消息
       *   let promise = tim.sendMessage(message);
       *   promise.then(function(imResponse) {
       *     // 发送成功
       *     console.log(imResponse);
       *   }).catch(function(imError) {
       *     // 发送失败
       *     console.warn('sendMessage error:', imError);
       *   });
       * });
       */

    }, {
      key: "createFileMessage",
      value: function createFileMessage(options) {
        return this.messageController.createFileMessage(options);
      }
      /**
       * 发送消息的接口，需先调用下列的创建消息实例的接口获取消息实例后，再调用该接口发送消息实例。
       * - [创建文本消息](https://imsdk-1252463788.file.myqcloud.com/IM_DOC/Web/SDK.html#createTextMessage)
       * - [创建图片消息](https://imsdk-1252463788.file.myqcloud.com/IM_DOC/Web/SDK.html#createImageMessage)
       * - [创建音频消息](https://imsdk-1252463788.file.myqcloud.com/IM_DOC/Web/SDK.html#createAudioMessage)
       * - [创建视频消息](https://imsdk-1252463788.file.myqcloud.com/IM_DOC/Web/SDK.html#createVideoMessage)
       * - [创建自定义消息](https://imsdk-1252463788.file.myqcloud.com/IM_DOC/Web/SDK.html#createCustomMessage)
       * - [创建表情消息](https://imsdk-1252463788.file.myqcloud.com/IM_DOC/Web/SDK.html#createFaceMessage)
       * - [创建文件消息](https://imsdk-1252463788.file.myqcloud.com/IM_DOC/Web/SDK.html#createFileMessage)
       * >注意1：调用该接口发送消息实例，需要 sdk 处于 ready 状态，否则将无法发送消息实例。sdk 状态，可通过监听以下事件得到：
       * - [TIM.EVENT.SDK_READY](https://imsdk-1252463788.file.myqcloud.com/IM_DOC/Web/module-EVENT.html#.SDK_READY) - sdk 处于 ready 状态时触发
       * - [TIM.EVENT.SDK_NOT_READY](https://imsdk-1252463788.file.myqcloud.com/IM_DOC/Web/module-EVENT.html#.SDK_NOT_READY) - sdk 处于 not ready 状态时触发
       * >注意2：接收推送的单聊、群聊、群提示、群系统通知的新消息，需监听事件 [TIM.EVENT.MESSAGE_RECEIVED](https://imsdk-1252463788.file.myqcloud.com/IM_DOC/Web/module-EVENT.html#.MESSAGE_RECEIVED)<br/>
       * >注意3：本实例发送的消息，不会触发事件 [TIM.EVENT.MESSAGE_RECEIVED](https://imsdk-1252463788.file.myqcloud.com/IM_DOC/Web/module-EVENT.html#.MESSAGE_RECEIVED)。同账号从其他端（或通过 REST API）发送的消息，会触发事件 [TIM.EVENT.MESSAGE_RECEIVED](https://imsdk-1252463788.file.myqcloud.com/IM_DOC/Web/module-EVENT.html#.MESSAGE_RECEIVED)
       * @param {Message} message - 消息实例
       * @returns {Promise}
       */

    }, {
      key: "sendMessage",
      value: function sendMessage(message) {
        if (!(message instanceof Message)) {
          return IMPromise.reject(new IMError({
            code: ERROR_CODE.MESSAGE_SEND_NEED_MESSAGE_INSTANCE,
            message: ERROR_MESSAGE.MESSAGE_SEND_NEED_MESSAGE_INSTANCE
          }));
        }

        return this.messageController.sendMessageInstance(message);
      }
      /**
       * 撤回单聊消息或者群聊消息。撤回成功后，消息对象的 isRevoked 属性值为 true。
       * >注意1：使用该接口前，需要将SDK版本升级至v2.4.0或以上。<br/>
       * >注意2：消息可撤回时间默认为2分钟。可通过 [控制台](https://console.cloud.tencent.com/im-detail/login-message) 调整消息可撤回时间。<br/>
       * >注意3：被撤回的消息，可以调用 [getMessageList](https://imsdk-1252463788.file.myqcloud.com/IM_DOC/Web/SDK.html#getMessageList) 接口从单聊或者群聊消息漫游中拉取到。接入侧须根据消息对象的 isRevoked 属性妥善处理被撤回消息的展示。如单聊会话内可展示为 "对方撤回了一条消息"；群聊会话内可展示为 "XXX撤回了一条消息"。<br/>
       * >注意4：可使用 REST API [撤回单聊消息](https://cloud.tencent.com/document/product/269/38980) 或 [撤回群聊消息](https://cloud.tencent.com/document/product/269/12341)。<br/>
       * @param {Message} message 消息实例
       * @returns {Promise}
       * @example
       * // 主动撤回消息
       * let promise = tim.revokeMessage(message);
       * promise.then(function(imResponse) {
       *   // 消息撤回成功
       * }).catch(function(imError) {
       *   // 消息撤回失败
       *   console.warn('revokeMessage error:', imError);
       * });
       * @example
       * // 收到消息被撤回的通知
       * tim.on(TIM.EVENT.MESSAGE_REVOKED, function(event) {
       *   // event.name - TIM.EVENT.MESSAGE_REVOKED
       *   // event.data - 存储 Message 对象的数组 - [Message] - 每个 Message 对象的 isRevoked 属性值为 true
       * });
       * @example
       * // 获取会话的消息列表时遇到被撤回的消息
       * let promise = tim.getMessageList({conversationID: 'C2Ctest', count: 15});
       * promise.then(function(imResponse) {
       *   const messageList = imResponse.data.messageList; // 消息列表
       *   messageList.forEach(function(message) {
       *     if (message.isRevoked) {
       *       // 处理被撤回的消息
       *     } else {
       *       // 处理普通消息
       *     }
       *   });
       * });
       */

    }, {
      key: "revokeMessage",
      value: function revokeMessage(message) {
        return this.messageController.revokeMessage(message);
      }
      /**
       * 重发消息的接口，当消息发送失败时，可调用该接口进行重发。
       * @param {Message} message 待重发的消息实例
       * @returns {Promise}
       * @example
       * // 重发消息
       * let promise = tim.resendMessage(message); // 传入需要重发的消息实例
       * promise.then(function(imResponse) {
       *   // 重发成功
       *   console.log(imResponse);
       * }).catch(function(imError) {
       *   // 重发失败
       *   console.warn('resendMessage error:', imError);
       * });
       */

    }, {
      key: "resendMessage",
      value: function resendMessage(message) {
        return this.messageController.resendMessage(message);
      }
      /**
       * 分页拉取指定会话的消息列表的接口，当用户进入会话首次渲染消息列表或者用户“下拉查看更多消息”时，需调用该接口。
       * >注意：该接口可用于"拉取历史消息"
       * @see [漫游消息存储](https://cloud.tencent.com/document/product/269/3571#.E6.BC.AB.E6.B8.B8.E6.B6.88.E6.81.AF.E5.AD.98.E5.82.A8)
       * @see Message
       * @param {Object} options
       * @param {String} options.conversationID 会话 ID。会话 ID 组成方式：
       * - C2C+userID（单聊）
       * - GROUP+groupID（群聊）
       * - @TIM#SYSTEM（系统通知会话）
       * @param {String} options.nextReqMessageID 用于分页续拉的消息 ID。第一次拉取时该字段可不填，每次调用该接口会返回该字段，续拉时将返回字段填入即可。
       * @param {Number} [options.count=15] 需要拉取的消息数量，默认值和最大值为15，即一次拉取至多返回15条消息。
       * @returns {Promise}
       * @example
       * // 打开某个会话时，第一次拉取消息列表
       * let promise = tim.getMessageList({conversationID: 'C2Ctest', count: 15});
       * promise.then(function(imResponse) {
       *   const messageList = imResponse.data.messageList; // 消息列表。
       *   const nextReqMessageID = imResponse.data.nextReqMessageID; // 用于续拉，分页续拉时需传入该字段。
       *   const isCompleted = imResponse.data.isCompleted; // 表示是否已经拉完所有消息。
       * });
       * @example
       * // 下拉查看更多消息
       * let promise = tim.getMessageList({conversationID: 'C2Ctest', nextReqMessageID, count: 15});
       * promise.then(function(imResponse) {
       *   const messageList = imResponse.data.messageList; // 消息列表。
       *   const nextReqMessageID = imResponse.data.nextReqMessageID; // 用于续拉，分页续拉时需传入该字段。
       *   const isCompleted = imResponse.data.isCompleted; // 表示是否已经拉完所有消息。
       * });
       */

    }, {
      key: "getMessageList",
      value: function getMessageList(options) {
        return this.messageController.getMessageList(options);
      }
      /**
       * 将某会话下的未读消息状态设置为已读，置为已读的消息不会计入到未读统计，当打开会话或切换会话时调用该接口。如果在打开/切换会话时，不调用该接口，则对应的消息会一直是未读的状态。
       * @param {Object} options
       * @param {String} options.conversationID 会话 ID。会话 ID 组成方式：
       * - C2C+userID（单聊）
       * - GROUP+groupID（群聊）
       * - @TIM#SYSTEM（系统通知会话）
       * @returns {Promise}
       * @example
       * // 将某会话下所有未读消息已读上报
       * let promise = tim.setMessageRead({conversationID: 'C2Cexample'});
       * promise.then(function(imResponse) {
       *   // 已读上报成功
       * }).catch(function(imError) {
       *   // 已读上报失败
       *   console.warn('setMessageRead error:', imError);
       * });
       */

    }, {
      key: "setMessageRead",
      value: function setMessageRead(options) {
        return this.messageController.setMessageRead(options);
      } //   ______                                                                          __      __
      //  /      \                                                                        |  \    |  \
      // |  $$$$$$\  ______   _______  __     __   ______    ______    _______   ______  _| $$_    \$$  ______   _______
      // | $$   \$$ /      \ |       \|  \   /  \ /      \  /      \  /       \ |      \|   $$ \  |  \ /      \ |       \
      // | $$      |  $$$$$$\| $$$$$$$\\$$\ /  $$|  $$$$$$\|  $$$$$$\|  $$$$$$$  \$$$$$$\\$$$$$$  | $$|  $$$$$$\| $$$$$$$\
      // | $$   __ | $$  | $$| $$  | $$ \$$\  $$ | $$    $$| $$   \$$ \$$    \  /      $$ | $$ __ | $$| $$  | $$| $$  | $$
      // | $$__/  \| $$__/ $$| $$  | $$  \$$ $$  | $$$$$$$$| $$       _\$$$$$$\|  $$$$$$$ | $$|  \| $$| $$__/ $$| $$  | $$
      //  \$$    $$ \$$    $$| $$  | $$   \$$$    \$$     \| $$      |       $$ \$$    $$  \$$  $$| $$ \$$    $$| $$  | $$
      //   \$$$$$$   \$$$$$$  \$$   \$$    \$      \$$$$$$$ \$$       \$$$$$$$   \$$$$$$$   \$$$$  \$$  \$$$$$$  \$$   \$$
      //
      // Conversation

      /**
       * 获取会话列表的接口，该接口会尝试同步最新的100条会话，在同步完成后返回 SDK 内部维护的会话列表。
       * 调用时机：需要刷新会话列表时
       * >注意1：该接口获取的会话列表中的资料是不完整的（仅包括头像、昵称等，能够满足会话列表的渲染需求），若要查询详细会话资料，可参考：{@link SDK#getConversationProfile getConversationProfile} <br/>
       * >注意2：会话保存时长跟会话最后一条消息保存时间一致，消息默认保存7天，即会话默认保存7天。<br/>
       * @see Conversation
       * @returns {Promise}
       * @example
       * // 拉取会话列表
       * let promise = tim.getConversationList();
       * promise.then(function(imResponse) {
       *   const conversationList = imResponse.data.conversationList; // 会话列表，用该列表覆盖原有的会话列表
       * }).catch(function(imError) {
       *   console.warn('getConversationList error:', imError); // 获取会话列表失败的相关信息
       * });
       */

    }, {
      key: "getConversationList",
      value: function getConversationList() {
        return this.conversationController.getConversationList();
      }
      /**
       * 获取会话资料的接口，当点击会话列表中的某个会话时，调用该接口获取会话的详细信息。
       * @param {String} conversationID 会话 ID。会话 ID 组成方式：
       * - C2C+userID（单聊）
       * - GROUP+groupID（群聊）
       * - @TIM#SYSTEM（系统通知会话）
       * @see {@link SDK.Conversation 会话结构描述}
       * @returns {Promise}
       * @example
       * let promise = tim.getConversationProfile(conversationID);
       * promise.then(function(imResponse) {
       *   // 获取成功
       *   console.log(imResponse.data.conversation); // 会话资料
       * }).catch(function(imError) {
       *   console.warn('getConversationProfile error:', imError); // 获取会话资料失败的相关信息
       * });
       */

    }, {
      key: "getConversationProfile",
      value: function getConversationProfile(conversationID) {
        return this.conversationController.getConversationProfile(conversationID);
      }
      /**
       * 根据会话 ID 删除会话的接口。该接口只删除会话，不删除消息，例如：删除与用户 A 的会话，下次再与用户 A 发起会话时，之前的聊天信息仍在。
       * @param {String} conversationID - 会话 ID。会话 ID 组成方式：
       * - C2C+userID（单聊）
       * - GROUP+groupID（群聊）
       * - @TIM#SYSTEM（系统通知会话）
       * @see {@link SDK.Conversation 会话结构描述}
       * @returns {Promise}
       * @example
       * let promise = tim.deleteConversation('C2CExample');
       * promise.then(function(imResponse) {
       *   //删除成功。
       *   const { conversationID } = imResponse.data;// 被删除的会话 ID
       * }).catch(function(imError) {
       *   console.warn('deleteConversation error:', imError); // 删除会话失败的相关信息
       * });
       */

    }, {
      key: "deleteConversation",
      value: function deleteConversation(conversationID) {
        return this.conversationController.deleteConversation(conversationID);
      } //  __    __
      // |  \  |  \
      // | $$  | $$  _______   ______    ______
      // | $$  | $$ /       \ /      \  /      \
      // | $$  | $$|  $$$$$$$|  $$$$$$\|  $$$$$$\
      // | $$  | $$ \$$    \ | $$    $$| $$   \$$
      // | $$__/ $$ _\$$$$$$\| $$$$$$$$| $$
      //  \$$    $$|       $$ \$$     \| $$
      //   \$$$$$$  \$$$$$$$   \$$$$$$$ \$$
      //
      // User

      /**
       * @description 获取个人资料
       * >注意：v2.3.2版本开始支持自定义资料字段，使用前需要将SDK升级至v2.3.2或以上。
       * @see {@link SDK.Profile 资料结构描述}
       * @returns {Promise}
       * @example
       * let promise = tim.getMyProfile();
       * promise.then(function(imResponse) {
       *   console.log(imResponse.data); // 个人资料 - Profile 实例
       * }).catch(function(imError) {
       *   console.warn('getMyProfile error:', imError); // 获取个人资料失败的相关信息
       * });
       */

    }, {
      key: "getMyProfile",
      value: function getMyProfile() {
        return this.userController.getMyProfile();
      }
      /**
       * @description 获取其他用户资料。此接口会同时获取标配资料和自定义资料，详细请参考 https://cloud.tencent.com/document/product/269/1500#.E8.B5.84.E6.96.99.E7.B3.BB.E7.BB.9F.E7.AE.80.E4.BB.8B
       * >注意1：v2.3.2版本开始支持自定义资料字段，使用前需要将SDK升级至v2.3.2或以上。<br/>
       * >注意2：如果您没有配置自定义资料字段，或者配置了自定义资料字段，但是没有设置 value，此接口将不会返回自定义资料的内容。<br/>
       * >注意3：每次拉取的用户数不超过100，避免因回包数据量太大导致回包失败。如果传入的数组长度大于100，则只取前100个用户进行查询，其余丢弃。
       * @param {Object} options - 搜索参数
       * @param {Array.<String>} options.userIDList - 用户的账号列表，类型为数组
       * @returns {Promise}
       * @example
       * let promise = tim.getUserProfile({
       *   userIDList: ['user1', 'user2'] // 请注意：即使只拉取一个用户的资料，也需要用数组类型，例如：userIDList: ['user1']
       * });
       * promise.then(function(imResponse) {
       *   console.log(imResponse.data); // 存储用户资料的数组 - [Profile]
       * }).catch(function(imError) {
       *   console.warn('getUserProfile error:', imError); // 获取其他用户资料失败的相关信息
       * });
       *
       */

    }, {
      key: "getUserProfile",
      value: function getUserProfile(options) {
        return this.userController.getUserProfile(options);
      }
      /**
       * @description 更新个人资料
       * >注意：v2.3.2版本开始支持自定义资料字段，使用前需要将SDK升级至v2.3.2或以上。
       * @param {Object} options - 资料参数
       * @param { String } options.nick - 昵称
       * @param { String } options.avatar - 头像地址
       * @param { String } options.gender - 性别：
       * - TIM.TYPES.GENDER_UNKNOWN（未设置性别）
       * - TIM.TYPES.GENDER_FEMALE（女）
       * - TIM.TYPES.GENDER_MALE（男）
       * @param { String } options.selfSignature 个性签名
       * @param { String } options.allowType - 当被加人加好友时：
       * - TIM.TYPES.ALLOW_TYPE_ALLOW_ANY（允许直接加为好友）
       * - TIM.TYPES.ALLOW_TYPE_NEED_CONFIRM（需要验证）
       * - TIM.TYPES.ALLOW_TYPE_DENY_ANY（拒绝）
       * @param { Number } options.birthday 生日 推荐用法：20000101
       * @param { String } options.location 所在地 推荐用法：App 本地定义一套数字到地名的映射关系 后台实际保存的是4个 uint32_t 类型的数字：
       *    其中第一个 uint32_t 表示国家；
       *    第二个 uint32_t 用于表示省份；
       *    第三个 uint32_t 用于表示城市；
       *    第四个 uint32_t 用于表示区县
       * @param { Number } options.language 语言
       * @param { Number } options.messageSettings 消息设置 0：接收消息，1：不接收消息
       * @param { String } options.adminForbidType 管理员禁止加好友标识：
       * - TIM.TYPES.FORBID_TYPE_NONE（默认值，允许加好友）
       * - TIM.TYPES.FORBID_TYPE_SEND_OUT（禁止该用户发起加好友请求）
       * @param { Number } options.level 等级 建议拆分以保存多种角色的等级信息
       * @param { Number } options.role 角色 建议拆分以保存多种角色信息
       * @param { Array.<Object> } options.profileCustomField 自定义资料键值对集合，可根据业务侧需要使用，详细请参考: https://cloud.tencent.com/document/product/269/1500#.E8.87.AA.E5.AE.9A.E4.B9.89.E8.B5.84.E6.96.99.E5.AD.97.E6.AE.B5
       * @returns {Promise}
       * @example
       * // 修改个人标配资料
       * let promise = tim.updateMyProfile({
       *   nick: '我的昵称',
       *   avatar: 'http(s)://url/to/image.jpg',
       *   gender: TIM.TYPES.GENDER_MALE,
       *   selfSignature: '我的个性签名',
       *   allowType: TIM.TYPES.ALLOW_TYPE_ALLOW_ANY
       * });
       * promise.then(function(imResponse) {
       *   console.log(imResponse.data); // 更新资料成功
       * }).catch(function(imError) {
       *   console.warn('updateMyProfile error:', imError); // 更新资料失败的相关信息
       * });
       * @example
       * // 修改个人自定义资料
       * // 自定义资料字段需要预先在控制台配置，详细请参考：https://cloud.tencent.com/document/product/269/1500#.E8.87.AA.E5.AE.9A.E4.B9.89.E8.B5.84.E6.96.99.E5.AD.97.E6.AE.B5
       * let promise = tim.updateMyProfile({
       *   // 这里要求您已在即时通信 IM 控制台>【应用配置】>【功能配置】 申请了自定义资料字段 Tag_Profile_Custom_Test1
       *   // 注意！即使只有一个自定义资料字段，profileCustomField 也需要用数组类型
       *   profileCustomField: [
       *     {
       *       key: 'Tag_Profile_Custom_Test1',
       *       value: '我的自定义资料1'
       *     }
       *   ]
       * });
       * promise.then(function(imResponse) {
       *   console.log(imResponse.data); // 更新资料成功
       * }).catch(function(imError) {
       *   console.warn('updateMyProfile error:', imError); // 更新资料失败的相关信息
       * });
       * @example
       * // 修改个人标配资料和自定义资料
       * let promise = tim.updateMyProfile({
       *   nick: '我的昵称',
       *   // 这里要求您已在即时通信 IM 控制台>【应用配置】>【功能配置】 申请了自定义资料字段 Tag_Profile_Custom_Test1 和 Tag_Profile_Custom_Test2
       *   profileCustomField: [
       *     {
       *       key: 'Tag_Profile_Custom_Test1',
       *       value: '我的自定义资料1'
       *     },
       *     {
       *       key: 'Tag_Profile_Custom_Test2',
       *       value: '我的自定义资料2'
       *     },
       *   ]
       * });
       * promise.then(function(imResponse) {
       *   console.log(imResponse.data); // 更新资料成功
       * }).catch(function(imError) {
       *   console.warn('updateMyProfile error:', imError); // 更新资料失败的相关信息
       * });
       */

    }, {
      key: "updateMyProfile",
      value: function updateMyProfile(options) {
        return this.userController.updateMyProfile(options);
      }
      /**
       * @private
       * @description 获取我的好友列表
       * @returns {Promise}
       * @example
       * let promise = tim.getFriendList();
       * promise.then(function(imResponse) {
       *   console.log(imResponse.data); // 拉取好友列表成功
       * }).catch(function(imError) {
       *   console.warn('getFriendList error:', imError); // 获取好友列表失败的相关信息
       * });
       */

    }, {
      key: "getFriendList",
      value: function getFriendList() {
        return this.userController.getFriendList();
      }
      /**
       * @description 删除好友
       * @param {Object} options - 请求参数
       * @param {Array.<String>} options.toAccount - 待删除的好友的 userID 列表，单次请求的 To_Account 数不得超过1000
       * @param {String} [options.deleteType='Delete_Type_Single'] - 删除模式，Delete_Type_Single或Delete_Type_Both，默认单向删除。详情可参见 [删除好友]{@link https://cloud.tencent.com/document/product/269/1501#.E5.88.A0.E9.99.A4.E5.A5.BD.E5.8F.8B}
       * @fires ON_DELETEFRIEND_SUCCESS,ON_DELETEFRIEND_FAIL
       * @returns {Promise}
       * @private
       */

    }, {
      key: "deleteFriend",
      value: function deleteFriend(options) {
        return this.userController.deleteFriend(options);
      }
      /**
       * @description 获取我的黑名单列表
       * @returns {Promise}
       * @example
       * let promise = tim.getBlacklist();
       * promise.then(function(imResponse) {
       *   console.log(imResponse.data); // 我的黑名单列表，结构为包含用户 userID 的数组 - [userID]
       * }).catch(function(imError) {
       *   console.warn('getBlacklist error:', imError); // 获取黑名单列表失败的相关信息
       * });
       */

    }, {
      key: "getBlacklist",
      value: function getBlacklist() {
        return this.userController.getBlacklist();
      }
      /**
       * @description 添加用户到黑名单列表。将用户加入黑名单后可以屏蔽来自 TA 的所有消息，因此该接口可以实现“屏蔽该用户消息”的功能。
       * - 如果用户 A 与用户 B 之间存在好友关系，拉黑时会解除双向好友关系。
       * - 如果用户 A 与用户 B 之间存在黑名单关系，二者之间无法发起会话。
       * - 如果用户 A 与用户 B 之间存在黑名单关系，二者之间无法发起加好友请求。
       * @param {Object} options
       * @param {Array.<String>} options.userIDList 待添加为黑名单的用户 userID 列表，单次请求的 userID 数不得超过1000
       * @returns {Promise}
       * @example
       * let promise = tim.addToBlacklist({userIDList: ['user1', 'user2']}); // 请注意：即使只添加一个用户帐号到黑名单，也需要用数组类型，例如：userIDList: ['user1']
       * promise.then(function(imResponse) {
       *   console.log(imResponse.data); // 成功添加到黑名单的账号信息，结构为包含用户 userID 的数组 - [userID]
       * }).catch(function(imError) {
       *   console.warn('addToBlacklist error:', imError); // 添加用户到黑名单列表失败的相关信息
       * });
       */

    }, {
      key: "addToBlacklist",
      value: function addToBlacklist(options) {
        return this.userController.addBlacklist(options);
      }
      /**
       * @description 将用户从黑名单中移除。移除后，可以接收来自 TA 的所有消息。
       * @param {Object} options
       * @param {Array.<String>} option.userIDList - 待从黑名单中移除的 userID 列表，单次请求的 userID 数不得超过1000
       * @returns {Promise}
       * @example
       * let promise = tim.removeFromBlacklist({userIDList: ['user1', 'user2']}); // 请注意：即使只从黑名单中移除一个用户帐号，也需要用数组类型，例如：userIDList: ['user1']
       * result.then(function(imResponse) {
       *   console.log(imResponse.data); // 从黑名单中成功移除的账号列表，结构为包含用户 userID 的数组 - [userID]
       * }).catch(function(imError) {
       *   console.warn('removeFromBlacklist error:', imError); // 将用户从黑名单中移除失败的相关信息
       * });
       */

    }, {
      key: "removeFromBlacklist",
      value: function removeFromBlacklist(options) {
        return this.userController.deleteBlacklist(options);
      } //   ______
      //  /      \
      // |  $$$$$$\  ______    ______   __    __   ______
      // | $$ __\$$ /      \  /      \ |  \  |  \ /      \
      // | $$|    \|  $$$$$$\|  $$$$$$\| $$  | $$|  $$$$$$\
      // | $$ \$$$$| $$   \$$| $$  | $$| $$  | $$| $$  | $$
      // | $$__| $$| $$      | $$__/ $$| $$__/ $$| $$__/ $$
      //  \$$    $$| $$       \$$    $$ \$$    $$| $$    $$
      //   \$$$$$$  \$$        \$$$$$$   \$$$$$$ | $$$$$$$
      //                                         | $$
      //                                         | $$
      //                                          \$$
      //
      // Group

      /**
       * 需要渲染或刷新【我的群组列表】时，调用该接口获取群组列表，更多详情请参见 [Group](https://imsdk-1252463788.file.myqcloud.com/IM_DOC/Web/Group.html)。
       * >注意：接口返回的群组列表，不包含 TIM.TYPES.GRP_AVCHATROOM（音视频聊天室）类型的群组。
       * @see {@link Group}
       * @param {Object} options 请求参数
       * @param {String[]} [options.groupProfileFilter] 群资料过滤器。除默认拉取的群资料外，指定需要额外拉取的群资料，支持的值如下：
       * - TIM.TYPES.GRP_PROFILE_OWNER_ID（群主 ID）
       * - TIM.TYPES.GRP_PROFILE_CREATE_TIME（群创建时间）
       * - TIM.TYPES.GRP_PROFILE_LAST_INFO_TIME（最后一次群资料变更时间）
       * - TIM.TYPES.GRP_PROFILE_MEMBER_NUM（群成员数量）
       * - TIM.TYPES.GRP_PROFILE_MAX_MEMBER_NUM（最大群成员数量）
       * - TIM.TYPES.GRP_PROFILE_JOIN_OPTION（申请加群选项）
       * - TIM.TYPES.GRP_PROFILE_INTRODUCTION（群介绍）
       * - TIM.TYPES.GRP_PROFILE_NOTIFICATION（群公告）
       * @returns {Promise}
       * @example
       * // 该接口默认只会拉取这些资料：群类型、群名称、群头像、最后一条消息的时间。
       * let promise = tim.getGroupList();
       * promise.then(function(imResponse) {
       *   console.log(imResponse.data.groupList); // 群组列表
       * }).catch(function(imError) {
       *   console.warn('getGroupList error:', imError); // 获取群组列表失败的相关信息
       * });
       * @example
       * // 若默认拉取的字段不满足需求，可以参考下述代码，拉取额外的资料字段。
       * let promise = tim.getGroupList({
       *    groupProfileFilter: [TIM.TYPES.GRP_PROFILE_OWNER_ID],
       * });
       * promise.then(function(imResponse) {
       *   console.log(imResponse.data.groupList); // 群组列表
       * }).catch(function(imError) {
       *   console.warn('getGroupList error:', imError); // 获取群组列表失败的相关信息
       * });
       */

    }, {
      key: "getGroupList",
      value: function getGroupList(options) {
        return this.groupController.getGroupList(options);
      }
      /**
       * 获取群详细资料
       * @see {@link Group}
       * @param {Object} options
       * @param {String} options.groupID 群组ID
       * @param {String[]} [options.groupCustomFieldFilter] 群组维度的自定义字段过滤器，指定需要获取的群组维度的自定义字段，详情请参阅 {@link https://cloud.tencent.com/document/product/269/1502#.E8.87.AA.E5.AE.9A.E4.B9.89.E5.AD.97.E6.AE.B5 自定义字段}
       * @returns {Promise}
       * @example
       * let promise = tim.getGroupProfile({ groupID: 'group1', groupCustomFieldFilter: ['key1','key2'] });
       * promise.then(function(imResponse) {
       *   console.log(imResponse.data.group);
       * }).catch(function(imError) {
       *   console.warn('getGroupProfile error:', imError); // 获取群详细资料失败的相关信息
       * });
       */

    }, {
      key: "getGroupProfile",
      value: function getGroupProfile(options) {
        return this.groupController.getGroupProfile(options);
      }
      /**
       * 创建群组 <br/>
       * >注意：该接口创建 TIM.TYPES.GRP_AVCHATROOM（音视频聊天室） 后，需调用 {@link SDK#joinGroup joinGroup} 接口加入群组后，才能进行消息收发流程。
       * @see {@link Group}
       * @see {@link https://cloud.tencent.com/document/product/269/1502#.E7.BE.A4.E7.BB.84.E5.BD.A2.E6.80.81.E4.BB.8B.E7.BB.8D 群组形态介绍}
       * @param {Object} options - 参数集
       * @param {String} options.name - 必填，群组名称，最长30字节
       * @param {String} [options.type=TIM.TYPES.GRP_PRIVATE] - 群组类型，包括：<br/>
       * - TIM.TYPES.GRP_PRIVATE（私有群，默认）
       * - TIM.TYPES.GRP_PUBLIC（公开群）
       * - TIM.TYPES.GRP_CHATROOM（聊天室）
       * - TIM.TYPES.GRP_AVCHATROOM（音视频聊天室）
       * @param {String} [options.groupID] - 群组ID。不填该字段时，会自动为群组创建一个唯一的群 ID
       * @param {String} [options.introduction] - 群简介，最长240字节
       * @param {String} [options.notification] - 群公告，最长300字节
       * @param {String} [options.avatar] - 群头像 URL，最长100字节
       * @param {Number} [options.maxMemberNum] - 最大群成员数量，缺省时的默认值：私有群是200，公开群是2000，聊天室是10000，音视频聊天室和在线成员广播大群无限制
       * @param {String} [options.joinOption=TIM.TYPES.JOIN_OPTIONS_FREE_ACCESS] - 申请加群处理方式。
       * - TIM.TYPES.JOIN_OPTIONS_FREE_ACCESS (自由加入)
       * - TIM.TYPES.JOIN_OPTIONS_NEED_PERMISSION (需要验证)
       * - TIM.TYPES.JOIN_OPTIONS_DISABLE_APPLY (禁止加群)<br/>
       * 注意：创建 TIM.TYPES.GRP_PRIVATE, TIM.TYPES.GRP_CHATROOM, TIM.TYPES.GRP_AVCHATROOM 类型的群组不能填写该字段。私有群禁止申请加群，聊天室和音视频聊天室自由加入。
       * @param {Array.<Object>} [options.memberList] - 初始群成员列表，最多500个。创建音视频聊天室时不能添加成员
       * @param {String} options.memberList.userID - 必填，群成员的 userID
       * @param {String} [options.memberList.role] - 成员身份，可选值只有Admin，表示添加该成员并设其为管理员
       * @param {Object[]} [options.memberList.memberCustomField] - 群成员维度的自定义字段，默认情况是没有的，需要开通，详情请参阅{@link https://cloud.tencent.com/document/product/269/1502#.E8.87.AA.E5.AE.9A.E4.B9.89.E5.AD.97.E6.AE.B5 自定义字段}
       * @param {Object[]} [options.groupCustomField] - 群组维度的自定义字段，默认情况是没有的，需要开通，详情请参阅{@link https://cloud.tencent.com/document/product/269/1502#.E8.87.AA.E5.AE.9A.E4.B9.89.E5.AD.97.E6.AE.B5 群成员资料}
       * @returns {Promise}
       * @example
       * // 创建私有群
       * let promise = tim.createGroup({
       *   type: TIM.TYPES.GRP_PRIVATE,
       *   name: 'WebSDK',
       *   memberList: [{userID: 'user1'}, {userID: 'user2'}] // 如果填写了 memberList，则必须填写 userID
       * });
       * promise.then(function(imResponse) { // 创建成功
       *   console.log(imResponse.data.group); // 创建的群的资料
       * }).catch(function(imError) {
       *   console.warn('createGroup error:', imError); // 创建群组失败的相关信息
       * });
       */

    }, {
      key: "createGroup",
      value: function createGroup(options) {
        return this.groupController.createGroup(options);
      }
      /**
       * 群主可调用该接口解散群组。<br/>
       * >注意：群主不能解散私有群。
       * @see {@link Group}
       * @see {@link https://cloud.tencent.com/document/product/269/3661 群组管理}
       * @param {String} groupID 群组 ID
       * @returns {Promise}
       * @example
       * let promise = tim.dismissGroup('group1');
       * promise.then(function(imResponse) { // 解散成功
       *   console.log(imResponse.data.groupID); // 被解散的群组 ID
       * }).catch(function(imError) {
       *   console.warn('dismissGroup error:', imError); // 解散群组失败的相关信息
       * });
       */

    }, {
      key: "dismissGroup",
      value: function dismissGroup(groupID) {
        return this.groupController.dismissGroup(groupID);
      }
      /**
       * 修改群组资料
       * @see {@link Group}
       * @see {@link https://cloud.tencent.com/document/product/269/3661 群组管理}
       * @param {Object} options 请求参数
       * @param {Object} options.groupID 群ID
       * @param {Object} [options.name] 群名称，最长30字节
       * @param {Object} [options.avatar] 群头像URL，最长100字节
       * @param {Object} [options.introduction] 群简介，最长240字节
       * @param {Object} [options.notification] 群公告，最长300字节
       * @param {Number} [options.maxMemberNum] 最大群成员数量，最大为6000
       * @param {String} [options.joinOption=TIM.TYPES.JOIN_OPTIONS_FREE_ACCESS] - 申请加群处理方式。
       * - TIM.TYPES.JOIN_OPTIONS_FREE_ACCESS （自由加入）
       * - TIM.TYPES.JOIN_OPTIONS_NEED_PERMISSION （需要验证）
       * - TIM.TYPES.JOIN_OPTIONS_DISABLE_APPLY （禁止加群）<br/>
       * 注意：TIM.TYPES.GRP_PRIVATE, TIM.TYPES.GRP_CHATROOM, TIM.TYPES.GRP_AVCHATROOM 类型群组的该属性不允许修改。私有群禁止申请加群，聊天室和音视频聊天室自由加入。
       * @param {Object[]} [options.groupCustomField] 群自定义字段。默认情况是没有的。开通群组维度的自定义字段详情请参见 {@link https://cloud.tencent.com/document/product/269/1502#.E8.87.AA.E5.AE.9A.E4.B9.89.E5.AD.97.E6.AE.B5 自定义字段}
       * @param {String} options.groupCustomField.key 自定义字段的 Key
       * @param {String} options.groupCustomField.value 自定义字段的 Value
       * @returns {Promise}
       * @example
       * let promise = tim.updateGroupProfile({
       *   groupID: 'group1',
       *   name: 'new name', // 修改群名称
       *   introduction: 'this is introduction.', // 修改群公告
       *   // v2.6.0 起，群成员能收到群自定义字段变更的群提示消息，且能获取到相关的内容，详见 Message.payload.newGroupProfile.groupCustomField
       *   groupCustomField: [{ key: 'group_level', value: 'high'}] // 修改群组维度自定义字段
       * });
       * promise.then(function(imResponse) {
       *   console.log(imResponse.data.group) // 修改成功后的群组详细资料
       * }).catch(function(imError) {
       *   console.warn('updateGroupProfile error:', imError); // 修改群组资料失败的相关信息
       * });
       */

    }, {
      key: "updateGroupProfile",
      value: function updateGroupProfile(options) {
        return this.groupController.updateGroupProfile(options);
      }
      /**
       * 申请加群的接口，申请加入某个群组时调用。<br/>
       * >注意：
       * 1. 私有群不允许申请加群，只能通过 {@link SDK#addGroupMember addGroupMember} 方式添加
       * 2. TIM.TYPES.GRP_AVCHATROOM（音视频聊天室）有两种加群方式：<br/>
       *  2.1 正常加群，即登录加群。此时 SDK 内的所有接口都能正常调用。<br/>
       *  2.2 匿名加群，即不登录加群。此时只能收消息，其他任何需要鉴权的接口都不能调用。
       * 3. 只有 TIM.TYPES.GRP_AVCHATROOM（音视频聊天室） 支持匿名加群，其他类型的群组不支持。
       * 4. 同一用户同时只能加入一个音视频聊天室。【例如】用户已在音视频聊天室 A 中，再加入音视频聊天室 B，SDK 会先退出音视频聊天室 A，然后加入音视频聊天室 B
       * @see {@link Group}
       * @param {Object} options
       * @param {String} options.groupID
       * @param {String} options.applyMessage 附言
       * @param {String} [options.type] 要加入群组的类型，加入音视频聊天室时该字段必填。可选值：
       * - TIM.TYPES.GRP_PUBLIC（公开群）
       * - TIM.TYPES.GRP_CHATROOM （聊天室）
       * - TIM.TYPES.GRP_AVCHATROOM （音视频聊天室）
       * @returns {Promise}
       * @example
       * let promise = tim.joinGroup({ groupID: 'group1', type: TIM.TYPES.GRP_AVCHATROOM });
       * promise.then(function(imResponse) {
       *   switch (imResponse.data.status) {
       *     case TIM.TYPES.JOIN_STATUS_WAIT_APPROVAL: // 等待管理员同意
       *       break;
       *     case TIM.TYPES.JOIN_STATUS_SUCCESS: // 加群成功
       *       console.log(imResponse.data.group); // 加入的群组资料
       *       break;
       *     case TIM.TYPES.JOIN_STATUS_ALREADY_IN_GROUP: // 已经在群中
       *       break;
       *     default:
       *       break;
       *   }
       * }).catch(function(imError){
       *   console.warn('joinGroup error:', imError); // 申请加群失败的相关信息
       * });
       */

    }, {
      key: "joinGroup",
      value: function joinGroup(options) {
        return this.groupController.joinGroup(options);
      }
      /**
       * 退出群组。<br/>
       * >注意：群主只能退出私有群，退出后该私有群无群主。
       * @see {@link Group}
       * @see {@link https://cloud.tencent.com/document/product/269/3661 群组管理}
       * @param {String} groupID - 群组 ID
       * @returns {Promise} 成功时 then 回调参数中包含退出的群组 ID
       * @example
       * let promise = tim.quitGroup('group1');
       * promise.then(function(imResponse) {
       *   console.log(imResponse.data.groupID); // 退出成功的群 ID
       * }).catch(function(imError){
       *   console.warn('quitGroup error:', imError); // 退出群组失败的相关信息
       * });
       */

    }, {
      key: "quitGroup",
      value: function quitGroup(groupID) {
        return this.groupController.quitGroup(groupID);
      }
      /**
       * 通过 groupID 搜索群组。<br/>
       * >注意：TIM.TYPES.GRP_PRIVATE 类型的群组（私有群）不能被搜索。
       * @see {@link Group}
       * @param {String} groupID 群组 ID
       * @returns {Promise}
       * @example
       * let promise = tim.searchGroupByID('group1');
       * promise.then(function(imResponse) {
       *   const group = imResponse.data.group; // 群组信息
       * }).catch(function(imError) {
       *   console.warn('searchGroupByID error:', imError); // 搜素群组失败的相关信息
       * });
       */

    }, {
      key: "searchGroupByID",
      value: function searchGroupByID(groupID) {
        return this.groupController.searchGroupByID(groupID);
      }
      /**
       * 转让群组。只有群主有权限操作。 <br/>
       * >注意：只有群主拥有转让的权限。TIM.TYPES.GRP_AVCHATROOM（音视频聊天室）类型的群组不能转让。
       * @see {@link Group}
       * @param {Object} options
       * @param {String} options.groupID - 待转让的群组 ID
       * @param {String} options.newOwnerID - 新群主的 ID
       * @returns {Promise}
       * @example
       * let promise = tim.changeGroupOwner({
       *   groupID: 'group1',
       *   newOwnerID: 'user2'
       * });
       * promise.then(function(imResponse) { // 转让成功
       *   console.log(imResponse.data.group); // 群组资料
       * }).catch(function(imError) { // 转让失败
       *   console.warn('changeGroupOwner error:', imError); // 转让群组失败的相关信息
       * });
       */

    }, {
      key: "changeGroupOwner",
      value: function changeGroupOwner(options) {
        return this.groupController.changeGroupOwner(options);
      }
      /**
       * 处理申请加群（同意或拒绝）
       * >注意：如果一个群有多位管理员，当有人申请加群时，所有在线的管理员都会收到[申请加群](https://imsdk-1252463788.file.myqcloud.com/IM_DOC/Web/Message.html#.GroupSystemNoticePayload)的群系统通知。如果某位管理员处理了这个申请（同意或者拒绝），则其他管理员无法重复处理（即不能修改处理的结果）。
       * @see {@link Group}
       * @param {Object} options
       * @param {String} options.handleAction 处理结果 Agree(同意) / Reject(拒绝)
       * @param {String} [options.handleMessage] 附言
       * @param {Message} options.message 对应【群系统通知】的消息实例
       * @returns {Promise}
       * @example
       * let promise = tim.handleGroupApplication({
       *   handleAction: 'Agree',
       *   handleMessage: '欢迎欢迎',
       *   message: message // 申请加群群系统通知的消息实例
       * });
       * promise.then(function(imResponse) {
       *   console.log(imResponse.data.group); // 群组资料
       * }).catch(function(imError){
       *   console.warn('handleGroupApplication error:', imError); // 错误信息
       * });
       */

    }, {
      key: "handleGroupApplication",
      value: function handleGroupApplication(options) {
        return this.groupController.handleGroupApplication(options);
      }
      /**
       * @description 设置自己的群消息提示类型。
       * @see {@link Group}
       * @see {@link GroupMember}
       * @param {Object} options
       * @param {String} options.groupID
       * @param {String} options.messageRemindType 群消息提示类型。详细如下：
       * - TIM.TYPES.MSG_REMIND_ACPT_AND_NOTE（SDK 接收消息并通知接入侧(抛出 {@link  module:EVENT.MESSAGE_RECEIVED 收到消息事件})，接入侧做提示）
       * - TIM.TYPES.MSG_REMIND_ACPT_NOT_NOTE（SDK 接收消息并通知接入侧(抛出 {@link  module:EVENT.MESSAGE_RECEIVED 收到消息事件})，接入侧不做提示）
       * - TIM.TYPES.MSG_REMIND_DISCARD（SDK 拒收消息）
       * @returns {Promise}
       * @example
       * let promise = tim.setMessageRemindType({ groupID: 'group1', messageRemindType: TIM.TYPES.MSG_REMIND_DISCARD }); // 拒收消息
       * promise.then(function(imResponse) {
       *   console.log(imResponse.data.group); // 设置后的群资料。
       * }).catch(function(imError) {
       *   console.warn('setMessageRemindType error:', imError);
       * });
       */

    }, {
      key: "setMessageRemindType",
      value: function setMessageRemindType(options) {
        return this.groupController.setMessageRemindType(options);
      }
      /**
       * @description 获取群成员列表。
       * >注意：该接口获取的群成员列表中的资料是不完整的（仅包括头像、昵称等，能够满足群成员列表的渲染需求），若要查询详细资料，可参考：{@link SDK#getGroupMemberProfile getGroupMemberProfile}
       * @see {@link GroupMember}
       * @param {Object} options 请求参数
       * @param {String} options.groupID 群组的 ID
       * @param {Number} [options.count=15] 需要拉取的数量。最大值：100，避免回包过大导致请求失败。若传入超过100，则只拉取前100个。
       * @param {Number} [options.offset=0] 偏移量，默认从0开始拉取
       * @returns {Promise}
       * @example
       * let promise = tim.getGroupMemberList({ groupID: 'group1', count: 30, offset:0 }); // 从0开始拉取30个群成员
       * promise.then(function(imResponse) {
       *   console.log(imResponse.data.memberList); // 群成员列表
       * }).catch(function(imError) {
       *   console.warn('getGroupMemberList error:', imError);
       * });
       */

    }, {
      key: "getGroupMemberList",
      value: function getGroupMemberList(options) {
        return this.groupController.getGroupMemberList(options);
      }
      /**
       * @description 获取群成员资料，如禁言时间等。
       * >注意1：使用该接口前，需要将SDK版本升级至v2.2.0或以上。<br/>
       * >注意2：每次查询的用户数上限是50。如果传入的数组长度大于50，则只取前50个用户进行查询，其余丢弃。
       * @see {@link GroupMember}
       * @param {Object} options 请求参数
       * @param {String} options.groupID 群组 ID
       * @param {String[]} options.userIDList 要查询的群成员用户 ID 列表
       * @param {String[]} [options.memberCustomFieldFilter] 群成员自定义字段筛选。可选，若不填，则默认查询所有群成员自定义字段。
       * @returns {Promise} 返回Promise对象
       * @example
       * let promise = tim.getGroupMemberProfile({
       *   groupID: 'group1',
       *   userIDList: ['user1', 'user2'], // 请注意：即使只拉取一个群成员的资料，也需要用数组类型，例如：userIDList: ['user1']
       *   memberCustomFieldFilter: ['group_member_custom'], // 筛选群成员自定义字段：group_member_custom
       * });
       * promise.then(function(imResponse) {
       *   console.log(imResponse.data.memberList); // 群成员列表
       * }).catch(function(imError) {
       *   console.warn('getGroupMemberProfile error:', imError);
       * });
       */

    }, {
      key: "getGroupMemberProfile",
      value: function getGroupMemberProfile(options) {
        return this.groupController.getGroupMemberProfile(options);
      }
      /**
       * 添加群成员。详细规则如下：
       * - TIM.TYPES.GRP_PRIVATE（私有群）：任何群成员都可邀请他人加群，且无需被邀请人同意，直接将其拉入群组中。
       * - TIM.TYPES.GRP_PUBLIC（公开群）/ TIM.TYPES.GRP_CHATROOM（聊天室）：只有 App 管理员可以邀请他人入群，且无需被邀请人同意，直接将其拉入群组中。
       * - TIM.TYPES.GRP_AVCHATROOM（音视频聊天室）：不允许任何人邀请他人入群（包括 App 管理员）。
       * @see {@link Group}
       * @see {@link GroupMember}
       * @see {@link https://cloud.tencent.com/document/product/269/1502#.E7.BE.A4.E6.88.90.E5.91.98.E6.93.8D.E4.BD.9C.E5.B7.AE.E5.BC.82 群成员操作差异}
       * @param {Object} options
       * @param {String} options.groupID
       * @param {String[]} options.userIDList 待添加的群成员 ID 数组。单次最多添加500个成员
       * @returns {Promise}
       * @example
       * let promise = tim.addGroupMember({groupID: 'group1', userIDList: ['user1','user2','user3']});
       * promise.then(function(imResponse) {
       *   console.log(imResponse.data.successUserIDList); // 添加成功的群成员 userIDList
       *   console.log(imResponse.data.failureUserIDList); // 添加失败的群成员 userIDList
       *   console.log(imResponse.data.existedUserIDList); // 已在群中的群成员 userIDList
       *   console.log(imResponse.data.group); // 添加后的群组信息
       * }).catch(function(imError) {
       *   console.warn('addGroupMember error:', imError); // 错误信息
       * });
       */

    }, {
      key: "addGroupMember",
      value: function addGroupMember(options) {
        return this.groupController.addGroupMember(options);
      }
      /**
       * 删除群成员。群主可移除群成员。
       * @see {@link Group}
       * @see {@link GroupMember}
       * @param {Object} options
       * @param {String} options.groupID 群ID
       * @param {String[]} options.userIDList 待删除的群成员的 ID 列表
       * @param {String} [options.reason] 踢人的原因
       * @returns {Promise}
       * @example
       * let promise = tim.deleteGroupMember({groupID: 'group1', userIDList:['user1'], reason: '你违规了，我要踢你！'});
       * promise.then(function(imResponse) {
       *   console.log(imResponse.data.group); // 删除后的群组信息
       *   console.log(imResponse.data.userIDList); // 被删除的群成员的 userID 列表
       * }).catch(function(imError) {
       *   console.warn('deleteGroupMember error:', imError); // 错误信息
       * });
       */

    }, {
      key: "deleteGroupMember",
      value: function deleteGroupMember(options) {
        return this.groupController.deleteGroupMember(options);
      }
      /**
       * 设置群成员的禁言时间，可以禁言群成员，也可取消禁言。TIM.TYPES.GRP_PRIVATE 类型的群组（即私有群）不能禁言。<br/>
       * >注意：只有群主和管理员拥有该操作权限：
       * - 群主可以禁言/取消禁言管理员和普通群成员。
       * - 管理员可以禁言/取消禁言普通群成员。
       * @see {@link Group}
       * @see {@link GroupMember}
       * @see {@link https://cloud.tencent.com/document/product/269/1502#.E6.B6.88.E6.81.AF.E7.AE.A1.E7.90.86.E5.B7.AE.E5.BC.82 群组消息管理差异}
       * @param {Object} options
       * @param {String} options.groupID
       * @param {String} options.userID
       * @param {Number} options.muteTime 禁言时长，单位秒。如设为1000，则表示从现在起禁言该用户1000秒；设为0，则表示取消禁言。
       * @returns {Promise}
       * @example
       * let promise = tim.setGroupMemberMuteTime({
       *   groupID: 'group1',
       *   userID: 'user1',
       *   muteTime: 600 // 禁言10分钟；设为0，则表示取消禁言
       * });
       * promise.then(function(imResponse) {
       *   console.log(imResponse.data.group); // 修改后的群资料
       *   console.log(imResponse.data.member); // 修改后的群成员资料
       * }).catch(function(imError) {
       *   console.warn('setGroupMemberMuteTime error:', imError); // 禁言失败的相关信息
       * });
       */

    }, {
      key: "setGroupMemberMuteTime",
      value: function setGroupMemberMuteTime(options) {
        return this.groupController.setGroupMemberMuteTime(options);
      }
      /**
       * 修改群成员角色。只有群主拥有操作的权限。
       * @see {@link Group}
       * @see {@link GroupMember}
       * @param {Object} options
       * @param {String} options.groupID
       * @param {String} options.userID
       * @param {String} options.role 可选值：TIM.TYPES.GRP_MBR_ROLE_ADMIN（群管理员） 或 TIM.TYPES.GRP_MBR_ROLE_MEMBER（群普通成员）
       * @returns {Promise}
       * @example
       * let promise = tim.setGroupMemberRole({
       *   groupID: 'group1',
       *   userID: 'user1',
       *   role: TIM.TYPES.GRP_MBR_ROLE_ADMIN // 将群 ID: group1 中的用户：user1 设为管理员
       * });
       * promise.then(function(imResponse) {
       *   console.log(imResponse.data.group); // 修改后的群资料
       *   console.log(imResponse.data.member); // 修改后的群成员资料
       * }).catch(function(imError) {
       *   console.warn('setGroupMemberRole error:', imError); // 错误信息
       * });
       */

    }, {
      key: "setGroupMemberRole",
      value: function setGroupMemberRole(options) {
        return this.groupController.setGroupMemberRole(options);
      }
      /**
       * 设置群成员名片。<br/>
       * - 群主：可设置所有群成员的名片。
       * - 管理员：可设置自身和其他普通群成员的群名片。
       * - 普通群成员：只能设置自身群名片。
       * @see {@link Group}
       * @see {@link GroupMember}
       * @param {Object} options
       * @param {String} options.groupID
       * @param {String} [options.userID] 可选，默认修改自身的群名片
       * @param {String} options.nameCard
       * @returns {Promise}
       * @example
       * let promise = tim.setGroupMemberNameCard({ groupID: 'group1', userID: 'user1', nameCard: '用户名片' });
       * promise.then(function(imResponse) {
       *   console.log(imResponse.data.group); // 设置后的群资料
       *   console.log(imResponse.data.member); // 修改后的群成员资料
       * }).catch(function(imError) {
       *   console.warn('setGroupMemberNameCard error:', imError); // 设置群成员名片失败的相关信息
       * });
       */

    }, {
      key: "setGroupMemberNameCard",
      value: function setGroupMemberNameCard(options) {
        return this.groupController.setGroupMemberNameCard(options);
      }
      /**
       * @description 设置群成员自定义字段。<br/>
       * >注意：普通群成员只能设置自己的自定义字段。
       * @see {@link Group}
       * @see {@link GroupMember}
       * @param {Object} options
       * @param {String} options.groupID 群 ID
       * @param {String} [options.userID] 可选，不填则修改自己的群成员自定义字段
       * @param {Object[]} options.memberCustomField 群成员自定义字段
       * @param {String} options.memberCustomField.key 自定义字段的 Key
       * @param {String} options.memberCustomField.value 自定义字段的 Value
       * @returns {Promise}
       * @example
       * let promise = tim.setGroupMemberCustomField({ groupID: 'group1', memberCustomField: [{key: 'group_member_test', value: 'test'}]});
       * promise.then(function(imResponse) {
       *   console.log(imResponse.data.group); // 修改后的群资料
       *   console.log(imResponse.data.member); // 修改后的群成员资料
       * }).catch(function(imError) {
       *   console.warn('setGroupMemberCustomField error:', imError); // 设置群成员自定义字段失败的相关信息
       * });
       */

    }, {
      key: "setGroupMemberCustomField",
      value: function setGroupMemberCustomField(options) {
        return this.groupController.setGroupMemberCustomField(options);
      } //
      //  _______             __                       __
      // |       \           |  \                     |  \
      // | $$$$$$$\  ______   \$$ __     __  ______  _| $$_     ______
      // | $$__/ $$ /      \ |  \|  \   /  \|      \|   $$ \   /      \
      // | $$    $$|  $$$$$$\| $$ \$$\ /  $$ \$$$$$$\\$$$$$$  |  $$$$$$\
      // | $$$$$$$ | $$   \$$| $$  \$$\  $$ /      $$ | $$ __ | $$    $$
      // | $$      | $$      | $$   \$$ $$ |  $$$$$$$ | $$|  \| $$$$$$$$
      // | $$      | $$      | $$    \$$$   \$$    $$  \$$  $$ \$$     \
      //  \$$       \$$       \$$     \$     \$$$$$$$   \$$$$   \$$$$$$$
      //

      /**
       * 初始化TIM配置
       * @private
       * @param {Object} options
       */

    }, {
      key: "_initOptions",
      value: function _initOptions(options) {
        // 插件map
        this.plugins = {};
        var SDKAppID = options.SDKAppID || 0;
        var accountType = randomInt(); // 随后指向 ContextController 管理的 Context model

        this.context = {
          SDKAppID: SDKAppID,
          accountType: accountType
        };
        this.loginInfo = {
          SDKAppID: SDKAppID,
          accountType: accountType,
          identifier: null,
          userSig: null
        }; // 以下参数不对外提供，仅由开发测试使用

        this.options = {
          runLoopNetType: options.runLoopNetType || RUNLOOP_TYPES.XHR,
          // 暂时默认xhr，ws调通后应该默认ws
          enablePointer: options.enablePointer || false // 默认不允许打点，因为打点的log接入侧无需关心

        };
      }
      /**
       * 初始化成员变量
       * @private
       */

    }, {
      key: "_initMemberVariables",
      value: function _initMemberVariables() {
        this.innerEmitter = new eventemitter3();
        this.outerEmitter = new eventemitter3();
        IMPromise.hookEmitter(this.outerEmitter);
        this.packageConfig = new PackageConfig(this);
        this.storage = new Storage(this);
        this.netMonitor = new NetMonitor(); // 规范事件响应函数的参数

        this.outerEmitter._emit = this.outerEmitter.emit;

        this.outerEmitter.emit = function (eventName, eventData) {
          var _eventName = arguments[0];
          var args = [_eventName, {
            name: arguments[0],
            data: arguments[1]
          }];
          logger.debug("emit outer event:".concat(_eventName), args[1]);

          this.outerEmitter._emit.apply(this.outerEmitter, args);
        }.bind(this);

        this.innerEmitter._emit = this.innerEmitter.emit;

        this.innerEmitter.emit = function (eventName, eventData) {
          var args;

          if (isPlainObject(arguments[1]) && arguments[1]['data']) {
            logger.warn('inner eventData has data property, please check!');
            args = [eventName, {
              name: arguments[0],
              data: arguments[1]['data']
            }];
          } else {
            args = [eventName, {
              name: arguments[0],
              data: arguments[1]
            }];
          }

          logger.debug("emit inner event:".concat(eventName), args[1]);

          this.innerEmitter._emit.apply(this.innerEmitter, args);
        }.bind(this);
      }
      /**
       *  加载相关控制台，并挂到TIM的实例上
       * @private
       */

    }, {
      key: "_initControllers",
      value: function _initControllers() {
        // 不需要继承 IMController
        this.exceptionController = new ExceptionController(this);
        this.connectionController = new ConnectionController(this); // 继承 IMController

        this.contextController = new ContextController(this);
        this.context = this.contextController.getContext();
        this.signController = new SignController(this); // 加载登录控制器

        this.messageController = new MessageController(this);
        this.conversationController = new ConversationController(this);
        this.userController = new UserController(this);
        this.groupController = new GroupController(this);
        this.notificationController = new NotificationController(this);
        this.bigDataHallwayController = new BigDataHallwayController(this);
        this.statusController = new StatusController(this);
        this.uploadController = new UploadController(this); // 事件统计

        this.eventStatController = new EventStatController(this); // 汇总统计

        this.sumStatController = new SumStatController(this); // 最后初始化 mtaReportController

        this.mtaReportController = new MTAReportController(this);

        this._initReadyListener();
      }
      /**
       * 给SDK配置基本的监听事件
       * @private
       */

    }, {
      key: "_initListener",
      value: function _initListener() {
        var _this2 = this;

        // 当长时间掉线重连时
        this.innerEmitter.on(TIM_INNER_EVENT.NOTICE_LONGPOLL_SLOW_START, this._onSlowStart, this);

        if (IN_WX_MINI_APP && typeof wx.onAppShow === 'function' && typeof wx.onAppHide === 'function') {
          var ssoLog = null;
          wx.onAppHide(function () {
            ssoLog = new SSOLogData();
            ssoLog.setMethod(SSOMethods.MP_HIDE_TO_SHOW).setStart();
          });
          wx.onAppShow(function () {
            if (ssoLog !== null) {
              ssoLog.setCode(0).setNetworkType(_this2.netMonitor.getNetworkType()).setEnd();
            }
          });
        }
      }
      /**
       * 初始化 Ready 监听器
       * @private
       */

    }, {
      key: "_initReadyListener",
      value: function _initReadyListener() {
        var _this3 = this;

        var readyList = this.readyList;

        for (var i = 0, length = readyList.length; i < length; i++) {
          this[readyList[i]].ready(function () {
            return _this3._readyHandle();
          });
        }
      } // 慢启动重启长轮询

    }, {
      key: "_onSlowStart",
      value: function _onSlowStart() {
        logger.log('slow start longpolling...'); // 重置sdk数据，NotificationController.rest 会停止当前longPolling

        this.resetSDK(); // 重新登录、同步消息、启动轮询（注：当前逻辑下，登录成功后会按顺序触发同步、取通道ID、启动通道的过程）

        this.login(this.loginInfo);
      }
      /**
       * reset SDK 内部的数据
       * @private
       */

    }, {
      key: "resetSDK",
      value: function resetSDK() {
        var _this4 = this;

        // 1. 重置各个 控制器
        var initList = this.initList;
        initList.forEach(function (controller) {
          if (_this4[controller].reset) {
            _this4[controller].reset();
          }
        });
        this.netMonitor.reset(); // 2. 重置 storage

        this.storage.reset(); // 3. 重置 ready 状态

        this.resetReady(); // 4. 注册 ready 状态监听器

        this._initReadyListener(); // 5. 抛事件


        this.outerEmitter.emit(TIM_OUTER_EVENT.SDK_NOT_READY);
      }
      /**
       * SDK 初始化时 isReady 为false
       * 在关键 Controller 模块注册 ready 回调，都触发ready 后才可以正常调用sdk api
       * 1. 每个关键模块的ready回调都是同一个handle
       * 2. 当 handle 执行时循环关键模块的 ready 状态
       * 3. 有一例false 退出循环
       * 4. 全部都是true 时 sdk _isReady为true
       * @private
       */

    }, {
      key: "_readyHandle",
      value: function _readyHandle() {
        var readyList = this.readyList;
        var result = true;

        for (var i = 0, length = readyList.length; i < length; i++) {
          if (!this[readyList[i]].isReady()) {
            result = false;
            break;
          }
        }

        if (result) {
          var cost = logger.timeEnd(label.SDK_READY);
          logger.warn("SDK is ready. cost=".concat(cost, "ms"));
          this.triggerReady();
          this.innerEmitter.emit(TIM_INNER_EVENT.SDK_READY);
          this.outerEmitter.emit(TIM_OUTER_EVENT.SDK_READY); // event stat

          this._ssoLog.setCode(0).setNetworkType(this.netMonitor.getNetworkType()).setText(cost).setEnd();
        }
      }
    }]);

    return SDK;
  }(); // conversationController 是最后一个ready 的控制器，因此把它做为SDK ready的标记


  SDK$1.prototype.readyList = ['conversationController'];
  SDK$1.prototype.initList = ['exceptionController', 'connectionController', 'signController', 'contextController', 'messageController', 'conversationController', 'userController', 'groupController', 'notificationController', 'eventStatController', 'sumStatController'];

  var APINoNeedSDKReady = {
    login: 'login',
    on: 'on',
    off: 'off',
    ready: 'ready',
    setLogLevel: 'setLogLevel',
    joinGroup: 'joinGroup',
    // 匿名进 AVChatRoom 时不需校验 ready
    quitGroup: 'quitGroup',
    // 匿名退 AVChatRoom 时不需校验 ready
    registerPlugin: 'registerPlugin'
  };
  /**
   * 调用 API 前的 SDK ready 校验
   * @param {TIM} sdk sdk实例
   * @param {String} APIName 接口名称
   * @returns {Boolean} sdk已经ready或者接口用时不需sdk ready，返回true；否则返回false且提示
   */

  function validateReady(sdk, APIName) {
    if (sdk.isReady() || typeof APINoNeedSDKReady[APIName] !== 'undefined') {
      return true;
    }

    sdk.innerEmitter.emit(TIM_INNER_EVENT.ERROR_DETECTED, new IMError({
      code: ERROR_CODE.SDK_IS_NOT_READY,
      message: "".concat(APIName, " ").concat(ERROR_MESSAGE.SDK_IS_NOT_READY, "\uFF0C\u8BF7\u53C2\u8003 https://imsdk-1252463788.file.myqcloud.com/IM_DOC/Web/module-EVENT.html#.SDK_READY")
    }));
    return false;
  }

  // 临时文件，用于替换 TIM.js
  var sdkList = {};
  /**
   * @description TIM 是 IM Web SDK 的命名空间，提供了创建 SDK 实例的静态方法 create() ，以及事件常量 {@link module:EVENT EVENT}，类型常量 {@link module:TYPES TYPES}
   * @namespace TIM
    */

  var TIM = {};
  /**
   * @description 即时通信 IM Web SDK 的工厂函数，用于生成 SDK 实例。<br/>
   * 接入前，您需要在 [云通信控制台]{@link https://console.cloud.tencent.com/avc} 中创建一个云通信应用，并取得 `SDKAppID`。<br/>
   * 如果想快速体验通即时通信 IM 的 Demo，请参考文档：[《一分钟跑通 Demo》]{@link https://cloud.tencent.com/document/product/269/36838}
   * @memberof TIM
   * @param {Object} options 配置
   * @param {Number} options.SDKAppID - 云通信应用的 `SDKAppID`
   * @example
   * let options = {
   *   SDKAppID: 0 // 接入时需要将0替换为您的云通信应用的 SDKAppID
   * };
   * let tim = TIM.create(options); // SDK 实例通常用 tim 表示
   * @returns {Object} SDK 实例
   */

  TIM.create = function (options) {
    if (options.SDKAppID && sdkList[options.SDKAppID]) {
      return sdkList[options.SDKAppID];
    }

    logger.log('TIM.create');
    var sdk = new SDK$1(options);
    sdk.on(TIM_OUTER_EVENT.SDK_DESTROY, function (event) {
      // sdk销毁需要移除 sdkList 相应的实例
      sdkList[event.data.SDKAppID] = null;
      delete sdkList[event.data.SDKAppID];
    }); // 将配置里指定的 SDK API 挂载到无原型对象上。

    var obj = assemblySDK(sdk);
    sdkList[options.SDKAppID] = obj;
    logger.log('TIM.create ok');
    return obj;
  };
  /**
   *
   * @param {*} sdk
   * @private
   */


  function assemblySDK(sdk) {
    var obj = Object.create(null);
    Object.keys(APIList).forEach(function (key) {
      // 配置里的方法在 SDK 里没有找到
      if (!sdk[key]) {
        return;
      }

      var name = APIList[key];
      var validateMiddleware = new Middleware();

      obj[name] = function () {
        var args = Array.from(arguments); // console.log(args);
        // 参数验证中间件

        validateMiddleware.use(function (options, next) {
          if (validateReady(sdk, key)) {
            // sdk ready 校验
            return next();
          }
        }).use(function (options, next) {
          if (validateParams(options, APIValidateConfig[key], name) === true) {
            return next();
          }
        }).use(function (options, next) {
          return sdk[key].apply(sdk, options);
        });
        return validateMiddleware.run(args); // 异步返回promise ，同步返回response object
      };
    });
    return obj;
  } // 挂载常量配置
  // TIM.CONFIG = TIM_CONFIG;


  TIM.TYPES = TYPES; // TIM.ERROR = TIM_ERROR;

  TIM.EVENT = TIM_OUTER_EVENT;
  TIM.VERSION = version;
  logger.log("TIM.VERSION: ".concat(TIM.VERSION)); // 挂载模型

  return TIM;

})));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26)))

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(85), __esModule: true };

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = !__webpack_require__(10) && !__webpack_require__(15)(function () {
  return Object.defineProperty(__webpack_require__(37)('div'), 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(12);


/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

var has = __webpack_require__(14);
var toIObject = __webpack_require__(16);
var arrayIndexOf = __webpack_require__(89)(false);
var IE_PROTO = __webpack_require__(41)('IE_PROTO');

module.exports = function (object, names) {
  var O = toIObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};


/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

var document = __webpack_require__(3).document;
module.exports = document && document.documentElement;


/***/ }),
/* 61 */
/***/ (function(module, exports) {

module.exports = function (done, value) {
  return { value: value, done: !!done };
};


/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

// call something on iterator step with safe closing on error
var anObject = __webpack_require__(13);
module.exports = function (iterator, fn, value, entries) {
  try {
    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch (e) {
    var ret = iterator['return'];
    if (ret !== undefined) anObject(ret.call(iterator));
    throw e;
  }
};


/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

// check on default Array iterator
var Iterators = __webpack_require__(21);
var ITERATOR = __webpack_require__(5)('iterator');
var ArrayProto = Array.prototype;

module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
};


/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

var classof = __webpack_require__(45);
var ITERATOR = __webpack_require__(5)('iterator');
var Iterators = __webpack_require__(21);
module.exports = __webpack_require__(6).getIteratorMethod = function (it) {
  if (it != undefined) return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};


/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

// 7.3.20 SpeciesConstructor(O, defaultConstructor)
var anObject = __webpack_require__(13);
var aFunction = __webpack_require__(19);
var SPECIES = __webpack_require__(5)('species');
module.exports = function (O, D) {
  var C = anObject(O).constructor;
  var S;
  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
};


/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

var ctx = __webpack_require__(11);
var invoke = __webpack_require__(95);
var html = __webpack_require__(60);
var cel = __webpack_require__(37);
var global = __webpack_require__(3);
var process = global.process;
var setTask = global.setImmediate;
var clearTask = global.clearImmediate;
var MessageChannel = global.MessageChannel;
var Dispatch = global.Dispatch;
var counter = 0;
var queue = {};
var ONREADYSTATECHANGE = 'onreadystatechange';
var defer, channel, port;
var run = function () {
  var id = +this;
  // eslint-disable-next-line no-prototype-builtins
  if (queue.hasOwnProperty(id)) {
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};
var listener = function (event) {
  run.call(event.data);
};
// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if (!setTask || !clearTask) {
  setTask = function setImmediate(fn) {
    var args = [];
    var i = 1;
    while (arguments.length > i) args.push(arguments[i++]);
    queue[++counter] = function () {
      // eslint-disable-next-line no-new-func
      invoke(typeof fn == 'function' ? fn : Function(fn), args);
    };
    defer(counter);
    return counter;
  };
  clearTask = function clearImmediate(id) {
    delete queue[id];
  };
  // Node.js 0.8-
  if (__webpack_require__(22)(process) == 'process') {
    defer = function (id) {
      process.nextTick(ctx(run, id, 1));
    };
  // Sphere (JS game engine) Dispatch API
  } else if (Dispatch && Dispatch.now) {
    defer = function (id) {
      Dispatch.now(ctx(run, id, 1));
    };
  // Browsers with MessageChannel, includes WebWorkers
  } else if (MessageChannel) {
    channel = new MessageChannel();
    port = channel.port2;
    channel.port1.onmessage = listener;
    defer = ctx(port.postMessage, port, 1);
  // Browsers with postMessage, skip WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {
    defer = function (id) {
      global.postMessage(id + '', '*');
    };
    global.addEventListener('message', listener, false);
  // IE8-
  } else if (ONREADYSTATECHANGE in cel('script')) {
    defer = function (id) {
      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function () {
        html.removeChild(this);
        run.call(id);
      };
    };
  // Rest old browsers
  } else {
    defer = function (id) {
      setTimeout(ctx(run, id, 1), 0);
    };
  }
}
module.exports = {
  set: setTask,
  clear: clearTask
};


/***/ }),
/* 67 */
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return { e: false, v: exec() };
  } catch (e) {
    return { e: true, v: e };
  }
};


/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(13);
var isObject = __webpack_require__(9);
var newPromiseCapability = __webpack_require__(47);

module.exports = function (C, x) {
  anObject(C);
  if (isObject(x) && x.constructor === C) return x;
  var promiseCapability = newPromiseCapability.f(C);
  var resolve = promiseCapability.resolve;
  resolve(x);
  return promiseCapability.promise;
};


/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global = __webpack_require__(3);
var core = __webpack_require__(6);
var dP = __webpack_require__(8);
var DESCRIPTORS = __webpack_require__(10);
var SPECIES = __webpack_require__(5)('species');

module.exports = function (KEY) {
  var C = typeof core[KEY] == 'function' ? core[KEY] : global[KEY];
  if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {
    configurable: true,
    get: function () { return this; }
  });
};


/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

var ITERATOR = __webpack_require__(5)('iterator');
var SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR]();
  riter['return'] = function () { SAFE_CLOSING = true; };
  // eslint-disable-next-line no-throw-literal
  Array.from(riter, function () { throw 2; });
} catch (e) { /* empty */ }

module.exports = function (exec, skipClosing) {
  if (!skipClosing && !SAFE_CLOSING) return false;
  var safe = false;
  try {
    var arr = [7];
    var iter = arr[ITERATOR]();
    iter.next = function () { return { done: safe = true }; };
    arr[ITERATOR] = function () { return iter; };
    exec(arr);
  } catch (e) { /* empty */ }
  return safe;
};


/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

// 7.2.2 IsArray(argument)
var cof = __webpack_require__(22);
module.exports = Array.isArray || function isArray(arg) {
  return cof(arg) == 'Array';
};


/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var $keys = __webpack_require__(59);
var hiddenKeys = __webpack_require__(43).concat('length', 'prototype');

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return $keys(O, hiddenKeys);
};


/***/ }),
/* 73 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return emojiUrl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return emojiMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return emojiName; });
var emojiUrl = 'https://webim-1252463788.file.myqcloud.com/assets/emoji/';
var emojiMap = {
  '[NO]': 'emoji_0@2x.png',
  '[OK]': 'emoji_1@2x.png',
  '[下雨]': 'emoji_2@2x.png',
  '[么么哒]': 'emoji_3@2x.png',
  '[乒乓]': 'emoji_4@2x.png',
  '[便便]': 'emoji_5@2x.png',
  '[信封]': 'emoji_6@2x.png',
  '[偷笑]': 'emoji_7@2x.png',
  '[傲慢]': 'emoji_8@2x.png',
  '[再见]': 'emoji_9@2x.png',
  '[冷汗]': 'emoji_10@2x.png',
  '[凋谢]': 'emoji_11@2x.png',
  '[刀]': 'emoji_12@2x.png',
  '[删除]': 'emoji_13@2x.png',
  '[勾引]': 'emoji_14@2x.png',
  '[发呆]': 'emoji_15@2x.png',
  '[发抖]': 'emoji_16@2x.png',
  '[可怜]': 'emoji_17@2x.png',
  '[可爱]': 'emoji_18@2x.png',
  '[右哼哼]': 'emoji_19@2x.png',
  '[右太极]': 'emoji_20@2x.png',
  '[右车头]': 'emoji_21@2x.png',
  '[吐]': 'emoji_22@2x.png',
  '[吓]': 'emoji_23@2x.png',
  '[咒骂]': 'emoji_24@2x.png',
  '[咖啡]': 'emoji_25@2x.png',
  '[啤酒]': 'emoji_26@2x.png',
  '[嘘]': 'emoji_27@2x.png',
  '[回头]': 'emoji_28@2x.png',
  '[困]': 'emoji_29@2x.png',
  '[坏笑]': 'emoji_30@2x.png',
  '[多云]': 'emoji_31@2x.png',
  '[大兵]': 'emoji_32@2x.png',
  '[大哭]': 'emoji_33@2x.png',
  '[太阳]': 'emoji_34@2x.png',
  '[奋斗]': 'emoji_35@2x.png',
  '[奶瓶]': 'emoji_36@2x.png',
  '[委屈]': 'emoji_37@2x.png',
  '[害羞]': 'emoji_38@2x.png',
  '[尴尬]': 'emoji_39@2x.png',
  '[左哼哼]': 'emoji_40@2x.png',
  '[左太极]': 'emoji_41@2x.png',
  '[左车头]': 'emoji_42@2x.png',
  '[差劲]': 'emoji_43@2x.png',
  '[弱]': 'emoji_44@2x.png',
  '[强]': 'emoji_45@2x.png',
  '[彩带]': 'emoji_46@2x.png',
  '[彩球]': 'emoji_47@2x.png',
  '[得意]': 'emoji_48@2x.png',
  '[微笑]': 'emoji_49@2x.png',
  '[心碎了]': 'emoji_50@2x.png',
  '[快哭了]': 'emoji_51@2x.png',
  '[怄火]': 'emoji_52@2x.png',
  '[怒]': 'emoji_53@2x.png',
  '[惊恐]': 'emoji_54@2x.png',
  '[惊讶]': 'emoji_55@2x.png',
  '[憨笑]': 'emoji_56@2x.png',
  '[手枪]': 'emoji_57@2x.png',
  '[打哈欠]': 'emoji_58@2x.png',
  '[抓狂]': 'emoji_59@2x.png',
  '[折磨]': 'emoji_60@2x.png',
  '[抠鼻]': 'emoji_61@2x.png',
  '[抱抱]': 'emoji_62@2x.png',
  '[抱拳]': 'emoji_63@2x.png',
  '[拳头]': 'emoji_64@2x.png',
  '[挥手]': 'emoji_65@2x.png',
  '[握手]': 'emoji_66@2x.png',
  '[撇嘴]': 'emoji_67@2x.png',
  '[擦汗]': 'emoji_68@2x.png',
  '[敲打]': 'emoji_69@2x.png',
  '[晕]': 'emoji_70@2x.png',
  '[月亮]': 'emoji_71@2x.png',
  '[棒棒糖]': 'emoji_72@2x.png',
  '[汽车]': 'emoji_73@2x.png',
  '[沙发]': 'emoji_74@2x.png',
  '[流汗]': 'emoji_75@2x.png',
  '[流泪]': 'emoji_76@2x.png',
  '[激动]': 'emoji_77@2x.png',
  '[灯泡]': 'emoji_78@2x.png',
  '[炸弹]': 'emoji_79@2x.png',
  '[熊猫]': 'emoji_80@2x.png',
  '[爆筋]': 'emoji_81@2x.png',
  '[爱你]': 'emoji_82@2x.png',
  '[爱心]': 'emoji_83@2x.png',
  '[爱情]': 'emoji_84@2x.png',
  '[猪头]': 'emoji_85@2x.png',
  '[猫咪]': 'emoji_86@2x.png',
  '[献吻]': 'emoji_87@2x.png',
  '[玫瑰]': 'emoji_88@2x.png',
  '[瓢虫]': 'emoji_89@2x.png',
  '[疑问]': 'emoji_90@2x.png',
  '[白眼]': 'emoji_91@2x.png',
  '[皮球]': 'emoji_92@2x.png',
  '[睡觉]': 'emoji_93@2x.png',
  '[磕头]': 'emoji_94@2x.png',
  '[示爱]': 'emoji_95@2x.png',
  '[礼品袋]': 'emoji_96@2x.png',
  '[礼物]': 'emoji_97@2x.png',
  '[篮球]': 'emoji_98@2x.png',
  '[米饭]': 'emoji_99@2x.png',
  '[糗大了]': 'emoji_100@2x.png',
  '[红双喜]': 'emoji_101@2x.png',
  '[红灯笼]': 'emoji_102@2x.png',
  '[纸巾]': 'emoji_103@2x.png',
  '[胜利]': 'emoji_104@2x.png',
  '[色]': 'emoji_105@2x.png',
  '[药]': 'emoji_106@2x.png',
  '[菜刀]': 'emoji_107@2x.png',
  '[蛋糕]': 'emoji_108@2x.png',
  '[蜡烛]': 'emoji_109@2x.png',
  '[街舞]': 'emoji_110@2x.png',
  '[衰]': 'emoji_111@2x.png',
  '[西瓜]': 'emoji_112@2x.png',
  '[调皮]': 'emoji_113@2x.png',
  '[象棋]': 'emoji_114@2x.png',
  '[跳绳]': 'emoji_115@2x.png',
  '[跳跳]': 'emoji_116@2x.png',
  '[车厢]': 'emoji_117@2x.png',
  '[转圈]': 'emoji_118@2x.png',
  '[鄙视]': 'emoji_119@2x.png',
  '[酷]': 'emoji_120@2x.png',
  '[钞票]': 'emoji_121@2x.png',
  '[钻戒]': 'emoji_122@2x.png',
  '[闪电]': 'emoji_123@2x.png',
  '[闭嘴]': 'emoji_124@2x.png',
  '[闹钟]': 'emoji_125@2x.png',
  '[阴险]': 'emoji_126@2x.png',
  '[难过]': 'emoji_127@2x.png',
  '[雨伞]': 'emoji_128@2x.png',
  '[青蛙]': 'emoji_129@2x.png',
  '[面条]': 'emoji_130@2x.png',
  '[鞭炮]': 'emoji_131@2x.png',
  '[风车]': 'emoji_132@2x.png',
  '[飞吻]': 'emoji_133@2x.png',
  '[飞机]': 'emoji_134@2x.png',
  '[饥饿]': 'emoji_135@2x.png',
  '[香蕉]': 'emoji_136@2x.png',
  '[骷髅]': 'emoji_137@2x.png',
  '[麦克风]': 'emoji_138@2x.png',
  '[麻将]': 'emoji_139@2x.png',
  '[鼓掌]': 'emoji_140@2x.png',
  '[龇牙]': 'emoji_141@2x.png'
};
var emojiName = ['[龇牙]', '[调皮]', '[流汗]', '[偷笑]', '[再见]', '[敲打]', '[擦汗]', '[猪头]', '[玫瑰]', '[流泪]', '[大哭]', '[嘘]', '[酷]', '[抓狂]', '[委屈]', '[便便]', '[炸弹]', '[菜刀]', '[可爱]', '[色]', '[害羞]', '[得意]', '[吐]', '[微笑]', '[怒]', '[尴尬]', '[惊恐]', '[冷汗]', '[爱心]', '[示爱]', '[白眼]', '[傲慢]', '[难过]', '[惊讶]', '[疑问]', '[困]', '[么么哒]', '[憨笑]', '[爱情]', '[衰]', '[撇嘴]', '[阴险]', '[奋斗]', '[发呆]', '[右哼哼]', '[抱抱]', '[坏笑]', '[飞吻]', '[鄙视]', '[晕]', '[大兵]', '[可怜]', '[强]', '[弱]', '[握手]', '[胜利]', '[抱拳]', '[凋谢]', '[米饭]', '[蛋糕]', '[西瓜]', '[啤酒]', '[瓢虫]', '[勾引]', '[OK]', '[爱你]', '[咖啡]', '[月亮]', '[刀]', '[发抖]', '[差劲]', '[拳头]', '[心碎了]', '[太阳]', '[礼物]', '[皮球]', '[骷髅]', '[挥手]', '[闪电]', '[饥饿]', '[困]', '[咒骂]', '[折磨]', '[抠鼻]', '[鼓掌]', '[糗大了]', '[左哼哼]', '[打哈欠]', '[快哭了]', '[吓]', '[篮球]', '[乒乓]', '[NO]', '[跳跳]', '[怄火]', '[转圈]', '[磕头]', '[回头]', '[跳绳]', '[激动]', '[街舞]', '[献吻]', '[左太极]', '[右太极]', '[闭嘴]', '[猫咪]', '[红双喜]', '[鞭炮]', '[红灯笼]', '[麻将]', '[麦克风]', '[礼品袋]', '[信封]', '[象棋]', '[彩带]', '[蜡烛]', '[爆筋]', '[棒棒糖]', '[奶瓶]', '[面条]', '[香蕉]', '[飞机]', '[左车头]', '[车厢]', '[右车头]', '[多云]', '[下雨]', '[钞票]', '[熊猫]', '[灯泡]', '[风车]', '[闹钟]', '[雨伞]', '[彩球]', '[钻戒]', '[沙发]', '[纸巾]', '[手枪]', '[青蛙]'];

/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

!function(t,n){ true?module.exports=n():"function"==typeof define&&define.amd?define(n):t.dayjs=n()}(this,function(){"use strict";var t="millisecond",n="second",e="minute",r="hour",i="day",s="week",u="month",o="quarter",a="year",h=/^(\d{4})-?(\d{1,2})-?(\d{0,2})[^0-9]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?.?(\d{1,3})?$/,f=/\[([^\]]+)]|Y{2,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g,c=function(t,n,e){var r=String(t);return!r||r.length>=n?t:""+Array(n+1-r.length).join(e)+t},d={s:c,z:function(t){var n=-t.utcOffset(),e=Math.abs(n),r=Math.floor(e/60),i=e%60;return(n<=0?"+":"-")+c(r,2,"0")+":"+c(i,2,"0")},m:function(t,n){var e=12*(n.year()-t.year())+(n.month()-t.month()),r=t.clone().add(e,u),i=n-r<0,s=t.clone().add(e+(i?-1:1),u);return Number(-(e+(n-r)/(i?r-s:s-r))||0)},a:function(t){return t<0?Math.ceil(t)||0:Math.floor(t)},p:function(h){return{M:u,y:a,w:s,d:i,D:"date",h:r,m:e,s:n,ms:t,Q:o}[h]||String(h||"").toLowerCase().replace(/s$/,"")},u:function(t){return void 0===t}},$={name:"en",weekdays:"Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),months:"January_February_March_April_May_June_July_August_September_October_November_December".split("_")},l="en",m={};m[l]=$;var y=function(t){return t instanceof v},M=function(t,n,e){var r;if(!t)return l;if("string"==typeof t)m[t]&&(r=t),n&&(m[t]=n,r=t);else{var i=t.name;m[i]=t,r=i}return!e&&r&&(l=r),r||!e&&l},g=function(t,n,e){if(y(t))return t.clone();var r=n?"string"==typeof n?{format:n,pl:e}:n:{};return r.date=t,new v(r)},D=d;D.l=M,D.i=y,D.w=function(t,n){return g(t,{locale:n.$L,utc:n.$u,$offset:n.$offset})};var v=function(){function c(t){this.$L=this.$L||M(t.locale,null,!0),this.parse(t)}var d=c.prototype;return d.parse=function(t){this.$d=function(t){var n=t.date,e=t.utc;if(null===n)return new Date(NaN);if(D.u(n))return new Date;if(n instanceof Date)return new Date(n);if("string"==typeof n&&!/Z$/i.test(n)){var r=n.match(h);if(r)return e?new Date(Date.UTC(r[1],r[2]-1,r[3]||1,r[4]||0,r[5]||0,r[6]||0,r[7]||0)):new Date(r[1],r[2]-1,r[3]||1,r[4]||0,r[5]||0,r[6]||0,r[7]||0)}return new Date(n)}(t),this.init()},d.init=function(){var t=this.$d;this.$y=t.getFullYear(),this.$M=t.getMonth(),this.$D=t.getDate(),this.$W=t.getDay(),this.$H=t.getHours(),this.$m=t.getMinutes(),this.$s=t.getSeconds(),this.$ms=t.getMilliseconds()},d.$utils=function(){return D},d.isValid=function(){return!("Invalid Date"===this.$d.toString())},d.isSame=function(t,n){var e=g(t);return this.startOf(n)<=e&&e<=this.endOf(n)},d.isAfter=function(t,n){return g(t)<this.startOf(n)},d.isBefore=function(t,n){return this.endOf(n)<g(t)},d.$g=function(t,n,e){return D.u(t)?this[n]:this.set(e,t)},d.year=function(t){return this.$g(t,"$y",a)},d.month=function(t){return this.$g(t,"$M",u)},d.day=function(t){return this.$g(t,"$W",i)},d.date=function(t){return this.$g(t,"$D","date")},d.hour=function(t){return this.$g(t,"$H",r)},d.minute=function(t){return this.$g(t,"$m",e)},d.second=function(t){return this.$g(t,"$s",n)},d.millisecond=function(n){return this.$g(n,"$ms",t)},d.unix=function(){return Math.floor(this.valueOf()/1e3)},d.valueOf=function(){return this.$d.getTime()},d.startOf=function(t,o){var h=this,f=!!D.u(o)||o,c=D.p(t),d=function(t,n){var e=D.w(h.$u?Date.UTC(h.$y,n,t):new Date(h.$y,n,t),h);return f?e:e.endOf(i)},$=function(t,n){return D.w(h.toDate()[t].apply(h.toDate(),(f?[0,0,0,0]:[23,59,59,999]).slice(n)),h)},l=this.$W,m=this.$M,y=this.$D,M="set"+(this.$u?"UTC":"");switch(c){case a:return f?d(1,0):d(31,11);case u:return f?d(1,m):d(0,m+1);case s:var g=this.$locale().weekStart||0,v=(l<g?l+7:l)-g;return d(f?y-v:y+(6-v),m);case i:case"date":return $(M+"Hours",0);case r:return $(M+"Minutes",1);case e:return $(M+"Seconds",2);case n:return $(M+"Milliseconds",3);default:return this.clone()}},d.endOf=function(t){return this.startOf(t,!1)},d.$set=function(s,o){var h,f=D.p(s),c="set"+(this.$u?"UTC":""),d=(h={},h[i]=c+"Date",h.date=c+"Date",h[u]=c+"Month",h[a]=c+"FullYear",h[r]=c+"Hours",h[e]=c+"Minutes",h[n]=c+"Seconds",h[t]=c+"Milliseconds",h)[f],$=f===i?this.$D+(o-this.$W):o;if(f===u||f===a){var l=this.clone().set("date",1);l.$d[d]($),l.init(),this.$d=l.set("date",Math.min(this.$D,l.daysInMonth())).toDate()}else d&&this.$d[d]($);return this.init(),this},d.set=function(t,n){return this.clone().$set(t,n)},d.get=function(t){return this[D.p(t)]()},d.add=function(t,o){var h,f=this;t=Number(t);var c=D.p(o),d=function(n){var e=g(f);return D.w(e.date(e.date()+Math.round(n*t)),f)};if(c===u)return this.set(u,this.$M+t);if(c===a)return this.set(a,this.$y+t);if(c===i)return d(1);if(c===s)return d(7);var $=(h={},h[e]=6e4,h[r]=36e5,h[n]=1e3,h)[c]||1,l=this.$d.getTime()+t*$;return D.w(l,this)},d.subtract=function(t,n){return this.add(-1*t,n)},d.format=function(t){var n=this;if(!this.isValid())return"Invalid Date";var e=t||"YYYY-MM-DDTHH:mm:ssZ",r=D.z(this),i=this.$locale(),s=this.$H,u=this.$m,o=this.$M,a=i.weekdays,h=i.months,c=function(t,r,i,s){return t&&(t[r]||t(n,e))||i[r].substr(0,s)},d=function(t){return D.s(s%12||12,t,"0")},$=i.meridiem||function(t,n,e){var r=t<12?"AM":"PM";return e?r.toLowerCase():r},l={YY:String(this.$y).slice(-2),YYYY:this.$y,M:o+1,MM:D.s(o+1,2,"0"),MMM:c(i.monthsShort,o,h,3),MMMM:h[o]||h(this,e),D:this.$D,DD:D.s(this.$D,2,"0"),d:String(this.$W),dd:c(i.weekdaysMin,this.$W,a,2),ddd:c(i.weekdaysShort,this.$W,a,3),dddd:a[this.$W],H:String(s),HH:D.s(s,2,"0"),h:d(1),hh:d(2),a:$(s,u,!0),A:$(s,u,!1),m:String(u),mm:D.s(u,2,"0"),s:String(this.$s),ss:D.s(this.$s,2,"0"),SSS:D.s(this.$ms,3,"0"),Z:r};return e.replace(f,function(t,n){return n||l[t]||r.replace(":","")})},d.utcOffset=function(){return 15*-Math.round(this.$d.getTimezoneOffset()/15)},d.diff=function(t,h,f){var c,d=D.p(h),$=g(t),l=6e4*($.utcOffset()-this.utcOffset()),m=this-$,y=D.m(this,$);return y=(c={},c[a]=y/12,c[u]=y,c[o]=y/3,c[s]=(m-l)/6048e5,c[i]=(m-l)/864e5,c[r]=m/36e5,c[e]=m/6e4,c[n]=m/1e3,c)[d]||m,f?y:D.a(y)},d.daysInMonth=function(){return this.endOf(u).$D},d.$locale=function(){return m[this.$L]},d.locale=function(t,n){if(!t)return this.$L;var e=this.clone(),r=M(t,n,!0);return r&&(e.$L=r),e},d.clone=function(){return D.w(this.$d,this)},d.toDate=function(){return new Date(this.valueOf())},d.toJSON=function(){return this.isValid()?this.toISOString():null},d.toISOString=function(){return this.$d.toISOString()},d.toString=function(){return this.$d.toUTCString()},c}();return g.prototype=v.prototype,g.extend=function(t,n){return t(n,v,g),g},g.locale=M,g.isDayjs=y,g.unix=function(t){return g(1e3*t)},g.en=m[l],g.Ls=m,g});


/***/ }),
/* 75 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/*eslint-disable*/
var TYPES = {
  // /**
  //  * 消息类型
  //  * @property {String} TEXT 文本
  //  * @property {String} IMAGE 图片
  //  * @property {String} SOUND 音频
  //  * @property {String} FILE 文件
  //  * @property {String} CUSTOM 自定义消息
  //  * @property {String} GROUP_TIP 群提示消息
  //  * @property {String} GROUP_SYSTEM_NOTICE 群系统消息
  //  * @memberOf module:TYPES
  //  */
  // MESSAGE_TYPES: MESSAGE.ELEMENT_TYPES,
  /**
   * @description 消息类型：文本消息
   * @memberof module:TYPES
   */
  MSG_TEXT: 'TIMTextElem',

  /**
   * @description 消息类型：图片消息
   * @memberof module:TYPES
   */
  MSG_IMAGE: 'TIMImageElem',

  /**
   * @description 消息类型：音频消息
   * @memberof module:TYPES
   */
  MSG_SOUND: 'TIMSoundElem',

  /**
   * @description 消息类型：文件消息
   * @memberof module:TYPES
   */
  MSG_FILE: 'TIMFileElem',

  /**
   * @private
   * @description 消息类型：表情消息
   * @memberof module:TYPES
   */
  MSG_FACE: 'TIMFaceElem',

  /**
   * @private
   * @description 消息类型：视频消息
   * @memberof module:TYPES
   */
  MSG_VIDEO: 'TIMVideoElem',

  /**
   * @private
   * @description 消息类型：位置消息
   * @memberof module:TYPES
   */
  MSG_GEO: 'TIMLocationElem',

  /**
   * @description 消息类型：群提示消息
   * @memberof module:TYPES
   */
  MSG_GRP_TIP: 'TIMGroupTipElem',

  /**
   * @description 消息类型：群系统通知消息
   * @memberof module:TYPES
   */
  MSG_GRP_SYS_NOTICE: 'TIMGroupSystemNoticeElem',

  /**
   * @description 消息类型：自定义消息
   * @memberof module:TYPES
   */
  MSG_CUSTOM: 'TIMCustomElem',

  // /**
  //  * 会话类型
  //  * @property {String} C2C C2C 会话类型
  //  * @property {String} GROUP 群组会话类型
  //  * @property {String} SYSTEM 系统会话类型
  //  * @memberOf module:TYPES
  //  */
  // // CONVERSATION_TYPES,
  /**
   * @description 会话类型：C2C(Client to Client, 端到端) 会话
   * @memberof module:TYPES
   */
  CONV_C2C: 'C2C',
  /**
   * @description 会话类型：GROUP(群组) 会话
   * @memberof module:TYPES
   */
  CONV_GROUP: 'GROUP',
  /**
   * @description 会话类型：SYSTEM(系统) 会话
   * @memberof module:TYPES
   */
  CONV_SYSTEM: '@TIM#SYSTEM',

  /**
   * 群组类型
   * @property {String} PRIVATE 私有群
   * @property {String} PUBLIC 公开群
   * @property {String} CHATROOM 聊天室
   * @property {String} AVCHATROOM 音视频聊天室
   * @memberOf module:TYPES
   */
  // GROUP_TYPES,
  /**
   * @description 群组类型：私有群
   * @memberof module:TYPES
   */
  GRP_PRIVATE: 'Private',

  /**
   * @description 群组类型：公开群
   * @memberof module:TYPES
   */
  GRP_PUBLIC: 'Public',

  /**
   * @description 群组类型：聊天室
   * @memberof module:TYPES
   */
  GRP_CHATROOM: 'ChatRoom',

  /**
   * @description 群组类型：音视频聊天室
   * @memberof module:TYPES
   */
  GRP_AVCHATROOM: 'AVChatRoom',

  /**
   * 群成员身份类型常量及含义
   * @property {String} OWNER 群主
   * @property {String} ADMIN 管理员
   * @property {String} MEMBER 普通群成员
   * @memberOf module:TYPES
   */
  // GROUP_MEMBER_ROLE_TYPES,

  /**
   * @description 群成员角色：群主
   * @memberof module:TYPES
   */
  GRP_MBR_ROLE_OWNER: 'Owner',

  /**
   * @description 群成员角色：管理员
   * @memberof module:TYPES
   */
  GRP_MBR_ROLE_ADMIN: 'Admin',

  /**
   * @description 群成员角色：普通群成员
   * @memberof module:TYPES
   */
  GRP_MBR_ROLE_MEMBER: 'Member',

  /**
   * 群提示消息类型常量含义
   * @property {Number} MEMBER_JOIN 有群成员加群
   * @property {Number} MEMBER_QUIT 有群成员退群
   * @property {Number} MEMBER_KICKED_OUT 有群成员被踢出群
   * @property {Number} MEMBER_SET_ADMIN 有群成员被设为管理员
   * @property {Number} MEMBER_CANCELED_ADMIN 有群成员被撤销管理员
   * @property {Number} GROUP_INFO_MODIFIED 群组资料变更
   * @property {Number} MEMBER_INFO_MODIFIED 群成员资料变更
   * @memberOf module:TYPES
   */
  // GROUP_TIP_TYPES,

  /**
   * @description 群提示：有成员加群
   * @memberof module:TYPES
   */
  GRP_TIP_MBR_JOIN: 1,

  /**
   * @description 群提示：有群成员退群
   * @memberof module:TYPES
   */
  GRP_TIP_MBR_QUIT: 2,

  /**
   * @description 群提示：有群成员被踢出群
   * @memberof module:TYPES
   */
  GRP_TIP_MBR_KICKED_OUT: 3,

  /**
   * @description 群提示：有群成员被设为管理员
   * @memberof module:TYPES
   */
  GRP_TIP_MBR_SET_ADMIN: 4, //被设置为管理员

  /**
   * @description 群提示：有群成员被撤销管理员
   * @memberof module:TYPES
   */
  GRP_TIP_MBR_CANCELED_ADMIN: 5, //被取消管理员

  /**
   * @description 群提示：群组资料变更
   * @memberof module:TYPES
   */
  GRP_TIP_GRP_PROFILE_UPDATED: 6, //修改群资料，转让群组为该类型，msgBody.msgGroupNewInfo.ownerAccount表示新群主的ID

  /**
   * @description 群提示：群成员资料变更
   * @memberof module:TYPES
   */
  GRP_TIP_MBR_PROFILE_UPDATED: 7, //修改群成员信息

  /**
   * 群系统通知类型常量及含义
   * @property {Number} JOIN_GROUP_REQUEST 有用户申请加群。群管理员/群主接收
   * @property {Number} JOIN_GROUP_ACCEPT 申请加群被同意。申请加群的用户接收
   * @property {Number} JOIN_GROUP_REFUSE 申请加群被拒绝。申请加群的用户接收
   * @property {Number} KICKED_OUT 被踢出群组。被踢出的用户接收
   * @property {Number} GROUP_DISMISSED 群组被解散。全体群成员接收
   * @property {Number} GROUP_CREATED 创建群组。创建者接收
   * @property {Number} QUIT 退群。退群者接收
   * @property {Number} SET_ADMIN 设置管理员。被设置方接收
   * @property {Number} CANCELED_ADMIN 取消管理员。被取消方接收
   * @property {Number} CUSTOM 自定义系统通知。全员接收
   * @memberOf module:TYPES
   */
  // GROUP_SYSTEM_NOTICE_TYPES,
  /**
   * @private
   * @description 有用户申请加群。群管理员/群主接收
   * @memberof module:TYPES
   */
  // GROUP_SYSTEM_NOTICE_JOIN_GROUP_REQUEST: 1, //申请加群请求（只有管理员会收到）

  /**
   * @private
   * @description 申请加群被同意。申请加群的用户接收
   * @memberof module:TYPES
   */
  // GROUP_SYSTEM_NOTICE_JOIN_GROUP_ACCEPT: 2, //申请加群被同意（只有申请人能够收到）

  /**
   * @private
   * @description 申请加群被拒绝。申请加群的用户接收
   * @memberof module:TYPES
   */
  // GROUP_SYSTEM_NOTICE_JOIN_GROUP_REFUSE: 3, //申请加群被拒绝（只有申请人能够收到）

  /**
   * @private
   * @description 被踢出群组。被踢出的用户接收
   * @memberof module:TYPES
   */
  // GROUP_SYSTEM_NOTICE_KICKED_OUT: 4, //被管理员踢出群(只有被踢者接收到)

  /**
   * @private
   * @description 群组被解散。全体群成员接收
   * @memberof module:TYPES
   */
  // GROUP_SYSTEM_NOTICE_GROUP_DISMISSED: 5, //群被解散(全员接收)

  /**
   * @private
   * @description 创建群组。创建者接收
   * @memberof module:TYPES
   */
  // GROUP_SYSTEM_NOTICE_GROUP_CREATED: 6, //创建群(创建者接收, 不展示)

  /**
   * @private
   * @description 邀请加群(被邀请者接收)
   * @memberof module:TYPES
   */
  // GROUP_SYSTEM_NOTICE_INVITED_JOIN_GROUP_REQUEST: 7, //邀请加群(被邀请者接收)。

  /**
   * @private
   * @description 退群。退群者接收
   * @memberof module:TYPES
   */
  // GROUP_SYSTEM_NOTICE_QUIT: 8, //主动退群(主动退出者接收, 不展示)

  /**
   * @private
   * @description 设置管理员。被设置方接收
   * @memberof module:TYPES
   */
  // GROUP_SYSTEM_NOTICE_SET_ADMIN: 9, //设置管理员(被设置者接收)

  /**
   * @private
   * @description 取消管理员。被取消方接收
   * @memberof module:TYPES
   */
  // GROUP_SYSTEM_NOTICE_CANCELED_ADMIN: 10, //取消管理员(被取消者接收)

  /**
   * @private
   * @description 群已被回收(全员接收, 不展示)
   * @memberof module:TYPES
   */
  // GROUP_SYSTEM_NOTICE_REVOKE: 11, //群已被回收(全员接收, 不展示)

  /**
   * @private
   * @description 邀请加群(被邀请者需同意)
   * @memberof module:TYPES
   */
  // GROUP_SYSTEM_NOTICE_INVITED_JOIN_GROUP_REQUEST_AGREE: 12, //邀请加群(被邀请者需同意)

  /**
   * @private
   * @description 群消息已读同步
   * @memberof module:TYPES
   */
  // GROUP_SYSTEM_NOTICE_READED: 15, //群消息已读同步

  /**
   * @private
   * @description 用户自定义通知(默认全员接收)
   * @memberof module:TYPES
   */
  // GROUP_SYSTEM_NOTICE_CUSTOM: 255, //用户自定义通知(默认全员接收)

  /**
   * 群消息提示类型常量及含义
   * @property {String} ACCEPT_AND_NOTIFY 通知并提示
   * @property {String} ACCEPT_NOT_NOTIFY 通知但不提示
   * @property {String} DISCARD 拒收消息
   * @memberOf module:TYPES
   */
  // MESSAGE_REMIND_TYPES,
  /**
   * @description 群消息提示类型：SDK 接收消息并通知接入侧，接入侧做提示
   * @memberof module:TYPES
   */
  MSG_REMIND_ACPT_AND_NOTE: 'AcceptAndNotify',

  /**
   * @description 群消息提示类型：SDK 接收消息并通知接入侧，接入侧不做提示
   * @memberof module:TYPES
   */
  MSG_REMIND_ACPT_NOT_NOTE: 'AcceptNotNotify',

  /**
   * @description 群消息提示类型：SDK 拒收消息
   * @memberof module:TYPES
   */
  MSG_REMIND_DISCARD: 'Discard',

  /**
   * 性别类型常量及含义
   * @property {String} MALE 男
   * @property {String} FEMALE 女
   * @property {String} UNKNOWN 未设置性别
   * @memberOf module:TYPES
   */
  // GENDER_TYPES,
  /**
   * @description 性别：未设置性别
   * @memberOf module:TYPES
   */
  GENDER_UNKNOWN: 'Gender_Type_Unknown',

  /**
   * @description 性别：女性
   * @memberOf module:TYPES
   */
  GENDER_FEMALE: 'Gender_Type_Female',

  /**
   * @description 性别：男性
   * @memberOf module:TYPES
   */
  GENDER_MALE: 'Gender_Type_Male',

  /**
   * 被踢类型常量及含义
   * @property {String} MUTIPLE_ACCOUNT 多账号登录被踢
   * @memberOf module:TYPES
   */
  // KICKED_OUT_TYPES,

  /**
   * @description 被踢类型：多账号登录被踢
   * @memberOf module:TYPES
   */
  KICKED_OUT_MULT_ACCOUNT: 'mutipleAccount',

  /**
   * @private
   */
  KICKED_OUT_MULT_DEVICE: 'mutipleDevice',

  /**
   * @description 当被人加好友时：允许任何人添加自己为好友
   * @memberOf module:TYPES
   */
  ALLOW_TYPE_ALLOW_ANY: 'AllowType_Type_AllowAny',

  /**
   * @description 当被人加好友时：需要经过自己确认才能添加自己为好友
   * @memberOf module:TYPES
   */
  ALLOW_TYPE_NEED_CONFIRM: 'AllowType_Type_NeedConfirm',

  /**
   * @description 当被人加好友时：不允许任何人添加自己为好友
   * @memberOf module:TYPES
   */
  ALLOW_TYPE_DENY_ANY: 'AllowType_Type_DenyAny',

  /**
   * @description 管理员禁止加好友标识：默认值，允许加好友
   * @memberOf module:TYPES
   */
  FORBID_TYPE_NONE: 'AdminForbid_Type_None',

  /**
   * @description 管理员禁止加好友标识：禁止该用户发起加好友请求
   * @memberOf module:TYPES
   */
  FORBID_TYPE_SEND_OUT: 'AdminForbid_Type_SendOut',

  /**
   * @description 加群选项：自由加入
   * @memberOf module:TYPES
   */
  JOIN_OPTIONS_FREE_ACCESS: 'FreeAccess',

  /**
   * @description 加群选项：需要管理员同意
   * @memberOf module:TYPES
   */
  JOIN_OPTIONS_NEED_PERMISSION: 'NeedPermission',

  /**
   * @description 加群选项：不允许加群
   * @memberOf module:TYPES
   */
  JOIN_OPTIONS_DISABLE_APPLY: 'DisableApply',

  /**
   * @description 加群申请状态：加群成功
   * @memberOf module:TYPES
   */
  JOIN_STATUS_SUCCESS: 'JoinedSuccess',

  /**
   * @description 加群申请状态：等待管理员同意
   * @memberOf module:TYPES
   */
  JOIN_STATUS_WAIT_APPROVAL: 'WaitAdminApproval'

};

/* harmony default export */ __webpack_exports__["a"] = (TYPES);

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(127), __esModule: true };

/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(9);
module.exports = function (it, TYPE) {
  if (!isObject(it) || it._t !== TYPE) throw TypeError('Incompatible receiver, ' + TYPE + ' required!');
  return it;
};


/***/ }),
/* 78 */,
/* 79 */,
/* 80 */,
/* 81 */,
/* 82 */,
/* 83 */,
/* 84 */,
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(33);
__webpack_require__(27);
__webpack_require__(44);
__webpack_require__(94);
__webpack_require__(98);
__webpack_require__(99);
module.exports = __webpack_require__(6).Promise;


/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(34);
var defined = __webpack_require__(35);
// true  -> String#at
// false -> String#codePointAt
module.exports = function (TO_STRING) {
  return function (that, pos) {
    var s = String(defined(that));
    var i = toInteger(pos);
    var l = s.length;
    var a, b;
    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};


/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var create = __webpack_require__(39);
var descriptor = __webpack_require__(20);
var setToStringTag = __webpack_require__(23);
var IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
__webpack_require__(12)(IteratorPrototype, __webpack_require__(5)('iterator'), function () { return this; });

module.exports = function (Constructor, NAME, next) {
  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
  setToStringTag(Constructor, NAME + ' Iterator');
};


/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(8);
var anObject = __webpack_require__(13);
var getKeys = __webpack_require__(28);

module.exports = __webpack_require__(10) ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = getKeys(Properties);
  var length = keys.length;
  var i = 0;
  var P;
  while (length > i) dP.f(O, P = keys[i++], Properties[P]);
  return O;
};


/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

// false -> Array#indexOf
// true  -> Array#includes
var toIObject = __webpack_require__(16);
var toLength = __webpack_require__(29);
var toAbsoluteIndex = __webpack_require__(90);
module.exports = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
      if (O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};


/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(34);
var max = Math.max;
var min = Math.min;
module.exports = function (index, length) {
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};


/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has = __webpack_require__(14);
var toObject = __webpack_require__(24);
var IE_PROTO = __webpack_require__(41)('IE_PROTO');
var ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto : null;
};


/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var addToUnscopables = __webpack_require__(93);
var step = __webpack_require__(61);
var Iterators = __webpack_require__(21);
var toIObject = __webpack_require__(16);

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = __webpack_require__(36)(Array, 'Array', function (iterated, kind) {
  this._t = toIObject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var kind = this._k;
  var index = this._i++;
  if (!O || index >= O.length) {
    this._t = undefined;
    return step(1);
  }
  if (kind == 'keys') return step(0, index);
  if (kind == 'values') return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');


/***/ }),
/* 93 */
/***/ (function(module, exports) {

module.exports = function () { /* empty */ };


/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var LIBRARY = __webpack_require__(18);
var global = __webpack_require__(3);
var ctx = __webpack_require__(11);
var classof = __webpack_require__(45);
var $export = __webpack_require__(7);
var isObject = __webpack_require__(9);
var aFunction = __webpack_require__(19);
var anInstance = __webpack_require__(46);
var forOf = __webpack_require__(25);
var speciesConstructor = __webpack_require__(65);
var task = __webpack_require__(66).set;
var microtask = __webpack_require__(96)();
var newPromiseCapabilityModule = __webpack_require__(47);
var perform = __webpack_require__(67);
var userAgent = __webpack_require__(97);
var promiseResolve = __webpack_require__(68);
var PROMISE = 'Promise';
var TypeError = global.TypeError;
var process = global.process;
var versions = process && process.versions;
var v8 = versions && versions.v8 || '';
var $Promise = global[PROMISE];
var isNode = classof(process) == 'process';
var empty = function () { /* empty */ };
var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;
var newPromiseCapability = newGenericPromiseCapability = newPromiseCapabilityModule.f;

var USE_NATIVE = !!function () {
  try {
    // correct subclassing with @@species support
    var promise = $Promise.resolve(1);
    var FakePromise = (promise.constructor = {})[__webpack_require__(5)('species')] = function (exec) {
      exec(empty, empty);
    };
    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
    return (isNode || typeof PromiseRejectionEvent == 'function')
      && promise.then(empty) instanceof FakePromise
      // v8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
      // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
      // we can't detect it synchronously, so just check versions
      && v8.indexOf('6.6') !== 0
      && userAgent.indexOf('Chrome/66') === -1;
  } catch (e) { /* empty */ }
}();

// helpers
var isThenable = function (it) {
  var then;
  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
};
var notify = function (promise, isReject) {
  if (promise._n) return;
  promise._n = true;
  var chain = promise._c;
  microtask(function () {
    var value = promise._v;
    var ok = promise._s == 1;
    var i = 0;
    var run = function (reaction) {
      var handler = ok ? reaction.ok : reaction.fail;
      var resolve = reaction.resolve;
      var reject = reaction.reject;
      var domain = reaction.domain;
      var result, then, exited;
      try {
        if (handler) {
          if (!ok) {
            if (promise._h == 2) onHandleUnhandled(promise);
            promise._h = 1;
          }
          if (handler === true) result = value;
          else {
            if (domain) domain.enter();
            result = handler(value); // may throw
            if (domain) {
              domain.exit();
              exited = true;
            }
          }
          if (result === reaction.promise) {
            reject(TypeError('Promise-chain cycle'));
          } else if (then = isThenable(result)) {
            then.call(result, resolve, reject);
          } else resolve(result);
        } else reject(value);
      } catch (e) {
        if (domain && !exited) domain.exit();
        reject(e);
      }
    };
    while (chain.length > i) run(chain[i++]); // variable length - can't use forEach
    promise._c = [];
    promise._n = false;
    if (isReject && !promise._h) onUnhandled(promise);
  });
};
var onUnhandled = function (promise) {
  task.call(global, function () {
    var value = promise._v;
    var unhandled = isUnhandled(promise);
    var result, handler, console;
    if (unhandled) {
      result = perform(function () {
        if (isNode) {
          process.emit('unhandledRejection', value, promise);
        } else if (handler = global.onunhandledrejection) {
          handler({ promise: promise, reason: value });
        } else if ((console = global.console) && console.error) {
          console.error('Unhandled promise rejection', value);
        }
      });
      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
      promise._h = isNode || isUnhandled(promise) ? 2 : 1;
    } promise._a = undefined;
    if (unhandled && result.e) throw result.v;
  });
};
var isUnhandled = function (promise) {
  return promise._h !== 1 && (promise._a || promise._c).length === 0;
};
var onHandleUnhandled = function (promise) {
  task.call(global, function () {
    var handler;
    if (isNode) {
      process.emit('rejectionHandled', promise);
    } else if (handler = global.onrejectionhandled) {
      handler({ promise: promise, reason: promise._v });
    }
  });
};
var $reject = function (value) {
  var promise = this;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  promise._v = value;
  promise._s = 2;
  if (!promise._a) promise._a = promise._c.slice();
  notify(promise, true);
};
var $resolve = function (value) {
  var promise = this;
  var then;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  try {
    if (promise === value) throw TypeError("Promise can't be resolved itself");
    if (then = isThenable(value)) {
      microtask(function () {
        var wrapper = { _w: promise, _d: false }; // wrap
        try {
          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
        } catch (e) {
          $reject.call(wrapper, e);
        }
      });
    } else {
      promise._v = value;
      promise._s = 1;
      notify(promise, false);
    }
  } catch (e) {
    $reject.call({ _w: promise, _d: false }, e); // wrap
  }
};

// constructor polyfill
if (!USE_NATIVE) {
  // 25.4.3.1 Promise(executor)
  $Promise = function Promise(executor) {
    anInstance(this, $Promise, PROMISE, '_h');
    aFunction(executor);
    Internal.call(this);
    try {
      executor(ctx($resolve, this, 1), ctx($reject, this, 1));
    } catch (err) {
      $reject.call(this, err);
    }
  };
  // eslint-disable-next-line no-unused-vars
  Internal = function Promise(executor) {
    this._c = [];             // <- awaiting reactions
    this._a = undefined;      // <- checked in isUnhandled reactions
    this._s = 0;              // <- state
    this._d = false;          // <- done
    this._v = undefined;      // <- value
    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
    this._n = false;          // <- notify
  };
  Internal.prototype = __webpack_require__(48)($Promise.prototype, {
    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
    then: function then(onFulfilled, onRejected) {
      var reaction = newPromiseCapability(speciesConstructor(this, $Promise));
      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
      reaction.fail = typeof onRejected == 'function' && onRejected;
      reaction.domain = isNode ? process.domain : undefined;
      this._c.push(reaction);
      if (this._a) this._a.push(reaction);
      if (this._s) notify(this, false);
      return reaction.promise;
    },
    // 25.4.5.1 Promise.prototype.catch(onRejected)
    'catch': function (onRejected) {
      return this.then(undefined, onRejected);
    }
  });
  OwnPromiseCapability = function () {
    var promise = new Internal();
    this.promise = promise;
    this.resolve = ctx($resolve, promise, 1);
    this.reject = ctx($reject, promise, 1);
  };
  newPromiseCapabilityModule.f = newPromiseCapability = function (C) {
    return C === $Promise || C === Wrapper
      ? new OwnPromiseCapability(C)
      : newGenericPromiseCapability(C);
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Promise: $Promise });
__webpack_require__(23)($Promise, PROMISE);
__webpack_require__(69)(PROMISE);
Wrapper = __webpack_require__(6)[PROMISE];

// statics
$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
  // 25.4.4.5 Promise.reject(r)
  reject: function reject(r) {
    var capability = newPromiseCapability(this);
    var $$reject = capability.reject;
    $$reject(r);
    return capability.promise;
  }
});
$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
  // 25.4.4.6 Promise.resolve(x)
  resolve: function resolve(x) {
    return promiseResolve(LIBRARY && this === Wrapper ? $Promise : this, x);
  }
});
$export($export.S + $export.F * !(USE_NATIVE && __webpack_require__(70)(function (iter) {
  $Promise.all(iter)['catch'](empty);
})), PROMISE, {
  // 25.4.4.1 Promise.all(iterable)
  all: function all(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = perform(function () {
      var values = [];
      var index = 0;
      var remaining = 1;
      forOf(iterable, false, function (promise) {
        var $index = index++;
        var alreadyCalled = false;
        values.push(undefined);
        remaining++;
        C.resolve(promise).then(function (value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[$index] = value;
          --remaining || resolve(values);
        }, reject);
      });
      --remaining || resolve(values);
    });
    if (result.e) reject(result.v);
    return capability.promise;
  },
  // 25.4.4.4 Promise.race(iterable)
  race: function race(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var reject = capability.reject;
    var result = perform(function () {
      forOf(iterable, false, function (promise) {
        C.resolve(promise).then(capability.resolve, reject);
      });
    });
    if (result.e) reject(result.v);
    return capability.promise;
  }
});


/***/ }),
/* 95 */
/***/ (function(module, exports) {

// fast apply, http://jsperf.lnkit.com/fast-apply/5
module.exports = function (fn, args, that) {
  var un = that === undefined;
  switch (args.length) {
    case 0: return un ? fn()
                      : fn.call(that);
    case 1: return un ? fn(args[0])
                      : fn.call(that, args[0]);
    case 2: return un ? fn(args[0], args[1])
                      : fn.call(that, args[0], args[1]);
    case 3: return un ? fn(args[0], args[1], args[2])
                      : fn.call(that, args[0], args[1], args[2]);
    case 4: return un ? fn(args[0], args[1], args[2], args[3])
                      : fn.call(that, args[0], args[1], args[2], args[3]);
  } return fn.apply(that, args);
};


/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(3);
var macrotask = __webpack_require__(66).set;
var Observer = global.MutationObserver || global.WebKitMutationObserver;
var process = global.process;
var Promise = global.Promise;
var isNode = __webpack_require__(22)(process) == 'process';

module.exports = function () {
  var head, last, notify;

  var flush = function () {
    var parent, fn;
    if (isNode && (parent = process.domain)) parent.exit();
    while (head) {
      fn = head.fn;
      head = head.next;
      try {
        fn();
      } catch (e) {
        if (head) notify();
        else last = undefined;
        throw e;
      }
    } last = undefined;
    if (parent) parent.enter();
  };

  // Node.js
  if (isNode) {
    notify = function () {
      process.nextTick(flush);
    };
  // browsers with MutationObserver, except iOS Safari - https://github.com/zloirock/core-js/issues/339
  } else if (Observer && !(global.navigator && global.navigator.standalone)) {
    var toggle = true;
    var node = document.createTextNode('');
    new Observer(flush).observe(node, { characterData: true }); // eslint-disable-line no-new
    notify = function () {
      node.data = toggle = !toggle;
    };
  // environments with maybe non-completely correct, but existent Promise
  } else if (Promise && Promise.resolve) {
    // Promise.resolve without an argument throws an error in LG WebOS 2
    var promise = Promise.resolve(undefined);
    notify = function () {
      promise.then(flush);
    };
  // for other environments - macrotask based on:
  // - setImmediate
  // - MessageChannel
  // - window.postMessag
  // - onreadystatechange
  // - setTimeout
  } else {
    notify = function () {
      // strange IE + webpack dev server bug - use .call(global)
      macrotask.call(global, flush);
    };
  }

  return function (fn) {
    var task = { fn: fn, next: undefined };
    if (last) last.next = task;
    if (!head) {
      head = task;
      notify();
    } last = task;
  };
};


/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(3);
var navigator = global.navigator;

module.exports = navigator && navigator.userAgent || '';


/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// https://github.com/tc39/proposal-promise-finally

var $export = __webpack_require__(7);
var core = __webpack_require__(6);
var global = __webpack_require__(3);
var speciesConstructor = __webpack_require__(65);
var promiseResolve = __webpack_require__(68);

$export($export.P + $export.R, 'Promise', { 'finally': function (onFinally) {
  var C = speciesConstructor(this, core.Promise || global.Promise);
  var isFunction = typeof onFinally == 'function';
  return this.then(
    isFunction ? function (x) {
      return promiseResolve(C, onFinally()).then(function () { return x; });
    } : onFinally,
    isFunction ? function (e) {
      return promiseResolve(C, onFinally()).then(function () { throw e; });
    } : onFinally
  );
} });


/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://github.com/tc39/proposal-promise-try
var $export = __webpack_require__(7);
var newPromiseCapability = __webpack_require__(47);
var perform = __webpack_require__(67);

$export($export.S, 'Promise', { 'try': function (callbackfn) {
  var promiseCapability = newPromiseCapability.f(this);
  var result = perform(callbackfn);
  (result.e ? promiseCapability.reject : promiseCapability.resolve)(result.v);
  return promiseCapability.promise;
} });


/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(101), __esModule: true };

/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(27);
__webpack_require__(102);
module.exports = __webpack_require__(6).Array.from;


/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ctx = __webpack_require__(11);
var $export = __webpack_require__(7);
var toObject = __webpack_require__(24);
var call = __webpack_require__(62);
var isArrayIter = __webpack_require__(63);
var toLength = __webpack_require__(29);
var createProperty = __webpack_require__(103);
var getIterFn = __webpack_require__(64);

$export($export.S + $export.F * !__webpack_require__(70)(function (iter) { Array.from(iter); }), 'Array', {
  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
  from: function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
    var O = toObject(arrayLike);
    var C = typeof this == 'function' ? this : Array;
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var index = 0;
    var iterFn = getIterFn(O);
    var length, result, step, iterator;
    if (mapping) mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
    // if object isn't iterable or it's array with default iterator - use simple case
    if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {
      for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
      }
    } else {
      length = toLength(O.length);
      for (result = new C(length); length > index; index++) {
        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
      }
    }
    result.length = index;
    return result;
  }
});


/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $defineProperty = __webpack_require__(8);
var createDesc = __webpack_require__(20);

module.exports = function (object, index, value) {
  if (index in object) $defineProperty.f(object, index, createDesc(0, value));
  else object[index] = value;
};


/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _iterator = __webpack_require__(105);

var _iterator2 = _interopRequireDefault(_iterator);

var _symbol = __webpack_require__(107);

var _symbol2 = _interopRequireDefault(_symbol);

var _typeof = typeof _symbol2.default === "function" && typeof _iterator2.default === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj; };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = typeof _symbol2.default === "function" && _typeof(_iterator2.default) === "symbol" ? function (obj) {
  return typeof obj === "undefined" ? "undefined" : _typeof(obj);
} : function (obj) {
  return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof(obj);
};

/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(106), __esModule: true };

/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(27);
__webpack_require__(44);
module.exports = __webpack_require__(49).f('iterator');


/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(108), __esModule: true };

/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(109);
__webpack_require__(33);
__webpack_require__(113);
__webpack_require__(114);
module.exports = __webpack_require__(6).Symbol;


/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ECMAScript 6 symbols shim
var global = __webpack_require__(3);
var has = __webpack_require__(14);
var DESCRIPTORS = __webpack_require__(10);
var $export = __webpack_require__(7);
var redefine = __webpack_require__(58);
var META = __webpack_require__(50).KEY;
var $fails = __webpack_require__(15);
var shared = __webpack_require__(42);
var setToStringTag = __webpack_require__(23);
var uid = __webpack_require__(30);
var wks = __webpack_require__(5);
var wksExt = __webpack_require__(49);
var wksDefine = __webpack_require__(51);
var enumKeys = __webpack_require__(110);
var isArray = __webpack_require__(71);
var anObject = __webpack_require__(13);
var isObject = __webpack_require__(9);
var toObject = __webpack_require__(24);
var toIObject = __webpack_require__(16);
var toPrimitive = __webpack_require__(38);
var createDesc = __webpack_require__(20);
var _create = __webpack_require__(39);
var gOPNExt = __webpack_require__(111);
var $GOPD = __webpack_require__(112);
var $GOPS = __webpack_require__(52);
var $DP = __webpack_require__(8);
var $keys = __webpack_require__(28);
var gOPD = $GOPD.f;
var dP = $DP.f;
var gOPN = gOPNExt.f;
var $Symbol = global.Symbol;
var $JSON = global.JSON;
var _stringify = $JSON && $JSON.stringify;
var PROTOTYPE = 'prototype';
var HIDDEN = wks('_hidden');
var TO_PRIMITIVE = wks('toPrimitive');
var isEnum = {}.propertyIsEnumerable;
var SymbolRegistry = shared('symbol-registry');
var AllSymbols = shared('symbols');
var OPSymbols = shared('op-symbols');
var ObjectProto = Object[PROTOTYPE];
var USE_NATIVE = typeof $Symbol == 'function' && !!$GOPS.f;
var QObject = global.QObject;
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDesc = DESCRIPTORS && $fails(function () {
  return _create(dP({}, 'a', {
    get: function () { return dP(this, 'a', { value: 7 }).a; }
  })).a != 7;
}) ? function (it, key, D) {
  var protoDesc = gOPD(ObjectProto, key);
  if (protoDesc) delete ObjectProto[key];
  dP(it, key, D);
  if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);
} : dP;

var wrap = function (tag) {
  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
  sym._k = tag;
  return sym;
};

var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  return it instanceof $Symbol;
};

var $defineProperty = function defineProperty(it, key, D) {
  if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
  anObject(it);
  key = toPrimitive(key, true);
  anObject(D);
  if (has(AllSymbols, key)) {
    if (!D.enumerable) {
      if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
      D = _create(D, { enumerable: createDesc(0, false) });
    } return setSymbolDesc(it, key, D);
  } return dP(it, key, D);
};
var $defineProperties = function defineProperties(it, P) {
  anObject(it);
  var keys = enumKeys(P = toIObject(P));
  var i = 0;
  var l = keys.length;
  var key;
  while (l > i) $defineProperty(it, key = keys[i++], P[key]);
  return it;
};
var $create = function create(it, P) {
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};
var $propertyIsEnumerable = function propertyIsEnumerable(key) {
  var E = isEnum.call(this, key = toPrimitive(key, true));
  if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
  it = toIObject(it);
  key = toPrimitive(key, true);
  if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;
  var D = gOPD(it, key);
  if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
  return D;
};
var $getOwnPropertyNames = function getOwnPropertyNames(it) {
  var names = gOPN(toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
  } return result;
};
var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
  var IS_OP = it === ObjectProto;
  var names = gOPN(IS_OP ? OPSymbols : toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
  } return result;
};

// 19.4.1.1 Symbol([description])
if (!USE_NATIVE) {
  $Symbol = function Symbol() {
    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
    var $set = function (value) {
      if (this === ObjectProto) $set.call(OPSymbols, value);
      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc(1, value));
    };
    if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });
    return wrap(tag);
  };
  redefine($Symbol[PROTOTYPE], 'toString', function toString() {
    return this._k;
  });

  $GOPD.f = $getOwnPropertyDescriptor;
  $DP.f = $defineProperty;
  __webpack_require__(72).f = gOPNExt.f = $getOwnPropertyNames;
  __webpack_require__(32).f = $propertyIsEnumerable;
  $GOPS.f = $getOwnPropertySymbols;

  if (DESCRIPTORS && !__webpack_require__(18)) {
    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }

  wksExt.f = function (name) {
    return wrap(wks(name));
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol });

for (var es6Symbols = (
  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
).split(','), j = 0; es6Symbols.length > j;)wks(es6Symbols[j++]);

for (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) wksDefine(wellKnownSymbols[k++]);

$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
  // 19.4.2.1 Symbol.for(key)
  'for': function (key) {
    return has(SymbolRegistry, key += '')
      ? SymbolRegistry[key]
      : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');
    for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;
  },
  useSetter: function () { setter = true; },
  useSimple: function () { setter = false; }
});

$export($export.S + $export.F * !USE_NATIVE, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// Chrome 38 and 39 `Object.getOwnPropertySymbols` fails on primitives
// https://bugs.chromium.org/p/v8/issues/detail?id=3443
var FAILS_ON_PRIMITIVES = $fails(function () { $GOPS.f(1); });

$export($export.S + $export.F * FAILS_ON_PRIMITIVES, 'Object', {
  getOwnPropertySymbols: function getOwnPropertySymbols(it) {
    return $GOPS.f(toObject(it));
  }
});

// 24.3.2 JSON.stringify(value [, replacer [, space]])
$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {
  var S = $Symbol();
  // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols
  return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';
})), 'JSON', {
  stringify: function stringify(it) {
    var args = [it];
    var i = 1;
    var replacer, $replacer;
    while (arguments.length > i) args.push(arguments[i++]);
    $replacer = replacer = args[1];
    if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
    if (!isArray(replacer)) replacer = function (key, value) {
      if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
      if (!isSymbol(value)) return value;
    };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  }
});

// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(12)($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
// 19.4.3.5 Symbol.prototype[@@toStringTag]
setToStringTag($Symbol, 'Symbol');
// 20.2.1.9 Math[@@toStringTag]
setToStringTag(Math, 'Math', true);
// 24.3.3 JSON[@@toStringTag]
setToStringTag(global.JSON, 'JSON', true);


/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

// all enumerable object keys, includes symbols
var getKeys = __webpack_require__(28);
var gOPS = __webpack_require__(52);
var pIE = __webpack_require__(32);
module.exports = function (it) {
  var result = getKeys(it);
  var getSymbols = gOPS.f;
  if (getSymbols) {
    var symbols = getSymbols(it);
    var isEnum = pIE.f;
    var i = 0;
    var key;
    while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);
  } return result;
};


/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toIObject = __webpack_require__(16);
var gOPN = __webpack_require__(72).f;
var toString = {}.toString;

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function (it) {
  try {
    return gOPN(it);
  } catch (e) {
    return windowNames.slice();
  }
};

module.exports.f = function getOwnPropertyNames(it) {
  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
};


/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

var pIE = __webpack_require__(32);
var createDesc = __webpack_require__(20);
var toIObject = __webpack_require__(16);
var toPrimitive = __webpack_require__(38);
var has = __webpack_require__(14);
var IE8_DOM_DEFINE = __webpack_require__(57);
var gOPD = Object.getOwnPropertyDescriptor;

exports.f = __webpack_require__(10) ? gOPD : function getOwnPropertyDescriptor(O, P) {
  O = toIObject(O);
  P = toPrimitive(P, true);
  if (IE8_DOM_DEFINE) try {
    return gOPD(O, P);
  } catch (e) { /* empty */ }
  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
};


/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(51)('asyncIterator');


/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(51)('observable');


/***/ }),
/* 115 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// dict.js是用来解析某中文字符的拼音首字符的函数
// export function pinyin (raw) {
//   const str = `${raw}`
//   if (!str || /^ +$/g.test(str)) {
//     return ''
//   }
//   let result = []
//   for (let i = 0; i < str.length; i++) {
//     let unicode = str.charCodeAt(i)
//     let char = str.charAt(i)
//     if (unicode >= 19968 && unicode <= 40869) {
//       char = firstletter.charAt(unicode - 19968)
//     }
//     result.push(char)
//   }
//   return result.join('')
// }
/* harmony default export */ __webpack_exports__["a"] = ('YDYQSXMWZSSXJBYMGCCZQPSSQBYCDSCDQLDYLYBSSJGYZZJJFKCCLZDHWDWZJLJPFYYNWJJTMYHZWZHFLZPPQHGSCYYYNJQYXXGJHHSDSJNKKTMOMLCRXYPSNQSECCQZGGLLYJLMYZZSECYKYYHQWJSSGGYXYZYJWWKDJHYCHMYXJTLXJYQBYXZLDWRDJRWYSRLDZJPCBZJJBRCFTLECZSTZFXXZHTRQHYBDLYCZSSYMMRFMYQZPWWJJYFCRWFDFZQPYDDWYXKYJAWJFFXYPSFTZYHHYZYSWCJYXSCLCXXWZZXNBGNNXBXLZSZSBSGPYSYZDHMDZBQBZCWDZZYYTZHBTSYYBZGNTNXQYWQSKBPHHLXGYBFMJEBJHHGQTJCYSXSTKZHLYCKGLYSMZXYALMELDCCXGZYRJXSDLTYZCQKCNNJWHJTZZCQLJSTSTBNXBTYXCEQXGKWJYFLZQLYHYXSPSFXLMPBYSXXXYDJCZYLLLSJXFHJXPJBTFFYABYXBHZZBJYZLWLCZGGBTSSMDTJZXPTHYQTGLJSCQFZKJZJQNLZWLSLHDZBWJNCJZYZSQQYCQYRZCJJWYBRTWPYFTWEXCSKDZCTBZHYZZYYJXZCFFZZMJYXXSDZZOTTBZLQWFCKSZSXFYRLNYJMBDTHJXSQQCCSBXYYTSYFBXDZTGBCNSLCYZZPSAZYZZSCJCSHZQYDXLBPJLLMQXTYDZXSQJTZPXLCGLQTZWJBHCTSYJSFXYEJJTLBGXSXJMYJQQPFZASYJNTYDJXKJCDJSZCBARTDCLYJQMWNQNCLLLKBYBZZSYHQQLTWLCCXTXLLZNTYLNEWYZYXCZXXGRKRMTCNDNJTSYYSSDQDGHSDBJGHRWRQLYBGLXHLGTGXBQJDZPYJSJYJCTMRNYMGRZJCZGJMZMGXMPRYXKJNYMSGMZJYMKMFXMLDTGFBHCJHKYLPFMDXLQJJSMTQGZSJLQDLDGJYCALCMZCSDJLLNXDJFFFFJCZFMZFFPFKHKGDPSXKTACJDHHZDDCRRCFQYJKQCCWJDXHWJLYLLZGCFCQDSMLZPBJJPLSBCJGGDCKKDEZSQCCKJGCGKDJTJDLZYCXKLQSCGJCLTFPCQCZGWPJDQYZJJBYJHSJDZWGFSJGZKQCCZLLPSPKJGQJHZZLJPLGJGJJTHJJYJZCZMLZLYQBGJWMLJKXZDZNJQSYZMLJLLJKYWXMKJLHSKJGBMCLYYMKXJQLBMLLKMDXXKWYXYSLMLPSJQQJQXYXFJTJDXMXXLLCXQBSYJBGWYMBGGBCYXPJYGPEPFGDJGBHBNSQJYZJKJKHXQFGQZKFHYGKHDKLLSDJQXPQYKYBNQSXQNSZSWHBSXWHXWBZZXDMNSJBSBKBBZKLYLXGWXDRWYQZMYWSJQLCJXXJXKJEQXSCYETLZHLYYYSDZPAQYZCMTLSHTZCFYZYXYLJSDCJQAGYSLCQLYYYSHMRQQKLDXZSCSSSYDYCJYSFSJBFRSSZQSBXXPXJYSDRCKGJLGDKZJZBDKTCSYQPYHSTCLDJDHMXMCGXYZHJDDTMHLTXZXYLYMOHYJCLTYFBQQXPFBDFHHTKSQHZYYWCNXXCRWHOWGYJLEGWDQCWGFJYCSNTMYTOLBYGWQWESJPWNMLRYDZSZTXYQPZGCWXHNGPYXSHMYQJXZTDPPBFYHZHTJYFDZWKGKZBLDNTSXHQEEGZZYLZMMZYJZGXZXKHKSTXNXXWYLYAPSTHXDWHZYMPXAGKYDXBHNHXKDPJNMYHYLPMGOCSLNZHKXXLPZZLBMLSFBHHGYGYYGGBHSCYAQTYWLXTZQCEZYDQDQMMHTKLLSZHLSJZWFYHQSWSCWLQAZYNYTLSXTHAZNKZZSZZLAXXZWWCTGQQTDDYZTCCHYQZFLXPSLZYGPZSZNGLNDQTBDLXGTCTAJDKYWNSYZLJHHZZCWNYYZYWMHYCHHYXHJKZWSXHZYXLYSKQYSPSLYZWMYPPKBYGLKZHTYXAXQSYSHXASMCHKDSCRSWJPWXSGZJLWWSCHSJHSQNHCSEGNDAQTBAALZZMSSTDQJCJKTSCJAXPLGGXHHGXXZCXPDMMHLDGTYBYSJMXHMRCPXXJZCKZXSHMLQXXTTHXWZFKHCCZDYTCJYXQHLXDHYPJQXYLSYYDZOZJNYXQEZYSQYAYXWYPDGXDDXSPPYZNDLTWRHXYDXZZJHTCXMCZLHPYYYYMHZLLHNXMYLLLMDCPPXHMXDKYCYRDLTXJCHHZZXZLCCLYLNZSHZJZZLNNRLWHYQSNJHXYNTTTKYJPYCHHYEGKCTTWLGQRLGGTGTYGYHPYHYLQYQGCWYQKPYYYTTTTLHYHLLTYTTSPLKYZXGZWGPYDSSZZDQXSKCQNMJJZZBXYQMJRTFFBTKHZKBXLJJKDXJTLBWFZPPTKQTZTGPDGNTPJYFALQMKGXBDCLZFHZCLLLLADPMXDJHLCCLGYHDZFGYDDGCYYFGYDXKSSEBDHYKDKDKHNAXXYBPBYYHXZQGAFFQYJXDMLJCSQZLLPCHBSXGJYNDYBYQSPZWJLZKSDDTACTBXZDYZYPJZQSJNKKTKNJDJGYYPGTLFYQKASDNTCYHBLWDZHBBYDWJRYGKZYHEYYFJMSDTYFZJJHGCXPLXHLDWXXJKYTCYKSSSMTWCTTQZLPBSZDZWZXGZAGYKTYWXLHLSPBCLLOQMMZSSLCMBJCSZZKYDCZJGQQDSMCYTZQQLWZQZXSSFPTTFQMDDZDSHDTDWFHTDYZJYQJQKYPBDJYYXTLJHDRQXXXHAYDHRJLKLYTWHLLRLLRCXYLBWSRSZZSYMKZZHHKYHXKSMDSYDYCJPBZBSQLFCXXXNXKXWYWSDZYQOGGQMMYHCDZTTFJYYBGSTTTYBYKJDHKYXBELHTYPJQNFXFDYKZHQKZBYJTZBXHFDXKDASWTAWAJLDYJSFHBLDNNTNQJTJNCHXFJSRFWHZFMDRYJYJWZPDJKZYJYMPCYZNYNXFBYTFYFWYGDBNZZZDNYTXZEMMQBSQEHXFZMBMFLZZSRXYMJGSXWZJSPRYDJSJGXHJJGLJJYNZZJXHGXKYMLPYYYCXYTWQZSWHWLYRJLPXSLSXMFSWWKLCTNXNYNPSJSZHDZEPTXMYYWXYYSYWLXJQZQXZDCLEEELMCPJPCLWBXSQHFWWTFFJTNQJHJQDXHWLBYZNFJLALKYYJLDXHHYCSTYYWNRJYXYWTRMDRQHWQCMFJDYZMHMYYXJWMYZQZXTLMRSPWWCHAQBXYGZYPXYYRRCLMPYMGKSJSZYSRMYJSNXTPLNBAPPYPYLXYYZKYNLDZYJZCZNNLMZHHARQMPGWQTZMXXMLLHGDZXYHXKYXYCJMFFYYHJFSBSSQLXXNDYCANNMTCJCYPRRNYTYQNYYMBMSXNDLYLYSLJRLXYSXQMLLYZLZJJJKYZZCSFBZXXMSTBJGNXYZHLXNMCWSCYZYFZLXBRNNNYLBNRTGZQYSATSWRYHYJZMZDHZGZDWYBSSCSKXSYHYTXXGCQGXZZSHYXJSCRHMKKBXCZJYJYMKQHZJFNBHMQHYSNJNZYBKNQMCLGQHWLZNZSWXKHLJHYYBQLBFCDSXDLDSPFZPSKJYZWZXZDDXJSMMEGJSCSSMGCLXXKYYYLNYPWWWGYDKZJGGGZGGSYCKNJWNJPCXBJJTQTJWDSSPJXZXNZXUMELPXFSXTLLXCLJXJJLJZXCTPSWXLYDHLYQRWHSYCSQYYBYAYWJJJQFWQCQQCJQGXALDBZZYJGKGXPLTZYFXJLTPADKYQHPMATLCPDCKBMTXYBHKLENXDLEEGQDYMSAWHZMLJTWYGXLYQZLJEEYYBQQFFNLYXRDSCTGJGXYYNKLLYQKCCTLHJLQMKKZGCYYGLLLJDZGYDHZWXPYSJBZKDZGYZZHYWYFQYTYZSZYEZZLYMHJJHTSMQWYZLKYYWZCSRKQYTLTDXWCTYJKLWSQZWBDCQYNCJSRSZJLKCDCDTLZZZACQQZZDDXYPLXZBQJYLZLLLQDDZQJYJYJZYXNYYYNYJXKXDAZWYRDLJYYYRJLXLLDYXJCYWYWNQCCLDDNYYYNYCKCZHXXCCLGZQJGKWPPCQQJYSBZZXYJSQPXJPZBSBDSFNSFPZXHDWZTDWPPTFLZZBZDMYYPQJRSDZSQZSQXBDGCPZSWDWCSQZGMDHZXMWWFYBPDGPHTMJTHZSMMBGZMBZJCFZWFZBBZMQCFMBDMCJXLGPNJBBXGYHYYJGPTZGZMQBQTCGYXJXLWZKYDPDYMGCFTPFXYZTZXDZXTGKMTYBBCLBJASKYTSSQYYMSZXFJEWLXLLSZBQJJJAKLYLXLYCCTSXMCWFKKKBSXLLLLJYXTYLTJYYTDPJHNHNNKBYQNFQYYZBYYESSESSGDYHFHWTCJBSDZZTFDMXHCNJZYMQWSRYJDZJQPDQBBSTJGGFBKJBXTGQHNGWJXJGDLLTHZHHYYYYYYSXWTYYYCCBDBPYPZYCCZYJPZYWCBDLFWZCWJDXXHYHLHWZZXJTCZLCDPXUJCZZZLYXJJTXPHFXWPYWXZPTDZZBDZCYHJHMLXBQXSBYLRDTGJRRCTTTHYTCZWMXFYTWWZCWJWXJYWCSKYBZSCCTZQNHXNWXXKHKFHTSWOCCJYBCMPZZYKBNNZPBZHHZDLSYDDYTYFJPXYNGFXBYQXCBHXCPSXTYZDMKYSNXSXLHKMZXLYHDHKWHXXSSKQYHHCJYXGLHZXCSNHEKDTGZXQYPKDHEXTYKCNYMYYYPKQYYYKXZLTHJQTBYQHXBMYHSQCKWWYLLHCYYLNNEQXQWMCFBDCCMLJGGXDQKTLXKGNQCDGZJWYJJLYHHQTTTNWCHMXCXWHWSZJYDJCCDBQCDGDNYXZTHCQRXCBHZTQCBXWGQWYYBXHMBYMYQTYEXMQKYAQYRGYZSLFYKKQHYSSQYSHJGJCNXKZYCXSBXYXHYYLSTYCXQTHYSMGSCPMMGCCCCCMTZTASMGQZJHKLOSQYLSWTMXSYQKDZLJQQYPLSYCZTCQQPBBQJZCLPKHQZYYXXDTDDTSJCXFFLLCHQXMJLWCJCXTSPYCXNDTJSHJWXDQQJSKXYAMYLSJHMLALYKXCYYDMNMDQMXMCZNNCYBZKKYFLMCHCMLHXRCJJHSYLNMTJZGZGYWJXSRXCWJGJQHQZDQJDCJJZKJKGDZQGJJYJYLXZXXCDQHHHEYTMHLFSBDJSYYSHFYSTCZQLPBDRFRZTZYKYWHSZYQKWDQZRKMSYNBCRXQBJYFAZPZZEDZCJYWBCJWHYJBQSZYWRYSZPTDKZPFPBNZTKLQYHBBZPNPPTYZZYBQNYDCPJMMCYCQMCYFZZDCMNLFPBPLNGQJTBTTNJZPZBBZNJKLJQYLNBZQHKSJZNGGQSZZKYXSHPZSNBCGZKDDZQANZHJKDRTLZLSWJLJZLYWTJNDJZJHXYAYNCBGTZCSSQMNJPJYTYSWXZFKWJQTKHTZPLBHSNJZSYZBWZZZZLSYLSBJHDWWQPSLMMFBJDWAQYZTCJTBNNWZXQXCDSLQGDSDPDZHJTQQPSWLYYJZLGYXYZLCTCBJTKTYCZJTQKBSJLGMGZDMCSGPYNJZYQYYKNXRPWSZXMTNCSZZYXYBYHYZAXYWQCJTLLCKJJTJHGDXDXYQYZZBYWDLWQCGLZGJGQRQZCZSSBCRPCSKYDZNXJSQGXSSJMYDNSTZTPBDLTKZWXQWQTZEXNQCZGWEZKSSBYBRTSSSLCCGBPSZQSZLCCGLLLZXHZQTHCZMQGYZQZNMCOCSZJMMZSQPJYGQLJYJPPLDXRGZYXCCSXHSHGTZNLZWZKJCXTCFCJXLBMQBCZZWPQDNHXLJCTHYZLGYLNLSZZPCXDSCQQHJQKSXZPBAJYEMSMJTZDXLCJYRYYNWJBNGZZTMJXLTBSLYRZPYLSSCNXPHLLHYLLQQZQLXYMRSYCXZLMMCZLTZSDWTJJLLNZGGQXPFSKYGYGHBFZPDKMWGHCXMSGDXJMCJZDYCABXJDLNBCDQYGSKYDQTXDJJYXMSZQAZDZFSLQXYJSJZYLBTXXWXQQZBJZUFBBLYLWDSLJHXJYZJWTDJCZFQZQZZDZSXZZQLZCDZFJHYSPYMPQZMLPPLFFXJJNZZYLSJEYQZFPFZKSYWJJJHRDJZZXTXXGLGHYDXCSKYSWMMZCWYBAZBJKSHFHJCXMHFQHYXXYZFTSJYZFXYXPZLCHMZMBXHZZSXYFYMNCWDABAZLXKTCSHHXKXJJZJSTHYGXSXYYHHHJWXKZXSSBZZWHHHCWTZZZPJXSNXQQJGZYZYWLLCWXZFXXYXYHXMKYYSWSQMNLNAYCYSPMJKHWCQHYLAJJMZXHMMCNZHBHXCLXTJPLTXYJHDYYLTTXFSZHYXXSJBJYAYRSMXYPLCKDUYHLXRLNLLSTYZYYQYGYHHSCCSMZCTZQXKYQFPYYRPFFLKQUNTSZLLZMWWTCQQYZWTLLMLMPWMBZSSTZRBPDDTLQJJBXZCSRZQQYGWCSXFWZLXCCRSZDZMCYGGDZQSGTJSWLJMYMMZYHFBJDGYXCCPSHXNZCSBSJYJGJMPPWAFFYFNXHYZXZYLREMZGZCYZSSZDLLJCSQFNXZKPTXZGXJJGFMYYYSNBTYLBNLHPFZDCYFBMGQRRSSSZXYSGTZRNYDZZCDGPJAFJFZKNZBLCZSZPSGCYCJSZLMLRSZBZZLDLSLLYSXSQZQLYXZLSKKBRXBRBZCYCXZZZEEYFGKLZLYYHGZSGZLFJHGTGWKRAAJYZKZQTSSHJJXDCYZUYJLZYRZDQQHGJZXSSZBYKJPBFRTJXLLFQWJHYLQTYMBLPZDXTZYGBDHZZRBGXHWNJTJXLKSCFSMWLSDQYSJTXKZSCFWJLBXFTZLLJZLLQBLSQMQQCGCZFPBPHZCZJLPYYGGDTGWDCFCZQYYYQYSSCLXZSKLZZZGFFCQNWGLHQYZJJCZLQZZYJPJZZBPDCCMHJGXDQDGDLZQMFGPSYTSDYFWWDJZJYSXYYCZCYHZWPBYKXRYLYBHKJKSFXTZJMMCKHLLTNYYMSYXYZPYJQYCSYCWMTJJKQYRHLLQXPSGTLYYCLJSCPXJYZFNMLRGJJTYZBXYZMSJYJHHFZQMSYXRSZCWTLRTQZSSTKXGQKGSPTGCZNJSJCQCXHMXGGZTQYDJKZDLBZSXJLHYQGGGTHQSZPYHJHHGYYGKGGCWJZZYLCZLXQSFTGZSLLLMLJSKCTBLLZZSZMMNYTPZSXQHJCJYQXYZXZQZCPSHKZZYSXCDFGMWQRLLQXRFZTLYSTCTMJCXJJXHJNXTNRZTZFQYHQGLLGCXSZSJDJLJCYDSJTLNYXHSZXCGJZYQPYLFHDJSBPCCZHJJJQZJQDYBSSLLCMYTTMQTBHJQNNYGKYRQYQMZGCJKPDCGMYZHQLLSLLCLMHOLZGDYYFZSLJCQZLYLZQJESHNYLLJXGJXLYSYYYXNBZLJSSZCQQCJYLLZLTJYLLZLLBNYLGQCHXYYXOXCXQKYJXXXYKLXSXXYQXCYKQXQCSGYXXYQXYGYTQOHXHXPYXXXULCYEYCHZZCBWQBBWJQZSCSZSSLZYLKDESJZWMYMCYTSDSXXSCJPQQSQYLYYZYCMDJDZYWCBTJSYDJKCYDDJLBDJJSODZYSYXQQYXDHHGQQYQHDYXWGMMMAJDYBBBPPBCMUUPLJZSMTXERXJMHQNUTPJDCBSSMSSSTKJTSSMMTRCPLZSZMLQDSDMJMQPNQDXCFYNBFSDQXYXHYAYKQYDDLQYYYSSZBYDSLNTFQTZQPZMCHDHCZCWFDXTMYQSPHQYYXSRGJCWTJTZZQMGWJJTJHTQJBBHWZPXXHYQFXXQYWYYHYSCDYDHHQMNMTMWCPBSZPPZZGLMZFOLLCFWHMMSJZTTDHZZYFFYTZZGZYSKYJXQYJZQBHMBZZLYGHGFMSHPZFZSNCLPBQSNJXZSLXXFPMTYJYGBXLLDLXPZJYZJYHHZCYWHJYLSJEXFSZZYWXKZJLUYDTMLYMQJPWXYHXSKTQJEZRPXXZHHMHWQPWQLYJJQJJZSZCPHJLCHHNXJLQWZJHBMZYXBDHHYPZLHLHLGFWLCHYYTLHJXCJMSCPXSTKPNHQXSRTYXXTESYJCTLSSLSTDLLLWWYHDHRJZSFGXTSYCZYNYHTDHWJSLHTZDQDJZXXQHGYLTZPHCSQFCLNJTCLZPFSTPDYNYLGMJLLYCQHYSSHCHYLHQYQTMZYPBYWRFQYKQSYSLZDQJMPXYYSSRHZJNYWTQDFZBWWTWWRXCWHGYHXMKMYYYQMSMZHNGCEPMLQQMTCWCTMMPXJPJJHFXYYZSXZHTYBMSTSYJTTQQQYYLHYNPYQZLCYZHZWSMYLKFJXLWGXYPJYTYSYXYMZCKTTWLKSMZSYLMPWLZWXWQZSSAQSYXYRHSSNTSRAPXCPWCMGDXHXZDZYFJHGZTTSBJHGYZSZYSMYCLLLXBTYXHBBZJKSSDMALXHYCFYGMQYPJYCQXJLLLJGSLZGQLYCJCCZOTYXMTMTTLLWTGPXYMZMKLPSZZZXHKQYSXCTYJZYHXSHYXZKXLZWPSQPYHJWPJPWXQQYLXSDHMRSLZZYZWTTCYXYSZZSHBSCCSTPLWSSCJCHNLCGCHSSPHYLHFHHXJSXYLLNYLSZDHZXYLSXLWZYKCLDYAXZCMDDYSPJTQJZLNWQPSSSWCTSTSZLBLNXSMNYYMJQBQHRZWTYYDCHQLXKPZWBGQYBKFCMZWPZLLYYLSZYDWHXPSBCMLJBSCGBHXLQHYRLJXYSWXWXZSLDFHLSLYNJLZYFLYJYCDRJLFSYZFSLLCQYQFGJYHYXZLYLMSTDJCYHBZLLNWLXXYGYYHSMGDHXXHHLZZJZXCZZZCYQZFNGWPYLCPKPYYPMCLQKDGXZGGWQBDXZZKZFBXXLZXJTPJPTTBYTSZZDWSLCHZHSLTYXHQLHYXXXYYZYSWTXZKHLXZXZPYHGCHKCFSYHUTJRLXFJXPTZTWHPLYXFCRHXSHXKYXXYHZQDXQWULHYHMJTBFLKHTXCWHJFWJCFPQRYQXCYYYQYGRPYWSGSUNGWCHKZDXYFLXXHJJBYZWTSXXNCYJJYMSWZJQRMHXZWFQSYLZJZGBHYNSLBGTTCSYBYXXWXYHXYYXNSQYXMQYWRGYQLXBBZLJSYLPSYTJZYHYZAWLRORJMKSCZJXXXYXCHDYXRYXXJDTSQFXLYLTSFFYXLMTYJMJUYYYXLTZCSXQZQHZXLYYXZHDNBRXXXJCTYHLBRLMBRLLAXKYLLLJLYXXLYCRYLCJTGJCMTLZLLCYZZPZPCYAWHJJFYBDYYZSMPCKZDQYQPBPCJPDCYZMDPBCYYDYCNNPLMTMLRMFMMGWYZBSJGYGSMZQQQZTXMKQWGXLLPJGZBQCDJJJFPKJKCXBLJMSWMDTQJXLDLPPBXCWRCQFBFQJCZAHZGMYKPHYYHZYKNDKZMBPJYXPXYHLFPNYYGXJDBKXNXHJMZJXSTRSTLDXSKZYSYBZXJLXYSLBZYSLHXJPFXPQNBYLLJQKYGZMCYZZYMCCSLCLHZFWFWYXZMWSXTYNXJHPYYMCYSPMHYSMYDYSHQYZCHMJJMZCAAGCFJBBHPLYZYLXXSDJGXDHKXXTXXNBHRMLYJSLTXMRHNLXQJXYZLLYSWQGDLBJHDCGJYQYCMHWFMJYBMBYJYJWYMDPWHXQLDYGPDFXXBCGJSPCKRSSYZJMSLBZZJFLJJJLGXZGYXYXLSZQYXBEXYXHGCXBPLDYHWETTWWCJMBTXCHXYQXLLXFLYXLLJLSSFWDPZSMYJCLMWYTCZPCHQEKCQBWLCQYDPLQPPQZQFJQDJHYMMCXTXDRMJWRHXCJZYLQXDYYNHYYHRSLSRSYWWZJYMTLTLLGTQCJZYABTCKZCJYCCQLJZQXALMZYHYWLWDXZXQDLLQSHGPJFJLJHJABCQZDJGTKHSSTCYJLPSWZLXZXRWGLDLZRLZXTGSLLLLZLYXXWGDZYGBDPHZPBRLWSXQBPFDWOFMWHLYPCBJCCLDMBZPBZZLCYQXLDOMZBLZWPDWYYGDSTTHCSQSCCRSSSYSLFYBFNTYJSZDFNDPDHDZZMBBLSLCMYFFGTJJQWFTMTPJWFNLBZCMMJTGBDZLQLPYFHYYMJYLSDCHDZJWJCCTLJCLDTLJJCPDDSQDSSZYBNDBJLGGJZXSXNLYCYBJXQYCBYLZCFZPPGKCXZDZFZTJJFJSJXZBNZYJQTTYJYHTYCZHYMDJXTTMPXSPLZCDWSLSHXYPZGTFMLCJTYCBPMGDKWYCYZCDSZZYHFLYCTYGWHKJYYLSJCXGYWJCBLLCSNDDBTZBSCLYZCZZSSQDLLMQYYHFSLQLLXFTYHABXGWNYWYYPLLSDLDLLBJCYXJZMLHLJDXYYQYTDLLLBUGBFDFBBQJZZMDPJHGCLGMJJPGAEHHBWCQXAXHHHZCHXYPHJAXHLPHJPGPZJQCQZGJJZZUZDMQYYBZZPHYHYBWHAZYJHYKFGDPFQSDLZMLJXKXGALXZDAGLMDGXMWZQYXXDXXPFDMMSSYMPFMDMMKXKSYZYSHDZKXSYSMMZZZMSYDNZZCZXFPLSTMZDNMXCKJMZTYYMZMZZMSXHHDCZJEMXXKLJSTLWLSQLYJZLLZJSSDPPMHNLZJCZYHMXXHGZCJMDHXTKGRMXFWMCGMWKDTKSXQMMMFZZYDKMSCLCMPCGMHSPXQPZDSSLCXKYXTWLWJYAHZJGZQMCSNXYYMMPMLKJXMHLMLQMXCTKZMJQYSZJSYSZHSYJZJCDAJZYBSDQJZGWZQQXFKDMSDJLFWEHKZQKJPEYPZYSZCDWYJFFMZZYLTTDZZEFMZLBNPPLPLPEPSZALLTYLKCKQZKGENQLWAGYXYDPXLHSXQQWQCQXQCLHYXXMLYCCWLYMQYSKGCHLCJNSZKPYZKCQZQLJPDMDZHLASXLBYDWQLWDNBQCRYDDZTJYBKBWSZDXDTNPJDTCTQDFXQQMGNXECLTTBKPWSLCTYQLPWYZZKLPYGZCQQPLLKCCYLPQMZCZQCLJSLQZDJXLDDHPZQDLJJXZQDXYZQKZLJCYQDYJPPYPQYKJYRMPCBYMCXKLLZLLFQPYLLLMBSGLCYSSLRSYSQTMXYXZQZFDZUYSYZTFFMZZSMZQHZSSCCMLYXWTPZGXZJGZGSJSGKDDHTQGGZLLBJDZLCBCHYXYZHZFYWXYZYMSDBZZYJGTSMTFXQYXQSTDGSLNXDLRYZZLRYYLXQHTXSRTZNGZXBNQQZFMYKMZJBZYMKBPNLYZPBLMCNQYZZZSJZHJCTZKHYZZJRDYZHNPXGLFZTLKGJTCTSSYLLGZRZBBQZZKLPKLCZYSSUYXBJFPNJZZXCDWXZYJXZZDJJKGGRSRJKMSMZJLSJYWQSKYHQJSXPJZZZLSNSHRNYPZTWCHKLPSRZLZXYJQXQKYSJYCZTLQZYBBYBWZPQDWWYZCYTJCJXCKCWDKKZXSGKDZXWWYYJQYYTCYTDLLXWKCZKKLCCLZCQQDZLQLCSFQCHQHSFSMQZZLNBJJZBSJHTSZDYSJQJPDLZCDCWJKJZZLPYCGMZWDJJBSJQZSYZYHHXJPBJYDSSXDZNCGLQMBTSFSBPDZDLZNFGFJGFSMPXJQLMBLGQCYYXBQKDJJQYRFKZTJDHCZKLBSDZCFJTPLLJGXHYXZCSSZZXSTJYGKGCKGYOQXJPLZPBPGTGYJZGHZQZZLBJLSQFZGKQQJZGYCZBZQTLDXRJXBSXXPZXHYZYCLWDXJJHXMFDZPFZHQHQMQGKSLYHTYCGFRZGNQXCLPDLBZCSCZQLLJBLHBZCYPZZPPDYMZZSGYHCKCPZJGSLJLNSCDSLDLXBMSTLDDFJMKDJDHZLZXLSZQPQPGJLLYBDSZGQLBZLSLKYYHZTTNTJYQTZZPSZQZTLLJTYYLLQLLQYZQLBDZLSLYYZYMDFSZSNHLXZNCZQZPBWSKRFBSYZMTHBLGJPMCZZLSTLXSHTCSYZLZBLFEQHLXFLCJLYLJQCBZLZJHHSSTBRMHXZHJZCLXFNBGXGTQJCZTMSFZKJMSSNXLJKBHSJXNTNLZDNTLMSJXGZJYJCZXYJYJWRWWQNZTNFJSZPZSHZJFYRDJSFSZJZBJFZQZZHZLXFYSBZQLZSGYFTZDCSZXZJBQMSZKJRHYJZCKMJKHCHGTXKXQGLXPXFXTRTYLXJXHDTSJXHJZJXZWZLCQSBTXWXGXTXXHXFTSDKFJHZYJFJXRZSDLLLTQSQQZQWZXSYQTWGWBZCGZLLYZBCLMQQTZHZXZXLJFRMYZFLXYSQXXJKXRMQDZDMMYYBSQBHGZMWFWXGMXLZPYYTGZYCCDXYZXYWGSYJYZNBHPZJSQSYXSXRTFYZGRHZTXSZZTHCBFCLSYXZLZQMZLMPLMXZJXSFLBYZMYQHXJSXRXSQZZZSSLYFRCZJRCRXHHZXQYDYHXSJJHZCXZBTYNSYSXJBQLPXZQPYMLXZKYXLXCJLCYSXXZZLXDLLLJJYHZXGYJWKJRWYHCPSGNRZLFZWFZZNSXGXFLZSXZZZBFCSYJDBRJKRDHHGXJLJJTGXJXXSTJTJXLYXQFCSGSWMSBCTLQZZWLZZKXJMLTMJYHSDDBXGZHDLBMYJFRZFSGCLYJBPMLYSMSXLSZJQQHJZFXGFQFQBPXZGYYQXGZTCQWYLTLGWSGWHRLFSFGZJMGMGBGTJFSYZZGZYZAFLSSPMLPFLCWBJZCLJJMZLPJJLYMQDMYYYFBGYGYZMLYZDXQYXRQQQHSYYYQXYLJTYXFSFSLLGNQCYHYCWFHCCCFXPYLYPLLZYXXXXXKQHHXSHJZCFZSCZJXCPZWHHHHHAPYLQALPQAFYHXDYLUKMZQGGGDDESRNNZLTZGCHYPPYSQJJHCLLJTOLNJPZLJLHYMHEYDYDSQYCDDHGZUNDZCLZYZLLZNTNYZGSLHSLPJJBDGWXPCDUTJCKLKCLWKLLCASSTKZZDNQNTTLYYZSSYSSZZRYLJQKCQDHHCRXRZYDGRGCWCGZQFFFPPJFZYNAKRGYWYQPQXXFKJTSZZXSWZDDFBBXTBGTZKZNPZZPZXZPJSZBMQHKCYXYLDKLJNYPKYGHGDZJXXEAHPNZKZTZCMXCXMMJXNKSZQNMNLWBWWXJKYHCPSTMCSQTZJYXTPCTPDTNNPGLLLZSJLSPBLPLQHDTNJNLYYRSZFFJFQWDPHZDWMRZCCLODAXNSSNYZRESTYJWJYJDBCFXNMWTTBYLWSTSZGYBLJPXGLBOCLHPCBJLTMXZLJYLZXCLTPNCLCKXTPZJSWCYXSFYSZDKNTLBYJCYJLLSTGQCBXRYZXBXKLYLHZLQZLNZCXWJZLJZJNCJHXMNZZGJZZXTZJXYCYYCXXJYYXJJXSSSJSTSSTTPPGQTCSXWZDCSYFPTFBFHFBBLZJCLZZDBXGCXLQPXKFZFLSYLTUWBMQJHSZBMDDBCYSCCLDXYCDDQLYJJWMQLLCSGLJJSYFPYYCCYLTJANTJJPWYCMMGQYYSXDXQMZHSZXPFTWWZQSWQRFKJLZJQQYFBRXJHHFWJJZYQAZMYFRHCYYBYQWLPEXCCZSTYRLTTDMQLYKMBBGMYYJPRKZNPBSXYXBHYZDJDNGHPMFSGMWFZMFQMMBCMZZCJJLCNUXYQLMLRYGQZCYXZLWJGCJCGGMCJNFYZZJHYCPRRCMTZQZXHFQGTJXCCJEAQCRJYHPLQLSZDJRBCQHQDYRHYLYXJSYMHZYDWLDFRYHBPYDTSSCNWBXGLPZMLZZTQSSCPJMXXYCSJYTYCGHYCJWYRXXLFEMWJNMKLLSWTXHYYYNCMMCWJDQDJZGLLJWJRKHPZGGFLCCSCZMCBLTBHBQJXQDSPDJZZGKGLFQYWBZYZJLTSTDHQHCTCBCHFLQMPWDSHYYTQWCNZZJTLBYMBPDYYYXSQKXWYYFLXXNCWCXYPMAELYKKJMZZZBRXYYQJFLJPFHHHYTZZXSGQQMHSPGDZQWBWPJHZJDYSCQWZKTXXSQLZYYMYSDZGRXCKKUJLWPYSYSCSYZLRMLQSYLJXBCXTLWDQZPCYCYKPPPNSXFYZJJRCEMHSZMSXLXGLRWGCSTLRSXBZGBZGZTCPLUJLSLYLYMTXMTZPALZXPXJTJWTCYYZLBLXBZLQMYLXPGHDSLSSDMXMBDZZSXWHAMLCZCPJMCNHJYSNSYGCHSKQMZZQDLLKABLWJXSFMOCDXJRRLYQZKJMYBYQLYHETFJZFRFKSRYXFJTWDSXXSYSQJYSLYXWJHSNLXYYXHBHAWHHJZXWMYLJCSSLKYDZTXBZSYFDXGXZJKHSXXYBSSXDPYNZWRPTQZCZENYGCXQFJYKJBZMLJCMQQXUOXSLYXXLYLLJDZBTYMHPFSTTQQWLHOKYBLZZALZXQLHZWRRQHLSTMYPYXJJXMQSJFNBXYXYJXXYQYLTHYLQYFMLKLJTMLLHSZWKZHLJMLHLJKLJSTLQXYLMBHHLNLZXQJHXCFXXLHYHJJGBYZZKBXSCQDJQDSUJZYYHZHHMGSXCSYMXFEBCQWWRBPYYJQTYZCYQYQQZYHMWFFHGZFRJFCDPXNTQYZPDYKHJLFRZXPPXZDBBGZQSTLGDGYLCQMLCHHMFYWLZYXKJLYPQHSYWMQQGQZMLZJNSQXJQSYJYCBEHSXFSZPXZWFLLBCYYJDYTDTHWZSFJMQQYJLMQXXLLDTTKHHYBFPWTYYSQQWNQWLGWDEBZWCMYGCULKJXTMXMYJSXHYBRWFYMWFRXYQMXYSZTZZTFYKMLDHQDXWYYNLCRYJBLPSXCXYWLSPRRJWXHQYPHTYDNXHHMMYWYTZCSQMTSSCCDALWZTCPQPYJLLQZYJSWXMZZMMYLMXCLMXCZMXMZSQTZPPQQBLPGXQZHFLJJHYTJSRXWZXSCCDLXTYJDCQJXSLQYCLZXLZZXMXQRJMHRHZJBHMFLJLMLCLQNLDXZLLLPYPSYJYSXCQQDCMQJZZXHNPNXZMEKMXHYKYQLXSXTXJYYHWDCWDZHQYYBGYBCYSCFGPSJNZDYZZJZXRZRQJJYMCANYRJTLDPPYZBSTJKXXZYPFDWFGZZRPYMTNGXZQBYXNBUFNQKRJQZMJEGRZGYCLKXZDSKKNSXKCLJSPJYYZLQQJYBZSSQLLLKJXTBKTYLCCDDBLSPPFYLGYDTZJYQGGKQTTFZXBDKTYYHYBBFYTYYBCLPDYTGDHRYRNJSPTCSNYJQHKLLLZSLYDXXWBCJQSPXBPJZJCJDZFFXXBRMLAZHCSNDLBJDSZBLPRZTSWSBXBCLLXXLZDJZSJPYLYXXYFTFFFBHJJXGBYXJPMMMPSSJZJMTLYZJXSWXTYLEDQPJMYGQZJGDJLQJWJQLLSJGJGYGMSCLJJXDTYGJQJQJCJZCJGDZZSXQGSJGGCXHQXSNQLZZBXHSGZXCXYLJXYXYYDFQQJHJFXDHCTXJYRXYSQTJXYEFYYSSYYJXNCYZXFXMSYSZXYYSCHSHXZZZGZZZGFJDLTYLNPZGYJYZYYQZPBXQBDZTZCZYXXYHHSQXSHDHGQHJHGYWSZTMZMLHYXGEBTYLZKQWYTJZRCLEKYSTDBCYKQQSAYXCJXWWGSBHJYZYDHCSJKQCXSWXFLTYNYZPZCCZJQTZWJQDZZZQZLJJXLSBHPYXXPSXSHHEZTXFPTLQYZZXHYTXNCFZYYHXGNXMYWXTZSJPTHHGYMXMXQZXTSBCZYJYXXTYYZYPCQLMMSZMJZZLLZXGXZAAJZYXJMZXWDXZSXZDZXLEYJJZQBHZWZZZQTZPSXZTDSXJJJZNYAZPHXYYSRNQDTHZHYYKYJHDZXZLSWCLYBZYECWCYCRYLCXNHZYDZYDYJDFRJJHTRSQTXYXJRJHOJYNXELXSFSFJZGHPZSXZSZDZCQZBYYKLSGSJHCZSHDGQGXYZGXCHXZJWYQWGYHKSSEQZZNDZFKWYSSTCLZSTSYMCDHJXXYWEYXCZAYDMPXMDSXYBSQMJMZJMTZQLPJYQZCGQHXJHHLXXHLHDLDJQCLDWBSXFZZYYSCHTYTYYBHECXHYKGJPXHHYZJFXHWHBDZFYZBCAPNPGNYDMSXHMMMMAMYNBYJTMPXYYMCTHJBZYFCGTYHWPHFTWZZEZSBZEGPFMTSKFTYCMHFLLHGPZJXZJGZJYXZSBBQSCZZLZCCSTPGXMJSFTCCZJZDJXCYBZLFCJSYZFGSZLYBCWZZBYZDZYPSWYJZXZBDSYUXLZZBZFYGCZXBZHZFTPBGZGEJBSTGKDMFHYZZJHZLLZZGJQZLSFDJSSCBZGPDLFZFZSZYZYZSYGCXSNXXCHCZXTZZLJFZGQSQYXZJQDCCZTQCDXZJYQJQCHXZTDLGSCXZSYQJQTZWLQDQZTQCHQQJZYEZZZPBWKDJFCJPZTYPQYQTTYNLMBDKTJZPQZQZZFPZSBNJLGYJDXJDZZKZGQKXDLPZJTCJDQBXDJQJSTCKNXBXZMSLYJCQMTJQWWCJQNJNLLLHJCWQTBZQYDZCZPZZDZYDDCYZZZCCJTTJFZDPRRTZTJDCQTQZDTJNPLZBCLLCTZSXKJZQZPZLBZRBTJDCXFCZDBCCJJLTQQPLDCGZDBBZJCQDCJWYNLLZYZCCDWLLXWZLXRXNTQQCZXKQLSGDFQTDDGLRLAJJTKUYMKQLLTZYTDYYCZGJWYXDXFRSKSTQTENQMRKQZHHQKDLDAZFKYPBGGPZREBZZYKZZSPEGJXGYKQZZZSLYSYYYZWFQZYLZZLZHWCHKYPQGNPGBLPLRRJYXCCSYYHSFZFYBZYYTGZXYLXCZWXXZJZBLFFLGSKHYJZEYJHLPLLLLCZGXDRZELRHGKLZZYHZLYQSZZJZQLJZFLNBHGWLCZCFJYSPYXZLZLXGCCPZBLLCYBBBBUBBCBPCRNNZCZYRBFSRLDCGQYYQXYGMQZWTZYTYJXYFWTEHZZJYWLCCNTZYJJZDEDPZDZTSYQJHDYMBJNYJZLXTSSTPHNDJXXBYXQTZQDDTJTDYYTGWSCSZQFLSHLGLBCZPHDLYZJYCKWTYTYLBNYTSDSYCCTYSZYYEBHEXHQDTWNYGYCLXTSZYSTQMYGZAZCCSZZDSLZCLZRQXYYELJSBYMXSXZTEMBBLLYYLLYTDQYSHYMRQWKFKBFXNXSBYCHXBWJYHTQBPBSBWDZYLKGZSKYHXQZJXHXJXGNLJKZLYYCDXLFYFGHLJGJYBXQLYBXQPQGZTZPLNCYPXDJYQYDYMRBESJYYHKXXSTMXRCZZYWXYQYBMCLLYZHQYZWQXDBXBZWZMSLPDMYSKFMZKLZCYQYCZLQXFZZYDQZPZYGYJYZMZXDZFYFYTTQTZHGSPCZMLCCYTZXJCYTJMKSLPZHYSNZLLYTPZCTZZCKTXDHXXTQCYFKSMQCCYYAZHTJPCYLZLYJBJXTPNYLJYYNRXSYLMMNXJSMYBCSYSYLZYLXJJQYLDZLPQBFZZBLFNDXQKCZFYWHGQMRDSXYCYTXNQQJZYYPFZXDYZFPRXEJDGYQBXRCNFYYQPGHYJDYZXGRHTKYLNWDZNTSMPKLBTHBPYSZBZTJZSZZJTYYXZPHSSZZBZCZPTQFZMYFLYPYBBJQXZMXXDJMTSYSKKBJZXHJCKLPSMKYJZCXTMLJYXRZZQSLXXQPYZXMKYXXXJCLJPRMYYGADYSKQLSNDHYZKQXZYZTCGHZTLMLWZYBWSYCTBHJHJFCWZTXWYTKZLXQSHLYJZJXTMPLPYCGLTBZZTLZJCYJGDTCLKLPLLQPJMZPAPXYZLKKTKDZCZZBNZDYDYQZJYJGMCTXLTGXSZLMLHBGLKFWNWZHDXUHLFMKYSLGXDTWWFRJEJZTZHYDXYKSHWFZCQSHKTMQQHTZHYMJDJSKHXZJZBZZXYMPAGQMSTPXLSKLZYNWRTSQLSZBPSPSGZWYHTLKSSSWHZZLYYTNXJGMJSZSUFWNLSOZTXGXLSAMMLBWLDSZYLAKQCQCTMYCFJBSLXCLZZCLXXKSBZQCLHJPSQPLSXXCKSLNHPSFQQYTXYJZLQLDXZQJZDYYDJNZPTUZDSKJFSLJHYLZSQZLBTXYDGTQFDBYAZXDZHZJNHHQBYKNXJJQCZMLLJZKSPLDYCLBBLXKLELXJLBQYCXJXGCNLCQPLZLZYJTZLJGYZDZPLTQCSXFDMNYCXGBTJDCZNBGBQYQJWGKFHTNPYQZQGBKPBBYZMTJDYTBLSQMPSXTBNPDXKLEMYYCJYNZCTLDYKZZXDDXHQSHDGMZSJYCCTAYRZLPYLTLKXSLZCGGEXCLFXLKJRTLQJAQZNCMBYDKKCXGLCZJZXJHPTDJJMZQYKQSECQZDSHHADMLZFMMZBGNTJNNLGBYJBRBTMLBYJDZXLCJLPLDLPCQDHLXZLYCBLCXZZJADJLNZMMSSSMYBHBSQKBHRSXXJMXSDZNZPXLGBRHWGGFCXGMSKLLTSJYYCQLTSKYWYYHYWXBXQYWPYWYKQLSQPTNTKHQCWDQKTWPXXHCPTHTWUMSSYHBWCRWXHJMKMZNGWTMLKFGHKJYLSYYCXWHYECLQHKQHTTQKHFZLDXQWYZYYDESBPKYRZPJFYYZJCEQDZZDLATZBBFJLLCXDLMJSSXEGYGSJQXCWBXSSZPDYZCXDNYXPPZYDLYJCZPLTXLSXYZYRXCYYYDYLWWNZSAHJSYQYHGYWWAXTJZDAXYSRLTDPSSYYFNEJDXYZHLXLLLZQZSJNYQYQQXYJGHZGZCYJCHZLYCDSHWSHJZYJXCLLNXZJJYYXNFXMWFPYLCYLLABWDDHWDXJMCXZTZPMLQZHSFHZYNZTLLDYWLSLXHYMMYLMBWWKYXYADTXYLLDJPYBPWUXJMWMLLSAFDLLYFLBHHHBQQLTZJCQJLDJTFFKMMMBYTHYGDCQRDDWRQJXNBYSNWZDBYYTBJHPYBYTTJXAAHGQDQTMYSTQXKBTZPKJLZRBEQQSSMJJBDJOTGTBXPGBKTLHQXJJJCTHXQDWJLWRFWQGWSHCKRYSWGFTGYGBXSDWDWRFHWYTJJXXXJYZYSLPYYYPAYXHYDQKXSHXYXGSKQHYWFDDDPPLCJLQQEEWXKSYYKDYPLTJTHKJLTCYYHHJTTPLTZZCDLTHQKZXQYSTEEYWYYZYXXYYSTTJKLLPZMCYHQGXYHSRMBXPLLNQYDQHXSXXWGDQBSHYLLPJJJTHYJKYPPTHYYKTYEZYENMDSHLCRPQFDGFXZPSFTLJXXJBSWYYSKSFLXLPPLBBBLBSFXFYZBSJSSYLPBBFFFFSSCJDSTZSXZRYYSYFFSYZYZBJTBCTSBSDHRTJJBYTCXYJEYLXCBNEBJDSYXYKGSJZBXBYTFZWGENYHHTHZHHXFWGCSTBGXKLSXYWMTMBYXJSTZSCDYQRCYTWXZFHMYMCXLZNSDJTTTXRYCFYJSBSDYERXJLJXBBDEYNJGHXGCKGSCYMBLXJMSZNSKGXFBNBPTHFJAAFXYXFPXMYPQDTZCXZZPXRSYWZDLYBBKTYQPQJPZYPZJZNJPZJLZZFYSBTTSLMPTZRTDXQSJEHBZYLZDHLJSQMLHTXTJECXSLZZSPKTLZKQQYFSYGYWPCPQFHQHYTQXZKRSGTTSQCZLPTXCDYYZXSQZSLXLZMYCPCQBZYXHBSXLZDLTCDXTYLZJYYZPZYZLTXJSJXHLPMYTXCQRBLZSSFJZZTNJYTXMYJHLHPPLCYXQJQQKZZSCPZKSWALQSBLCCZJSXGWWWYGYKTJBBZTDKHXHKGTGPBKQYSLPXPJCKBMLLXDZSTBKLGGQKQLSBKKTFXRMDKBFTPZFRTBBRFERQGXYJPZSSTLBZTPSZQZSJDHLJQLZBPMSMMSXLQQNHKNBLRDDNXXDHDDJCYYGYLXGZLXSYGMQQGKHBPMXYXLYTQWLWGCPBMQXCYZYDRJBHTDJYHQSHTMJSBYPLWHLZFFNYPMHXXHPLTBQPFBJWQDBYGPNZTPFZJGSDDTQSHZEAWZZYLLTYYBWJKXXGHLFKXDJTMSZSQYNZGGSWQSPHTLSSKMCLZXYSZQZXNCJDQGZDLFNYKLJCJLLZLMZZNHYDSSHTHZZLZZBBHQZWWYCRZHLYQQJBEYFXXXWHSRXWQHWPSLMSSKZTTYGYQQWRSLALHMJTQJSMXQBJJZJXZYZKXBYQXBJXSHZTSFJLXMXZXFGHKZSZGGYLCLSARJYHSLLLMZXELGLXYDJYTLFBHBPNLYZFBBHPTGJKWETZHKJJXZXXGLLJLSTGSHJJYQLQZFKCGNNDJSSZFDBCTWWSEQFHQJBSAQTGYPQLBXBMMYWXGSLZHGLZGQYFLZBYFZJFRYSFMBYZHQGFWZSYFYJJPHZBYYZFFWODGRLMFTWLBZGYCQXCDJYGZYYYYTYTYDWEGAZYHXJLZYYHLRMGRXXZCLHNELJJTJTPWJYBJJBXJJTJTEEKHWSLJPLPSFYZPQQBDLQJJTYYQLYZKDKSQJYYQZLDQTGJQYZJSUCMRYQTHTEJMFCTYHYPKMHYZWJDQFHYYXWSHCTXRLJHQXHCCYYYJLTKTTYTMXGTCJTZAYYOCZLYLBSZYWJYTSJYHBYSHFJLYGJXXTMZYYLTXXYPZLXYJZYZYYPNHMYMDYYLBLHLSYYQQLLNJJYMSOYQBZGDLYXYLCQYXTSZEGXHZGLHWBLJHEYXTWQMAKBPQCGYSHHEGQCMWYYWLJYJHYYZLLJJYLHZYHMGSLJLJXCJJYCLYCJPCPZJZJMMYLCQLNQLJQJSXYJMLSZLJQLYCMMHCFMMFPQQMFYLQMCFFQMMMMHMZNFHHJGTTHHKHSLNCHHYQDXTMMQDCYZYXYQMYQYLTDCYYYZAZZCYMZYDLZFFFMMYCQZWZZMABTBYZTDMNZZGGDFTYPCGQYTTSSFFWFDTZQSSYSTWXJHXYTSXXYLBYQHWWKXHZXWZNNZZJZJJQJCCCHYYXBZXZCYZTLLCQXYNJYCYYCYNZZQYYYEWYCZDCJYCCHYJLBTZYYCQWMPWPYMLGKDLDLGKQQBGYCHJXY');

/***/ }),
/* 116 */,
/* 117 */,
/* 118 */,
/* 119 */,
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

!function(_,e){ true?module.exports=e(__webpack_require__(74)):"function"==typeof define&&define.amd?define(["dayjs"],e):_.dayjs_locale_zh_cn=e(_.dayjs)}(this,function(_){"use strict";_=_&&_.hasOwnProperty("default")?_.default:_;var e={name:"zh-cn",weekdays:"星期日_星期一_星期二_星期三_星期四_星期五_星期六".split("_"),weekdaysShort:"周日_周一_周二_周三_周四_周五_周六".split("_"),weekdaysMin:"日_一_二_三_四_五_六".split("_"),months:"一月_二月_三月_四月_五月_六月_七月_八月_九月_十月_十一月_十二月".split("_"),monthsShort:"1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月".split("_"),ordinal:function(_,e){switch(e){case"W":return _+"周";default:return _+"日"}},weekStart:1,yearStart:4,formats:{LT:"HH:mm",LTS:"HH:mm:ss",L:"YYYY/MM/DD",LL:"YYYY年M月D日",LLL:"YYYY年M月D日Ah点mm分",LLLL:"YYYY年M月D日ddddAh点mm分",l:"YYYY/M/D",ll:"YYYY年M月D日",lll:"YYYY年M月D日 HH:mm",llll:"YYYY年M月D日dddd HH:mm"},relativeTime:{future:"%s内",past:"%s前",s:"几秒",m:"1 分钟",mm:"%d 分钟",h:"1 小时",hh:"%d 小时",d:"1 天",dd:"%d 天",M:"1 个月",MM:"%d 个月",y:"1 年",yy:"%d 年"},meridiem:function(_,e){var t=100*_+e;return t<600?"凌晨":t<900?"早上":t<1130?"上午":t<1230?"中午":t<1800?"下午":"晚上"}};return _.locale(e,null,!0),e});


/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["COS"] = factory();
	else
		root["COS"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "D:\\code\\cos-wx-sdk-v5\\demo\\lib";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 5);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var md5 = __webpack_require__(8);
var CryptoJS = __webpack_require__(6);
var xml2json = __webpack_require__(10);
var json2xml = __webpack_require__(7);
var base64 = __webpack_require__(1);

function camSafeUrlEncode(str) {
    return encodeURIComponent(str)
        .replace(/!/g, '%21')
        .replace(/'/g, '%27')
        .replace(/\(/g, '%28')
        .replace(/\)/g, '%29')
        .replace(/\*/g, '%2A');
}

//测试用的key后面可以去掉
var getAuth = function (opt) {
    opt = opt || {};

    var SecretId = opt.SecretId;
    var SecretKey = opt.SecretKey;
    var KeyTime = opt.KeyTime;
    var method = (opt.method || opt.Method || 'get').toLowerCase();
    var queryParams = clone(opt.Query || opt.params || {});
    var headers = clone(opt.Headers || opt.headers || {});
    var pathname = opt.Pathname || '/' + (opt.Key || '');

    if (!SecretId) return console.error('missing param SecretId');
    if (!SecretKey) return console.error('missing param SecretKey');

    var getObjectKeys = function (obj) {
        var list = [];
        for (var key in obj) {
            if (obj.hasOwnProperty(key)) {
                list.push(key);
            }
        }
        return list.sort(function (a, b) {
            a = a.toLowerCase();
            b = b.toLowerCase();
            return a === b ? 0 : (a > b ? 1 : -1);
        });
    };

    var obj2str = function (obj) {
        var i, key, val;
        var list = [];
        var keyList = getObjectKeys(obj);
        for (i = 0; i < keyList.length; i++) {
            key = keyList[i];
            val = (obj[key] === undefined || obj[key] === null) ? '' : ('' + obj[key]);
            key = key.toLowerCase();
            key = camSafeUrlEncode(key);
            val = camSafeUrlEncode(val) || '';
            list.push(key + '=' + val)
        }
        return list.join('&');
    };

    // 签名有效起止时间
    var now = Math.round(getSkewTime(opt.SystemClockOffset) / 1000) - 1;
    var exp = now;

    var Expires = opt.Expires || opt.expires;
    if (Expires === undefined) {
        exp += 900; // 签名过期时间为当前 + 900s
    } else {
        exp += (Expires * 1) || 0;
    }

    // 要用到的 Authorization 参数列表
    var qSignAlgorithm = 'sha1';
    var qAk = SecretId;
    var qSignTime = KeyTime || now + ';' + exp;
    var qKeyTime = KeyTime || now + ';' + exp;
    var qHeaderList = getObjectKeys(headers).join(';').toLowerCase();
    var qUrlParamList = getObjectKeys(queryParams).join(';').toLowerCase();

    // 签名算法说明文档：https://www.qcloud.com/document/product/436/7778
    // 步骤一：计算 SignKey
    var signKey = CryptoJS.HmacSHA1(qKeyTime, SecretKey).toString();

    // 步骤二：构成 FormatString
    var formatString = [method, pathname, obj2str(queryParams), obj2str(headers), ''].join('\n');

    // 步骤三：计算 StringToSign
    var stringToSign = ['sha1', qSignTime, CryptoJS.SHA1(formatString).toString(), ''].join('\n');

    // 步骤四：计算 Signature
    var qSignature = CryptoJS.HmacSHA1(stringToSign, signKey).toString();

    // 步骤五：构造 Authorization
    var authorization = [
        'q-sign-algorithm=' + qSignAlgorithm,
        'q-ak=' + qAk,
        'q-sign-time=' + qSignTime,
        'q-key-time=' + qKeyTime,
        'q-header-list=' + qHeaderList,
        'q-url-param-list=' + qUrlParamList,
        'q-signature=' + qSignature
    ].join('&');

    return authorization;

};

var noop = function () {

};

// 清除对象里值为的 undefined 或 null 的属性
var clearKey = function (obj) {
    var retObj = {};
    for (var key in obj) {
        if (obj.hasOwnProperty(key) && obj[key] !== undefined && obj[key] !== null) {
            retObj[key] = obj[key];
        }
    }
    return retObj;
};

var readAsBinaryString = function (blob, callback) {
    var readFun;
    var fr = new FileReader();
    if (FileReader.prototype.readAsBinaryString) {
        readFun = FileReader.prototype.readAsBinaryString;
        fr.onload = function () {
            callback(this.result);
        };
    } else if (FileReader.prototype.readAsArrayBuffer) { // 在 ie11 添加 readAsBinaryString 兼容
        readFun = function (fileData) {
            var binary = "";
            var pt = this;
            var reader = new FileReader();
            reader.onload = function (e) {
                var bytes = new Uint8Array(reader.result);
                var length = bytes.byteLength;
                for (var i = 0; i < length; i++) {
                    binary += String.fromCharCode(bytes[i]);
                }
                callback(binary);
            };
            reader.readAsArrayBuffer(fileData);
        };
    } else {
        console.error('FileReader not support readAsBinaryString');
    }
    readFun.call(fr, blob);
};

// 获取文件 md5 值
var getFileMd5 = function (blob, callback) {
    readAsBinaryString(blob, function (content) {
        var hash = md5(content, true);
        callback(null, hash);
    });
};

function clone(obj) {
    return map(obj, function (v) {
        return typeof v === 'object' ? clone(v) : v;
    });
}

function extend(target, source) {
    each(source, function (val, key) {
        target[key] = source[key];
    });
    return target;
}

function isArray(arr) {
    return arr instanceof Array;
}

function isInArray(arr, item) {
    var flag = false;
    for (var i = 0; i < arr.length; i++) {
        if (item === arr[i]) {
            flag = true;
            break;
        }
    }
    return flag;
}

function makeArray(arr) {
    return isArray(arr) ? arr : [arr];
}

function each(obj, fn) {
    for (var i in obj) {
        if (obj.hasOwnProperty(i)) {
            fn(obj[i], i);
        }
    }
}

function map(obj, fn) {
    var o = isArray(obj) ? [] : {};
    for (var i in obj) {
        if (obj.hasOwnProperty(i)) {
            o[i] = fn(obj[i], i);
        }
    }
    return o;
}

function filter(obj, fn) {
    var iaArr = isArray(obj);
    var o = iaArr ? [] : {};
    for (var i in obj) {
        if (obj.hasOwnProperty(i)) {
            if (fn(obj[i], i)) {
                if (iaArr) {
                    o.push(obj[i]);
                } else {
                    o[i] = obj[i];
                }
            }
        }
    }
    return o;
}

var binaryBase64 = function (str) {
    var i, len, char, res = '';
    for (i = 0, len = str.length / 2; i < len; i++) {
        char = parseInt(str[i * 2] + str[i * 2 + 1], 16);
        res += String.fromCharCode(char);
    }
    return base64.btoa(res);
};
var uuid = function () {
    var S4 = function () {
        return (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1);
    };
    return (S4() + S4() + "-" + S4() + "-" + S4() + "-" + S4() + "-" + S4() + S4() + S4());
};

var hasMissingParams = function (apiName, params) {
    var Bucket = params.Bucket;
    var Region = params.Region;
    var Key = params.Key;
    if (apiName.indexOf('Bucket') > -1 || apiName === 'deleteMultipleObject' || apiName === 'multipartList' || apiName === 'listObjectVersions') {
        if (!Bucket) return 'Bucket';
        if (!Region) return 'Region';
    } else if (apiName.indexOf('Object') > -1 || apiName.indexOf('multipart') > -1 || apiName === 'sliceUploadFile' || apiName === 'abortUploadTask') {
        if (!Bucket) return 'Bucket';
        if (!Region) return 'Region';
        if (!Key) return 'Key';
    }
    return false;
};

var formatParams = function (apiName, params) {

    // 复制参数对象
    params = extend({}, params);

    // 统一处理 Headers
    if (apiName !== 'getAuth' && apiName !== 'getV4Auth' && apiName !== 'getObjectUrl') {
        var Headers = params.Headers || {};
        if (params && typeof params === 'object') {
            (function () {
                for (var key in params) {
                    if (params.hasOwnProperty(key) && key.indexOf('x-cos-') > -1) {
                        Headers[key] = params[key];
                    }
                }
            })();

            var headerMap = {
                // params headers
                'x-cos-mfa': 'MFA',
                'Content-MD5': 'ContentMD5',
                'Content-Length': 'ContentLength',
                'Content-Type': 'ContentType',
                'Expect': 'Expect',
                'Expires': 'Expires',
                'Cache-Control': 'CacheControl',
                'Content-Disposition': 'ContentDisposition',
                'Content-Encoding': 'ContentEncoding',
                'Range': 'Range',
                'If-Modified-Since': 'IfModifiedSince',
                'If-Unmodified-Since': 'IfUnmodifiedSince',
                'If-Match': 'IfMatch',
                'If-None-Match': 'IfNoneMatch',
                'x-cos-copy-source': 'CopySource',
                'x-cos-copy-source-Range': 'CopySourceRange',
                'x-cos-metadata-directive': 'MetadataDirective',
                'x-cos-copy-source-If-Modified-Since': 'CopySourceIfModifiedSince',
                'x-cos-copy-source-If-Unmodified-Since': 'CopySourceIfUnmodifiedSince',
                'x-cos-copy-source-If-Match': 'CopySourceIfMatch',
                'x-cos-copy-source-If-None-Match': 'CopySourceIfNoneMatch',
                'x-cos-acl': 'ACL',
                'x-cos-grant-read': 'GrantRead',
                'x-cos-grant-write': 'GrantWrite',
                'x-cos-grant-full-control': 'GrantFullControl',
                'x-cos-grant-read-acp': 'GrantReadAcp',
                'x-cos-grant-write-acp': 'GrantWriteAcp',
                'x-cos-storage-class': 'StorageClass',
                // SSE-C
                'x-cos-server-side-encryption-customer-algorithm': 'SSECustomerAlgorithm',
                'x-cos-server-side-encryption-customer-key': 'SSECustomerKey',
                'x-cos-server-side-encryption-customer-key-MD5': 'SSECustomerKeyMD5',
                // SSE-COS、SSE-KMS
                'x-cos-server-side-encryption': 'ServerSideEncryption',
                'x-cos-server-side-encryption-cos-kms-key-id': 'SSEKMSKeyId',
                'x-cos-server-side-encryption-context': 'SSEContext',
            };
            util.each(headerMap, function (paramKey, headerKey) {
                if (params[paramKey] !== undefined) {
                    Headers[headerKey] = params[paramKey];
                }
            });

            params.Headers = clearKey(Headers);
        }
    }

    return params;
};

var apiWrapper = function (apiName, apiFn) {
    return function (params, callback) {

        // 处理参数
        if (typeof params === 'function') {
            callback = params;
            params = {};
        }

        // 整理参数格式
        params = formatParams(apiName, params);

        // 代理回调函数
        var formatResult = function (result) {
            if (result && result.headers) {
                result.headers['x-cos-version-id'] && (result.VersionId = result.headers['x-cos-version-id']);
                result.headers['x-cos-delete-marker'] && (result.DeleteMarker = result.headers['x-cos-delete-marker']);
            }
            return result;
        };
        var _callback = function (err, data) {
            callback && callback(formatResult(err), formatResult(data));
        };

        if (apiName !== 'getService' && apiName !== 'abortUploadTask') {
            // 判断参数是否完整
            var missingResult;
            if (missingResult = hasMissingParams(apiName, params)) {
                _callback({error: 'missing param ' + missingResult});
                return;
            }
            // 判断 region 格式
            if (params.Region) {
                if (params.Region.indexOf('cos.') > -1) {
                    _callback({error: 'param Region should not be start with "cos."'});
                    return;
                } else if (!/^([a-z\d-]+)$/.test(params.Region)) {
                    _callback({error: 'Region format error.'});
                    return;
                }
                // 判断 region 格式
                if (!this.options.CompatibilityMode && params.Region.indexOf('-') === -1 && params.Region !== 'yfb' && params.Region !== 'default') {
                    console.warn('warning: param Region format error, find help here: https://cloud.tencent.com/document/product/436/6224');
                }
            }
            // 兼容不带 AppId 的 Bucket
            if (params.Bucket) {
                if (!/^([a-z\d-]+)-(\d+)$/.test(params.Bucket)) {
                    if (params.AppId) {
                        params.Bucket = params.Bucket + '-' + params.AppId;
                    } else if (this.options.AppId) {
                        params.Bucket = params.Bucket + '-' + this.options.AppId;
                    } else {
                        _callback({error: 'Bucket should format as "test-1250000000".'});
                        return;
                    }
                }
                if (params.AppId) {
                    console.warn('warning: AppId has been deprecated, Please put it at the end of parameter Bucket(E.g Bucket:"test-1250000000" ).');
                    delete params.AppId;
                }
            }
        }
        var res = apiFn.call(this, params, _callback);
        if (apiName === 'getAuth' || apiName === 'getObjectUrl') {
            return res;
        }
    }
};

var throttleOnProgress = function (total, onProgress) {

    if (!onProgress || typeof onProgress !== 'function') return noop;
    var self = this;
    var size0 = 0;
    var size1 = 0;
    var time0 = Date.now();
    var time1;
    var timer;

    function update() {
        clearTimeout(timer);
        timer = 0;
        time1 = Date.now();
        var speed = Math.max(0, Math.round((size1 - size0) / ((time1 - time0) / 1000) * 100) / 100);
        var percent;
        if (size1 === 0 && total === 0) {
            percent = 1;
        } else {
            percent = Math.round(size1 / total * 100) / 100 || 0;
        }
        time0 = time1;
        size0 = size1;
        try {
            onProgress({loaded: size1, total: total, speed: speed, percent: percent});
        } catch (e) {
        }
    }

    return function (info, immediately) {
        if (info) {
            size1 = info.loaded;
            total = info.total;
        }
        if (Date.now() - time0 > self.options.ProgressInterval || immediately) {
            update();
        } else {
            if (timer) return;
            timer = setTimeout(update, self.options.ProgressInterval);
        }
    };
};

var getFileSize = function (api, params, callback) {
    var size;
    if (typeof params.Body === 'string') {
        params.Body = new Blob([params.Body], {type: 'text/plain'});
    }
    if ((params.Body && (params.Body instanceof Blob || params.Body.toString() === '[object File]' || params.Body.toString() === '[object Blob]'))) {
        size = params.Body.size;
    } else {
        callback({error: 'params body format error, Only allow File|Blob|String.'});
        return;
    }
    params.ContentLength = size;
    callback(null, size);
};

var getSkewTime = function (offset) {
    return Date.now() + (offset || 0);
};

var util = {
    noop: noop,
    formatParams: formatParams,
    apiWrapper: apiWrapper,
    xml2json: xml2json,
    json2xml: json2xml,
    md5: md5,
    clearKey: clearKey,
    getFileMd5: getFileMd5,
    binaryBase64: binaryBase64,
    extend: extend,
    isArray: isArray,
    isInArray: isInArray,
    makeArray: makeArray,
    each: each,
    map: map,
    filter: filter,
    clone: clone,
    uuid: uuid,
    camSafeUrlEncode: camSafeUrlEncode,
    throttleOnProgress: throttleOnProgress,
    getFileSize: getFileSize,
    getSkewTime: getSkewTime,
    getAuth: getAuth,
    isBrowser: true,
};

util.fileSlice = function (file, start, end) {
    if (file.slice) {
        return file.slice(start, end);
    } else if (file.mozSlice) {
        return file.mozSlice(start, end);
    } else if (file.webkitSlice) {
        return file.webkitSlice(start, end);
    }
};
util.getFileUUID = function (file, ChunkSize) {
    // 如果信息不完整，不获取
    if (file.name && file.size && file.lastModifiedDate && ChunkSize) {
        return util.md5([file.name, file.size, file.lastModifiedDate, ChunkSize].join('::'));
    } else {
        return null;
    }
};
util.getBodyMd5 = function (UploadCheckContentMd5, Body, callback) {
    callback = callback || noop;
    if (UploadCheckContentMd5) {
        if (typeof Body === 'string') {
            callback(util.md5(Body, true));
        } else {
            callback();
        }
    } else {
        callback();
    }
};

module.exports = util;


/***/ }),
/* 1 */
/***/ (function(module, exports) {

/*
 * $Id: base64.js,v 2.15 2014/04/05 12:58:57 dankogai Exp dankogai $
 *
 *  Licensed under the BSD 3-Clause License.
 *    http://opensource.org/licenses/BSD-3-Clause
 *
 *  References:
 *    http://en.wikipedia.org/wiki/Base64
 */

var Base64 = (function(global) {
    global = global || {};
    'use strict';
    // existing version for noConflict()
    var _Base64 = global.Base64;
    var version = "2.1.9";
    // if node.js, we use Buffer
    var buffer;
    // constants
    var b64chars
        = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
    var b64tab = function(bin) {
        var t = {};
        for (var i = 0, l = bin.length; i < l; i++) t[bin.charAt(i)] = i;
        return t;
    }(b64chars);
    var fromCharCode = String.fromCharCode;
    // encoder stuff
    var cb_utob = function(c) {
        if (c.length < 2) {
            var cc = c.charCodeAt(0);
            return cc < 0x80 ? c
                : cc < 0x800 ? (fromCharCode(0xc0 | (cc >>> 6))
                                + fromCharCode(0x80 | (cc & 0x3f)))
                : (fromCharCode(0xe0 | ((cc >>> 12) & 0x0f))
                   + fromCharCode(0x80 | ((cc >>>  6) & 0x3f))
                   + fromCharCode(0x80 | ( cc         & 0x3f)));
        } else {
            var cc = 0x10000
                + (c.charCodeAt(0) - 0xD800) * 0x400
                + (c.charCodeAt(1) - 0xDC00);
            return (fromCharCode(0xf0 | ((cc >>> 18) & 0x07))
                    + fromCharCode(0x80 | ((cc >>> 12) & 0x3f))
                    + fromCharCode(0x80 | ((cc >>>  6) & 0x3f))
                    + fromCharCode(0x80 | ( cc         & 0x3f)));
        }
    };
    var re_utob = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g;
    var utob = function(u) {
        return u.replace(re_utob, cb_utob);
    };
    var cb_encode = function(ccc) {
        var padlen = [0, 2, 1][ccc.length % 3],
        ord = ccc.charCodeAt(0) << 16
            | ((ccc.length > 1 ? ccc.charCodeAt(1) : 0) << 8)
            | ((ccc.length > 2 ? ccc.charCodeAt(2) : 0)),
        chars = [
            b64chars.charAt( ord >>> 18),
            b64chars.charAt((ord >>> 12) & 63),
            padlen >= 2 ? '=' : b64chars.charAt((ord >>> 6) & 63),
            padlen >= 1 ? '=' : b64chars.charAt(ord & 63)
        ];
        return chars.join('');
    };
    var btoa = global.btoa ? function(b) {
        return global.btoa(b);
    } : function(b) {
        return b.replace(/[\s\S]{1,3}/g, cb_encode);
    };
    var _encode = buffer ? function (u) {
        return (u.constructor === buffer.constructor ? u : new buffer(u))
        .toString('base64')
    }
    : function (u) { return btoa(utob(u)) }
    ;
    var encode = function(u, urisafe) {
        return !urisafe
            ? _encode(String(u))
            : _encode(String(u)).replace(/[+\/]/g, function(m0) {
                return m0 == '+' ? '-' : '_';
            }).replace(/=/g, '');
    };
    var encodeURI = function(u) { return encode(u, true) };
    // decoder stuff
    var re_btou = new RegExp([
        '[\xC0-\xDF][\x80-\xBF]',
        '[\xE0-\xEF][\x80-\xBF]{2}',
        '[\xF0-\xF7][\x80-\xBF]{3}'
    ].join('|'), 'g');
    var cb_btou = function(cccc) {
        switch(cccc.length) {
        case 4:
            var cp = ((0x07 & cccc.charCodeAt(0)) << 18)
                |    ((0x3f & cccc.charCodeAt(1)) << 12)
                |    ((0x3f & cccc.charCodeAt(2)) <<  6)
                |     (0x3f & cccc.charCodeAt(3)),
            offset = cp - 0x10000;
            return (fromCharCode((offset  >>> 10) + 0xD800)
                    + fromCharCode((offset & 0x3FF) + 0xDC00));
        case 3:
            return fromCharCode(
                ((0x0f & cccc.charCodeAt(0)) << 12)
                    | ((0x3f & cccc.charCodeAt(1)) << 6)
                    |  (0x3f & cccc.charCodeAt(2))
            );
        default:
            return  fromCharCode(
                ((0x1f & cccc.charCodeAt(0)) << 6)
                    |  (0x3f & cccc.charCodeAt(1))
            );
        }
    };
    var btou = function(b) {
        return b.replace(re_btou, cb_btou);
    };
    var cb_decode = function(cccc) {
        var len = cccc.length,
        padlen = len % 4,
        n = (len > 0 ? b64tab[cccc.charAt(0)] << 18 : 0)
            | (len > 1 ? b64tab[cccc.charAt(1)] << 12 : 0)
            | (len > 2 ? b64tab[cccc.charAt(2)] <<  6 : 0)
            | (len > 3 ? b64tab[cccc.charAt(3)]       : 0),
        chars = [
            fromCharCode( n >>> 16),
            fromCharCode((n >>>  8) & 0xff),
            fromCharCode( n         & 0xff)
        ];
        chars.length -= [0, 0, 2, 1][padlen];
        return chars.join('');
    };
    var atob = global.atob ? function(a) {
        return global.atob(a);
    } : function(a){
        return a.replace(/[\s\S]{1,4}/g, cb_decode);
    };
    var _decode = buffer ? function(a) {
        return (a.constructor === buffer.constructor
                ? a : new buffer(a, 'base64')).toString();
    }
    : function(a) { return btou(atob(a)) };
    var decode = function(a){
        return _decode(
            String(a).replace(/[-_]/g, function(m0) { return m0 == '-' ? '+' : '/' })
                .replace(/[^A-Za-z0-9\+\/]/g, '')
        );
    };
    var noConflict = function() {
        var Base64 = global.Base64;
        global.Base64 = _Base64;
        return Base64;
    };
    // export Base64
    var Base64 = {
        VERSION: version,
        atob: atob,
        btoa: btoa,
        fromBase64: decode,
        toBase64: encode,
        utob: utob,
        encode: encode,
        encodeURI: encodeURI,
        btou: btou,
        decode: decode,
        noConflict: noConflict
    };
    return Base64;
})();

module.exports = Base64;



/***/ }),
/* 2 */
/***/ (function(module, exports) {

/*
 * DOM Level 2
 * Object DOMException
 * @see http://www.w3.org/TR/REC-DOM-Level-1/ecma-script-language-binding.html
 * @see http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/ecma-script-binding.html
 */

function copy(src,dest){
	for(var p in src){
		dest[p] = src[p];
	}
}
/**
^\w+\.prototype\.([_\w]+)\s*=\s*((?:.*\{\s*?[\r\n][\s\S]*?^})|\S.*?(?=[;\r\n]));?
^\w+\.prototype\.([_\w]+)\s*=\s*(\S.*?(?=[;\r\n]));?
 */
function _extends(Class,Super){
	var pt = Class.prototype;
	if(Object.create){
		var ppt = Object.create(Super.prototype)
		pt.__proto__ = ppt;
	}
	if(!(pt instanceof Super)){
		function t(){};
		t.prototype = Super.prototype;
		t = new t();
		copy(pt,t);
		Class.prototype = pt = t;
	}
	if(pt.constructor != Class){
		if(typeof Class != 'function'){
			console.error("unknow Class:"+Class)
		}
		pt.constructor = Class
	}
}
var htmlns = 'http://www.w3.org/1999/xhtml' ;
// Node Types
var NodeType = {}
var ELEMENT_NODE                = NodeType.ELEMENT_NODE                = 1;
var ATTRIBUTE_NODE              = NodeType.ATTRIBUTE_NODE              = 2;
var TEXT_NODE                   = NodeType.TEXT_NODE                   = 3;
var CDATA_SECTION_NODE          = NodeType.CDATA_SECTION_NODE          = 4;
var ENTITY_REFERENCE_NODE       = NodeType.ENTITY_REFERENCE_NODE       = 5;
var ENTITY_NODE                 = NodeType.ENTITY_NODE                 = 6;
var PROCESSING_INSTRUCTION_NODE = NodeType.PROCESSING_INSTRUCTION_NODE = 7;
var COMMENT_NODE                = NodeType.COMMENT_NODE                = 8;
var DOCUMENT_NODE               = NodeType.DOCUMENT_NODE               = 9;
var DOCUMENT_TYPE_NODE          = NodeType.DOCUMENT_TYPE_NODE          = 10;
var DOCUMENT_FRAGMENT_NODE      = NodeType.DOCUMENT_FRAGMENT_NODE      = 11;
var NOTATION_NODE               = NodeType.NOTATION_NODE               = 12;

// ExceptionCode
var ExceptionCode = {}
var ExceptionMessage = {};
var INDEX_SIZE_ERR              = ExceptionCode.INDEX_SIZE_ERR              = ((ExceptionMessage[1]="Index size error"),1);
var DOMSTRING_SIZE_ERR          = ExceptionCode.DOMSTRING_SIZE_ERR          = ((ExceptionMessage[2]="DOMString size error"),2);
var HIERARCHY_REQUEST_ERR       = ExceptionCode.HIERARCHY_REQUEST_ERR       = ((ExceptionMessage[3]="Hierarchy request error"),3);
var WRONG_DOCUMENT_ERR          = ExceptionCode.WRONG_DOCUMENT_ERR          = ((ExceptionMessage[4]="Wrong document"),4);
var INVALID_CHARACTER_ERR       = ExceptionCode.INVALID_CHARACTER_ERR       = ((ExceptionMessage[5]="Invalid character"),5);
var NO_DATA_ALLOWED_ERR         = ExceptionCode.NO_DATA_ALLOWED_ERR         = ((ExceptionMessage[6]="No data allowed"),6);
var NO_MODIFICATION_ALLOWED_ERR = ExceptionCode.NO_MODIFICATION_ALLOWED_ERR = ((ExceptionMessage[7]="No modification allowed"),7);
var NOT_FOUND_ERR               = ExceptionCode.NOT_FOUND_ERR               = ((ExceptionMessage[8]="Not found"),8);
var NOT_SUPPORTED_ERR           = ExceptionCode.NOT_SUPPORTED_ERR           = ((ExceptionMessage[9]="Not supported"),9);
var INUSE_ATTRIBUTE_ERR         = ExceptionCode.INUSE_ATTRIBUTE_ERR         = ((ExceptionMessage[10]="Attribute in use"),10);
//level2
var INVALID_STATE_ERR        	= ExceptionCode.INVALID_STATE_ERR        	= ((ExceptionMessage[11]="Invalid state"),11);
var SYNTAX_ERR               	= ExceptionCode.SYNTAX_ERR               	= ((ExceptionMessage[12]="Syntax error"),12);
var INVALID_MODIFICATION_ERR 	= ExceptionCode.INVALID_MODIFICATION_ERR 	= ((ExceptionMessage[13]="Invalid modification"),13);
var NAMESPACE_ERR            	= ExceptionCode.NAMESPACE_ERR           	= ((ExceptionMessage[14]="Invalid namespace"),14);
var INVALID_ACCESS_ERR       	= ExceptionCode.INVALID_ACCESS_ERR      	= ((ExceptionMessage[15]="Invalid access"),15);


function DOMException(code, message) {
	if(message instanceof Error){
		var error = message;
	}else{
		error = this;
		Error.call(this, ExceptionMessage[code]);
		this.message = ExceptionMessage[code];
		if(Error.captureStackTrace) Error.captureStackTrace(this, DOMException);
	}
	error.code = code;
	if(message) this.message = this.message + ": " + message;
	return error;
};
DOMException.prototype = Error.prototype;
copy(ExceptionCode,DOMException)
/**
 * @see http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html#ID-536297177
 * The NodeList interface provides the abstraction of an ordered collection of nodes, without defining or constraining how this collection is implemented. NodeList objects in the DOM are live.
 * The items in the NodeList are accessible via an integral index, starting from 0.
 */
function NodeList() {
};
NodeList.prototype = {
	/**
	 * The number of nodes in the list. The range of valid child node indices is 0 to length-1 inclusive.
	 * @standard level1
	 */
	length:0, 
	/**
	 * Returns the indexth item in the collection. If index is greater than or equal to the number of nodes in the list, this returns null.
	 * @standard level1
	 * @param index  unsigned long 
	 *   Index into the collection.
	 * @return Node
	 * 	The node at the indexth position in the NodeList, or null if that is not a valid index. 
	 */
	item: function(index) {
		return this[index] || null;
	},
	toString:function(isHTML,nodeFilter){
		for(var buf = [], i = 0;i<this.length;i++){
			serializeToString(this[i],buf,isHTML,nodeFilter);
		}
		return buf.join('');
	}
};
function LiveNodeList(node,refresh){
	this._node = node;
	this._refresh = refresh
	_updateLiveList(this);
}
function _updateLiveList(list){
	var inc = list._node._inc || list._node.ownerDocument._inc;
	if(list._inc != inc){
		var ls = list._refresh(list._node);
		//console.log(ls.length)
		__set__(list,'length',ls.length);
		copy(ls,list);
		list._inc = inc;
	}
}
LiveNodeList.prototype.item = function(i){
	_updateLiveList(this);
	return this[i];
}

_extends(LiveNodeList,NodeList);
/**
 * 
 * Objects implementing the NamedNodeMap interface are used to represent collections of nodes that can be accessed by name. Note that NamedNodeMap does not inherit from NodeList; NamedNodeMaps are not maintained in any particular order. Objects contained in an object implementing NamedNodeMap may also be accessed by an ordinal index, but this is simply to allow convenient enumeration of the contents of a NamedNodeMap, and does not imply that the DOM specifies an order to these Nodes.
 * NamedNodeMap objects in the DOM are live.
 * used for attributes or DocumentType entities 
 */
function NamedNodeMap() {
};

function _findNodeIndex(list,node){
	var i = list.length;
	while(i--){
		if(list[i] === node){return i}
	}
}

function _addNamedNode(el,list,newAttr,oldAttr){
	if(oldAttr){
		list[_findNodeIndex(list,oldAttr)] = newAttr;
	}else{
		list[list.length++] = newAttr;
	}
	if(el){
		newAttr.ownerElement = el;
		var doc = el.ownerDocument;
		if(doc){
			oldAttr && _onRemoveAttribute(doc,el,oldAttr);
			_onAddAttribute(doc,el,newAttr);
		}
	}
}
function _removeNamedNode(el,list,attr){
	//console.log('remove attr:'+attr)
	var i = _findNodeIndex(list,attr);
	if(i>=0){
		var lastIndex = list.length-1
		while(i<lastIndex){
			list[i] = list[++i]
		}
		list.length = lastIndex;
		if(el){
			var doc = el.ownerDocument;
			if(doc){
				_onRemoveAttribute(doc,el,attr);
				attr.ownerElement = null;
			}
		}
	}else{
		throw DOMException(NOT_FOUND_ERR,new Error(el.tagName+'@'+attr))
	}
}
NamedNodeMap.prototype = {
	length:0,
	item:NodeList.prototype.item,
	getNamedItem: function(key) {
//		if(key.indexOf(':')>0 || key == 'xmlns'){
//			return null;
//		}
		//console.log()
		var i = this.length;
		while(i--){
			var attr = this[i];
			//console.log(attr.nodeName,key)
			if(attr.nodeName == key){
				return attr;
			}
		}
	},
	setNamedItem: function(attr) {
		var el = attr.ownerElement;
		if(el && el!=this._ownerElement){
			throw new DOMException(INUSE_ATTRIBUTE_ERR);
		}
		var oldAttr = this.getNamedItem(attr.nodeName);
		_addNamedNode(this._ownerElement,this,attr,oldAttr);
		return oldAttr;
	},
	/* returns Node */
	setNamedItemNS: function(attr) {// raises: WRONG_DOCUMENT_ERR,NO_MODIFICATION_ALLOWED_ERR,INUSE_ATTRIBUTE_ERR
		var el = attr.ownerElement, oldAttr;
		if(el && el!=this._ownerElement){
			throw new DOMException(INUSE_ATTRIBUTE_ERR);
		}
		oldAttr = this.getNamedItemNS(attr.namespaceURI,attr.localName);
		_addNamedNode(this._ownerElement,this,attr,oldAttr);
		return oldAttr;
	},

	/* returns Node */
	removeNamedItem: function(key) {
		var attr = this.getNamedItem(key);
		_removeNamedNode(this._ownerElement,this,attr);
		return attr;
		
		
	},// raises: NOT_FOUND_ERR,NO_MODIFICATION_ALLOWED_ERR
	
	//for level2
	removeNamedItemNS:function(namespaceURI,localName){
		var attr = this.getNamedItemNS(namespaceURI,localName);
		_removeNamedNode(this._ownerElement,this,attr);
		return attr;
	},
	getNamedItemNS: function(namespaceURI, localName) {
		var i = this.length;
		while(i--){
			var node = this[i];
			if(node.localName == localName && node.namespaceURI == namespaceURI){
				return node;
			}
		}
		return null;
	}
};
/**
 * @see http://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-102161490
 */
function DOMImplementation(/* Object */ features) {
	this._features = {};
	if (features) {
		for (var feature in features) {
			 this._features = features[feature];
		}
	}
};

DOMImplementation.prototype = {
	hasFeature: function(/* string */ feature, /* string */ version) {
		var versions = this._features[feature.toLowerCase()];
		if (versions && (!version || version in versions)) {
			return true;
		} else {
			return false;
		}
	},
	// Introduced in DOM Level 2:
	createDocument:function(namespaceURI,  qualifiedName, doctype){// raises:INVALID_CHARACTER_ERR,NAMESPACE_ERR,WRONG_DOCUMENT_ERR
		var doc = new Document();
		doc.implementation = this;
		doc.childNodes = new NodeList();
		doc.doctype = doctype;
		if(doctype){
			doc.appendChild(doctype);
		}
		if(qualifiedName){
			var root = doc.createElementNS(namespaceURI,qualifiedName);
			doc.appendChild(root);
		}
		return doc;
	},
	// Introduced in DOM Level 2:
	createDocumentType:function(qualifiedName, publicId, systemId){// raises:INVALID_CHARACTER_ERR,NAMESPACE_ERR
		var node = new DocumentType();
		node.name = qualifiedName;
		node.nodeName = qualifiedName;
		node.publicId = publicId;
		node.systemId = systemId;
		// Introduced in DOM Level 2:
		//readonly attribute DOMString        internalSubset;
		
		//TODO:..
		//  readonly attribute NamedNodeMap     entities;
		//  readonly attribute NamedNodeMap     notations;
		return node;
	}
};


/**
 * @see http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html#ID-1950641247
 */

function Node() {
};

Node.prototype = {
	firstChild : null,
	lastChild : null,
	previousSibling : null,
	nextSibling : null,
	attributes : null,
	parentNode : null,
	childNodes : null,
	ownerDocument : null,
	nodeValue : null,
	namespaceURI : null,
	prefix : null,
	localName : null,
	// Modified in DOM Level 2:
	insertBefore:function(newChild, refChild){//raises 
		return _insertBefore(this,newChild,refChild);
	},
	replaceChild:function(newChild, oldChild){//raises 
		this.insertBefore(newChild,oldChild);
		if(oldChild){
			this.removeChild(oldChild);
		}
	},
	removeChild:function(oldChild){
		return _removeChild(this,oldChild);
	},
	appendChild:function(newChild){
		return this.insertBefore(newChild,null);
	},
	hasChildNodes:function(){
		return this.firstChild != null;
	},
	cloneNode:function(deep){
		return cloneNode(this.ownerDocument||this,this,deep);
	},
	// Modified in DOM Level 2:
	normalize:function(){
		var child = this.firstChild;
		while(child){
			var next = child.nextSibling;
			if(next && next.nodeType == TEXT_NODE && child.nodeType == TEXT_NODE){
				this.removeChild(next);
				child.appendData(next.data);
			}else{
				child.normalize();
				child = next;
			}
		}
	},
  	// Introduced in DOM Level 2:
	isSupported:function(feature, version){
		return this.ownerDocument.implementation.hasFeature(feature,version);
	},
    // Introduced in DOM Level 2:
    hasAttributes:function(){
    	return this.attributes.length>0;
    },
    lookupPrefix:function(namespaceURI){
    	var el = this;
    	while(el){
    		var map = el._nsMap;
    		//console.dir(map)
    		if(map){
    			for(var n in map){
    				if(map[n] == namespaceURI){
    					return n;
    				}
    			}
    		}
    		el = el.nodeType == ATTRIBUTE_NODE?el.ownerDocument : el.parentNode;
    	}
    	return null;
    },
    // Introduced in DOM Level 3:
    lookupNamespaceURI:function(prefix){
    	var el = this;
    	while(el){
    		var map = el._nsMap;
    		//console.dir(map)
    		if(map){
    			if(prefix in map){
    				return map[prefix] ;
    			}
    		}
    		el = el.nodeType == ATTRIBUTE_NODE?el.ownerDocument : el.parentNode;
    	}
    	return null;
    },
    // Introduced in DOM Level 3:
    isDefaultNamespace:function(namespaceURI){
    	var prefix = this.lookupPrefix(namespaceURI);
    	return prefix == null;
    }
};


function _xmlEncoder(c){
	return c == '<' && '&lt;' ||
         c == '>' && '&gt;' ||
         c == '&' && '&amp;' ||
         c == '"' && '&quot;' ||
         '&#'+c.charCodeAt()+';'
}


copy(NodeType,Node);
copy(NodeType,Node.prototype);

/**
 * @param callback return true for continue,false for break
 * @return boolean true: break visit;
 */
function _visitNode(node,callback){
	if(callback(node)){
		return true;
	}
	if(node = node.firstChild){
		do{
			if(_visitNode(node,callback)){return true}
        }while(node=node.nextSibling)
    }
}



function Document(){
}
function _onAddAttribute(doc,el,newAttr){
	doc && doc._inc++;
	var ns = newAttr.namespaceURI ;
	if(ns == 'http://www.w3.org/2000/xmlns/'){
		//update namespace
		el._nsMap[newAttr.prefix?newAttr.localName:''] = newAttr.value
	}
}
function _onRemoveAttribute(doc,el,newAttr,remove){
	doc && doc._inc++;
	var ns = newAttr.namespaceURI ;
	if(ns == 'http://www.w3.org/2000/xmlns/'){
		//update namespace
		delete el._nsMap[newAttr.prefix?newAttr.localName:'']
	}
}
function _onUpdateChild(doc,el,newChild){
	if(doc && doc._inc){
		doc._inc++;
		//update childNodes
		var cs = el.childNodes;
		if(newChild){
			cs[cs.length++] = newChild;
		}else{
			//console.log(1)
			var child = el.firstChild;
			var i = 0;
			while(child){
				cs[i++] = child;
				child =child.nextSibling;
			}
			cs.length = i;
		}
	}
}

/**
 * attributes;
 * children;
 * 
 * writeable properties:
 * nodeValue,Attr:value,CharacterData:data
 * prefix
 */
function _removeChild(parentNode,child){
	var previous = child.previousSibling;
	var next = child.nextSibling;
	if(previous){
		previous.nextSibling = next;
	}else{
		parentNode.firstChild = next
	}
	if(next){
		next.previousSibling = previous;
	}else{
		parentNode.lastChild = previous;
	}
	_onUpdateChild(parentNode.ownerDocument,parentNode);
	return child;
}
/**
 * preformance key(refChild == null)
 */
function _insertBefore(parentNode,newChild,nextChild){
	var cp = newChild.parentNode;
	if(cp){
		cp.removeChild(newChild);//remove and update
	}
	if(newChild.nodeType === DOCUMENT_FRAGMENT_NODE){
		var newFirst = newChild.firstChild;
		if (newFirst == null) {
			return newChild;
		}
		var newLast = newChild.lastChild;
	}else{
		newFirst = newLast = newChild;
	}
	var pre = nextChild ? nextChild.previousSibling : parentNode.lastChild;

	newFirst.previousSibling = pre;
	newLast.nextSibling = nextChild;
	
	
	if(pre){
		pre.nextSibling = newFirst;
	}else{
		parentNode.firstChild = newFirst;
	}
	if(nextChild == null){
		parentNode.lastChild = newLast;
	}else{
		nextChild.previousSibling = newLast;
	}
	do{
		newFirst.parentNode = parentNode;
	}while(newFirst !== newLast && (newFirst= newFirst.nextSibling))
	_onUpdateChild(parentNode.ownerDocument||parentNode,parentNode);
	//console.log(parentNode.lastChild.nextSibling == null)
	if (newChild.nodeType == DOCUMENT_FRAGMENT_NODE) {
		newChild.firstChild = newChild.lastChild = null;
	}
	return newChild;
}
function _appendSingleChild(parentNode,newChild){
	var cp = newChild.parentNode;
	if(cp){
		var pre = parentNode.lastChild;
		cp.removeChild(newChild);//remove and update
		var pre = parentNode.lastChild;
	}
	var pre = parentNode.lastChild;
	newChild.parentNode = parentNode;
	newChild.previousSibling = pre;
	newChild.nextSibling = null;
	if(pre){
		pre.nextSibling = newChild;
	}else{
		parentNode.firstChild = newChild;
	}
	parentNode.lastChild = newChild;
	_onUpdateChild(parentNode.ownerDocument,parentNode,newChild);
	return newChild;
	//console.log("__aa",parentNode.lastChild.nextSibling == null)
}
Document.prototype = {
	//implementation : null,
	nodeName :  '#document',
	nodeType :  DOCUMENT_NODE,
	doctype :  null,
	documentElement :  null,
	_inc : 1,
	
	insertBefore :  function(newChild, refChild){//raises 
		if(newChild.nodeType == DOCUMENT_FRAGMENT_NODE){
			var child = newChild.firstChild;
			while(child){
				var next = child.nextSibling;
				this.insertBefore(child,refChild);
				child = next;
			}
			return newChild;
		}
		if(this.documentElement == null && newChild.nodeType == ELEMENT_NODE){
			this.documentElement = newChild;
		}
		
		return _insertBefore(this,newChild,refChild),(newChild.ownerDocument = this),newChild;
	},
	removeChild :  function(oldChild){
		if(this.documentElement == oldChild){
			this.documentElement = null;
		}
		return _removeChild(this,oldChild);
	},
	// Introduced in DOM Level 2:
	importNode : function(importedNode,deep){
		return importNode(this,importedNode,deep);
	},
	// Introduced in DOM Level 2:
	getElementById :	function(id){
		var rtv = null;
		_visitNode(this.documentElement,function(node){
			if(node.nodeType == ELEMENT_NODE){
				if(node.getAttribute('id') == id){
					rtv = node;
					return true;
				}
			}
		})
		return rtv;
	},
	
	//document factory method:
	createElement :	function(tagName){
		var node = new Element();
		node.ownerDocument = this;
		node.nodeName = tagName;
		node.tagName = tagName;
		node.childNodes = new NodeList();
		var attrs	= node.attributes = new NamedNodeMap();
		attrs._ownerElement = node;
		return node;
	},
	createDocumentFragment :	function(){
		var node = new DocumentFragment();
		node.ownerDocument = this;
		node.childNodes = new NodeList();
		return node;
	},
	createTextNode :	function(data){
		var node = new Text();
		node.ownerDocument = this;
		node.appendData(data)
		return node;
	},
	createComment :	function(data){
		var node = new Comment();
		node.ownerDocument = this;
		node.appendData(data)
		return node;
	},
	createCDATASection :	function(data){
		var node = new CDATASection();
		node.ownerDocument = this;
		node.appendData(data)
		return node;
	},
	createProcessingInstruction :	function(target,data){
		var node = new ProcessingInstruction();
		node.ownerDocument = this;
		node.tagName = node.target = target;
		node.nodeValue= node.data = data;
		return node;
	},
	createAttribute :	function(name){
		var node = new Attr();
		node.ownerDocument	= this;
		node.name = name;
		node.nodeName	= name;
		node.localName = name;
		node.specified = true;
		return node;
	},
	createEntityReference :	function(name){
		var node = new EntityReference();
		node.ownerDocument	= this;
		node.nodeName	= name;
		return node;
	},
	// Introduced in DOM Level 2:
	createElementNS :	function(namespaceURI,qualifiedName){
		var node = new Element();
		var pl = qualifiedName.split(':');
		var attrs	= node.attributes = new NamedNodeMap();
		node.childNodes = new NodeList();
		node.ownerDocument = this;
		node.nodeName = qualifiedName;
		node.tagName = qualifiedName;
		node.namespaceURI = namespaceURI;
		if(pl.length == 2){
			node.prefix = pl[0];
			node.localName = pl[1];
		}else{
			//el.prefix = null;
			node.localName = qualifiedName;
		}
		attrs._ownerElement = node;
		return node;
	},
	// Introduced in DOM Level 2:
	createAttributeNS :	function(namespaceURI,qualifiedName){
		var node = new Attr();
		var pl = qualifiedName.split(':');
		node.ownerDocument = this;
		node.nodeName = qualifiedName;
		node.name = qualifiedName;
		node.namespaceURI = namespaceURI;
		node.specified = true;
		if(pl.length == 2){
			node.prefix = pl[0];
			node.localName = pl[1];
		}else{
			//el.prefix = null;
			node.localName = qualifiedName;
		}
		return node;
	}
};
_extends(Document,Node);


function Element() {
	this._nsMap = {};
};
Element.prototype = {
	nodeType : ELEMENT_NODE,
	hasAttribute : function(name){
		return this.getAttributeNode(name)!=null;
	},
	getAttribute : function(name){
		var attr = this.getAttributeNode(name);
		return attr && attr.value || '';
	},
	getAttributeNode : function(name){
		return this.attributes.getNamedItem(name);
	},
	setAttribute : function(name, value){
		var attr = this.ownerDocument.createAttribute(name);
		attr.value = attr.nodeValue = "" + value;
		this.setAttributeNode(attr)
	},
	removeAttribute : function(name){
		var attr = this.getAttributeNode(name)
		attr && this.removeAttributeNode(attr);
	},
	
	//four real opeartion method
	appendChild:function(newChild){
		if(newChild.nodeType === DOCUMENT_FRAGMENT_NODE){
			return this.insertBefore(newChild,null);
		}else{
			return _appendSingleChild(this,newChild);
		}
	},
	setAttributeNode : function(newAttr){
		return this.attributes.setNamedItem(newAttr);
	},
	setAttributeNodeNS : function(newAttr){
		return this.attributes.setNamedItemNS(newAttr);
	},
	removeAttributeNode : function(oldAttr){
		//console.log(this == oldAttr.ownerElement)
		return this.attributes.removeNamedItem(oldAttr.nodeName);
	},
	//get real attribute name,and remove it by removeAttributeNode
	removeAttributeNS : function(namespaceURI, localName){
		var old = this.getAttributeNodeNS(namespaceURI, localName);
		old && this.removeAttributeNode(old);
	},
	
	hasAttributeNS : function(namespaceURI, localName){
		return this.getAttributeNodeNS(namespaceURI, localName)!=null;
	},
	getAttributeNS : function(namespaceURI, localName){
		var attr = this.getAttributeNodeNS(namespaceURI, localName);
		return attr && attr.value || '';
	},
	setAttributeNS : function(namespaceURI, qualifiedName, value){
		var attr = this.ownerDocument.createAttributeNS(namespaceURI, qualifiedName);
		attr.value = attr.nodeValue = "" + value;
		this.setAttributeNode(attr)
	},
	getAttributeNodeNS : function(namespaceURI, localName){
		return this.attributes.getNamedItemNS(namespaceURI, localName);
	},
	
	getElementsByTagName : function(tagName){
		return new LiveNodeList(this,function(base){
			var ls = [];
			_visitNode(base,function(node){
				if(node !== base && node.nodeType == ELEMENT_NODE && (tagName === '*' || node.tagName == tagName)){
					ls.push(node);
				}
			});
			return ls;
		});
	},
	getElementsByTagNameNS : function(namespaceURI, localName){
		return new LiveNodeList(this,function(base){
			var ls = [];
			_visitNode(base,function(node){
				if(node !== base && node.nodeType === ELEMENT_NODE && (namespaceURI === '*' || node.namespaceURI === namespaceURI) && (localName === '*' || node.localName == localName)){
					ls.push(node);
				}
			});
			return ls;
			
		});
	}
};
Document.prototype.getElementsByTagName = Element.prototype.getElementsByTagName;
Document.prototype.getElementsByTagNameNS = Element.prototype.getElementsByTagNameNS;


_extends(Element,Node);
function Attr() {
};
Attr.prototype.nodeType = ATTRIBUTE_NODE;
_extends(Attr,Node);


function CharacterData() {
};
CharacterData.prototype = {
	data : '',
	substringData : function(offset, count) {
		return this.data.substring(offset, offset+count);
	},
	appendData: function(text) {
		text = this.data+text;
		this.nodeValue = this.data = text;
		this.length = text.length;
	},
	insertData: function(offset,text) {
		this.replaceData(offset,0,text);
	
	},
	appendChild:function(newChild){
		throw new Error(ExceptionMessage[HIERARCHY_REQUEST_ERR])
	},
	deleteData: function(offset, count) {
		this.replaceData(offset,count,"");
	},
	replaceData: function(offset, count, text) {
		var start = this.data.substring(0,offset);
		var end = this.data.substring(offset+count);
		text = start + text + end;
		this.nodeValue = this.data = text;
		this.length = text.length;
	}
}
_extends(CharacterData,Node);
function Text() {
};
Text.prototype = {
	nodeName : "#text",
	nodeType : TEXT_NODE,
	splitText : function(offset) {
		var text = this.data;
		var newText = text.substring(offset);
		text = text.substring(0, offset);
		this.data = this.nodeValue = text;
		this.length = text.length;
		var newNode = this.ownerDocument.createTextNode(newText);
		if(this.parentNode){
			this.parentNode.insertBefore(newNode, this.nextSibling);
		}
		return newNode;
	}
}
_extends(Text,CharacterData);
function Comment() {
};
Comment.prototype = {
	nodeName : "#comment",
	nodeType : COMMENT_NODE
}
_extends(Comment,CharacterData);

function CDATASection() {
};
CDATASection.prototype = {
	nodeName : "#cdata-section",
	nodeType : CDATA_SECTION_NODE
}
_extends(CDATASection,CharacterData);


function DocumentType() {
};
DocumentType.prototype.nodeType = DOCUMENT_TYPE_NODE;
_extends(DocumentType,Node);

function Notation() {
};
Notation.prototype.nodeType = NOTATION_NODE;
_extends(Notation,Node);

function Entity() {
};
Entity.prototype.nodeType = ENTITY_NODE;
_extends(Entity,Node);

function EntityReference() {
};
EntityReference.prototype.nodeType = ENTITY_REFERENCE_NODE;
_extends(EntityReference,Node);

function DocumentFragment() {
};
DocumentFragment.prototype.nodeName =	"#document-fragment";
DocumentFragment.prototype.nodeType =	DOCUMENT_FRAGMENT_NODE;
_extends(DocumentFragment,Node);


function ProcessingInstruction() {
}
ProcessingInstruction.prototype.nodeType = PROCESSING_INSTRUCTION_NODE;
_extends(ProcessingInstruction,Node);
function XMLSerializer(){}
XMLSerializer.prototype.serializeToString = function(node,isHtml,nodeFilter){
	return nodeSerializeToString.call(node,isHtml,nodeFilter);
}
Node.prototype.toString = nodeSerializeToString;
function nodeSerializeToString(isHtml,nodeFilter){
	var buf = [];
	var refNode = this.nodeType == 9?this.documentElement:this;
	var prefix = refNode.prefix;
	var uri = refNode.namespaceURI;
	
	if(uri && prefix == null){
		//console.log(prefix)
		var prefix = refNode.lookupPrefix(uri);
		if(prefix == null){
			//isHTML = true;
			var visibleNamespaces=[
			{namespace:uri,prefix:null}
			//{namespace:uri,prefix:''}
			]
		}
	}
	serializeToString(this,buf,isHtml,nodeFilter,visibleNamespaces);
	//console.log('###',this.nodeType,uri,prefix,buf.join(''))
	return buf.join('');
}
function needNamespaceDefine(node,isHTML, visibleNamespaces) {
	var prefix = node.prefix||'';
	var uri = node.namespaceURI;
	if (!prefix && !uri){
		return false;
	}
	if (prefix === "xml" && uri === "http://www.w3.org/XML/1998/namespace" 
		|| uri == 'http://www.w3.org/2000/xmlns/'){
		return false;
	}
	
	var i = visibleNamespaces.length 
	//console.log('@@@@',node.tagName,prefix,uri,visibleNamespaces)
	while (i--) {
		var ns = visibleNamespaces[i];
		// get namespace prefix
		//console.log(node.nodeType,node.tagName,ns.prefix,prefix)
		if (ns.prefix == prefix){
			return ns.namespace != uri;
		}
	}
	//console.log(isHTML,uri,prefix=='')
	//if(isHTML && prefix ==null && uri == 'http://www.w3.org/1999/xhtml'){
	//	return false;
	//}
	//node.flag = '11111'
	//console.error(3,true,node.flag,node.prefix,node.namespaceURI)
	return true;
}
function serializeToString(node,buf,isHTML,nodeFilter,visibleNamespaces){
	if(nodeFilter){
		node = nodeFilter(node);
		if(node){
			if(typeof node == 'string'){
				buf.push(node);
				return;
			}
		}else{
			return;
		}
		//buf.sort.apply(attrs, attributeSorter);
	}
	switch(node.nodeType){
	case ELEMENT_NODE:
		if (!visibleNamespaces) visibleNamespaces = [];
		var startVisibleNamespaces = visibleNamespaces.length;
		var attrs = node.attributes;
		var len = attrs.length;
		var child = node.firstChild;
		var nodeName = node.tagName;
		
		isHTML =  (htmlns === node.namespaceURI) ||isHTML 
		buf.push('<',nodeName);
		
		
		
		for(var i=0;i<len;i++){
			// add namespaces for attributes
			var attr = attrs.item(i);
			if (attr.prefix == 'xmlns') {
				visibleNamespaces.push({ prefix: attr.localName, namespace: attr.value });
			}else if(attr.nodeName == 'xmlns'){
				visibleNamespaces.push({ prefix: '', namespace: attr.value });
			}
		}
		for(var i=0;i<len;i++){
			var attr = attrs.item(i);
			if (needNamespaceDefine(attr,isHTML, visibleNamespaces)) {
				var prefix = attr.prefix||'';
				var uri = attr.namespaceURI;
				var ns = prefix ? ' xmlns:' + prefix : " xmlns";
				buf.push(ns, '="' , uri , '"');
				visibleNamespaces.push({ prefix: prefix, namespace:uri });
			}
			serializeToString(attr,buf,isHTML,nodeFilter,visibleNamespaces);
		}
		// add namespace for current node		
		if (needNamespaceDefine(node,isHTML, visibleNamespaces)) {
			var prefix = node.prefix||'';
			var uri = node.namespaceURI;
			var ns = prefix ? ' xmlns:' + prefix : " xmlns";
			buf.push(ns, '="' , uri , '"');
			visibleNamespaces.push({ prefix: prefix, namespace:uri });
		}
		
		if(child || isHTML && !/^(?:meta|link|img|br|hr|input)$/i.test(nodeName)){
			buf.push('>');
			//if is cdata child node
			if(isHTML && /^script$/i.test(nodeName)){
				while(child){
					if(child.data){
						buf.push(child.data);
					}else{
						serializeToString(child,buf,isHTML,nodeFilter,visibleNamespaces);
					}
					child = child.nextSibling;
				}
			}else
			{
				while(child){
					serializeToString(child,buf,isHTML,nodeFilter,visibleNamespaces);
					child = child.nextSibling;
				}
			}
			buf.push('</',nodeName,'>');
		}else{
			buf.push('/>');
		}
		// remove added visible namespaces
		//visibleNamespaces.length = startVisibleNamespaces;
		return;
	case DOCUMENT_NODE:
	case DOCUMENT_FRAGMENT_NODE:
		var child = node.firstChild;
		while(child){
			serializeToString(child,buf,isHTML,nodeFilter,visibleNamespaces);
			child = child.nextSibling;
		}
		return;
	case ATTRIBUTE_NODE:
		return buf.push(' ',node.name,'="',node.value.replace(/[<&"]/g,_xmlEncoder),'"');
	case TEXT_NODE:
		return buf.push(node.data.replace(/[<&]/g,_xmlEncoder));
	case CDATA_SECTION_NODE:
		return buf.push( '<![CDATA[',node.data,']]>');
	case COMMENT_NODE:
		return buf.push( "<!--",node.data,"-->");
	case DOCUMENT_TYPE_NODE:
		var pubid = node.publicId;
		var sysid = node.systemId;
		buf.push('<!DOCTYPE ',node.name);
		if(pubid){
			buf.push(' PUBLIC "',pubid);
			if (sysid && sysid!='.') {
				buf.push( '" "',sysid);
			}
			buf.push('">');
		}else if(sysid && sysid!='.'){
			buf.push(' SYSTEM "',sysid,'">');
		}else{
			var sub = node.internalSubset;
			if(sub){
				buf.push(" [",sub,"]");
			}
			buf.push(">");
		}
		return;
	case PROCESSING_INSTRUCTION_NODE:
		return buf.push( "<?",node.target," ",node.data,"?>");
	case ENTITY_REFERENCE_NODE:
		return buf.push( '&',node.nodeName,';');
	//case ENTITY_NODE:
	//case NOTATION_NODE:
	default:
		buf.push('??',node.nodeName);
	}
}
function importNode(doc,node,deep){
	var node2;
	switch (node.nodeType) {
	case ELEMENT_NODE:
		node2 = node.cloneNode(false);
		node2.ownerDocument = doc;
		//var attrs = node2.attributes;
		//var len = attrs.length;
		//for(var i=0;i<len;i++){
			//node2.setAttributeNodeNS(importNode(doc,attrs.item(i),deep));
		//}
	case DOCUMENT_FRAGMENT_NODE:
		break;
	case ATTRIBUTE_NODE:
		deep = true;
		break;
	//case ENTITY_REFERENCE_NODE:
	//case PROCESSING_INSTRUCTION_NODE:
	////case TEXT_NODE:
	//case CDATA_SECTION_NODE:
	//case COMMENT_NODE:
	//	deep = false;
	//	break;
	//case DOCUMENT_NODE:
	//case DOCUMENT_TYPE_NODE:
	//cannot be imported.
	//case ENTITY_NODE:
	//case NOTATION_NODE：
	//can not hit in level3
	//default:throw e;
	}
	if(!node2){
		node2 = node.cloneNode(false);//false
	}
	node2.ownerDocument = doc;
	node2.parentNode = null;
	if(deep){
		var child = node.firstChild;
		while(child){
			node2.appendChild(importNode(doc,child,deep));
			child = child.nextSibling;
		}
	}
	return node2;
}
//
//var _relationMap = {firstChild:1,lastChild:1,previousSibling:1,nextSibling:1,
//					attributes:1,childNodes:1,parentNode:1,documentElement:1,doctype,};
function cloneNode(doc,node,deep){
	var node2 = new node.constructor();
	for(var n in node){
		var v = node[n];
		if(typeof v != 'object' ){
			if(v != node2[n]){
				node2[n] = v;
			}
		}
	}
	if(node.childNodes){
		node2.childNodes = new NodeList();
	}
	node2.ownerDocument = doc;
	switch (node2.nodeType) {
	case ELEMENT_NODE:
		var attrs	= node.attributes;
		var attrs2	= node2.attributes = new NamedNodeMap();
		var len = attrs.length
		attrs2._ownerElement = node2;
		for(var i=0;i<len;i++){
			node2.setAttributeNode(cloneNode(doc,attrs.item(i),true));
		}
		break;;
	case ATTRIBUTE_NODE:
		deep = true;
	}
	if(deep){
		var child = node.firstChild;
		while(child){
			node2.appendChild(cloneNode(doc,child,deep));
			child = child.nextSibling;
		}
	}
	return node2;
}

function __set__(object,key,value){
	object[key] = value
}
//do dynamic
try{
	if(Object.defineProperty){
		Object.defineProperty(LiveNodeList.prototype,'length',{
			get:function(){
				_updateLiveList(this);
				return this.$$length;
			}
		});
		Object.defineProperty(Node.prototype,'textContent',{
			get:function(){
				return getTextContent(this);
			},
			set:function(data){
				switch(this.nodeType){
				case ELEMENT_NODE:
				case DOCUMENT_FRAGMENT_NODE:
					while(this.firstChild){
						this.removeChild(this.firstChild);
					}
					if(data || String(data)){
						this.appendChild(this.ownerDocument.createTextNode(data));
					}
					break;
				default:
					//TODO:
					this.data = data;
					this.value = data;
					this.nodeValue = data;
				}
			}
		})
		
		function getTextContent(node){
			switch(node.nodeType){
			case ELEMENT_NODE:
			case DOCUMENT_FRAGMENT_NODE:
				var buf = [];
				node = node.firstChild;
				while(node){
					if(node.nodeType!==7 && node.nodeType !==8){
						buf.push(getTextContent(node));
					}
					node = node.nextSibling;
				}
				return buf.join('');
			default:
				return node.nodeValue;
			}
		}
		__set__ = function(object,key,value){
			//console.log(value)
			object['$$'+key] = value
		}
	}
}catch(e){//ie8
}

//if(typeof require == 'function'){
	exports.DOMImplementation = DOMImplementation;
	exports.XMLSerializer = XMLSerializer;
//}


/***/ }),
/* 3 */
/***/ (function(module, exports) {

var initEvent = function (cos) {
    var listeners = {};
    var getList = function (action) {
        !listeners[action] && (listeners[action] = []);
        return listeners[action];
    };
    cos.on = function (action, callback) {
        getList(action).push(callback);
    };
    cos.off = function (action, callback) {
        var list = getList(action);
        for (var i = list.length - 1; i >= 0; i--) {
            callback === list[i] && list.splice(i, 1);
        }
    };
    cos.emit = function (action, data) {
        var list = getList(action).map(function (cb) {
            return cb;
        });
        for (var i = 0; i < list.length; i++) {
            list[i](data);
        }
    };
};

var EventProxy = function () {
    initEvent(this);
};

module.exports.init = initEvent;
module.exports.EventProxy = EventProxy;

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(0);
var event = __webpack_require__(3);
var task = __webpack_require__(16);
var base = __webpack_require__(15);
var advance = __webpack_require__(13);

var defaultOptions = {
    SecretId: '',
    SecretKey: '',
    XCosSecurityToken: '', // 使用临时密钥需要注意自行刷新 Token
    ChunkRetryTimes: 2,
    FileParallelLimit: 3,
    ChunkParallelLimit: 3,
    ChunkRetryTimes: 3,
    ChunkSize: 1024 * 1024,
    SliceSize: 1024 * 1024,
    CopyChunkParallelLimit: 20,
    CopyChunkSize: 1024 * 1024 * 10,
    CopySliceSize: 1024 * 1024 * 10,
    MaxPartNumber: 10000,
    ProgressInterval: 1000,
    UploadQueueSize: 10000,
    Domain: '',
    ServiceDomain: '',
    Protocol: '',
    CompatibilityMode: false,
    ForcePathStyle: false,
    CorrectClockSkew: true,
    SystemClockOffset: 0, // 单位毫秒，ms
};

// 对外暴露的类
var COS = function (options) {
    this.options = util.extend(util.clone(defaultOptions), options || {});
    this.options.FileParallelLimit = Math.max(1, this.options.FileParallelLimit);
    this.options.ChunkParallelLimit = Math.max(1, this.options.ChunkParallelLimit);
    this.options.ChunkRetryTimes = Math.max(0, this.options.ChunkRetryTimes);
    this.options.ChunkSize = Math.max(1024 * 1024, this.options.ChunkSize);
    this.options.CopyChunkParallelLimit = Math.max(1, this.options.CopyChunkParallelLimit);
    this.options.CopyChunkSize = Math.max(1024 * 1024, this.options.CopyChunkSize);
    this.options.CopySliceSize = Math.max(0, this.options.CopySliceSize);
    this.options.MaxPartNumber = Math.max(1024, Math.min(10000, this.options.MaxPartNumber));
    this.options.Timeout = Math.max(0, this.options.Timeout);
    if (this.options.AppId) {
        console.warn('warning: AppId has been deprecated, Please put it at the end of parameter Bucket(E.g: "test-1250000000").');
    }
    event.init(this);
    task.init(this);
};

base.init(COS, task);
advance.init(COS, task);

COS.getAuthorization = util.getAuth;
COS.version = '0.7.10';

module.exports = COS;


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

var COS = __webpack_require__(4);
module.exports = COS;

/***/ }),
/* 6 */
/***/ (function(module, exports) {

/*
 CryptoJS v3.1.2
 code.google.com/p/crypto-js
 (c) 2009-2013 by Jeff Mott. All rights reserved.
 code.google.com/p/crypto-js/wiki/License
 */
var CryptoJS=CryptoJS||function(g,l){var e={},d=e.lib={},m=function(){},k=d.Base={extend:function(a){m.prototype=this;var c=new m;a&&c.mixIn(a);c.hasOwnProperty("init")||(c.init=function(){c.$super.init.apply(this,arguments)});c.init.prototype=c;c.$super=this;return c},create:function(){var a=this.extend();a.init.apply(a,arguments);return a},init:function(){},mixIn:function(a){for(var c in a)a.hasOwnProperty(c)&&(this[c]=a[c]);a.hasOwnProperty("toString")&&(this.toString=a.toString)},clone:function(){return this.init.prototype.extend(this)}},
        p=d.WordArray=k.extend({init:function(a,c){a=this.words=a||[];this.sigBytes=c!=l?c:4*a.length},toString:function(a){return(a||n).stringify(this)},concat:function(a){var c=this.words,q=a.words,f=this.sigBytes;a=a.sigBytes;this.clamp();if(f%4)for(var b=0;b<a;b++)c[f+b>>>2]|=(q[b>>>2]>>>24-8*(b%4)&255)<<24-8*((f+b)%4);else if(65535<q.length)for(b=0;b<a;b+=4)c[f+b>>>2]=q[b>>>2];else c.push.apply(c,q);this.sigBytes+=a;return this},clamp:function(){var a=this.words,c=this.sigBytes;a[c>>>2]&=4294967295<<
            32-8*(c%4);a.length=g.ceil(c/4)},clone:function(){var a=k.clone.call(this);a.words=this.words.slice(0);return a},random:function(a){for(var c=[],b=0;b<a;b+=4)c.push(4294967296*g.random()|0);return new p.init(c,a)}}),b=e.enc={},n=b.Hex={stringify:function(a){var c=a.words;a=a.sigBytes;for(var b=[],f=0;f<a;f++){var d=c[f>>>2]>>>24-8*(f%4)&255;b.push((d>>>4).toString(16));b.push((d&15).toString(16))}return b.join("")},parse:function(a){for(var c=a.length,b=[],f=0;f<c;f+=2)b[f>>>3]|=parseInt(a.substr(f,
                2),16)<<24-4*(f%8);return new p.init(b,c/2)}},j=b.Latin1={stringify:function(a){var c=a.words;a=a.sigBytes;for(var b=[],f=0;f<a;f++)b.push(String.fromCharCode(c[f>>>2]>>>24-8*(f%4)&255));return b.join("")},parse:function(a){for(var c=a.length,b=[],f=0;f<c;f++)b[f>>>2]|=(a.charCodeAt(f)&255)<<24-8*(f%4);return new p.init(b,c)}},h=b.Utf8={stringify:function(a){try{return decodeURIComponent(escape(j.stringify(a)))}catch(c){throw Error("Malformed UTF-8 data");}},parse:function(a){return j.parse(unescape(encodeURIComponent(a)))}},
        r=d.BufferedBlockAlgorithm=k.extend({reset:function(){this._data=new p.init;this._nDataBytes=0},_append:function(a){"string"==typeof a&&(a=h.parse(a));this._data.concat(a);this._nDataBytes+=a.sigBytes},_process:function(a){var c=this._data,b=c.words,f=c.sigBytes,d=this.blockSize,e=f/(4*d),e=a?g.ceil(e):g.max((e|0)-this._minBufferSize,0);a=e*d;f=g.min(4*a,f);if(a){for(var k=0;k<a;k+=d)this._doProcessBlock(b,k);k=b.splice(0,a);c.sigBytes-=f}return new p.init(k,f)},clone:function(){var a=k.clone.call(this);
            a._data=this._data.clone();return a},_minBufferSize:0});d.Hasher=r.extend({cfg:k.extend(),init:function(a){this.cfg=this.cfg.extend(a);this.reset()},reset:function(){r.reset.call(this);this._doReset()},update:function(a){this._append(a);this._process();return this},finalize:function(a){a&&this._append(a);return this._doFinalize()},blockSize:16,_createHelper:function(a){return function(b,d){return(new a.init(d)).finalize(b)}},_createHmacHelper:function(a){return function(b,d){return(new s.HMAC.init(a,
        d)).finalize(b)}}});var s=e.algo={};return e}(Math);
(function(){var g=CryptoJS,l=g.lib,e=l.WordArray,d=l.Hasher,m=[],l=g.algo.SHA1=d.extend({_doReset:function(){this._hash=new e.init([1732584193,4023233417,2562383102,271733878,3285377520])},_doProcessBlock:function(d,e){for(var b=this._hash.words,n=b[0],j=b[1],h=b[2],g=b[3],l=b[4],a=0;80>a;a++){if(16>a)m[a]=d[e+a]|0;else{var c=m[a-3]^m[a-8]^m[a-14]^m[a-16];m[a]=c<<1|c>>>31}c=(n<<5|n>>>27)+l+m[a];c=20>a?c+((j&h|~j&g)+1518500249):40>a?c+((j^h^g)+1859775393):60>a?c+((j&h|j&g|h&g)-1894007588):c+((j^h^
g)-899497514);l=g;g=h;h=j<<30|j>>>2;j=n;n=c}b[0]=b[0]+n|0;b[1]=b[1]+j|0;b[2]=b[2]+h|0;b[3]=b[3]+g|0;b[4]=b[4]+l|0},_doFinalize:function(){var d=this._data,e=d.words,b=8*this._nDataBytes,g=8*d.sigBytes;e[g>>>5]|=128<<24-g%32;e[(g+64>>>9<<4)+14]=Math.floor(b/4294967296);e[(g+64>>>9<<4)+15]=b;d.sigBytes=4*e.length;this._process();return this._hash},clone:function(){var e=d.clone.call(this);e._hash=this._hash.clone();return e}});g.SHA1=d._createHelper(l);g.HmacSHA1=d._createHmacHelper(l)})();
(function(){var g=CryptoJS,l=g.enc.Utf8;g.algo.HMAC=g.lib.Base.extend({init:function(e,d){e=this._hasher=new e.init;"string"==typeof d&&(d=l.parse(d));var g=e.blockSize,k=4*g;d.sigBytes>k&&(d=e.finalize(d));d.clamp();for(var p=this._oKey=d.clone(),b=this._iKey=d.clone(),n=p.words,j=b.words,h=0;h<g;h++)n[h]^=1549556828,j[h]^=909522486;p.sigBytes=b.sigBytes=k;this.reset()},reset:function(){var e=this._hasher;e.reset();e.update(this._iKey)},update:function(e){this._hasher.update(e);return this},finalize:function(e){var d=
    this._hasher;e=d.finalize(e);d.reset();return d.finalize(this._oKey.clone().concat(e))}})})();


(function () {
    // Shortcuts
    var C = CryptoJS;
    var C_lib = C.lib;
    var WordArray = C_lib.WordArray;
    var C_enc = C.enc;

    /**
     * Base64 encoding strategy.
     */
    var Base64 = C_enc.Base64 = {
        /**
         * Converts a word array to a Base64 string.
         *
         * @param {WordArray} wordArray The word array.
         *
         * @return {string} The Base64 string.
         *
         * @static
         *
         * @example
         *
         *     var base64String = CryptoJS.enc.Base64.stringify(wordArray);
         */
        stringify: function (wordArray) {
            // Shortcuts
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var map = this._map;

            // Clamp excess bits
            wordArray.clamp();

            // Convert
            var base64Chars = [];
            for (var i = 0; i < sigBytes; i += 3) {
                var byte1 = (words[i >>> 2]       >>> (24 - (i % 4) * 8))       & 0xff;
                var byte2 = (words[(i + 1) >>> 2] >>> (24 - ((i + 1) % 4) * 8)) & 0xff;
                var byte3 = (words[(i + 2) >>> 2] >>> (24 - ((i + 2) % 4) * 8)) & 0xff;

                var triplet = (byte1 << 16) | (byte2 << 8) | byte3;

                for (var j = 0; (j < 4) && (i + j * 0.75 < sigBytes); j++) {
                    base64Chars.push(map.charAt((triplet >>> (6 * (3 - j))) & 0x3f));
                }
            }

            // Add padding
            var paddingChar = map.charAt(64);
            if (paddingChar) {
                while (base64Chars.length % 4) {
                    base64Chars.push(paddingChar);
                }
            }

            return base64Chars.join('');
        },

        /**
         * Converts a Base64 string to a word array.
         *
         * @param {string} base64Str The Base64 string.
         *
         * @return {WordArray} The word array.
         *
         * @static
         *
         * @example
         *
         *     var wordArray = CryptoJS.enc.Base64.parse(base64String);
         */
        parse: function (base64Str) {
            // Shortcuts
            var base64StrLength = base64Str.length;
            var map = this._map;

            // Ignore padding
            var paddingChar = map.charAt(64);
            if (paddingChar) {
                var paddingIndex = base64Str.indexOf(paddingChar);
                if (paddingIndex != -1) {
                    base64StrLength = paddingIndex;
                }
            }

            // Convert
            var words = [];
            var nBytes = 0;
            for (var i = 0; i < base64StrLength; i++) {
                if (i % 4) {
                    var bits1 = map.indexOf(base64Str.charAt(i - 1)) << ((i % 4) * 2);
                    var bits2 = map.indexOf(base64Str.charAt(i)) >>> (6 - (i % 4) * 2);
                    words[nBytes >>> 2] |= (bits1 | bits2) << (24 - (nBytes % 4) * 8);
                    nBytes++;
                }
            }

            return WordArray.create(words, nBytes);
        },

        _map: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='
    };
}());

module.exports = CryptoJS;


/***/ }),
/* 7 */
/***/ (function(module, exports) {

//copyright Ryan Day 2010 <http://ryanday.org>, Joscha Feth 2013 <http://www.feth.com> [MIT Licensed]

var element_start_char =
    "a-zA-Z_\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u00FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FFF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD";
var element_non_start_char = "\-.0-9\u00B7\u0300-\u036F\u203F\u2040";
var element_replace = new RegExp("^([^" + element_start_char + "])|^((x|X)(m|M)(l|L))|([^" + element_start_char + element_non_start_char + "])", "g");
var not_safe_in_xml = /[^\x09\x0A\x0D\x20-\xFF\x85\xA0-\uD7FF\uE000-\uFDCF\uFDE0-\uFFFD]/gm;

var objKeys = function (obj) {
    var l = [];
    if (obj instanceof Object) {
        for (var k in obj) {
            if (obj.hasOwnProperty(k)) {
                l.push(k);
            }
        }
    }
    return l;
};
var process_to_xml = function (node_data, options) {

    var makeNode = function (name, content, attributes, level, hasSubNodes) {
        var indent_value = options.indent !== undefined ? options.indent : "\t";
        var indent = options.prettyPrint ? '\n' + new Array(level).join(indent_value) : '';
        if (options.removeIllegalNameCharacters) {
            name = name.replace(element_replace, '_');
        }

        var node = [indent, '<', name, (attributes || '')];
        if (content && content.length > 0) {
            node.push('>')
            node.push(content);
            hasSubNodes && node.push(indent);
            node.push('</');
            node.push(name);
            node.push('>');
        } else {
            node.push('/>');
        }
        return node.join('');
    };

    return (function fn(node_data, node_descriptor, level) {
        var type = typeof node_data;
        if ((Array.isArray) ? Array.isArray(node_data) : node_data instanceof Array) {
            type = 'array';
        } else if (node_data instanceof Date) {
            type = 'date';
        }

        switch (type) {
            //if value is an array create child nodes from values
            case 'array':
                var ret = [];
                node_data.map(function (v) {
                    ret.push(fn(v, 1, level + 1));
                    //entries that are values of an array are the only ones that can be special node descriptors
                });
                options.prettyPrint && ret.push('\n');
                return ret.join('');
                break;

            case 'date':
                // cast dates to ISO 8601 date (soap likes it)
                return node_data.toJSON ? node_data.toJSON() : node_data + '';
                break;

            case 'object':
                var nodes = [];
                for (var name in node_data) {
                    if (node_data[name] instanceof Array) {
                        for (var j in node_data[name]) {
                            nodes.push(makeNode(name, fn(node_data[name][j], 0, level + 1), null, level + 1, objKeys(node_data[name][j]).length));
                        }
                    } else {
                        nodes.push(makeNode(name, fn(node_data[name], 0, level + 1), null, level + 1));
                    }
                }
                options.prettyPrint && nodes.length > 0 && nodes.push('\n');
                return nodes.join('');
                break;

            case 'function':
                return node_data();
                break;

            default:
                return options.escape ? esc(node_data) : '' + node_data;
        }

    }(node_data, 0, 0))
};


var xml_header = function (standalone) {
    var ret = ['<?xml version="1.0" encoding="UTF-8"'];

    if (standalone) {
        ret.push(' standalone="yes"');
    }
    ret.push('?>');

    return ret.join('');
};

function esc(str) {
    return ('' + str).replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/'/g, '&apos;')
        .replace(/"/g, '&quot;')
        .replace(not_safe_in_xml, '');
}

var json2xml = function (obj, options) {

    if (!options) {
        options = {
            xmlHeader: {
                standalone: true
            },
            prettyPrint: true,
            indent: "  "
        };
    }

    if (typeof obj == 'string') {
        try {
            obj = JSON.parse(obj.toString());
        } catch (e) {
            return false;
        }
    }

    var xmlheader = '';
    var docType = '';
    if (options) {
        if (typeof options == 'object') {
            // our config is an object

            if (options.xmlHeader) {
                // the user wants an xml header
                xmlheader = xml_header(!!options.xmlHeader.standalone);
            }

            if (typeof options.docType != 'undefined') {
                docType = '<!DOCTYPE ' + options.docType + '>'
            }
        } else {
            // our config is a boolean value, so just add xml header
            xmlheader = xml_header();
        }
    }
    options = options || {}

    var ret = [
        xmlheader,
        (options.prettyPrint && docType ? '\n' : ''),
        docType,
        process_to_xml(obj, options)
    ];
    return ret.join('').replace(/\n{2,}/g, '\n').replace(/\s+$/g, '');
};

module.exports = json2xml;

/***/ }),
/* 8 */
/***/ (function(module, exports) {

/**
 *
 *  MD5 (Message-Digest Algorithm)
 *  http://www.webtoolkit.info/
 *
 **/

var md5 = function (string) {

    function RotateLeft(lValue, iShiftBits) {
        return (lValue<<iShiftBits) | (lValue>>>(32-iShiftBits));
    }

    function AddUnsigned(lX,lY) {
        var lX4,lY4,lX8,lY8,lResult;
        lX8 = (lX & 0x80000000);
        lY8 = (lY & 0x80000000);
        lX4 = (lX & 0x40000000);
        lY4 = (lY & 0x40000000);
        lResult = (lX & 0x3FFFFFFF)+(lY & 0x3FFFFFFF);
        if (lX4 & lY4) {
            return (lResult ^ 0x80000000 ^ lX8 ^ lY8);
        }
        if (lX4 | lY4) {
            if (lResult & 0x40000000) {
                return (lResult ^ 0xC0000000 ^ lX8 ^ lY8);
            } else {
                return (lResult ^ 0x40000000 ^ lX8 ^ lY8);
            }
        } else {
            return (lResult ^ lX8 ^ lY8);
        }
    }

    function F(x,y,z) { return (x & y) | ((~x) & z); }
    function G(x,y,z) { return (x & z) | (y & (~z)); }
    function H(x,y,z) { return (x ^ y ^ z); }
    function I(x,y,z) { return (y ^ (x | (~z))); }

    function FF(a,b,c,d,x,s,ac) {
        a = AddUnsigned(a, AddUnsigned(AddUnsigned(F(b, c, d), x), ac));
        return AddUnsigned(RotateLeft(a, s), b);
    };

    function GG(a,b,c,d,x,s,ac) {
        a = AddUnsigned(a, AddUnsigned(AddUnsigned(G(b, c, d), x), ac));
        return AddUnsigned(RotateLeft(a, s), b);
    };

    function HH(a,b,c,d,x,s,ac) {
        a = AddUnsigned(a, AddUnsigned(AddUnsigned(H(b, c, d), x), ac));
        return AddUnsigned(RotateLeft(a, s), b);
    };

    function II(a,b,c,d,x,s,ac) {
        a = AddUnsigned(a, AddUnsigned(AddUnsigned(I(b, c, d), x), ac));
        return AddUnsigned(RotateLeft(a, s), b);
    };

    function ConvertToWordArray(string) {
        var lWordCount;
        var lMessageLength = string.length;
        var lNumberOfWords_temp1=lMessageLength + 8;
        var lNumberOfWords_temp2=(lNumberOfWords_temp1-(lNumberOfWords_temp1 % 64))/64;
        var lNumberOfWords = (lNumberOfWords_temp2+1)*16;
        var lWordArray=Array(lNumberOfWords-1);
        var lBytePosition = 0;
        var lByteCount = 0;
        while ( lByteCount < lMessageLength ) {
            lWordCount = (lByteCount-(lByteCount % 4))/4;
            lBytePosition = (lByteCount % 4)*8;
            lWordArray[lWordCount] = (lWordArray[lWordCount] | (string.charCodeAt(lByteCount)<<lBytePosition));
            lByteCount++;
        }
        lWordCount = (lByteCount-(lByteCount % 4))/4;
        lBytePosition = (lByteCount % 4)*8;
        lWordArray[lWordCount] = lWordArray[lWordCount] | (0x80<<lBytePosition);
        lWordArray[lNumberOfWords-2] = lMessageLength<<3;
        lWordArray[lNumberOfWords-1] = lMessageLength>>>29;
        return lWordArray;
    };

    function WordToHex(lValue) {
        var WordToHexValue="",WordToHexValue_temp="",lByte,lCount;
        for (lCount = 0;lCount<=3;lCount++) {
            lByte = (lValue>>>(lCount*8)) & 255;
            WordToHexValue_temp = "0" + lByte.toString(16);
            WordToHexValue = WordToHexValue + WordToHexValue_temp.substr(WordToHexValue_temp.length-2,2);
        }
        return WordToHexValue;
    };

    function Utf8Encode(string) {
        string = string.replace(/\r\n/g,"\n");
        var utftext = "";

        for (var n = 0; n < string.length; n++) {

            var c = string.charCodeAt(n);

            if (c < 128) {
                utftext += String.fromCharCode(c);
            }
            else if((c > 127) && (c < 2048)) {
                utftext += String.fromCharCode((c >> 6) | 192);
                utftext += String.fromCharCode((c & 63) | 128);
            }
            else {
                utftext += String.fromCharCode((c >> 12) | 224);
                utftext += String.fromCharCode(((c >> 6) & 63) | 128);
                utftext += String.fromCharCode((c & 63) | 128);
            }

        }

        return utftext;
    };

    var x=Array();
    var k,AA,BB,CC,DD,a,b,c,d;
    var S11=7, S12=12, S13=17, S14=22;
    var S21=5, S22=9 , S23=14, S24=20;
    var S31=4, S32=11, S33=16, S34=23;
    var S41=6, S42=10, S43=15, S44=21;

    string = Utf8Encode(string);

    x = ConvertToWordArray(string);

    a = 0x67452301; b = 0xEFCDAB89; c = 0x98BADCFE; d = 0x10325476;

    for (k=0;k<x.length;k+=16) {
        AA=a; BB=b; CC=c; DD=d;
        a=FF(a,b,c,d,x[k+0], S11,0xD76AA478);
        d=FF(d,a,b,c,x[k+1], S12,0xE8C7B756);
        c=FF(c,d,a,b,x[k+2], S13,0x242070DB);
        b=FF(b,c,d,a,x[k+3], S14,0xC1BDCEEE);
        a=FF(a,b,c,d,x[k+4], S11,0xF57C0FAF);
        d=FF(d,a,b,c,x[k+5], S12,0x4787C62A);
        c=FF(c,d,a,b,x[k+6], S13,0xA8304613);
        b=FF(b,c,d,a,x[k+7], S14,0xFD469501);
        a=FF(a,b,c,d,x[k+8], S11,0x698098D8);
        d=FF(d,a,b,c,x[k+9], S12,0x8B44F7AF);
        c=FF(c,d,a,b,x[k+10],S13,0xFFFF5BB1);
        b=FF(b,c,d,a,x[k+11],S14,0x895CD7BE);
        a=FF(a,b,c,d,x[k+12],S11,0x6B901122);
        d=FF(d,a,b,c,x[k+13],S12,0xFD987193);
        c=FF(c,d,a,b,x[k+14],S13,0xA679438E);
        b=FF(b,c,d,a,x[k+15],S14,0x49B40821);
        a=GG(a,b,c,d,x[k+1], S21,0xF61E2562);
        d=GG(d,a,b,c,x[k+6], S22,0xC040B340);
        c=GG(c,d,a,b,x[k+11],S23,0x265E5A51);
        b=GG(b,c,d,a,x[k+0], S24,0xE9B6C7AA);
        a=GG(a,b,c,d,x[k+5], S21,0xD62F105D);
        d=GG(d,a,b,c,x[k+10],S22,0x2441453);
        c=GG(c,d,a,b,x[k+15],S23,0xD8A1E681);
        b=GG(b,c,d,a,x[k+4], S24,0xE7D3FBC8);
        a=GG(a,b,c,d,x[k+9], S21,0x21E1CDE6);
        d=GG(d,a,b,c,x[k+14],S22,0xC33707D6);
        c=GG(c,d,a,b,x[k+3], S23,0xF4D50D87);
        b=GG(b,c,d,a,x[k+8], S24,0x455A14ED);
        a=GG(a,b,c,d,x[k+13],S21,0xA9E3E905);
        d=GG(d,a,b,c,x[k+2], S22,0xFCEFA3F8);
        c=GG(c,d,a,b,x[k+7], S23,0x676F02D9);
        b=GG(b,c,d,a,x[k+12],S24,0x8D2A4C8A);
        a=HH(a,b,c,d,x[k+5], S31,0xFFFA3942);
        d=HH(d,a,b,c,x[k+8], S32,0x8771F681);
        c=HH(c,d,a,b,x[k+11],S33,0x6D9D6122);
        b=HH(b,c,d,a,x[k+14],S34,0xFDE5380C);
        a=HH(a,b,c,d,x[k+1], S31,0xA4BEEA44);
        d=HH(d,a,b,c,x[k+4], S32,0x4BDECFA9);
        c=HH(c,d,a,b,x[k+7], S33,0xF6BB4B60);
        b=HH(b,c,d,a,x[k+10],S34,0xBEBFBC70);
        a=HH(a,b,c,d,x[k+13],S31,0x289B7EC6);
        d=HH(d,a,b,c,x[k+0], S32,0xEAA127FA);
        c=HH(c,d,a,b,x[k+3], S33,0xD4EF3085);
        b=HH(b,c,d,a,x[k+6], S34,0x4881D05);
        a=HH(a,b,c,d,x[k+9], S31,0xD9D4D039);
        d=HH(d,a,b,c,x[k+12],S32,0xE6DB99E5);
        c=HH(c,d,a,b,x[k+15],S33,0x1FA27CF8);
        b=HH(b,c,d,a,x[k+2], S34,0xC4AC5665);
        a=II(a,b,c,d,x[k+0], S41,0xF4292244);
        d=II(d,a,b,c,x[k+7], S42,0x432AFF97);
        c=II(c,d,a,b,x[k+14],S43,0xAB9423A7);
        b=II(b,c,d,a,x[k+5], S44,0xFC93A039);
        a=II(a,b,c,d,x[k+12],S41,0x655B59C3);
        d=II(d,a,b,c,x[k+3], S42,0x8F0CCC92);
        c=II(c,d,a,b,x[k+10],S43,0xFFEFF47D);
        b=II(b,c,d,a,x[k+1], S44,0x85845DD1);
        a=II(a,b,c,d,x[k+8], S41,0x6FA87E4F);
        d=II(d,a,b,c,x[k+15],S42,0xFE2CE6E0);
        c=II(c,d,a,b,x[k+6], S43,0xA3014314);
        b=II(b,c,d,a,x[k+13],S44,0x4E0811A1);
        a=II(a,b,c,d,x[k+4], S41,0xF7537E82);
        d=II(d,a,b,c,x[k+11],S42,0xBD3AF235);
        c=II(c,d,a,b,x[k+2], S43,0x2AD7D2BB);
        b=II(b,c,d,a,x[k+9], S44,0xEB86D391);
        a=AddUnsigned(a,AA);
        b=AddUnsigned(b,BB);
        c=AddUnsigned(c,CC);
        d=AddUnsigned(d,DD);
    }

    var temp = WordToHex(a)+WordToHex(b)+WordToHex(c)+WordToHex(d);

    return temp.toLowerCase();
}

module.exports = md5;

/***/ }),
/* 9 */
/***/ (function(module, exports) {

var obj2str = function (obj) {
    var i, key, val;
    var list = [];
    var keyList = Object.keys(obj);
    for (i = 0; i < keyList.length; i++) {
        key = keyList[i];
        val = obj[key] || '';
        list.push(key + '=' + encodeURIComponent(val));
    }
    return list.join('&');
};

var request = function (params, callback) {
    var filePath = params.filePath;
    var headers = params.headers || {};
    var url = params.url;
    var method = params.method;
    var onProgress = params.onProgress;
    var requestTask;

    var cb = function (err, response) {
        callback(err, {statusCode: response.statusCode, headers: response.header}, response.data);
    };

    if (filePath) {
        var fileKey;
        var m = url.match(/^(https?:\/\/[^/]+\/)([^/]*\/?)(.*)$/);
        if (params.pathStyle) {
            fileKey = decodeURIComponent(m[3] || '');
            url = m[1] + m[2];
        } else {
            fileKey = decodeURIComponent(m[2] + m[3] || '');
            url = m[1];
        }

        // 整理 postObject 参数
        var formData = {
            'key': fileKey,
            'success_action_status': 200,
            'Signature': headers.Authorization,
        };
        var headerKeys = [
            'Cache-Control',
            'Content-Type',
            'Content-Disposition',
            'Content-Encoding',
            'Expires',
            'x-cos-storage-class',
            'x-cos-security-token',
        ];
        for (var i in params.headers) {
            if (params.headers.hasOwnProperty(i) && (i.indexOf('x-cos-meta-') > -1 || headerKeys.indexOf(i) > -1)) {
                formData[i] = params.headers[i];
            }
        }
        headers['x-cos-acl'] && (formData.acl = headers['x-cos-acl']);
        !formData['Content-Type'] && (formData['Content-Type'] = '');

        var responseHeader = {};
        requestTask = wx.uploadFile({
            url: url,
            method: method,
            name: 'file',
            filePath: filePath,
            formData: formData,
            success: function (response) {
                !response.header && (response.header = responseHeader);
                cb(null, response);
            },
            fail: function (response) {
                cb(response.errMsg, response);
            }
        });

        requestTask.onHeadersReceived && requestTask.onHeadersReceived(function(res){
            responseHeader = res.header;
        });

        requestTask.onProgressUpdate(function (res) {
            onProgress({
                loaded: res.totalBytesSent,
                total: res.totalBytesExpectedToSend,
                progress: res.progress / 100
            });
        });
    } else {
        var qsStr = params.qs && obj2str(params.qs) || '';
        if (qsStr) {
            url += (url.indexOf('?') > -1 ? '&' : '?') + qsStr;
        }
        headers['Content-Length'] && (delete headers['Content-Length']);
        wx.request({
            url: url,
            method: method,
            header: headers,
            dataType: 'text',
            data: params.body,
            success: function (response) {
                cb(null, response);
            },
            fail: function (response) {
                cb(response.errMsg, response);
            }
        });
    }

    return requestTask;
};

module.exports = request;

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

/*
 Copyright 2011-2013 Abdulla Abdurakhmanov
 Original sources are available at https://code.google.com/p/x2js/

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
 */
var DOMParser = __webpack_require__(11).DOMParser;

var x2js = function (config) {
    'use strict';

    var VERSION = "1.2.0";

    config = config || {};
    initConfigDefaults();
    initRequiredPolyfills();

    function initConfigDefaults() {
        if(config.escapeMode === undefined) {
            config.escapeMode = true;
        }

        config.attributePrefix = config.attributePrefix || "_";
        config.arrayAccessForm = config.arrayAccessForm || "none";
        config.emptyNodeForm = config.emptyNodeForm || "text";

        if(config.enableToStringFunc === undefined) {
            config.enableToStringFunc = true;
        }
        config.arrayAccessFormPaths = config.arrayAccessFormPaths || [];
        if(config.skipEmptyTextNodesForObj === undefined) {
            config.skipEmptyTextNodesForObj = true;
        }
        if(config.stripWhitespaces === undefined) {
            config.stripWhitespaces = true;
        }
        config.datetimeAccessFormPaths = config.datetimeAccessFormPaths || [];

        if(config.useDoubleQuotes === undefined) {
            config.useDoubleQuotes = false;
        }

        config.xmlElementsFilter = config.xmlElementsFilter || [];
        config.jsonPropertiesFilter = config.jsonPropertiesFilter || [];

        if(config.keepCData === undefined) {
            config.keepCData = false;
        }
    }

    var DOMNodeTypes = {
        ELEMENT_NODE 	   : 1,
        TEXT_NODE    	   : 3,
        CDATA_SECTION_NODE : 4,
        COMMENT_NODE	   : 8,
        DOCUMENT_NODE 	   : 9
    };

    function initRequiredPolyfills() {
    }

    function getNodeLocalName( node ) {
        var nodeLocalName = node.localName;
        if(nodeLocalName == null) // Yeah, this is IE!!
            nodeLocalName = node.baseName;
        if(nodeLocalName == null || nodeLocalName=="") // =="" is IE too
            nodeLocalName = node.nodeName;
        return nodeLocalName;
    }

    function getNodePrefix(node) {
        return node.prefix;
    }

    function escapeXmlChars(str) {
        if(typeof(str) == "string")
            return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&apos;');
        else
            return str;
    }

    function unescapeXmlChars(str) {
        return str.replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace(/&quot;/g, '"').replace(/&apos;/g, "'").replace(/&amp;/g, '&');
    }

    function checkInStdFiltersArrayForm(stdFiltersArrayForm, obj, name, path) {
        var idx = 0;
        for(; idx < stdFiltersArrayForm.length; idx++) {
            var filterPath = stdFiltersArrayForm[idx];
            if( typeof filterPath === "string" ) {
                if(filterPath == path)
                    break;
            }
            else
            if( filterPath instanceof RegExp) {
                if(filterPath.test(path))
                    break;
            }
            else
            if( typeof filterPath === "function") {
                if(filterPath(obj, name, path))
                    break;
            }
        }
        return idx!=stdFiltersArrayForm.length;
    }

    function toArrayAccessForm(obj, childName, path) {
        switch(config.arrayAccessForm) {
            case "property":
                if(!(obj[childName] instanceof Array))
                    obj[childName+"_asArray"] = [obj[childName]];
                else
                    obj[childName+"_asArray"] = obj[childName];
                break;
            /*case "none":
             break;*/
        }

        if(!(obj[childName] instanceof Array) && config.arrayAccessFormPaths.length > 0) {
            if(checkInStdFiltersArrayForm(config.arrayAccessFormPaths, obj, childName, path)) {
                obj[childName] = [obj[childName]];
            }
        }
    }

    function fromXmlDateTime(prop) {
        // Implementation based up on http://stackoverflow.com/questions/8178598/xml-datetime-to-javascript-date-object
        // Improved to support full spec and optional parts
        var bits = prop.split(/[-T:+Z]/g);

        var d = new Date(bits[0], bits[1]-1, bits[2]);
        var secondBits = bits[5].split("\.");
        d.setHours(bits[3], bits[4], secondBits[0]);
        if(secondBits.length>1)
            d.setMilliseconds(secondBits[1]);

        // Get supplied time zone offset in minutes
        if(bits[6] && bits[7]) {
            var offsetMinutes = bits[6] * 60 + Number(bits[7]);
            var sign = /\d\d-\d\d:\d\d$/.test(prop)? '-' : '+';

            // Apply the sign
            offsetMinutes = 0 + (sign == '-'? -1 * offsetMinutes : offsetMinutes);

            // Apply offset and local timezone
            d.setMinutes(d.getMinutes() - offsetMinutes - d.getTimezoneOffset())
        }
        else
        if(prop.indexOf("Z", prop.length - 1) !== -1) {
            d = new Date(Date.UTC(d.getFullYear(), d.getMonth(), d.getDate(), d.getHours(), d.getMinutes(), d.getSeconds(), d.getMilliseconds()));
        }

        // d is now a local time equivalent to the supplied time
        return d;
    }

    function checkFromXmlDateTimePaths(value, childName, fullPath) {
        if(config.datetimeAccessFormPaths.length > 0) {
            var path = fullPath.split("\.#")[0];
            if(checkInStdFiltersArrayForm(config.datetimeAccessFormPaths, value, childName, path)) {
                return fromXmlDateTime(value);
            }
            else
                return value;
        }
        else
            return value;
    }

    function checkXmlElementsFilter(obj, childType, childName, childPath) {
        if( childType == DOMNodeTypes.ELEMENT_NODE && config.xmlElementsFilter.length > 0) {
            return checkInStdFiltersArrayForm(config.xmlElementsFilter, obj, childName, childPath);
        }
        else
            return true;
    }

    function parseDOMChildren( node, path ) {
        if(node.nodeType == DOMNodeTypes.DOCUMENT_NODE) {
            var result = new Object;
            var nodeChildren = node.childNodes;
            // Alternative for firstElementChild which is not supported in some environments
            for(var cidx=0; cidx <nodeChildren.length; cidx++) {
                var child = nodeChildren.item(cidx);
                if(child.nodeType == DOMNodeTypes.ELEMENT_NODE) {
                    var childName = getNodeLocalName(child);
                    result[childName] = parseDOMChildren(child, childName);
                }
            }
            return result;
        }
        else
        if(node.nodeType == DOMNodeTypes.ELEMENT_NODE) {
            var result = new Object;
            result.__cnt=0;

            var nodeChildren = node.childNodes;

            // Children nodes
            for(var cidx=0; cidx <nodeChildren.length; cidx++) {
                var child = nodeChildren.item(cidx); // nodeChildren[cidx];
                var childName = getNodeLocalName(child);

                if(child.nodeType!= DOMNodeTypes.COMMENT_NODE) {
                    var childPath = path+"."+childName;
                    if (checkXmlElementsFilter(result,child.nodeType,childName,childPath)) {
                        result.__cnt++;
                        if(result[childName] == null) {
                            result[childName] = parseDOMChildren(child, childPath);
                            toArrayAccessForm(result, childName, childPath);
                        }
                        else {
                            if(result[childName] != null) {
                                if( !(result[childName] instanceof Array)) {
                                    result[childName] = [result[childName]];
                                    toArrayAccessForm(result, childName, childPath);
                                }
                            }
                            (result[childName])[result[childName].length] = parseDOMChildren(child, childPath);
                        }
                    }
                }
            }

            // Attributes
            for(var aidx=0; aidx <node.attributes.length; aidx++) {
                var attr = node.attributes.item(aidx); // [aidx];
                result.__cnt++;
                result[config.attributePrefix+attr.name]=attr.value;
            }

            // Node namespace prefix
            var nodePrefix = getNodePrefix(node);
            if(nodePrefix!=null && nodePrefix!="") {
                result.__cnt++;
                result.__prefix=nodePrefix;
            }

            if(result["#text"]!=null) {
                result.__text = result["#text"];
                if(result.__text instanceof Array) {
                    result.__text = result.__text.join("\n");
                }
                //if(config.escapeMode)
                //	result.__text = unescapeXmlChars(result.__text);
                if(config.stripWhitespaces)
                    result.__text = result.__text.trim();
                delete result["#text"];
                if(config.arrayAccessForm=="property")
                    delete result["#text_asArray"];
                result.__text = checkFromXmlDateTimePaths(result.__text, childName, path+"."+childName);
            }
            if(result["#cdata-section"]!=null) {
                result.__cdata = result["#cdata-section"];
                delete result["#cdata-section"];
                if(config.arrayAccessForm=="property")
                    delete result["#cdata-section_asArray"];
            }

            if( result.__cnt == 0 && config.emptyNodeForm=="text" ) {
                result = '';
            }
            else
            if( result.__cnt == 1 && result.__text!=null  ) {
                result = result.__text;
            }
            else
            if( result.__cnt == 1 && result.__cdata!=null && !config.keepCData  ) {
                result = result.__cdata;
            }
            else
            if ( result.__cnt > 1 && result.__text!=null && config.skipEmptyTextNodesForObj) {
                if( (config.stripWhitespaces && result.__text=="") || (result.__text.trim()=="")) {
                    delete result.__text;
                }
            }
            delete result.__cnt;

            if( config.enableToStringFunc && (result.__text!=null || result.__cdata!=null )) {
                result.toString = function() {
                    return (this.__text!=null? this.__text:'')+( this.__cdata!=null ? this.__cdata:'');
                };
            }

            return result;
        }
        else
        if(node.nodeType == DOMNodeTypes.TEXT_NODE || node.nodeType == DOMNodeTypes.CDATA_SECTION_NODE) {
            return node.nodeValue;
        }
    }

    function startTag(jsonObj, element, attrList, closed) {
        var resultStr = "<"+ ( (jsonObj!=null && jsonObj.__prefix!=null)? (jsonObj.__prefix+":"):"") + element;
        if(attrList!=null) {
            for(var aidx = 0; aidx < attrList.length; aidx++) {
                var attrName = attrList[aidx];
                var attrVal = jsonObj[attrName];
                if(config.escapeMode)
                    attrVal=escapeXmlChars(attrVal);
                resultStr+=" "+attrName.substr(config.attributePrefix.length)+"=";
                if(config.useDoubleQuotes)
                    resultStr+='"'+attrVal+'"';
                else
                    resultStr+="'"+attrVal+"'";
            }
        }
        if(!closed)
            resultStr+=">";
        else
            resultStr+="/>";
        return resultStr;
    }

    function endTag(jsonObj,elementName) {
        return "</"+ (jsonObj.__prefix!=null? (jsonObj.__prefix+":"):"")+elementName+">";
    }

    function endsWith(str, suffix) {
        return str.indexOf(suffix, str.length - suffix.length) !== -1;
    }

    function jsonXmlSpecialElem ( jsonObj, jsonObjField ) {
        if((config.arrayAccessForm=="property" && endsWith(jsonObjField.toString(),("_asArray")))
            || jsonObjField.toString().indexOf(config.attributePrefix)==0
            || jsonObjField.toString().indexOf("__")==0
            || (jsonObj[jsonObjField] instanceof Function) )
            return true;
        else
            return false;
    }

    function jsonXmlElemCount ( jsonObj ) {
        var elementsCnt = 0;
        if(jsonObj instanceof Object ) {
            for( var it in jsonObj  ) {
                if(jsonXmlSpecialElem ( jsonObj, it) )
                    continue;
                elementsCnt++;
            }
        }
        return elementsCnt;
    }

    function checkJsonObjPropertiesFilter(jsonObj, propertyName, jsonObjPath) {
        return config.jsonPropertiesFilter.length == 0
            || jsonObjPath==""
            || checkInStdFiltersArrayForm(config.jsonPropertiesFilter, jsonObj, propertyName, jsonObjPath);
    }

    function parseJSONAttributes ( jsonObj ) {
        var attrList = [];
        if(jsonObj instanceof Object ) {
            for( var ait in jsonObj  ) {
                if(ait.toString().indexOf("__")== -1 && ait.toString().indexOf(config.attributePrefix)==0) {
                    attrList.push(ait);
                }
            }
        }
        return attrList;
    }

    function parseJSONTextAttrs ( jsonTxtObj ) {
        var result ="";

        if(jsonTxtObj.__cdata!=null) {
            result+="<![CDATA["+jsonTxtObj.__cdata+"]]>";
        }

        if(jsonTxtObj.__text!=null) {
            if(config.escapeMode)
                result+=escapeXmlChars(jsonTxtObj.__text);
            else
                result+=jsonTxtObj.__text;
        }
        return result;
    }

    function parseJSONTextObject ( jsonTxtObj ) {
        var result ="";

        if( jsonTxtObj instanceof Object ) {
            result+=parseJSONTextAttrs ( jsonTxtObj );
        }
        else
        if(jsonTxtObj!=null) {
            if(config.escapeMode)
                result+=escapeXmlChars(jsonTxtObj);
            else
                result+=jsonTxtObj;
        }

        return result;
    }

    function getJsonPropertyPath(jsonObjPath, jsonPropName) {
        if (jsonObjPath==="") {
            return jsonPropName;
        }
        else
            return jsonObjPath+"."+jsonPropName;
    }

    function parseJSONArray ( jsonArrRoot, jsonArrObj, attrList, jsonObjPath ) {
        var result = "";
        if(jsonArrRoot.length == 0) {
            result+=startTag(jsonArrRoot, jsonArrObj, attrList, true);
        }
        else {
            for(var arIdx = 0; arIdx < jsonArrRoot.length; arIdx++) {
                result+=startTag(jsonArrRoot[arIdx], jsonArrObj, parseJSONAttributes(jsonArrRoot[arIdx]), false);
                result+=parseJSONObject(jsonArrRoot[arIdx], getJsonPropertyPath(jsonObjPath,jsonArrObj));
                result+=endTag(jsonArrRoot[arIdx],jsonArrObj);
            }
        }
        return result;
    }

    function parseJSONObject ( jsonObj, jsonObjPath ) {
        var result = "";

        var elementsCnt = jsonXmlElemCount ( jsonObj );

        if(elementsCnt > 0) {
            for( var it in jsonObj ) {

                if(jsonXmlSpecialElem ( jsonObj, it) || (jsonObjPath!="" && !checkJsonObjPropertiesFilter(jsonObj, it, getJsonPropertyPath(jsonObjPath,it))) )
                    continue;

                var subObj = jsonObj[it];

                var attrList = parseJSONAttributes( subObj )

                if(subObj == null || subObj == undefined) {
                    result+=startTag(subObj, it, attrList, true);
                }
                else
                if(subObj instanceof Object) {

                    if(subObj instanceof Array) {
                        result+=parseJSONArray( subObj, it, attrList, jsonObjPath );
                    }
                    else if(subObj instanceof Date) {
                        result+=startTag(subObj, it, attrList, false);
                        result+=subObj.toISOString();
                        result+=endTag(subObj,it);
                    }
                    else {
                        var subObjElementsCnt = jsonXmlElemCount ( subObj );
                        if(subObjElementsCnt > 0 || subObj.__text!=null || subObj.__cdata!=null) {
                            result+=startTag(subObj, it, attrList, false);
                            result+=parseJSONObject(subObj, getJsonPropertyPath(jsonObjPath,it));
                            result+=endTag(subObj,it);
                        }
                        else {
                            result+=startTag(subObj, it, attrList, true);
                        }
                    }
                }
                else {
                    result+=startTag(subObj, it, attrList, false);
                    result+=parseJSONTextObject(subObj);
                    result+=endTag(subObj,it);
                }
            }
        }
        result+=parseJSONTextObject(jsonObj);

        return result;
    }

    this.parseXmlString = function(xmlDocStr) {
        // var isIEParser = window.ActiveXObject || "ActiveXObject" in window;
        var isIEParser = false;
        if (xmlDocStr === undefined) {
            return null;
        }
        var xmlDoc;
        if (DOMParser) {
            var parser=new DOMParser();
            var parsererrorNS = null;
            // IE9+ now is here
            if(!isIEParser) {
                try {
                    parsererrorNS = parser.parseFromString("INVALID", "text/xml").getElementsByTagName("parsererror")[0].namespaceURI;
                }
                catch(err) {
                    parsererrorNS = null;
                }
            }
            try {
                xmlDoc = parser.parseFromString( xmlDocStr, "text/xml" );
                if( parsererrorNS!= null && xmlDoc.getElementsByTagNameNS(parsererrorNS, "parsererror").length > 0) {
                    //throw new Error('Error parsing XML: '+xmlDocStr);
                    xmlDoc = null;
                }
            }
            catch(err) {
                xmlDoc = null;
            }
        }
        else {
            // IE :(
            if(xmlDocStr.indexOf("<?")==0) {
                xmlDocStr = xmlDocStr.substr( xmlDocStr.indexOf("?>") + 2 );
            }
            xmlDoc=new ActiveXObject("Microsoft.XMLDOM");
            xmlDoc.async="false";
            xmlDoc.loadXML(xmlDocStr);
        }
        return xmlDoc;
    };

    this.asArray = function(prop) {
        if (prop === undefined || prop == null)
            return [];
        else
        if(prop instanceof Array)
            return prop;
        else
            return [prop];
    };

    this.toXmlDateTime = function(dt) {
        if(dt instanceof Date)
            return dt.toISOString();
        else
        if(typeof(dt) === 'number' )
            return new Date(dt).toISOString();
        else
            return null;
    };

    this.asDateTime = function(prop) {
        if(typeof(prop) == "string") {
            return fromXmlDateTime(prop);
        }
        else
            return prop;
    };

    this.xml2json = function (xmlDoc) {
        return parseDOMChildren ( xmlDoc );
    };

    this.xml_str2json = function (xmlDocStr) {
        var xmlDoc = this.parseXmlString(xmlDocStr);
        if(xmlDoc!=null)
            return this.xml2json(xmlDoc);
        else
            return null;
    };

    this.json2xml_str = function (jsonObj) {
        return parseJSONObject ( jsonObj, "" );
    };

    this.json2xml = function (jsonObj) {
        var xmlDocStr = this.json2xml_str (jsonObj);
        return this.parseXmlString(xmlDocStr);
    };

    this.getVersion = function () {
        return VERSION;
    };
};

var xml2json = function (str) {
    if (!str) return null;
    var parser = new DOMParser();
    var xmlDoc = parser.parseFromString(str, "text/xml");
    var x2jsObj = new x2js();
    var data = x2jsObj.xml2json(xmlDoc);
    if (data.html && data.getElementsByTagName('parsererror').length) {
        return null;
    } else {
        return data;
    }
};

var json2xml = function (data) {
    var x2jsObj = new x2js();
    return x2jsObj.json2xml(data);
};

module.exports = xml2json;

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

function DOMParser(options){
	this.options = options ||{locator:{}};
	
}
DOMParser.prototype.parseFromString = function(source,mimeType){
	var options = this.options;
	var sax =  new XMLReader();
	var domBuilder = options.domBuilder || new DOMHandler();//contentHandler and LexicalHandler
	var errorHandler = options.errorHandler;
	var locator = options.locator;
	var defaultNSMap = options.xmlns||{};
	var entityMap = {'lt':'<','gt':'>','amp':'&','quot':'"','apos':"'"}
	if(locator){
		domBuilder.setDocumentLocator(locator)
	}
	
	sax.errorHandler = buildErrorHandler(errorHandler,domBuilder,locator);
	sax.domBuilder = options.domBuilder || domBuilder;
	if(/\/x?html?$/.test(mimeType)){
		entityMap.nbsp = '\xa0';
		entityMap.copy = '\xa9';
		defaultNSMap['']= 'http://www.w3.org/1999/xhtml';
	}
	defaultNSMap.xml = defaultNSMap.xml || 'http://www.w3.org/XML/1998/namespace';
	if(source){
		sax.parse(source,defaultNSMap,entityMap);
	}else{
		sax.errorHandler.error("invalid doc source");
	}
	return domBuilder.doc;
}
function buildErrorHandler(errorImpl,domBuilder,locator){
	if(!errorImpl){
		if(domBuilder instanceof DOMHandler){
			return domBuilder;
		}
		errorImpl = domBuilder ;
	}
	var errorHandler = {}
	var isCallback = errorImpl instanceof Function;
	locator = locator||{}
	function build(key){
		var fn = errorImpl[key];
		if(!fn && isCallback){
			fn = errorImpl.length == 2?function(msg){errorImpl(key,msg)}:errorImpl;
		}
		errorHandler[key] = fn && function(msg){
			fn('[xmldom '+key+']\t'+msg+_locator(locator));
		}||function(){};
	}
	build('warning');
	build('error');
	build('fatalError');
	return errorHandler;
}

//console.log('#\n\n\n\n\n\n\n####')
/**
 * +ContentHandler+ErrorHandler
 * +LexicalHandler+EntityResolver2
 * -DeclHandler-DTDHandler 
 * 
 * DefaultHandler:EntityResolver, DTDHandler, ContentHandler, ErrorHandler
 * DefaultHandler2:DefaultHandler,LexicalHandler, DeclHandler, EntityResolver2
 * @link http://www.saxproject.org/apidoc/org/xml/sax/helpers/DefaultHandler.html
 */
function DOMHandler() {
    this.cdata = false;
}
function position(locator,node){
	node.lineNumber = locator.lineNumber;
	node.columnNumber = locator.columnNumber;
}
/**
 * @see org.xml.sax.ContentHandler#startDocument
 * @link http://www.saxproject.org/apidoc/org/xml/sax/ContentHandler.html
 */ 
DOMHandler.prototype = {
	startDocument : function() {
    	this.doc = new DOMImplementation().createDocument(null, null, null);
    	if (this.locator) {
        	this.doc.documentURI = this.locator.systemId;
    	}
	},
	startElement:function(namespaceURI, localName, qName, attrs) {
		var doc = this.doc;
	    var el = doc.createElementNS(namespaceURI, qName||localName);
	    var len = attrs.length;
	    appendElement(this, el);
	    this.currentElement = el;
	    
		this.locator && position(this.locator,el)
	    for (var i = 0 ; i < len; i++) {
	        var namespaceURI = attrs.getURI(i);
	        var value = attrs.getValue(i);
	        var qName = attrs.getQName(i);
			var attr = doc.createAttributeNS(namespaceURI, qName);
			this.locator &&position(attrs.getLocator(i),attr);
			attr.value = attr.nodeValue = value;
			el.setAttributeNode(attr)
	    }
	},
	endElement:function(namespaceURI, localName, qName) {
		var current = this.currentElement
		var tagName = current.tagName;
		this.currentElement = current.parentNode;
	},
	startPrefixMapping:function(prefix, uri) {
	},
	endPrefixMapping:function(prefix) {
	},
	processingInstruction:function(target, data) {
	    var ins = this.doc.createProcessingInstruction(target, data);
	    this.locator && position(this.locator,ins)
	    appendElement(this, ins);
	},
	ignorableWhitespace:function(ch, start, length) {
	},
	characters:function(chars, start, length) {
		chars = _toString.apply(this,arguments)
		//console.log(chars)
		if(chars){
			if (this.cdata) {
				var charNode = this.doc.createCDATASection(chars);
			} else {
				var charNode = this.doc.createTextNode(chars);
			}
			if(this.currentElement){
				this.currentElement.appendChild(charNode);
			}else if(/^\s*$/.test(chars)){
				this.doc.appendChild(charNode);
				//process xml
			}
			this.locator && position(this.locator,charNode)
		}
	},
	skippedEntity:function(name) {
	},
	endDocument:function() {
		this.doc.normalize();
	},
	setDocumentLocator:function (locator) {
	    if(this.locator = locator){// && !('lineNumber' in locator)){
	    	locator.lineNumber = 0;
	    }
	},
	//LexicalHandler
	comment:function(chars, start, length) {
		chars = _toString.apply(this,arguments)
	    var comm = this.doc.createComment(chars);
	    this.locator && position(this.locator,comm)
	    appendElement(this, comm);
	},
	
	startCDATA:function() {
	    //used in characters() methods
	    this.cdata = true;
	},
	endCDATA:function() {
	    this.cdata = false;
	},
	
	startDTD:function(name, publicId, systemId) {
		var impl = this.doc.implementation;
	    if (impl && impl.createDocumentType) {
	        var dt = impl.createDocumentType(name, publicId, systemId);
	        this.locator && position(this.locator,dt)
	        appendElement(this, dt);
	    }
	},
	/**
	 * @see org.xml.sax.ErrorHandler
	 * @link http://www.saxproject.org/apidoc/org/xml/sax/ErrorHandler.html
	 */
	warning:function(error) {
		console.warn('[xmldom warning]\t'+error,_locator(this.locator));
	},
	error:function(error) {
		console.error('[xmldom error]\t'+error,_locator(this.locator));
	},
	fatalError:function(error) {
		console.error('[xmldom fatalError]\t'+error,_locator(this.locator));
	    throw error;
	}
}
function _locator(l){
	if(l){
		return '\n@'+(l.systemId ||'')+'#[line:'+l.lineNumber+',col:'+l.columnNumber+']'
	}
}
function _toString(chars,start,length){
	if(typeof chars == 'string'){
		return chars.substr(start,length)
	}else{//java sax connect width xmldom on rhino(what about: "? && !(chars instanceof String)")
		if(chars.length >= start+length || start){
			return new java.lang.String(chars,start,length)+'';
		}
		return chars;
	}
}

/*
 * @link http://www.saxproject.org/apidoc/org/xml/sax/ext/LexicalHandler.html
 * used method of org.xml.sax.ext.LexicalHandler:
 *  #comment(chars, start, length)
 *  #startCDATA()
 *  #endCDATA()
 *  #startDTD(name, publicId, systemId)
 *
 *
 * IGNORED method of org.xml.sax.ext.LexicalHandler:
 *  #endDTD()
 *  #startEntity(name)
 *  #endEntity(name)
 *
 *
 * @link http://www.saxproject.org/apidoc/org/xml/sax/ext/DeclHandler.html
 * IGNORED method of org.xml.sax.ext.DeclHandler
 * 	#attributeDecl(eName, aName, type, mode, value)
 *  #elementDecl(name, model)
 *  #externalEntityDecl(name, publicId, systemId)
 *  #internalEntityDecl(name, value)
 * @link http://www.saxproject.org/apidoc/org/xml/sax/ext/EntityResolver2.html
 * IGNORED method of org.xml.sax.EntityResolver2
 *  #resolveEntity(String name,String publicId,String baseURI,String systemId)
 *  #resolveEntity(publicId, systemId)
 *  #getExternalSubset(name, baseURI)
 * @link http://www.saxproject.org/apidoc/org/xml/sax/DTDHandler.html
 * IGNORED method of org.xml.sax.DTDHandler
 *  #notationDecl(name, publicId, systemId) {};
 *  #unparsedEntityDecl(name, publicId, systemId, notationName) {};
 */
"endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl".replace(/\w+/g,function(key){
	DOMHandler.prototype[key] = function(){return null}
})

/* Private static helpers treated below as private instance methods, so don't need to add these to the public API; we might use a Relator to also get rid of non-standard public properties */
function appendElement (hander,node) {
    if (!hander.currentElement) {
        hander.doc.appendChild(node);
    } else {
        hander.currentElement.appendChild(node);
    }
}//appendChild and setAttributeNS are preformance key

//if(typeof require == 'function'){
	var XMLReader = __webpack_require__(12).XMLReader;
	var DOMImplementation = exports.DOMImplementation = __webpack_require__(2).DOMImplementation;
	exports.XMLSerializer = __webpack_require__(2).XMLSerializer ;
	exports.DOMParser = DOMParser;
//}


/***/ }),
/* 12 */
/***/ (function(module, exports) {

//[4]   	NameStartChar	   ::=   	":" | [A-Z] | "_" | [a-z] | [#xC0-#xD6] | [#xD8-#xF6] | [#xF8-#x2FF] | [#x370-#x37D] | [#x37F-#x1FFF] | [#x200C-#x200D] | [#x2070-#x218F] | [#x2C00-#x2FEF] | [#x3001-#xD7FF] | [#xF900-#xFDCF] | [#xFDF0-#xFFFD] | [#x10000-#xEFFFF]
//[4a]   	NameChar	   ::=   	NameStartChar | "-" | "." | [0-9] | #xB7 | [#x0300-#x036F] | [#x203F-#x2040]
//[5]   	Name	   ::=   	NameStartChar (NameChar)*
var nameStartChar = /[A-Z_a-z\xC0-\xD6\xD8-\xF6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]///\u10000-\uEFFFF
var nameChar = new RegExp("[\\-\\.0-9"+nameStartChar.source.slice(1,-1)+"\\u00B7\\u0300-\\u036F\\u203F-\\u2040]");
var tagNamePattern = new RegExp('^'+nameStartChar.source+nameChar.source+'*(?:\:'+nameStartChar.source+nameChar.source+'*)?$');
//var tagNamePattern = /^[a-zA-Z_][\w\-\.]*(?:\:[a-zA-Z_][\w\-\.]*)?$/
//var handlers = 'resolveEntity,getExternalSubset,characters,endDocument,endElement,endPrefixMapping,ignorableWhitespace,processingInstruction,setDocumentLocator,skippedEntity,startDocument,startElement,startPrefixMapping,notationDecl,unparsedEntityDecl,error,fatalError,warning,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,comment,endCDATA,endDTD,endEntity,startCDATA,startDTD,startEntity'.split(',')

//S_TAG,	S_ATTR,	S_EQ,	S_ATTR_NOQUOT_VALUE
//S_ATTR_SPACE,	S_ATTR_END,	S_TAG_SPACE, S_TAG_CLOSE
var S_TAG = 0;//tag name offerring
var S_ATTR = 1;//attr name offerring 
var S_ATTR_SPACE=2;//attr name end and space offer
var S_EQ = 3;//=space?
var S_ATTR_NOQUOT_VALUE = 4;//attr value(no quot value only)
var S_ATTR_END = 5;//attr value end and no space(quot end)
var S_TAG_SPACE = 6;//(attr value end || tag end ) && (space offer)
var S_TAG_CLOSE = 7;//closed el<el />

function XMLReader(){
	
}

XMLReader.prototype = {
	parse:function(source,defaultNSMap,entityMap){
		var domBuilder = this.domBuilder;
		domBuilder.startDocument();
		_copy(defaultNSMap ,defaultNSMap = {})
		parse(source,defaultNSMap,entityMap,
				domBuilder,this.errorHandler);
		domBuilder.endDocument();
	}
}
function parse(source,defaultNSMapCopy,entityMap,domBuilder,errorHandler){
	function fixedFromCharCode(code) {
		// String.prototype.fromCharCode does not supports
		// > 2 bytes unicode chars directly
		if (code > 0xffff) {
			code -= 0x10000;
			var surrogate1 = 0xd800 + (code >> 10)
				, surrogate2 = 0xdc00 + (code & 0x3ff);

			return String.fromCharCode(surrogate1, surrogate2);
		} else {
			return String.fromCharCode(code);
		}
	}
	function entityReplacer(a){
		var k = a.slice(1,-1);
		if(k in entityMap){
			return entityMap[k]; 
		}else if(k.charAt(0) === '#'){
			return fixedFromCharCode(parseInt(k.substr(1).replace('x','0x')))
		}else{
			errorHandler.error('entity not found:'+a);
			return a;
		}
	}
	function appendText(end){//has some bugs
		if(end>start){
			var xt = source.substring(start,end).replace(/&#?\w+;/g,entityReplacer);
			locator&&position(start);
			domBuilder.characters(xt,0,end-start);
			start = end
		}
	}
	function position(p,m){
		while(p>=lineEnd && (m = linePattern.exec(source))){
			lineStart = m.index;
			lineEnd = lineStart + m[0].length;
			locator.lineNumber++;
			//console.log('line++:',locator,startPos,endPos)
		}
		locator.columnNumber = p-lineStart+1;
	}
	var lineStart = 0;
	var lineEnd = 0;
	var linePattern = /.*(?:\r\n?|\n)|.*$/g
	var locator = domBuilder.locator;
	
	var parseStack = [{currentNSMap:defaultNSMapCopy}]
	var closeMap = {};
	var start = 0;
	while(true){
		try{
			var tagStart = source.indexOf('<',start);
			if(tagStart<0){
				if(!source.substr(start).match(/^\s*$/)){
					var doc = domBuilder.doc;
	    			var text = doc.createTextNode(source.substr(start));
	    			doc.appendChild(text);
	    			domBuilder.currentElement = text;
				}
				return;
			}
			if(tagStart>start){
				appendText(tagStart);
			}
			switch(source.charAt(tagStart+1)){
			case '/':
				var end = source.indexOf('>',tagStart+3);
				var tagName = source.substring(tagStart+2,end);
				var config = parseStack.pop();
				if(end<0){
					
	        		tagName = source.substring(tagStart+2).replace(/[\s<].*/,'');
	        		//console.error('#@@@@@@'+tagName)
	        		errorHandler.error("end tag name: "+tagName+' is not complete:'+config.tagName);
	        		end = tagStart+1+tagName.length;
	        	}else if(tagName.match(/\s</)){
	        		tagName = tagName.replace(/[\s<].*/,'');
	        		errorHandler.error("end tag name: "+tagName+' maybe not complete');
	        		end = tagStart+1+tagName.length;
				}
				//console.error(parseStack.length,parseStack)
				//console.error(config);
				var localNSMap = config.localNSMap;
				var endMatch = config.tagName == tagName;
				var endIgnoreCaseMach = endMatch || config.tagName&&config.tagName.toLowerCase() == tagName.toLowerCase()
		        if(endIgnoreCaseMach){
		        	domBuilder.endElement(config.uri,config.localName,tagName);
					if(localNSMap){
						for(var prefix in localNSMap){
							domBuilder.endPrefixMapping(prefix) ;
						}
					}
					if(!endMatch){
		            	errorHandler.fatalError("end tag name: "+tagName+' is not match the current start tagName:'+config.tagName );
					}
		        }else{
		        	parseStack.push(config)
		        }
				
				end++;
				break;
				// end elment
			case '?':// <?...?>
				locator&&position(tagStart);
				end = parseInstruction(source,tagStart,domBuilder);
				break;
			case '!':// <!doctype,<![CDATA,<!--
				locator&&position(tagStart);
				end = parseDCC(source,tagStart,domBuilder,errorHandler);
				break;
			default:
				locator&&position(tagStart);
				var el = new ElementAttributes();
				var currentNSMap = parseStack[parseStack.length-1].currentNSMap;
				//elStartEnd
				var end = parseElementStartPart(source,tagStart,el,currentNSMap,entityReplacer,errorHandler);
				var len = el.length;
				
				
				if(!el.closed && fixSelfClosed(source,end,el.tagName,closeMap)){
					el.closed = true;
					if(!entityMap.nbsp){
						errorHandler.warning('unclosed xml attribute');
					}
				}
				if(locator && len){
					var locator2 = copyLocator(locator,{});
					//try{//attribute position fixed
					for(var i = 0;i<len;i++){
						var a = el[i];
						position(a.offset);
						a.locator = copyLocator(locator,{});
					}
					//}catch(e){console.error('@@@@@'+e)}
					domBuilder.locator = locator2
					if(appendElement(el,domBuilder,currentNSMap)){
						parseStack.push(el)
					}
					domBuilder.locator = locator;
				}else{
					if(appendElement(el,domBuilder,currentNSMap)){
						parseStack.push(el)
					}
				}
				
				
				
				if(el.uri === 'http://www.w3.org/1999/xhtml' && !el.closed){
					end = parseHtmlSpecialContent(source,end,el.tagName,entityReplacer,domBuilder)
				}else{
					end++;
				}
			}
		}catch(e){
			errorHandler.error('element parse error: '+e)
			//errorHandler.error('element parse error: '+e);
			end = -1;
			//throw e;
		}
		if(end>start){
			start = end;
		}else{
			//TODO: 这里有可能sax回退，有位置错误风险
			appendText(Math.max(tagStart,start)+1);
		}
	}
}
function copyLocator(f,t){
	t.lineNumber = f.lineNumber;
	t.columnNumber = f.columnNumber;
	return t;
}

/**
 * @see #appendElement(source,elStartEnd,el,selfClosed,entityReplacer,domBuilder,parseStack);
 * @return end of the elementStartPart(end of elementEndPart for selfClosed el)
 */
function parseElementStartPart(source,start,el,currentNSMap,entityReplacer,errorHandler){
	var attrName;
	var value;
	var p = ++start;
	var s = S_TAG;//status
	while(true){
		var c = source.charAt(p);
		switch(c){
		case '=':
			if(s === S_ATTR){//attrName
				attrName = source.slice(start,p);
				s = S_EQ;
			}else if(s === S_ATTR_SPACE){
				s = S_EQ;
			}else{
				//fatalError: equal must after attrName or space after attrName
				throw new Error('attribute equal must after attrName');
			}
			break;
		case '\'':
		case '"':
			if(s === S_EQ || s === S_ATTR //|| s == S_ATTR_SPACE
				){//equal
				if(s === S_ATTR){
					errorHandler.warning('attribute value must after "="')
					attrName = source.slice(start,p)
				}
				start = p+1;
				p = source.indexOf(c,start)
				if(p>0){
					value = source.slice(start,p).replace(/&#?\w+;/g,entityReplacer);
					el.add(attrName,value,start-1);
					s = S_ATTR_END;
				}else{
					//fatalError: no end quot match
					throw new Error('attribute value no end \''+c+'\' match');
				}
			}else if(s == S_ATTR_NOQUOT_VALUE){
				value = source.slice(start,p).replace(/&#?\w+;/g,entityReplacer);
				//console.log(attrName,value,start,p)
				el.add(attrName,value,start);
				//console.dir(el)
				errorHandler.warning('attribute "'+attrName+'" missed start quot('+c+')!!');
				start = p+1;
				s = S_ATTR_END
			}else{
				//fatalError: no equal before
				throw new Error('attribute value must after "="');
			}
			break;
		case '/':
			switch(s){
			case S_TAG:
				el.setTagName(source.slice(start,p));
			case S_ATTR_END:
			case S_TAG_SPACE:
			case S_TAG_CLOSE:
				s =S_TAG_CLOSE;
				el.closed = true;
			case S_ATTR_NOQUOT_VALUE:
			case S_ATTR:
			case S_ATTR_SPACE:
				break;
			//case S_EQ:
			default:
				throw new Error("attribute invalid close char('/')")
			}
			break;
		case ''://end document
			//throw new Error('unexpected end of input')
			errorHandler.error('unexpected end of input');
			if(s == S_TAG){
				el.setTagName(source.slice(start,p));
			}
			return p;
		case '>':
			switch(s){
			case S_TAG:
				el.setTagName(source.slice(start,p));
			case S_ATTR_END:
			case S_TAG_SPACE:
			case S_TAG_CLOSE:
				break;//normal
			case S_ATTR_NOQUOT_VALUE://Compatible state
			case S_ATTR:
				value = source.slice(start,p);
				if(value.slice(-1) === '/'){
					el.closed  = true;
					value = value.slice(0,-1)
				}
			case S_ATTR_SPACE:
				if(s === S_ATTR_SPACE){
					value = attrName;
				}
				if(s == S_ATTR_NOQUOT_VALUE){
					errorHandler.warning('attribute "'+value+'" missed quot(")!!');
					el.add(attrName,value.replace(/&#?\w+;/g,entityReplacer),start)
				}else{
					if(currentNSMap[''] !== 'http://www.w3.org/1999/xhtml' || !value.match(/^(?:disabled|checked|selected)$/i)){
						errorHandler.warning('attribute "'+value+'" missed value!! "'+value+'" instead!!')
					}
					el.add(value,value,start)
				}
				break;
			case S_EQ:
				throw new Error('attribute value missed!!');
			}
//			console.log(tagName,tagNamePattern,tagNamePattern.test(tagName))
			return p;
		/*xml space '\x20' | #x9 | #xD | #xA; */
		case '\u0080':
			c = ' ';
		default:
			if(c<= ' '){//space
				switch(s){
				case S_TAG:
					el.setTagName(source.slice(start,p));//tagName
					s = S_TAG_SPACE;
					break;
				case S_ATTR:
					attrName = source.slice(start,p)
					s = S_ATTR_SPACE;
					break;
				case S_ATTR_NOQUOT_VALUE:
					var value = source.slice(start,p).replace(/&#?\w+;/g,entityReplacer);
					errorHandler.warning('attribute "'+value+'" missed quot(")!!');
					el.add(attrName,value,start)
				case S_ATTR_END:
					s = S_TAG_SPACE;
					break;
				//case S_TAG_SPACE:
				//case S_EQ:
				//case S_ATTR_SPACE:
				//	void();break;
				//case S_TAG_CLOSE:
					//ignore warning
				}
			}else{//not space
//S_TAG,	S_ATTR,	S_EQ,	S_ATTR_NOQUOT_VALUE
//S_ATTR_SPACE,	S_ATTR_END,	S_TAG_SPACE, S_TAG_CLOSE
				switch(s){
				//case S_TAG:void();break;
				//case S_ATTR:void();break;
				//case S_ATTR_NOQUOT_VALUE:void();break;
				case S_ATTR_SPACE:
					var tagName =  el.tagName;
					if(currentNSMap[''] !== 'http://www.w3.org/1999/xhtml' || !attrName.match(/^(?:disabled|checked|selected)$/i)){
						errorHandler.warning('attribute "'+attrName+'" missed value!! "'+attrName+'" instead2!!')
					}
					el.add(attrName,attrName,start);
					start = p;
					s = S_ATTR;
					break;
				case S_ATTR_END:
					errorHandler.warning('attribute space is required"'+attrName+'"!!')
				case S_TAG_SPACE:
					s = S_ATTR;
					start = p;
					break;
				case S_EQ:
					s = S_ATTR_NOQUOT_VALUE;
					start = p;
					break;
				case S_TAG_CLOSE:
					throw new Error("elements closed character '/' and '>' must be connected to");
				}
			}
		}//end outer switch
		//console.log('p++',p)
		p++;
	}
}
/**
 * @return true if has new namespace define
 */
function appendElement(el,domBuilder,currentNSMap){
	var tagName = el.tagName;
	var localNSMap = null;
	//var currentNSMap = parseStack[parseStack.length-1].currentNSMap;
	var i = el.length;
	while(i--){
		var a = el[i];
		var qName = a.qName;
		var value = a.value;
		var nsp = qName.indexOf(':');
		if(nsp>0){
			var prefix = a.prefix = qName.slice(0,nsp);
			var localName = qName.slice(nsp+1);
			var nsPrefix = prefix === 'xmlns' && localName
		}else{
			localName = qName;
			prefix = null
			nsPrefix = qName === 'xmlns' && ''
		}
		//can not set prefix,because prefix !== ''
		a.localName = localName ;
		//prefix == null for no ns prefix attribute 
		if(nsPrefix !== false){//hack!!
			if(localNSMap == null){
				localNSMap = {}
				//console.log(currentNSMap,0)
				_copy(currentNSMap,currentNSMap={})
				//console.log(currentNSMap,1)
			}
			currentNSMap[nsPrefix] = localNSMap[nsPrefix] = value;
			a.uri = 'http://www.w3.org/2000/xmlns/'
			domBuilder.startPrefixMapping(nsPrefix, value) 
		}
	}
	var i = el.length;
	while(i--){
		a = el[i];
		var prefix = a.prefix;
		if(prefix){//no prefix attribute has no namespace
			if(prefix === 'xml'){
				a.uri = 'http://www.w3.org/XML/1998/namespace';
			}if(prefix !== 'xmlns'){
				a.uri = currentNSMap[prefix || '']
				
				//{console.log('###'+a.qName,domBuilder.locator.systemId+'',currentNSMap,a.uri)}
			}
		}
	}
	var nsp = tagName.indexOf(':');
	if(nsp>0){
		prefix = el.prefix = tagName.slice(0,nsp);
		localName = el.localName = tagName.slice(nsp+1);
	}else{
		prefix = null;//important!!
		localName = el.localName = tagName;
	}
	//no prefix element has default namespace
	var ns = el.uri = currentNSMap[prefix || ''];
	domBuilder.startElement(ns,localName,tagName,el);
	//endPrefixMapping and startPrefixMapping have not any help for dom builder
	//localNSMap = null
	if(el.closed){
		domBuilder.endElement(ns,localName,tagName);
		if(localNSMap){
			for(prefix in localNSMap){
				domBuilder.endPrefixMapping(prefix) 
			}
		}
	}else{
		el.currentNSMap = currentNSMap;
		el.localNSMap = localNSMap;
		//parseStack.push(el);
		return true;
	}
}
function parseHtmlSpecialContent(source,elStartEnd,tagName,entityReplacer,domBuilder){
	if(/^(?:script|textarea)$/i.test(tagName)){
		var elEndStart =  source.indexOf('</'+tagName+'>',elStartEnd);
		var text = source.substring(elStartEnd+1,elEndStart);
		if(/[&<]/.test(text)){
			if(/^script$/i.test(tagName)){
				//if(!/\]\]>/.test(text)){
					//lexHandler.startCDATA();
					domBuilder.characters(text,0,text.length);
					//lexHandler.endCDATA();
					return elEndStart;
				//}
			}//}else{//text area
				text = text.replace(/&#?\w+;/g,entityReplacer);
				domBuilder.characters(text,0,text.length);
				return elEndStart;
			//}
			
		}
	}
	return elStartEnd+1;
}
function fixSelfClosed(source,elStartEnd,tagName,closeMap){
	//if(tagName in closeMap){
	var pos = closeMap[tagName];
	if(pos == null){
		//console.log(tagName)
		pos =  source.lastIndexOf('</'+tagName+'>')
		if(pos<elStartEnd){//忘记闭合
			pos = source.lastIndexOf('</'+tagName)
		}
		closeMap[tagName] =pos
	}
	return pos<elStartEnd;
	//} 
}
function _copy(source,target){
	for(var n in source){target[n] = source[n]}
}
function parseDCC(source,start,domBuilder,errorHandler){//sure start with '<!'
	var next= source.charAt(start+2)
	switch(next){
	case '-':
		if(source.charAt(start + 3) === '-'){
			var end = source.indexOf('-->',start+4);
			//append comment source.substring(4,end)//<!--
			if(end>start){
				domBuilder.comment(source,start+4,end-start-4);
				return end+3;
			}else{
				errorHandler.error("Unclosed comment");
				return -1;
			}
		}else{
			//error
			return -1;
		}
	default:
		if(source.substr(start+3,6) == 'CDATA['){
			var end = source.indexOf(']]>',start+9);
			domBuilder.startCDATA();
			domBuilder.characters(source,start+9,end-start-9);
			domBuilder.endCDATA() 
			return end+3;
		}
		//<!DOCTYPE
		//startDTD(java.lang.String name, java.lang.String publicId, java.lang.String systemId) 
		var matchs = split(source,start);
		var len = matchs.length;
		if(len>1 && /!doctype/i.test(matchs[0][0])){
			var name = matchs[1][0];
			var pubid = len>3 && /^public$/i.test(matchs[2][0]) && matchs[3][0]
			var sysid = len>4 && matchs[4][0];
			var lastMatch = matchs[len-1]
			domBuilder.startDTD(name,pubid && pubid.replace(/^(['"])(.*?)\1$/,'$2'),
					sysid && sysid.replace(/^(['"])(.*?)\1$/,'$2'));
			domBuilder.endDTD();
			
			return lastMatch.index+lastMatch[0].length
		}
	}
	return -1;
}



function parseInstruction(source,start,domBuilder){
	var end = source.indexOf('?>',start);
	if(end){
		var match = source.substring(start,end).match(/^<\?(\S*)\s*([\s\S]*?)\s*$/);
		if(match){
			var len = match[0].length;
			domBuilder.processingInstruction(match[1], match[2]) ;
			return end+2;
		}else{//error
			return -1;
		}
	}
	return -1;
}

/**
 * @param source
 */
function ElementAttributes(source){
	
}
ElementAttributes.prototype = {
	setTagName:function(tagName){
		if(!tagNamePattern.test(tagName)){
			throw new Error('invalid tagName:'+tagName)
		}
		this.tagName = tagName
	},
	add:function(qName,value,offset){
		if(!tagNamePattern.test(qName)){
			throw new Error('invalid attribute:'+qName)
		}
		this[this.length++] = {qName:qName,value:value,offset:offset}
	},
	length:0,
	getLocalName:function(i){return this[i].localName},
	getLocator:function(i){return this[i].locator},
	getQName:function(i){return this[i].qName},
	getURI:function(i){return this[i].uri},
	getValue:function(i){return this[i].value}
//	,getIndex:function(uri, localName)){
//		if(localName){
//			
//		}else{
//			var qName = uri
//		}
//	},
//	getValue:function(){return this.getValue(this.getIndex.apply(this,arguments))},
//	getType:function(uri,localName){}
//	getType:function(i){},
}




function _set_proto_(thiz,parent){
	thiz.__proto__ = parent;
	return thiz;
}
if(!(_set_proto_({},_set_proto_.prototype) instanceof _set_proto_)){
	_set_proto_ = function(thiz,parent){
		function p(){};
		p.prototype = parent;
		p = new p();
		for(parent in thiz){
			p[parent] = thiz[parent];
		}
		return p;
	}
}

function split(source,start){
	var match;
	var buf = [];
	var reg = /'[^']+'|"[^"]+"|[^\s<>\/=]+=?|(\/?\s*>|<)/g;
	reg.lastIndex = start;
	reg.exec(source);//skip <
	while(match = reg.exec(source)){
		buf.push(match);
		if(match[1])return buf;
	}
}

exports.XMLReader = XMLReader;



/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

var Async = __webpack_require__(14);
var EventProxy = __webpack_require__(3).EventProxy;
var util = __webpack_require__(0);

// 抛弃分块上传任务
/*
 AsyncLimit (抛弃上传任务的并发量)，
 UploadId (上传任务的编号，当 Level 为 task 时候需要)
 Level (抛弃分块上传任务的级别，task : 抛弃指定的上传任务，file ： 抛弃指定的文件对应的上传任务，其他值 ：抛弃指定Bucket 的全部上传任务)
 */
function abortUploadTask(params, callback) {
    var Bucket = params.Bucket;
    var Region = params.Region;
    var Key = params.Key;
    var UploadId = params.UploadId;
    var Level = params.Level || 'task';
    var AsyncLimit = params.AsyncLimit;
    var self = this;

    var ep = new EventProxy();

    ep.on('error', function (errData) {
        return callback(errData);
    });

    // 已经获取到需要抛弃的任务列表
    ep.on('get_abort_array', function (AbortArray) {
        abortUploadTaskArray.call(self, {
            Bucket: Bucket,
            Region: Region,
            Key: Key,
            Headers: params.Headers,
            AsyncLimit: AsyncLimit,
            AbortArray: AbortArray
        }, function (err, data) {
            if (err) {
                return callback(err);
            }
            callback(null, data);
        });
    });

    if (Level === 'bucket') {
        // Bucket 级别的任务抛弃，抛弃该 Bucket 下的全部上传任务
        wholeMultipartList.call(self, {
            Bucket: Bucket,
            Region: Region
        }, function (err, data) {
            if (err) {
                return callback(err);
            }
            ep.emit('get_abort_array', data.UploadList || []);
        });
    } else if (Level === 'file') {
        // 文件级别的任务抛弃，抛弃该文件的全部上传任务
        if (!Key) return callback({error: 'abort_upload_task_no_key'});
        wholeMultipartList.call(self, {
            Bucket: Bucket,
            Region: Region,
            Key: Key
        }, function (err, data) {
            if (err) {
                return callback(err);
            }
            ep.emit('get_abort_array', data.UploadList || []);
        });
    } else if (Level === 'task') {
        // 单个任务级别的任务抛弃，抛弃指定 UploadId 的上传任务
        if (!UploadId) return callback({error: 'abort_upload_task_no_id'});
        if (!Key) return callback({error: 'abort_upload_task_no_key'});
        ep.emit('get_abort_array', [{
            Key: Key,
            UploadId: UploadId
        }]);
    } else {
        return callback({error: 'abort_unknown_level'});
    }
}

// 批量抛弃分块上传任务
function abortUploadTaskArray(params, callback) {

    var Bucket = params.Bucket;
    var Region = params.Region;
    var Key = params.Key;
    var AbortArray = params.AbortArray;
    var AsyncLimit = params.AsyncLimit || 1;
    var self = this;

    var index = 0;
    var resultList = new Array(AbortArray.length);
    Async.eachLimit(AbortArray, AsyncLimit, function (AbortItem, callback) {
        var eachIndex = index;
        if (Key && Key !== AbortItem.Key) {
            resultList[eachIndex] = {error: {KeyNotMatch: true}};
            callback(null);
            return;
        }
        var UploadId = AbortItem.UploadId || AbortItem.UploadID;

        self.multipartAbort({
            Bucket: Bucket,
            Region: Region,
            Key: AbortItem.Key,
            Headers: params.Headers,
            UploadId: UploadId
        }, function (err, data) {
            var task = {
                Bucket: Bucket,
                Region: Region,
                Key: AbortItem.Key,
                UploadId: UploadId
            };
            resultList[eachIndex] = {error: err, task: task};
            callback(null);
        });
        index++;

    }, function (err) {
        if (err) {
            return callback(err);
        }

        var successList = [];
        var errorList = [];

        for (var i = 0, len = resultList.length; i < len; i++) {
            var item = resultList[i];
            if (item['task']) {
                if (item['error']) {
                    errorList.push(item['task']);
                } else {
                    successList.push(item['task']);
                }
            }
        }

        return callback(null, {
            successList: successList,
            errorList: errorList
        });
    });
}

// 获取符合条件的全部上传任务 (条件包括 Bucket, Region, Prefix)
function wholeMultipartList(params, callback) {
    var self = this;
    var UploadList = [];
    var sendParams = {
        Bucket: params.Bucket,
        Region: params.Region,
        Prefix: params.Key
    };
    var next = function () {
        self.multipartList(sendParams, function (err, data) {
            if (err) return callback(err);
            UploadList.push.apply(UploadList, data.Upload || []);
            if (data.IsTruncated == 'true') { // 列表不完整
                sendParams.KeyMarker = data.NextKeyMarker;
                sendParams.UploadIdMarker = data.NextUploadIdMarker;
                next();
            } else {
                callback(null, {UploadList: UploadList});
            }
        });
    };
    next();
}


// 分片复制文件
function sliceCopyFile(params, callback) {
    var ep = new EventProxy();

    var self = this;
    var Bucket = params.Bucket;
    var Region = params.Region;
    var Key = params.Key;
    var CopySource = params.CopySource;
    var m = CopySource.match(/^([^.]+-\d+)\.cos(v6)?\.([^.]+)\.[^/]+\/(.+)$/);
    if (!m) {
        callback({error: 'CopySource format error'});
        return;
    }

    var SourceBucket = m[1];
    var SourceRegion = m[3];
    var SourceKey = decodeURIComponent(m[4]);
    var CopySliceSize = params.SliceSize === undefined ? self.options.CopySliceSize : params.SliceSize;
    CopySliceSize = Math.max(0, Math.min(CopySliceSize, 5 * 1024 * 1024 * 1024));

    var ChunkSize = params.ChunkSize || this.options.CopyChunkSize;
    var ChunkParallel = this.options.CopyChunkParallelLimit;

    var FinishSize = 0;
    var FileSize;
    var onProgress;

    // 分片复制完成，开始 multipartComplete 操作
    ep.on('copy_slice_complete', function (UploadData) {
        self.multipartComplete({
            Bucket: Bucket,
            Region: Region,
            Key: Key,
            UploadId: UploadData.UploadId,
            Parts: UploadData.PartList,
        },function (err, data) {
            if (err) {
                onProgress(null, true);
                return callback(err);
            }
            onProgress({loaded: FileSize, total: FileSize}, true);
            callback(null, data);
        });
    });

    ep.on('get_copy_data_finish',function (UploadData) {
        Async.eachLimit(UploadData.PartList, ChunkParallel, function (SliceItem, asyncCallback) {
            var PartNumber = SliceItem.PartNumber;
            var CopySourceRange = SliceItem.CopySourceRange;
            var currentSize = SliceItem.end - SliceItem.start;
            var preAddSize = 0;

            copySliceItem.call(self,{
                Bucket: Bucket,
                Region: Region,
                Key: Key,
                CopySource: CopySource,
                UploadId: UploadData.UploadId,
                PartNumber: PartNumber,
                CopySourceRange: CopySourceRange,
                onProgress: function (data) {
                    FinishSize += data.loaded - preAddSize;
                    preAddSize = data.loaded;
                    onProgress({loaded: FinishSize, total: FileSize});
                }
            },function (err,data) {
                if (err) {
                    return asyncCallback(err);
                }
                onProgress({loaded: FinishSize, total: FileSize});

                FinishSize += currentSize - preAddSize;
                SliceItem.ETag = data.ETag;
                asyncCallback(err || null, data);
            });
        }, function (err) {
            if (err) {
                onProgress(null, true);
                return callback(err);
            }

            ep.emit('copy_slice_complete', UploadData);
        });
    });

    ep.on('get_file_size_finish', function (SourceHeaders) {
        // 控制分片大小
        (function () {
            var SIZE = [1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 1024 * 2, 1024 * 4, 1024 * 5];
            var AutoChunkSize = 1024 * 1024;
            for (var i = 0; i < SIZE.length; i++) {
                AutoChunkSize = SIZE[i] * 1024 * 1024;
                if (FileSize / AutoChunkSize <= self.options.MaxPartNumber) break;
            }
            params.ChunkSize = ChunkSize = Math.max(ChunkSize, AutoChunkSize);

            var ChunkCount = Math.ceil(FileSize / ChunkSize);

            var list = [];
            for (var partNumber = 1; partNumber <= ChunkCount; partNumber++) {
                var start = (partNumber - 1) * ChunkSize;
                var end = partNumber * ChunkSize < FileSize ? (partNumber * ChunkSize - 1) : FileSize - 1;
                var item = {
                    PartNumber: partNumber,
                    start: start,
                    end: end,
                    CopySourceRange: "bytes=" + start + "-" + end,
                };
                list.push(item);
            }
            params.PartList = list;
        })();

        var TargetHeader;
        if (params.Headers['x-cos-metadata-directive'] === 'Replaced') {
            TargetHeader = params.Headers;
        } else {
            TargetHeader = SourceHeaders;
        }
        TargetHeader['x-cos-storage-class'] = params.Headers['x-cos-storage-class'] || SourceHeaders['x-cos-storage-class'];
        TargetHeader = util.clearKey(TargetHeader);
        self.multipartInit({
            Bucket: Bucket,
            Region: Region,
            Key: Key,
            Headers: TargetHeader,
        },function (err,data) {
            if (err) {
                return callback(err);
            }
            params.UploadId = data.UploadId;
            ep.emit('get_copy_data_finish', params);
        });
    });

    // 获取远端复制源文件的大小
    self.headObject({
        Bucket: SourceBucket,
        Region: SourceRegion,
        Key: SourceKey,
    },function(err, data) {
        if (err) {
            if (err.statusCode && err.statusCode === 404) {
                callback({ErrorStatus: SourceKey + ' Not Exist'});
            } else {
                callback(err);
            }
            return;
        }

        FileSize = params.FileSize = data.headers['content-length'];
        if (FileSize === undefined || !FileSize) {
            callback({error: 'get Content-Length error, please add "Content-Length" to CORS ExposeHeader setting.'});
            return;
        }

        onProgress = util.throttleOnProgress.call(self, FileSize, params.onProgress);

        // 开始上传
        if (FileSize <= CopySliceSize) {
            if (!params.Headers['x-cos-metadata-directive']) {
                params.Headers['x-cos-metadata-directive'] = 'Copy';
            }
            self.putObjectCopy(params, function (err, data) {
                if (err) {
                    onProgress(null, true);
                    return callback(err);
                }
                onProgress({loaded: FileSize, total: FileSize}, true);
                callback(err, data);
            });
        } else {
            var resHeaders = data.headers;
            var SourceHeaders = {
                'Cache-Control': resHeaders['cache-control'],
                'Content-Disposition': resHeaders['content-disposition'],
                'Content-Encoding': resHeaders['content-encoding'],
                'Content-Type': resHeaders['content-type'],
                'Expires': resHeaders['expires'],
                'x-cos-storage-class': resHeaders['x-cos-storage-class'],
            };
            util.each(resHeaders, function (v, k) {
                var metaPrefix = 'x-cos-meta-';
                if (k.indexOf(metaPrefix) === 0 && k.length > metaPrefix.length) {
                    SourceHeaders[k] = v;
                }
            });
            ep.emit('get_file_size_finish', SourceHeaders);
        }
    });
}

// 复制指定分片
function copySliceItem(params, callback) {
    var TaskId = params.TaskId;
    var Bucket = params.Bucket;
    var Region = params.Region;
    var Key = params.Key;
    var CopySource = params.CopySource;
    var UploadId = params.UploadId;
    var PartNumber = params.PartNumber * 1;
    var CopySourceRange = params.CopySourceRange;

    var ChunkRetryTimes = this.options.ChunkRetryTimes + 1;
    var self = this;

    Async.retry(ChunkRetryTimes, function (tryCallback) {
        self.uploadPartCopy({
            TaskId: TaskId,
            Bucket: Bucket,
            Region: Region,
            Key: Key,
            CopySource: CopySource,
            UploadId: UploadId,
            PartNumber:PartNumber,
            CopySourceRange:CopySourceRange,
            onProgress:params.onProgress,
        },function (err,data) {
            tryCallback(err || null, data);
        })
    }, function (err, data) {
        return callback(err, data);
    });
}


var API_MAP = {
    abortUploadTask: abortUploadTask,
    sliceCopyFile: sliceCopyFile,
};

module.exports.init = function (COS, task) {
    util.each(API_MAP, function (fn, apiName) {
        COS.prototype[apiName] = util.apiWrapper(apiName, fn);
    });
};


/***/ }),
/* 14 */
/***/ (function(module, exports) {

var eachLimit = function (arr, limit, iterator, callback) {
    callback = callback || function () {};
    if (!arr.length || limit <= 0) {
        return callback();
    }

    var completed = 0;
    var started = 0;
    var running = 0;

    (function replenish () {
        if (completed >= arr.length) {
            return callback();
        }

        while (running < limit && started < arr.length) {
            started += 1;
            running += 1;
            iterator(arr[started - 1], function (err) {

                if (err) {
                    callback(err);
                    callback = function () {};
                } else {
                    completed += 1;
                    running -= 1;
                    if (completed >= arr.length) {
                        callback();
                    } else {
                        replenish();
                    }
                }
            });
        }
    })();
};

var retry = function (times, iterator, callback) {
    var next = function (index) {
        iterator(function (err, data) {
            if (err && index < times) {
                next(index + 1);
            } else {
                callback(err, data);
            }
        });
    };
    if (times < 1) {
        callback();
    } else {
        next(1);
    }
};

var async = {
    eachLimit: eachLimit,
    retry: retry
};

module.exports = async;

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var REQUEST = __webpack_require__(9);
var base64 = __webpack_require__(1);
var util = __webpack_require__(0);


// Bucket 相关

/**
 * 获取用户的 bucket 列表
 * @param  {Object}  params         回调函数，必须，下面为参数列表
 * 无特殊参数
 * @param  {Function}  callback     回调函数，必须
 */
function getService(params, callback) {
    if (typeof params === 'function') {
        callback = params;
        params = {};
    }
    var protocol = 'https:';
    var domain = this.options.ServiceDomain;
    var appId = params.AppId || this.options.appId;
    var region = params.Region;
    if (domain) {
        domain = domain.replace(/\{\{AppId\}\}/ig, appId || '')
                     .replace(/\{\{Region\}\}/ig, region || '').replace(/\{\{.*?\}\}/ig, '');
        if (!/^[a-zA-Z]+:\/\//.test(domain)) {
            domain = protocol + '//' + domain;
        }
        if (domain.slice(-1) === '/') {
            domain = domain.slice(0, -1);
        }
    } else if(region){
        domain = protocol + '//cos.'+ region + '.myqcloud.com';
    } else {
        domain = protocol + '//service.cos.myqcloud.com';
    }

    submitRequest.call(this, {
        Action: 'name/cos:GetService',
        url: domain + '/',
        method: 'GET',
    }, function (err, data) {
        if (err) {
            return callback(err);
        }
        var buckets = (data && data.ListAllMyBucketsResult && data.ListAllMyBucketsResult.Buckets
            && data.ListAllMyBucketsResult.Buckets.Bucket) || [];
        buckets = util.isArray(buckets) ? buckets : [buckets];
        var owner = (data && data.ListAllMyBucketsResult && data.ListAllMyBucketsResult.Owner) || {};
        callback(null, {
            Buckets: buckets,
            Owner: owner,
            statusCode: data.statusCode,
            headers: data.headers,
        });
    });
}

/**
 * 查看是否存在该Bucket，是否有权限访问
 * @param  {Object}  params                     参数对象，必须
 *     @param  {String}  params.Bucket          Bucket名称，必须
 *     @param  {String}  params.Region          地域名称，必须
 * @param  {Function}  callback                 回调函数，必须
 * @return  {Object}  err                       请求失败的错误，如果请求成功，则为空。https://cloud.tencent.com/document/product/436/7730
 * @return  {Object}  data                      返回的数据
 *     @return  {Boolean}  data.BucketExist     Bucket是否存在
 *     @return  {Boolean}  data.BucketAuth      是否有 Bucket 的访问权限
 */
function headBucket(params, callback) {
    submitRequest.call(this, {
        Action: 'name/cos:HeadBucket',
        Bucket: params.Bucket,
        Region: params.Region,
        headers: params.Headers,
        method: 'HEAD',
    }, function (err, data) {
        callback(err, data);
    });
}

/**
 * 获取 Bucket 下的 object 列表
 * @param  {Object}  params                         参数对象，必须
 *     @param  {String}  params.Bucket              Bucket名称，必须
 *     @param  {String}  params.Region              地域名称，必须
 *     @param  {String}  params.Prefix              前缀匹配，用来规定返回的文件前缀地址，非必须
 *     @param  {String}  params.Delimiter           定界符为一个符号，如果有Prefix，则将Prefix到delimiter之间的相同路径归为一类，非必须
 *     @param  {String}  params.Marker              默认以UTF-8二进制顺序列出条目，所有列出条目从marker开始，非必须
 *     @param  {String}  params.MaxKeys             单次返回最大的条目数量，默认1000，非必须
 *     @param  {String}  params.EncodingType        规定返回值的编码方式，非必须
 * @param  {Function}  callback                     回调函数，必须
 * @return  {Object}  err                           请求失败的错误，如果请求成功，则为空。https://cloud.tencent.com/document/product/436/7730
 * @return  {Object}  data                          返回的数据
 *     @return  {Object}  data.ListBucketResult     返回的 object 列表信息
 */
function getBucket(params, callback) {
    var reqParams = {};
    reqParams['prefix'] = params['Prefix'] || '';
    reqParams['delimiter'] = params['Delimiter'];
    reqParams['marker'] = params['Marker'];
    reqParams['max-keys'] = params['MaxKeys'];
    reqParams['encoding-type'] = params['EncodingType'];

    submitRequest.call(this, {
        Action: 'name/cos:GetBucket',
        ResourceKey: reqParams['prefix'],
        method: 'GET',
        Bucket: params.Bucket,
        Region: params.Region,
        headers: params.Headers,
        qs: reqParams,
    }, function (err, data) {
        if (err) {
            return callback(err);
        }
        var ListBucketResult = data.ListBucketResult || {};
        var Contents = ListBucketResult.Contents || [];
        var CommonPrefixes = ListBucketResult.CommonPrefixes || [];

        Contents = util.isArray(Contents) ? Contents : [Contents];
        CommonPrefixes = util.isArray(CommonPrefixes) ? CommonPrefixes : [CommonPrefixes];

        var result = util.clone(ListBucketResult);
        util.extend(result, {
            Contents: Contents,
            CommonPrefixes: CommonPrefixes,
            statusCode: data.statusCode,
            headers: data.headers,
        });

        callback(null, result);
    });
}

/**
 * 创建 Bucket，并初始化访问权限
 * @param  {Object}  params                         参数对象，必须
 *     @param  {String}  params.Bucket              Bucket名称，必须
 *     @param  {String}  params.Region              地域名称，必须
 *     @param  {String}  params.ACL                 用户自定义文件权限，可以设置：private，public-read；默认值：private，非必须
 *     @param  {String}  params.GrantRead           赋予被授权者读的权限，格式x-cos-grant-read: uin=" ",uin=" "，非必须
 *     @param  {String}  params.GrantWrite          赋予被授权者写的权限，格式x-cos-grant-write: uin=" ",uin=" "，非必须
 *     @param  {String}  params.GrantFullControl    赋予被授权者读写权限，格式x-cos-grant-full-control: uin=" ",uin=" "，非必须
 * @param  {Function}  callback                     回调函数，必须
 * @return  {Object}  err                           请求失败的错误，如果请求成功，则为空。https://cloud.tencent.com/document/product/436/7730
 * @return  {Object}  data                          返回的数据
 *     @return  {String}  data.Location             操作地址
 */
function putBucket(params, callback) {
    var self = this;
    var headers = {};
    headers['x-cos-acl'] = params['ACL'];
    headers['x-cos-grant-read'] = params['GrantRead'];
    headers['x-cos-grant-write'] = params['GrantWrite'];
    headers['x-cos-grant-read-acp'] = params['GrantReadAcp'];
    headers['x-cos-grant-write-acp'] = params['GrantWriteAcp'];
    headers['x-cos-grant-full-control'] = params['GrantFullControl'];
    submitRequest.call(this, {
        Action: 'name/cos:PutBucket',
        method: 'PUT',
        Bucket: params.Bucket,
        Region: params.Region,
        headers: headers,
    }, function (err, data) {
        if (err) {
            return callback(err);
        }
        var url = getUrl({
            domain: self.options.Domain,
            bucket: params.Bucket,
            region: params.Region,
            isLocation: true,
        });
        callback(null, {
            Location: url,
            statusCode: data.statusCode,
            headers: data.headers,
        });
    });
}

/**
 * 删除 Bucket
 * @param  {Object}  params                 参数对象，必须
 *     @param  {String}  params.Bucket      Bucket名称，必须
 *     @param  {String}  params.Region      地域名称，必须
 * @param  {Function}  callback             回调函数，必须
 * @return  {Object}  err                   请求失败的错误，如果请求成功，则为空。https://cloud.tencent.com/document/product/436/7730
 * @return  {Object}  data                  返回的数据
 *     @return  {String}  data.Location     操作地址
 */
function deleteBucket(params, callback) {
    submitRequest.call(this, {
        Action: 'name/cos:DeleteBucket',
        Bucket: params.Bucket,
        Region: params.Region,
        headers: params.Headers,
        method: 'DELETE',
    }, function (err, data) {
        if (err && err.statusCode === 204) {
            return callback(null, {statusCode: err.statusCode});
        } else if (err) {
            return callback(err);
        }
        callback(null, {
            statusCode: data.statusCode,
            headers: data.headers,
        });
    });
}

/**
 * 获取 Bucket 的 权限列表
 * @param  {Object}  params                         参数对象，必须
 *     @param  {String}  params.Bucket              Bucket名称，必须
 *     @param  {String}  params.Region              地域名称，必须
 * @param  {Function}  callback                     回调函数，必须
 * @return  {Object}  err                           请求失败的错误，如果请求成功，则为空。https://cloud.tencent.com/document/product/436/7730
 * @return  {Object}  data                          返回的数据
 *     @return  {Object}  data.AccessControlPolicy  访问权限信息
 */
function getBucketAcl(params, callback) {
    submitRequest.call(this, {
        Action: 'name/cos:GetBucketACL',
        method: 'GET',
        Bucket: params.Bucket,
        Region: params.Region,
        headers: params.Headers,
        action: 'acl',
    }, function (err, data) {
        if (err) {
            return callback(err);
        }
        var AccessControlPolicy = data.AccessControlPolicy || {};
        var Owner = AccessControlPolicy.Owner || {};
        var Grant = AccessControlPolicy.AccessControlList.Grant || [];
        Grant = util.isArray(Grant) ? Grant : [Grant];
        var result = decodeAcl(AccessControlPolicy);
        if (data.headers && data.headers['x-cos-acl']) {
            result.ACL = data.headers['x-cos-acl'];
        }
        result = util.extend(result, {
            Owner: Owner,
            Grants: Grant,
            statusCode: data.statusCode,
            headers: data.headers,
        });
        callback(null, result);
    });
}

/**
 * 设置 Bucket 的 权限列表
 * @param  {Object}  params                         参数对象，必须
 *     @param  {String}  params.Bucket              Bucket名称，必须
 *     @param  {String}  params.Region              地域名称，必须
 *     @param  {String}  params.ACL                 用户自定义文件权限，可以设置：private，public-read；默认值：private，非必须
 *     @param  {String}  params.GrantRead           赋予被授权者读的权限，格式x-cos-grant-read: uin=" ",uin=" "，非必须
 *     @param  {String}  params.GrantWrite          赋予被授权者写的权限，格式x-cos-grant-write: uin=" ",uin=" "，非必须
 *     @param  {String}  params.GrantFullControl    赋予被授权者读写权限，格式x-cos-grant-full-control: uin=" ",uin=" "，非必须
 * @param  {Function}  callback                     回调函数，必须
 * @return  {Object}  err                           请求失败的错误，如果请求成功，则为空。https://cloud.tencent.com/document/product/436/7730
 * @return  {Object}  data                          返回的数据
 */
function putBucketAcl(params, callback) {
    var headers = params.Headers;

    var xml = '';
    if (params['AccessControlPolicy']) {
        var AccessControlPolicy = util.clone(params['AccessControlPolicy'] || {});
        var Grants = AccessControlPolicy.Grants || AccessControlPolicy.Grant;
        Grants = util.isArray(Grants) ? Grants : [Grants];
        delete AccessControlPolicy.Grant;
        delete AccessControlPolicy.Grants;
        AccessControlPolicy.AccessControlList = {Grant: Grants};
        xml = util.json2xml({AccessControlPolicy: AccessControlPolicy});

        headers['Content-Type'] = 'application/xml';
        headers['Content-MD5'] = util.binaryBase64(util.md5(xml));
    }

    // Grant Header 去重
    util.each(headers, function (val, key) {
        if (key.indexOf('x-cos-grant-') === 0) {
            headers[key] = uniqGrant(headers[key]);
        }
    });

    submitRequest.call(this, {
        Action: 'name/cos:PutBucketACL',
        method: 'PUT',
        Bucket: params.Bucket,
        Region: params.Region,
        headers: headers,
        action: 'acl',
        body: xml,
    }, function (err, data) {
        if (err) {
            return callback(err);
        }
        callback(null, {
            statusCode: data.statusCode,
            headers: data.headers,
        });
    });
}

/**
 * 获取 Bucket 的 跨域设置
 * @param  {Object}  params                         参数对象，必须
 *     @param  {String}  params.Bucket              Bucket名称，必须
 *     @param  {String}  params.Region              地域名称，必须
 * @param  {Function}  callback                     回调函数，必须
 * @return  {Object}  err                           请求失败的错误，如果请求成功，则为空。https://cloud.tencent.com/document/product/436/7730
 * @return  {Object}  data                          返回的数据
 *     @return  {Object}  data.CORSRules            Bucket的跨域设置
 */
function getBucketCors(params, callback) {
    submitRequest.call(this, {
        Action: 'name/cos:GetBucketCORS',
        method: 'GET',
        Bucket: params.Bucket,
        Region: params.Region,
        headers: params.Headers,
        action: 'cors',
    }, function (err, data) {
        if (err) {
            if (err.statusCode === 404 && err.error && err.error.Code === 'NoSuchCORSConfiguration') {
                var result = {
                    CORSRules: [],
                    statusCode: err.statusCode,
                };
                err.headers && (result.headers = err.headers);
                callback(null, result);
            } else {
                callback(err);
            }
            return;
        }
        var CORSConfiguration = data.CORSConfiguration || {};
        var CORSRules = CORSConfiguration.CORSRules || CORSConfiguration.CORSRule || [];
        CORSRules = util.clone(util.isArray(CORSRules) ? CORSRules : [CORSRules]);

        util.each(CORSRules, function (rule) {
            util.each(['AllowedOrigin', 'AllowedHeader', 'AllowedMethod', 'ExposeHeader'], function (key, j) {
                var sKey = key + 's';
                var val = rule[sKey] || rule[key] || [];
                delete rule[key];
                rule[sKey] = util.isArray(val) ? val : [val];
            });
        });

        callback(null, {
            CORSRules: CORSRules,
            statusCode: data.statusCode,
            headers: data.headers,
        });
    });
}

/**
 * 设置 Bucket 的 跨域设置
 * @param  {Object}  params                             参数对象，必须
 *     @param  {String}  params.Bucket                  Bucket名称，必须
 *     @param  {String}  params.Region                  地域名称，必须
 *     @param  {Object}  params.CORSConfiguration       相关的跨域设置，必须
 * @param  {Array}  params.CORSConfiguration.CORSRules  对应的跨域规则
 * @param  {Function}  callback                         回调函数，必须
 * @return  {Object}  err                               请求失败的错误，如果请求成功，则为空。https://cloud.tencent.com/document/product/436/7730
 * @return  {Object}  data                              返回的数据
 */
function putBucketCors(params, callback) {

    var CORSConfiguration = params['CORSConfiguration'] || {};
    var CORSRules = CORSConfiguration['CORSRules'] || params['CORSRules'] || [];
    CORSRules = util.clone(util.isArray(CORSRules) ? CORSRules : [CORSRules]);
    util.each(CORSRules, function (rule) {
        util.each(['AllowedOrigin', 'AllowedHeader', 'AllowedMethod', 'ExposeHeader'], function (key, k) {
            var sKey = key + 's';
            var val = rule[sKey] || rule[key] || [];
            delete rule[sKey];
            rule[key] = util.isArray(val) ? val : [val];
        });
    });

    var xml = util.json2xml({CORSConfiguration: {CORSRule: CORSRules}});

    var headers = params.Headers;
    headers['Content-Type'] = 'application/xml';
    headers['Content-MD5'] = util.binaryBase64(util.md5(xml));

    submitRequest.call(this, {
        Action: 'name/cos:PutBucketCORS',
        method: 'PUT',
        Bucket: params.Bucket,
        Region: params.Region,
        body: xml,
        action: 'cors',
        headers: headers,
    }, function (err, data) {
        if (err) {
            return callback(err);
        }
        callback(null, {
            statusCode: data.statusCode,
            headers: data.headers,
        });
    });
}

/**
 * 删除 Bucket 的 跨域设置
 * @param  {Object}  params                 参数对象，必须
 *     @param  {String}  params.Bucket      Bucket名称，必须
 *     @param  {String}  params.Region      地域名称，必须
 * @param  {Function}  callback             回调函数，必须
 * @return  {Object}  err                   请求失败的错误，如果请求成功，则为空。https://cloud.tencent.com/document/product/436/7730
 * @return  {Object}  data                  返回的数据
 */
function deleteBucketCors(params, callback) {
    submitRequest.call(this, {
        Action: 'name/cos:DeleteBucketCORS',
        method: 'DELETE',
        Bucket: params.Bucket,
        Region: params.Region,
        headers: params.Headers,
        action: 'cors',
    }, function (err, data) {
        if (err && err.statusCode === 204) {
            return callback(null, {statusCode: err.statusCode});
        } else if (err) {
            return callback(err);
        }
        callback(null, {
            statusCode: data.statusCode || err.statusCode,
            headers: data.headers,
        });
    });
}

function putBucketPolicy(params, callback) {
    var Policy = params['Policy'];
    var PolicyStr = Policy;
    try {
        if (typeof Policy === 'string') {
            Policy = JSON.parse(PolicyStr);
        } else {
            PolicyStr = JSON.stringify(Policy);
        }
    } catch (e) {
        callback({error: 'Policy format error'});
    }

    var headers = params.Headers;
    headers['Content-Type'] = 'application/json';
    headers['Content-MD5'] = util.binaryBase64(util.md5(PolicyStr));

    submitRequest.call(this, {
        Action: 'name/cos:PutBucketPolicy',
        method: 'PUT',
        Bucket: params.Bucket,
        Region: params.Region,
        action: 'policy',
        body: util.isBrowser ? PolicyStr : Policy,
        headers: headers,
        json: true,
    }, function (err, data) {
        if (err && err.statusCode === 204) {
            return callback(null, {statusCode: err.statusCode});
        } else if (err) {
            return callback(err);
        }
        callback(null, {
            statusCode: data.statusCode,
            headers: data.headers,
        });
    });
}

/**
 * 删除 Bucket 的 跨域设置
 * @param  {Object}  params                 参数对象，必须
 *     @param  {String}  params.Bucket      Bucket名称，必须
 *     @param  {String}  params.Region      地域名称，必须
 * @param  {Function}  callback             回调函数，必须
 * @return  {Object}  err                   请求失败的错误，如果请求成功，则为空。https://cloud.tencent.com/document/product/436/7730
 * @return  {Object}  data                  返回的数据
 */
function deleteBucketPolicy(params, callback) {
    submitRequest.call(this, {
        Action: 'name/cos:DeleteBucketPolicy',
        method: 'DELETE',
        Bucket: params.Bucket,
        Region: params.Region,
        headers: params.Headers,
        action: 'policy',
    }, function (err, data) {
        if (err && err.statusCode === 204) {
            return callback(null, {statusCode: err.statusCode});
        } else if (err) {
            return callback(err);
        }
        callback(null, {
            statusCode: data.statusCode || err.statusCode,
            headers: data.headers,
        });
    });
}

/**
 * 获取 Bucket 的 地域信息
 * @param  {Object}  params             参数对象，必须
 *     @param  {String}  params.Bucket  Bucket名称，必须
 *     @param  {String}  params.Region  地域名称，必须
 * @param  {Function}  callback         回调函数，必须
 * @return  {Object}  err               请求失败的错误，如果请求成功，则为空。https://cloud.tencent.com/document/product/436/7730
 * @return  {Object}  data              返回数据，包含地域信息 LocationConstraint
 */
function getBucketLocation(params, callback) {
    submitRequest.call(this, {
        Action: 'name/cos:GetBucketLocation',
        method: 'GET',
        Bucket: params.Bucket,
        Region: params.Region,
        headers: params.Headers,
        action: 'location',
    }, function (err, data) {
        if (err) {
            return callback(err);
        }
        callback(null, data);
    });
}

/**
 * 获取 Bucket 的读取权限策略
 * @param  {Object}  params             参数对象，必须
 *     @param  {String}  params.Bucket  Bucket名称，必须
 *     @param  {String}  params.Region  地域名称，必须
 * @param  {Function}  callback         回调函数，必须
 * @return  {Object}  err               请求失败的错误，如果请求成功，则为空。https://cloud.tencent.com/document/product/436/7730
 * @return  {Object}  data              返回数据
 */
function getBucketPolicy(params, callback) {
    submitRequest.call(this, {
        Action: 'name/cos:GetBucketPolicy',
        method: 'GET',
        Bucket: params.Bucket,
        Region: params.Region,
        headers: params.Headers,
        action: 'policy',
        rawBody: true,
    }, function (err, data) {
        if (err) {
            if (err.statusCode && err.statusCode === 403) {
                return callback({ErrorStatus: 'Access Denied'});
            }
            if (err.statusCode && err.statusCode === 405) {
                return callback({ErrorStatus: 'Method Not Allowed'});
            }
            if (err.statusCode && err.statusCode === 404) {
                return callback({ErrorStatus: 'Policy Not Found'});
            }
            return callback(err);
        }
        var Policy = {};
        try {
            Policy = JSON.parse(data.body);
        } catch (e) {
        }
        callback(null, {
            Policy: Policy,
            statusCode: data.statusCode,
            headers: data.headers,
        });
    });
}

/**
 * 获取 Bucket 的标签设置
 * @param  {Object}  params             参数对象，必须
 *     @param  {String}  params.Bucket  Bucket名称，必须
 *     @param  {String}  params.Region  地域名称，必须
 * @param  {Function}  callback         回调函数，必须
 * @return  {Object}  err               请求失败的错误，如果请求成功，则为空。https://cloud.tencent.com/document/product/436/7730
 * @return  {Object}  data              返回数据
 */
function getBucketTagging(params, callback) {
    submitRequest.call(this, {
        Action: 'name/cos:GetBucketTagging',
        method: 'GET',
        Bucket: params.Bucket,
        Region: params.Region,
        headers: params.Headers,
        action: 'tagging',
    }, function (err, data) {
        if (err) {
            if (err.statusCode === 404 && err.error && (err.error === "Not Found" || err.error.Code === 'NoSuchTagSet')) {
                var result = {
                    Tags: [],
                    statusCode: err.statusCode,
                };
                err.headers && (result.headers = err.headers);
                callback(null, result);
            } else {
                callback(err);
            }
            return;
        }
        var Tags = [];
        try {
            Tags = data.Tagging.TagSet.Tag || [];
        } catch (e) {
        }
        Tags = util.clone(util.isArray(Tags) ? Tags : [Tags]);
        callback(null, {
            Tags: Tags,
            statusCode: data.statusCode,
            headers: data.headers,
        });
    });
}

/**
 * 设置 Bucket 的标签
 * @param  {Object}  params             参数对象，必须
 *     @param  {String}  params.Bucket  Bucket名称，必须
 *     @param  {String}  params.Region  地域名称，必须
 *     @param  {Array}   params.TagSet  标签设置，必须
 * @param  {Function}  callback         回调函数，必须
 * @return  {Object}  err               请求失败的错误，如果请求成功，则为空。https://cloud.tencent.com/document/product/436/7730
 * @return  {Object}  data              返回数据
 */
function putBucketTagging(params, callback) {

    var Tagging = params['Tagging'] || {};
    var Tags = Tagging.TagSet || Tagging.Tags || params['Tags'] || [];
    Tags = util.clone(util.isArray(Tags) ? Tags : [Tags]);
    var xml = util.json2xml({Tagging: {TagSet: {Tag: Tags}}});

    var headers = params.Headers;
    headers['Content-Type'] = 'application/xml';
    headers['Content-MD5'] = util.binaryBase64(util.md5(xml));

    submitRequest.call(this, {
        Action: 'name/cos:PutBucketTagging',
        method: 'PUT',
        Bucket: params.Bucket,
        Region: params.Region,
        body: xml,
        action: 'tagging',
        headers: headers,
    }, function (err, data) {
        if (err && err.statusCode === 204) {
            return callback(null, {statusCode: err.statusCode});
        } else if (err) {
            return callback(err);
        }
        callback(null, {
            statusCode: data.statusCode,
            headers: data.headers,
        });
    });
}


/**
 * 删除 Bucket 的 标签设置
 * @param  {Object}  params             参数对象，必须
 *     @param  {String}  params.Bucket  Bucket名称，必须
 *     @param  {String}  params.Region  地域名称，必须
 * @param  {Function}  callback         回调函数，必须
 * @return  {Object}  err               请求失败的错误，如果请求成功，则为空。https://cloud.tencent.com/document/product/436/7730
 * @return  {Object}  data              返回的数据
 */
function deleteBucketTagging(params, callback) {
    submitRequest.call(this, {
        Action: 'name/cos:DeleteBucketTagging',
        method: 'DELETE',
        Bucket: params.Bucket,
        Region: params.Region,
        headers: params.Headers,
        action: 'tagging',
    }, function (err, data) {
        if (err && err.statusCode === 204) {
            return callback(null, {statusCode: err.statusCode});
        } else if (err) {
            return callback(err);
        }
        callback(null, {
            statusCode: data.statusCode,
            headers: data.headers,
        });
    });
}

function putBucketLifecycle(params, callback) {

    var LifecycleConfiguration = params['LifecycleConfiguration'] || {};
    var Rules = LifecycleConfiguration.Rules || params.Rules || [];
    Rules = util.clone(Rules);
    var xml = util.json2xml({LifecycleConfiguration: {Rule: Rules}});

    var headers = params.Headers;
    headers['Content-Type'] = 'application/xml';
    headers['Content-MD5'] = util.binaryBase64(util.md5(xml));

    submitRequest.call(this, {
        Action: 'name/cos:PutBucketLifecycle',
        method: 'PUT',
        Bucket: params.Bucket,
        Region: params.Region,
        body: xml,
        action: 'lifecycle',
        headers: headers,
    }, function (err, data) {
        if (err && err.statusCode === 204) {
            return callback(null, {statusCode: err.statusCode});
        } else if (err) {
            return callback(err);
        }
        callback(null, {
            statusCode: data.statusCode,
            headers: data.headers,
        });
    });
}

function getBucketLifecycle(params, callback) {
    submitRequest.call(this, {
        Action: 'name/cos:GetBucketLifecycle',
        method: 'GET',
        Bucket: params.Bucket,
        Region: params.Region,
        headers: params.Headers,
        action: 'lifecycle',
    }, function (err, data) {
        if (err) {
            if (err.statusCode === 404 && err.error && err.error.Code === 'NoSuchLifecycleConfiguration') {
                var result = {
                    Rules: [],
                    statusCode: err.statusCode,
                };
                err.headers && (result.headers = err.headers);
                callback(null, result);
            } else {
                callback(err);
            }
            return;
        }
        var Rules = [];
        try {
            Rules = data.LifecycleConfiguration.Rule || [];
        } catch (e) {
        }
        Rules = util.clone(util.isArray(Rules) ? Rules : [Rules]);
        callback(null, {
            Rules: Rules,
            statusCode: data.statusCode,
            headers: data.headers,
        });
    });
}

function deleteBucketLifecycle(params, callback) {
    submitRequest.call(this, {
        Action: 'name/cos:DeleteBucketLifecycle',
        method: 'DELETE',
        Bucket: params.Bucket,
        Region: params.Region,
        headers: params.Headers,
        action: 'lifecycle',
    }, function (err, data) {
        if (err && err.statusCode === 204) {
            return callback(null, {statusCode: err.statusCode});
        } else if (err) {
            return callback(err);
        }
        callback(null, {
            statusCode: data.statusCode,
            headers: data.headers,
        });
    });
}

function putBucketVersioning(params, callback) {

    if (!params['VersioningConfiguration']) {
        callback({error: 'missing param VersioningConfiguration'});
        return;
    }
    var VersioningConfiguration = params['VersioningConfiguration'] || {};
    var xml = util.json2xml({VersioningConfiguration: VersioningConfiguration});

    var headers = params.Headers;
    headers['Content-Type'] = 'application/xml';
    headers['Content-MD5'] = util.binaryBase64(util.md5(xml));

    submitRequest.call(this, {
        Action: 'name/cos:PutBucketVersioning',
        method: 'PUT',
        Bucket: params.Bucket,
        Region: params.Region,
        body: xml,
        action: 'versioning',
        headers: headers,
    }, function (err, data) {
        if (err && err.statusCode === 204) {
            return callback(null, {statusCode: err.statusCode});
        } else if (err) {
            return callback(err);
        }
        callback(null, {
            statusCode: data.statusCode,
            headers: data.headers,
        });
    });
}

function getBucketVersioning(params, callback) {
    submitRequest.call(this, {
        Action: 'name/cos:GetBucketVersioning',
        method: 'GET',
        Bucket: params.Bucket,
        Region: params.Region,
        headers: params.Headers,
        action: 'versioning',
    }, function (err, data) {
        if (!err) {
            !data.VersioningConfiguration && (data.VersioningConfiguration = {});
        }
        callback(err, data);
    });
}

function putBucketReplication(params, callback) {
    var ReplicationConfiguration = util.clone(params.ReplicationConfiguration);
    var xml = util.json2xml({ReplicationConfiguration: ReplicationConfiguration});
    xml = xml.replace(/<(\/?)Rules>/ig, '<$1Rule>');
    xml = xml.replace(/<(\/?)Tags>/ig, '<$1Tag>');

    var headers = params.Headers;
    headers['Content-Type'] = 'application/xml';
    headers['Content-MD5'] = util.binaryBase64(util.md5(xml));

    submitRequest.call(this, {
        Action: 'name/cos:PutBucketReplication',
        method: 'PUT',
        Bucket: params.Bucket,
        Region: params.Region,
        body: xml,
        action: 'replication',
        headers: headers,
    }, function (err, data) {
        if (err && err.statusCode === 204) {
            return callback(null, {statusCode: err.statusCode});
        } else if (err) {
            return callback(err);
        }
        callback(null, {
            statusCode: data.statusCode,
            headers: data.headers,
        });
    });
}

function getBucketReplication(params, callback) {
    submitRequest.call(this, {
        Action: 'name/cos:GetBucketReplication',
        method: 'GET',
        Bucket: params.Bucket,
        Region: params.Region,
        headers: params.Headers,
        action: 'replication',
    }, function (err, data) {
        if (err) {
            if (err.statusCode === 404 && err.error && (err.error === 'Not Found' || err.error.Code === 'ReplicationConfigurationnotFoundError')) {
                var result = {
                    ReplicationConfiguration: {Rules: []},
                    statusCode: err.statusCode,
                };
                err.headers && (result.headers = err.headers);
                callback(null, result);
            } else {
                callback(err);
            }
            return;
        }
        if (!err) {
            !data.ReplicationConfiguration && (data.ReplicationConfiguration = {});
        }
        if (data.ReplicationConfiguration.Rule) {
            data.ReplicationConfiguration.Rules = data.ReplicationConfiguration.Rule;
            delete data.ReplicationConfiguration.Rule;
        }
        callback(err, data);
    });
}

function deleteBucketReplication(params, callback) {
    submitRequest.call(this, {
        Action: 'name/cos:DeleteBucketReplication',
        method: 'DELETE',
        Bucket: params.Bucket,
        Region: params.Region,
        headers: params.Headers,
        action: 'replication',
    }, function (err, data) {
        if (err && err.statusCode === 204) {
            return callback(null, {statusCode: err.statusCode});
        } else if (err) {
            return callback(err);
        }
        callback(null, {
            statusCode: data.statusCode,
            headers: data.headers,
        });
    });
}

// Object 相关

/**
 * 取回对应Object的元数据，Head的权限与Get的权限一致
 * @param  {Object}  params                         参数对象，必须
 *     @param  {String}  params.Bucket              Bucket名称，必须
 *     @param  {String}  params.Region              地域名称，必须
 *     @param  {String}  params.Key                 文件名称，必须
 *     @param  {String}  params.IfModifiedSince     当Object在指定时间后被修改，则返回对应Object元信息，否则返回304，非必须
 * @param  {Function}  callback                     回调函数，必须
 * @return  {Object}  err                           请求失败的错误，如果请求成功，则为空。https://cloud.tencent.com/document/product/436/7730
 * @return  {Object}  data                          为指定 object 的元数据，如果设置了 IfModifiedSince ，且文件未修改，则返回一个对象，NotModified 属性为 true
 *     @return  {Boolean}  data.NotModified         是否在 IfModifiedSince 时间点之后未修改该 object，则为 true
 */
function headObject(params, callback) {
    submitRequest.call(this, {
        Action: 'name/cos:HeadObject',
        method: 'HEAD',
        Bucket: params.Bucket,
        Region: params.Region,
        Key: params.Key,
        VersionId: params.VersionId,
        headers: params.Headers,
    }, function (err, data) {
        if (err) {
            var statusCode = err.statusCode;
            if (params.Headers['If-Modified-Since'] && statusCode && statusCode === 304) {
                return callback(null, {
                    NotModified: true,
                    statusCode: statusCode,
                });
            }
            return callback(err);
        }
        if (data.headers) {
            var headers = data.headers;
            data.ETag = headers.etag || headers.Etag || headers.ETag || '';
        }
        callback(null, data);
    });
}


function listObjectVersions(params, callback) {
    var reqParams = {};
    reqParams['prefix'] = params['Prefix'] || '';
    reqParams['delimiter'] = params['Delimiter'];
    reqParams['key-marker'] = params['KeyMarker'];
    reqParams['version-id-marker'] = params['VersionIdMarker'];
    reqParams['max-keys'] = params['MaxKeys'];
    reqParams['encoding-type'] = params['EncodingType'];

    submitRequest.call(this, {
        Action: 'name/cos:GetBucketObjectVersions',
        ResourceKey: reqParams['prefix'],
        method: 'GET',
        Bucket: params.Bucket,
        Region: params.Region,
        headers: params.Headers,
        qs: reqParams,
        action: 'versions',
    }, function (err, data) {
        if (err) {
            return callback(err);
        }
        var ListVersionsResult = data.ListVersionsResult || {};
        var DeleteMarkers = ListVersionsResult.DeleteMarker || [];
        DeleteMarkers = util.isArray(DeleteMarkers) ? DeleteMarkers : [DeleteMarkers];
        var Versions = ListVersionsResult.Version || [];
        Versions = util.isArray(Versions) ? Versions : [Versions];

        var result = util.clone(ListVersionsResult);
        delete result.DeleteMarker;
        delete result.Version;
        util.extend(result, {
            DeleteMarkers: DeleteMarkers,
            Versions: Versions,
            statusCode: data.statusCode,
            headers: data.headers,
        });

        callback(null, result);
    });
}

/**
 * 下载 object
 * @param  {Object}  params                                 参数对象，必须
 *     @param  {String}  params.Bucket                      Bucket名称，必须
 *     @param  {String}  params.Region                      地域名称，必须
 *     @param  {String}  params.Key                         文件名称，必须
 *     @param  {WriteStream}  params.Output                 文件写入流，非必须
 *     @param  {String}  params.IfModifiedSince             当Object在指定时间后被修改，则返回对应Object元信息，否则返回304，非必须
 *     @param  {String}  params.IfUnmodifiedSince           如果文件修改时间早于或等于指定时间，才返回文件内容。否则返回 412 (precondition failed)，非必须
 *     @param  {String}  params.IfMatch                     当 ETag 与指定的内容一致，才返回文件。否则返回 412 (precondition failed)，非必须
 *     @param  {String}  params.IfNoneMatch                 当 ETag 与指定的内容不一致，才返回文件。否则返回304 (not modified)，非必须
 *     @param  {String}  params.ResponseContentType         设置返回头部中的 Content-Type 参数，非必须
 *     @param  {String}  params.ResponseContentLanguage     设置返回头部中的 Content-Language 参数，非必须
 *     @param  {String}  params.ResponseExpires             设置返回头部中的 Content-Expires 参数，非必须
 *     @param  {String}  params.ResponseCacheControl        设置返回头部中的 Cache-Control 参数，非必须
 *     @param  {String}  params.ResponseContentDisposition  设置返回头部中的 Content-Disposition 参数，非必须
 *     @param  {String}  params.ResponseContentEncoding     设置返回头部中的 Content-Encoding 参数，非必须
 * @param  {Function}  callback                             回调函数，必须
 * @param  {Object}  err                                    请求失败的错误，如果请求成功，则为空。https://cloud.tencent.com/document/product/436/7730
 * @param  {Object}  data                                   为对应的 object 数据，包括 body 和 headers
 */
function getObject(params, callback) {
    var reqParams = {};

    reqParams['response-content-type'] = params['ResponseContentType'];
    reqParams['response-content-language'] = params['ResponseContentLanguage'];
    reqParams['response-expires'] = params['ResponseExpires'];
    reqParams['response-cache-control'] = params['ResponseCacheControl'];
    reqParams['response-content-disposition'] = params['ResponseContentDisposition'];
    reqParams['response-content-encoding'] = params['ResponseContentEncoding'];

    // 如果用户自己传入了 output
    submitRequest.call(this, {
        Action: 'name/cos:GetObject',
        method: 'GET',
        Bucket: params.Bucket,
        Region: params.Region,
        Key: params.Key,
        VersionId: params.VersionId,
        headers: params.Headers,
        qs: reqParams,
        rawBody: true,
    }, function (err, data) {
        if (err) {
            var statusCode = err.statusCode;
            if (params.Headers['If-Modified-Since'] && statusCode && statusCode === 304) {
                return callback(null, {
                    NotModified: true
                });
            }
            return callback(err);
        }
        var result = {};
        result.Body = data.body;

        if (data && data.headers) {
            var headers = data.headers;
            result.ETag = headers.etag || headers.Etag || headers.ETag || '';
        }
        util.extend(result, {
            statusCode: data.statusCode,
            headers: data.headers,
        });
        callback(null, result);
    });

}

/**
 * 上传 object
 * @param  {Object} params                                          参数对象，必须
 *     @param  {String}  params.Bucket                              Bucket名称，必须
 *     @param  {String}  params.Region                              地域名称，必须
 *     @param  {String}  params.Key                                 文件名称，必须
 *     @param  {String}  params.Body                                上传文件的内容，只支持字符串
 *     @param  {String}  params.CacheControl                        RFC 2616 中定义的缓存策略，将作为 Object 元数据保存，非必须
 *     @param  {String}  params.ContentDisposition                  RFC 2616 中定义的文件名称，将作为 Object 元数据保存，非必须
 *     @param  {String}  params.ContentEncoding                     RFC 2616 中定义的编码格式，将作为 Object 元数据保存，非必须
 *     @param  {String}  params.ContentLength                       RFC 2616 中定义的 HTTP 请求内容长度（字节），必须
 *     @param  {String}  params.ContentType                         RFC 2616 中定义的内容类型（MIME），将作为 Object 元数据保存，非必须
 *     @param  {String}  params.Expect                              当使用 Expect: 100-continue 时，在收到服务端确认后，才会发送请求内容，非必须
 *     @param  {String}  params.Expires                             RFC 2616 中定义的过期时间，将作为 Object 元数据保存，非必须
 *     @param  {String}  params.ContentSha1                         RFC 3174 中定义的 160-bit 内容 SHA-1 算法校验，非必须
 *     @param  {String}  params.ACL                                 允许用户自定义文件权限，有效值：private | public-read，非必须
 *     @param  {String}  params.GrantRead                           赋予被授权者读的权限，格式 x-cos-grant-read: uin=" ",uin=" "，非必须
 *     @param  {String}  params.GrantWrite                          赋予被授权者写的权限，格式 x-cos-grant-write: uin=" ",uin=" "，非必须
 *     @param  {String}  params.GrantFullControl                    赋予被授权者读写权限，格式 x-cos-grant-full-control: uin=" ",uin=" "，非必须
 *     @param  {String}  params.ServerSideEncryption               支持按照指定的加密算法进行服务端数据加密，格式 x-cos-server-side-encryption: "AES256"，非必须
 *     @param  {Function}  params.onProgress                        上传进度回调函数
 * @param  {Function}  callback                                     回调函数，必须
 * @return  {Object}  err                                           请求失败的错误，如果请求成功，则为空。https://cloud.tencent.com/document/product/436/7730
 * @return  {Object}  data                                          为对应的 object 数据
 *     @return  {String}  data.ETag                                 为对应上传文件的 ETag 值
 */
function putObject(params, callback) {
    var self = this;
    var FileSize = params.ContentLength;
    var onProgress = util.throttleOnProgress.call(self, FileSize, params.onProgress);

    util.getBodyMd5(self.options.UploadCheckContentMd5, params.Body, function (md5) {
        md5 && (params.Headers['Content-MD5'] = util.binaryBase64(md5));
        if (params.ContentLength !== undefined) {
            params.Headers['Content-Length'] = params.ContentLength;
        }
        submitRequest.call(self, {
            Action: 'name/cos:PutObject',
            TaskId: params.TaskId,
            method: 'PUT',
            Bucket: params.Bucket,
            Region: params.Region,
            Key: params.Key,
            headers: params.Headers,
            body: params.Body,
            onProgress: onProgress,
        }, function (err, data) {
            if (err) {
                onProgress(null, true);
                return callback(err);
            }
            onProgress({loaded: FileSize, total: FileSize}, true);

            if (data && data.headers ) {
                var headers = data.headers;
                var ETag = headers.etag || headers.Etag || headers.ETag || '';

                var url = getUrl({
                    ForcePathStyle: self.options.ForcePathStyle,
                    protocol: self.options.Protocol,
                    domain: self.options.Domain,
                    bucket: params.Bucket,
                    region: params.Region,
                    object: params.Key,
                });
                url = url.substr(url.indexOf('://') + 3);
                return callback(null, {
                    Location: url,
                    ETag: ETag,
                    statusCode: data.statusCode,
                    headers: headers,
                });
            }
            callback(null, data);
        });
    });
}

/**
 * 上传 object
 * @param  {Object} params                                          参数对象，必须
 *     @param  {String}  params.Bucket                              Bucket名称，必须
 *     @param  {String}  params.Region                              地域名称，必须
 *     @param  {String}  params.Key                                 文件名称，必须
 *     @param  {FilePath}  params.FilePath                          要上传的文件路径
 *     @param  {Function}  params.onProgress                        上传进度回调函数
 * @param  {Function}  callback                                     回调函数，必须
 * @return  {Object}  err                                           请求失败的错误，如果请求成功，则为空。https://cloud.tencent.com/document/product/436/7730
 * @return  {Object}  data                                          为对应的 object 数据
 *     @return  {String}  data.ETag                                 为对应上传文件的 ETag 值
 */
function postObject(params, callback) {
    var self = this;
    var headers = {};

    headers['Cache-Control'] = params['CacheControl'];
    headers['Content-Disposition'] = params['ContentDisposition'];
    headers['Content-Encoding'] = params['ContentEncoding'];
    headers['Content-MD5'] = params['ContentMD5'];
    headers['Content-Length'] = params['ContentLength'];
    headers['Content-Type'] = params['ContentType'];
    headers['Expect'] = params['Expect'];
    headers['Expires'] = params['Expires'];
    headers['x-cos-acl'] = params['ACL'];
    headers['x-cos-grant-read'] = params['GrantRead'];
    headers['x-cos-grant-write'] = params['GrantWrite'];
    headers['x-cos-grant-full-control'] = params['GrantFullControl'];
    headers['x-cos-storage-class'] = params['StorageClass'];

    var filePath = params.FilePath;
    for (var key in params) {
        if (key.indexOf('x-cos-meta-') > -1) {
            headers[key] = params[key];
        }
    }

    var onProgress = util.throttleOnProgress.call(self, headers['Content-Length'], params.onProgress);

    submitRequest.call(this, {
        Action: 'name/cos:PostObject',
        method: 'POST',
        Bucket: params.Bucket,
        Region: params.Region,
        Key: params.Key,
        headers: headers,
        filePath: filePath,
        onProgress: onProgress,
    }, function (err, data) {
        onProgress(null, true);
        if (err) {
            return callback(err);
        }
        if (data && data.headers) {
            var headers = data.headers;
            var ETag = headers.etag || headers.Etag || headers.ETag || '';

            var url = getUrl({
                ForcePathStyle: self.options.ForcePathStyle,
                protocol: self.options.Protocol,
                domain: self.options.Domain,
                bucket: params.Bucket,
                region: params.Region,
                object: params.Key,
                isLocation: true,
            });

            return callback(null, {
                Location: url,
                statusCode: data.statusCode,
                headers: headers,
                ETag: ETag,
            });
        }
        callback(null, data);
    });
}

/**
 * 删除 object
 * @param  {Object}  params                     参数对象，必须
 *     @param  {String}  params.Bucket          Bucket名称，必须
 *     @param  {String}  params.Region          地域名称，必须
 *     @param  {String}  params.Key             object名称，必须
 * @param  {Function}  callback                 回调函数，必须
 * @param  {Object}  err                        请求失败的错误，如果请求成功，则为空。https://cloud.tencent.com/document/product/436/7730
 * @param  {Object}  data                       删除操作成功之后返回的数据
 */
function deleteObject(params, callback) {
    submitRequest.call(this, {
        Action: 'name/cos:DeleteObject',
        method: 'DELETE',
        Bucket: params.Bucket,
        Region: params.Region,
        Key: params.Key,
        headers: params.Headers,
        VersionId: params.VersionId,
    }, function (err, data) {
        if (err) {
            var statusCode = err.statusCode;
            if (statusCode && statusCode === 204) {
                return callback(null, {statusCode: statusCode});
            } else if (statusCode && statusCode === 404) {
                return callback(null, {BucketNotFound: true, statusCode: statusCode,});
            } else {
                return callback(err);
            }
        }
        callback(null, {
            statusCode: data.statusCode,
            headers: data.headers,
        });
    });
}

/**
 * 获取 object 的 权限列表
 * @param  {Object}  params                         参数对象，必须
 *     @param  {String}  params.Bucket              Bucket名称，必须
 *     @param  {String}  params.Region              地域名称，必须
 *     @param  {String}  params.Key                 object名称，必须
 * @param  {Function}  callback                     回调函数，必须
 * @return  {Object}  err                           请求失败的错误，如果请求成功，则为空。https://cloud.tencent.com/document/product/436/7730
 * @return  {Object}  data                          返回的数据
 *     @return  {Object}  data.AccessControlPolicy  权限列表
 */
function getObjectAcl(params, callback) {

    submitRequest.call(this, {
        Action: 'name/cos:GetObjectACL',
        method: 'GET',
        Bucket: params.Bucket,
        Region: params.Region,
        Key: params.Key,
        headers: params.Headers,
        action: 'acl',
    }, function (err, data) {
        if (err) {
            return callback(err);
        }
        var AccessControlPolicy = data.AccessControlPolicy || {};
        var Owner = AccessControlPolicy.Owner || {};
        var Grant = AccessControlPolicy.AccessControlList && AccessControlPolicy.AccessControlList.Grant || [];
        Grant = util.isArray(Grant) ? Grant : [Grant];
        var result = decodeAcl(AccessControlPolicy);
        if (data.headers && data.headers['x-cos-acl']) {
            result.ACL = data.headers['x-cos-acl'];
        }
        result = util.extend(result, {
            Owner: Owner,
            Grants: Grant,
            statusCode: data.statusCode,
            headers: data.headers,
        });
        callback(null, result);
    });
}

/**
 * 设置 object 的 权限列表
 * @param  {Object}  params             参数对象，必须
 *     @param  {String}  params.Bucket  Bucket名称，必须
 *     @param  {String}  params.Region  地域名称，必须
 *     @param  {String}  params.Key     object名称，必须
 * @param  {Function}  callback         回调函数，必须
 * @return  {Object}  err               请求失败的错误，如果请求成功，则为空。https://cloud.tencent.com/document/product/436/7730
 * @return  {Object}  data              返回的数据
 */
function putObjectAcl(params, callback) {
    var headers = params.Headers;

    var xml = '';
    if (params['AccessControlPolicy']) {
        var AccessControlPolicy = util.clone(params['AccessControlPolicy'] || {});
        var Grants = AccessControlPolicy.Grants || AccessControlPolicy.Grant;
        Grants = util.isArray(Grants) ? Grants : [Grants];
        delete AccessControlPolicy.Grant;
        delete AccessControlPolicy.Grants;
        AccessControlPolicy.AccessControlList = {Grant: Grants};
        xml = util.json2xml({AccessControlPolicy: AccessControlPolicy});

        headers['Content-Type'] = 'application/xml';
        headers['Content-MD5'] = util.binaryBase64(util.md5(xml));
    }

    // Grant Header 去重
    util.each(headers, function (val, key) {
        if (key.indexOf('x-cos-grant-') === 0) {
            headers[key] = uniqGrant(headers[key]);
        }
    });

    submitRequest.call(this, {
        Action: 'name/cos:PutObjectACL',
        method: 'PUT',
        Bucket: params.Bucket,
        Region: params.Region,
        Key: params.Key,
        action: 'acl',
        headers: headers,
        body: xml,
    }, function (err, data) {
        if (err) {
            return callback(err);
        }
        callback(null, {
            statusCode: data.statusCode,
            headers: data.headers,
        });
    });
}

/**
 * Options Object请求实现跨域访问的预请求。即发出一个 OPTIONS 请求给服务器以确认是否可以进行跨域操作。
 * @param  {Object}  params             参数对象，必须
 *     @param  {String}  params.Bucket  Bucket名称，必须
 *     @param  {String}  params.Region  地域名称，必须
 *     @param  {String}  params.Key     object名称，必须
 * @param  {Function}  callback         回调函数，必须
 * @return  {Object}  err               请求失败的错误，如果请求成功，则为空。https://cloud.tencent.com/document/product/436/7730
 * @return  {Object}  data              返回的数据
 */
function optionsObject(params, callback) {

    var headers = params.Headers;
    headers['Origin'] = params['Origin'];
    headers['Access-Control-Request-Method'] = params['AccessControlRequestMethod'];
    headers['Access-Control-Request-Headers'] = params['AccessControlRequestHeaders'];

    submitRequest.call(this, {
        Action: 'name/cos:OptionsObject',
        method: 'OPTIONS',
        Bucket: params.Bucket,
        Region: params.Region,
        Key: params.Key,
        headers: headers,
    }, function (err, data) {
        if (err) {
            if (err.statusCode && err.statusCode === 403) {
                return callback(null, {
                    OptionsForbidden: true,
                    statusCode: err.statusCode
                });
            }
            return callback(err);
        }

        var headers = data.headers || {};
        callback(null, {
            AccessControlAllowOrigin: headers['access-control-allow-origin'],
            AccessControlAllowMethods: headers['access-control-allow-methods'],
            AccessControlAllowHeaders: headers['access-control-allow-headers'],
            AccessControlExposeHeaders: headers['access-control-expose-headers'],
            AccessControlMaxAge: headers['access-control-max-age'],
            statusCode: data.statusCode,
            headers: data.headers,
        });
    });
}

/**
 * @param  {Object}                                     参数列表
 *     @param  {String}  Bucket                         Bucket 名称
 *     @param  {String}  Region                         地域名称
 *     @param  {String}  Key                            文件名称
 *     @param  {String}  CopySource                     源文件URL绝对路径，可以通过versionid子资源指定历史版本
 *     @param  {String}  ACL                            允许用户自定义文件权限。有效值：private，public-read默认值：private。
 *     @param  {String}  GrantRead                      赋予被授权者读的权限，格式 x-cos-grant-read: uin=" ",uin=" "，当需要给子账户授权时，uin="RootAcountID/SubAccountID"，当需要给根账户授权时，uin="RootAcountID"。
 *     @param  {String}  GrantWrite                     赋予被授权者写的权限，格式 x-cos-grant-write: uin=" ",uin=" "，当需要给子账户授权时，uin="RootAcountID/SubAccountID"，当需要给根账户授权时，uin="RootAcountID"。
 *     @param  {String}  GrantFullControl               赋予被授权者读写权限，格式 x-cos-grant-full-control: uin=" ",uin=" "，当需要给子账户授权时，uin="RootAcountID/SubAccountID"，当需要给根账户授权时，uin="RootAcountID"。
 *     @param  {String}  MetadataDirective              是否拷贝元数据，枚举值：Copy, Replaced，默认值Copy。假如标记为Copy，忽略Header中的用户元数据信息直接复制；假如标记为Replaced，按Header信息修改元数据。当目标路径和原路径一致，即用户试图修改元数据时，必须为Replaced
 *     @param  {String}  CopySourceIfModifiedSince      当Object在指定时间后被修改，则执行操作，否则返回412。可与x-cos-copy-source-If-None-Match一起使用，与其他条件联合使用返回冲突。
 *     @param  {String}  CopySourceIfUnmodifiedSince    当Object在指定时间后未被修改，则执行操作，否则返回412。可与x-cos-copy-source-If-Match一起使用，与其他条件联合使用返回冲突。
 *     @param  {String}  CopySourceIfMatch              当Object的ETag和给定一致时，则执行操作，否则返回412。可与x-cos-copy-source-If-Unmodified-Since一起使用，与其他条件联合使用返回冲突。
 *     @param  {String}  CopySourceIfNoneMatch          当Object的ETag和给定不一致时，则执行操作，否则返回412。可与x-cos-copy-source-If-Modified-Since一起使用，与其他条件联合使用返回冲突。
 *     @param  {String}  StorageClass                   存储级别，枚举值：存储级别，枚举值：Standard, Standard_IA，Archive；默认值：Standard
 *     @param  {String}  CacheControl                   指定所有缓存机制在整个请求/响应链中必须服从的指令。
 *     @param  {String}  ContentDisposition             MIME 协议的扩展，MIME 协议指示 MIME 用户代理如何显示附加的文件
 *     @param  {String}  ContentEncoding                HTTP 中用来对「采用何种编码格式传输正文」进行协定的一对头部字段
 *     @param  {String}  ContentLength                  设置响应消息的实体内容的大小，单位为字节
 *     @param  {String}  ContentType                    RFC 2616 中定义的 HTTP 请求内容类型（MIME），例如text/plain
 *     @param  {String}  Expect                         请求的特定的服务器行为
 *     @param  {String}  Expires                        响应过期的日期和时间
 *     @param  {String}  params.ServerSideEncryption   支持按照指定的加密算法进行服务端数据加密，格式 x-cos-server-side-encryption: "AES256"，非必须
 *     @param  {String}  ContentLanguage                指定内容语言
 *     @param  {String}  x-cos-meta-*                   允许用户自定义的头部信息，将作为 Object 元数据返回。大小限制2K。
 */
function putObjectCopy(params, callback) {
    var CopySource = params.CopySource || '';
    var m = CopySource.match(/^([^.]+-\d+)\.cos(v6)?\.([^.]+)\.[^/]+\/(.+)$/);
    if (!m) {
        callback({error: 'CopySource format error'});
        return;
    }

    var SourceBucket = m[1];
    var SourceRegion = m[3];
    var SourceKey = decodeURIComponent(m[4]);

    submitRequest.call(this, {
        Scope: [{
            action: 'name/cos:GetObject',
            bucket: SourceBucket,
            region: SourceRegion,
            prefix: SourceKey,
        }, {
            action: 'name/cos:PutObject',
            bucket: params.Bucket,
            region: params.Region,
            prefix: params.Key,
        }],
        method: 'PUT',
        Bucket: params.Bucket,
        Region: params.Region,
        Key: params.Key,
        VersionId: params.VersionId,
        headers: params.Headers,
    }, function (err, data) {
        if (err) {
            return callback(err);
        }
        var result = util.clone(data.CopyObjectResult || {});
        util.extend(result, {
            statusCode: data.statusCode,
            headers: data.headers,
        });
        callback(null, result);
    });
}

function uploadPartCopy(params, callback) {

    var CopySource = params.CopySource || '';
    var m = CopySource.match(/^([^.]+-\d+)\.cos(v6)?\.([^.]+)\.[^/]+\/(.+)$/);
    if (!m) {
        callback({error: 'CopySource format error'});
        return;
    }

    var SourceBucket = m[1];
    var SourceRegion = m[3];
    var SourceKey = decodeURIComponent(m[4]);

    submitRequest.call(this, {
        Scope: [{
            action: 'name/cos:GetObject',
            bucket: SourceBucket,
            region: SourceRegion,
            prefix: SourceKey,
        }, {
            action: 'name/cos:PutObject',
            bucket: params.Bucket,
            region: params.Region,
            prefix: params.Key,
        }],
        method: 'PUT',
        Bucket: params.Bucket,
        Region: params.Region,
        Key: params.Key,
        VersionId: params.VersionId,
        qs: {
            partNumber: params['PartNumber'],
            uploadId: params['UploadId'],
        },
        headers: params.Headers,
    }, function (err, data) {
        if (err) {
            return callback(err);
        }
        var result = util.clone(data.CopyPartResult || {});
        util.extend(result, {
            statusCode: data.statusCode,
            headers: data.headers,
        });
        callback(null, result);
    });
}

function deleteMultipleObject(params, callback) {
    var Objects = params.Objects || [];
    var Quiet = params.Quiet;
    Objects = util.isArray(Objects) ? Objects : [Objects];

    var xml = util.json2xml({Delete: {Object: Objects, Quiet: Quiet || false}});

    var headers = params.Headers;
    headers['Content-Type'] = 'application/xml';
    headers['Content-MD5'] = util.binaryBase64(util.md5(xml));

    var Scope = util.map(Objects, function (v) {
        return {
            action: 'name/cos:DeleteObject',
            bucket: params.Bucket,
            region: params.Region,
            prefix: v.Key,
        };
    });

    submitRequest.call(this, {
        Scope: Scope,
        method: 'POST',
        Bucket: params.Bucket,
        Region: params.Region,
        body: xml,
        action: 'delete',
        headers: headers,
    }, function (err, data) {
        if (err) {
            return callback(err);
        }
        var DeleteResult = data.DeleteResult || {};
        var Deleted = DeleteResult.Deleted || [];
        var Errors = DeleteResult.Error || [];

        Deleted = util.isArray(Deleted) ? Deleted : [Deleted];
        Errors = util.isArray(Errors) ? Errors : [Errors];

        var result = util.clone(DeleteResult);
        util.extend(result, {
            Error: Errors,
            Deleted: Deleted,
            statusCode: data.statusCode,
            headers: data.headers,
        });
        callback(null, result);
    });
}

function restoreObject(params, callback) {
    var headers = params.Headers;
    if (!params['RestoreRequest']) {
        callback({error: 'missing param RestoreRequest'});
        return;
    }

    var RestoreRequest = params.RestoreRequest || {};
    var xml = util.json2xml({RestoreRequest: RestoreRequest});

    headers['Content-Type'] = 'application/xml';
    headers['Content-MD5'] = util.binaryBase64(util.md5(xml));

    submitRequest.call(this, {
        Action: 'name/cos:RestoreObject',
        method: 'POST',
        Bucket: params.Bucket,
        Region: params.Region,
        Key: params.Key,
        VersionId: params.VersionId,
        body: xml,
        action: 'restore',
        headers: headers,
    }, function (err, data) {
        callback(err, data);
    });
}


// 分块上传


/**
 * 初始化分块上传
 * @param  {Object}  params                                     参数对象，必须
 *     @param  {String}  params.Bucket                          Bucket名称，必须
 *     @param  {String}  params.Region                          地域名称，必须
 *     @param  {String}  params.Key                             object名称，必须
 *     @param  {String}  params.UploadId                        object名称，必须
 *     @param  {String}  params.CacheControl                    RFC 2616 中定义的缓存策略，将作为 Object 元数据保存，非必须
 *     @param  {String}  params.ContentDisposition              RFC 2616 中定义的文件名称，将作为 Object 元数据保存    ，非必须
 *     @param  {String}  params.ContentEncoding                 RFC 2616 中定义的编码格式，将作为 Object 元数据保存，非必须
 *     @param  {String}  params.ContentType                     RFC 2616 中定义的内容类型（MIME），将作为 Object 元数据保存，非必须
 *     @param  {String}  params.Expires                         RFC 2616 中定义的过期时间，将作为 Object 元数据保存，非必须
 *     @param  {String}  params.ACL                             允许用户自定义文件权限，非必须
 *     @param  {String}  params.GrantRead                       赋予被授权者读的权限 ，非必须
 *     @param  {String}  params.GrantWrite                      赋予被授权者写的权限 ，非必须
 *     @param  {String}  params.GrantFullControl                赋予被授权者读写权限 ，非必须
 *     @param  {String}  params.StorageClass                    设置Object的存储级别，枚举值：Standard，Standard_IA，Archive，非必须
 *     @param  {String}  params.ServerSideEncryption           支持按照指定的加密算法进行服务端数据加密，格式 x-cos-server-side-encryption: "AES256"，非必须
 * @param  {Function}  callback                                 回调函数，必须
 * @return  {Object}  err                                       请求失败的错误，如果请求成功，则为空。https://cloud.tencent.com/document/product/436/7730
 * @return  {Object}  data                                      返回的数据
 */
function multipartInit(params, callback) {
    submitRequest.call(this, {
        Action: 'name/cos:InitiateMultipartUpload',
        method: 'POST',
        Bucket: params.Bucket,
        Region: params.Region,
        Key: params.Key,
        action: 'uploads',
        headers: params.Headers,
    }, function (err, data) {
        if (err) {
            return callback(err);
        }
        data = util.clone(data || {});
        if (data && data.InitiateMultipartUploadResult) {
            return callback(null, util.extend(data.InitiateMultipartUploadResult, {
                statusCode: data.statusCode,
                headers: data.headers,
            }));
        }
        callback(null, data);
    });
}

/**
 * 分块上传
 * @param  {Object}  params                                 参数对象，必须
 *     @param  {String}  params.Bucket                      Bucket名称，必须
 *     @param  {String}  params.Region                      地域名称，必须
 *     @param  {String}  params.Key                         object名称，必须
 *     @param  {String}  params.Body                        上传文件对象或字符串
 *     @param  {String} params.ContentLength                RFC 2616 中定义的 HTTP 请求内容长度（字节），非必须
 *     @param  {String} params.Expect                       当使用 Expect: 100-continue 时，在收到服务端确认后，才会发送请求内容，非必须
 *     @param  {String} params.ServerSideEncryption         支持按照指定的加密算法进行服务端数据加密，格式 x-cos-server-side-encryption: "AES256"，非必须
 *     @param  {String} params.ContentSha1                  RFC 3174 中定义的 160-bit 内容 SHA-1 算法校验值，非必须
 * @param  {Function}  callback                             回调函数，必须
 *     @return  {Object}  err                               请求失败的错误，如果请求成功，则为空。https://cloud.tencent.com/document/product/436/7730
 *     @return  {Object}  data                              返回的数据
 *     @return  {Object}  data.ETag                         返回的文件分块 sha1 值
 */
function multipartUpload(params, callback) {

    var self = this;
    util.getFileSize('multipartUpload', params, function () {
        util.getBodyMd5(self.options.UploadCheckContentMd5, params.Body, function (md5) {
            md5 && (params.Headers['Content-MD5'] = util.binaryBase64(md5));
            submitRequest.call(self, {
                Action: 'name/cos:UploadPart',
                TaskId: params.TaskId,
                method: 'PUT',
                Bucket: params.Bucket,
                Region: params.Region,
                Key: params.Key,
                qs: {
                    partNumber: params['PartNumber'],
                    uploadId: params['UploadId'],
                },
                headers: params.Headers,
                onProgress: params.onProgress,
                body: params.Body || null
            }, function (err, data) {
                if (err) {
                    return callback(err);
                }
                if(data && data.headers){
                    var headers = data.headers;
                    data.ETag = headers.etag || headers.Etag || headers.ETag || '';
                }

                callback(null, data);
            });
        });
    });

}

/**
 * 完成分块上传
 * @param  {Object}  params                             参数对象，必须
 *     @param  {String}  params.Bucket                  Bucket名称，必须
 *     @param  {String}  params.Region                  地域名称，必须
 *     @param  {String}  params.Key                     object名称，必须
 *     @param  {Array}   params.Parts                   分块信息列表，必须
 *     @param  {String}  params.Parts[i].PartNumber     块编号，必须
 *     @param  {String}  params.Parts[i].ETag           分块的 sha1 校验值
 * @param  {Function}  callback                         回调函数，必须
 * @return  {Object}  err                               请求失败的错误，如果请求成功，则为空。https://cloud.tencent.com/document/product/436/7730
 * @return  {Object}  data                              返回的数据
 *     @return  {Object}  data.CompleteMultipartUpload  完成分块上传后的文件信息，包括Location, Bucket, Key 和 ETag
 */
function multipartComplete(params, callback) {
    var self = this;

    var UploadId = params.UploadId;

    var Parts = params['Parts'];

    for (var i = 0, len = Parts.length; i < len; i++) {
        if (Parts[i]['ETag'].indexOf('"') === 0) {
            continue;
        }
        Parts[i]['ETag'] = '"' + Parts[i]['ETag'] + '"';
    }

    var xml = util.json2xml({CompleteMultipartUpload: {Part: Parts}});

    var headers = params.Headers;
    headers['Content-Type'] = 'application/xml';
    headers['Content-MD5'] = util.binaryBase64(util.md5(xml));

    submitRequest.call(this, {
        Action: 'name/cos:CompleteMultipartUpload',
        method: 'POST',
        Bucket: params.Bucket,
        Region: params.Region,
        Key: params.Key,
        qs: {
            uploadId: UploadId
        },
        body: xml,
        headers: headers,
    }, function (err, data) {
        if (err) {
            return callback(err);
        }
        var url = getUrl({
            ForcePathStyle: self.options.ForcePathStyle,
            protocol: self.options.Protocol,
            domain: self.options.Domain,
            bucket: params.Bucket,
            region: params.Region,
            object: params.Key,
            isLocation: true,
        });
        var CompleteMultipartUploadResult = data.CompleteMultipartUploadResult || {};
        var result = util.extend(CompleteMultipartUploadResult, {
            Location: url,
            statusCode: data.statusCode,
            headers: data.headers,
        });
        callback(null, result);
    });
}

/**
 * 分块上传任务列表查询
 * @param  {Object}  params                                 参数对象，必须
 *     @param  {String}  params.Bucket                      Bucket名称，必须
 *     @param  {String}  params.Region                      地域名称，必须
 *     @param  {String}  params.Delimiter                   定界符为一个符号，如果有Prefix，则将Prefix到delimiter之间的相同路径归为一类，定义为Common Prefix，然后列出所有Common Prefix。如果没有Prefix，则从路径起点开始，非必须
 *     @param  {String}  params.EncodingType                规定返回值的编码方式，非必须
 *     @param  {String}  params.Prefix                      前缀匹配，用来规定返回的文件前缀地址，非必须
 *     @param  {String}  params.MaxUploads                  单次返回最大的条目数量，默认1000，非必须
 *     @param  {String}  params.KeyMarker                   与upload-id-marker一起使用 </Br>当upload-id-marker未被指定时，ObjectName字母顺序大于key-marker的条目将被列出 </Br>当upload-id-marker被指定时，ObjectName字母顺序大于key-marker的条目被列出，ObjectName字母顺序等于key-marker同时UploadId大于upload-id-marker的条目将被列出，非必须
 *     @param  {String}  params.UploadIdMarker              与key-marker一起使用 </Br>当key-marker未被指定时，upload-id-marker将被忽略 </Br>当key-marker被指定时，ObjectName字母顺序大于key-marker的条目被列出，ObjectName字母顺序等于key-marker同时UploadId大于upload-id-marker的条目将被列出，非必须
 * @param  {Function}  callback                             回调函数，必须
 * @return  {Object}  err                                   请求失败的错误，如果请求成功，则为空。https://cloud.tencent.com/document/product/436/7730
 * @return  {Object}  data                                  返回的数据
 *     @return  {Object}  data.ListMultipartUploadsResult   分块上传任务信息
 */
function multipartList(params, callback) {
    var reqParams = {};

    reqParams['delimiter'] = params['Delimiter'];
    reqParams['encoding-type'] = params['EncodingType'];
    reqParams['prefix'] = params['Prefix'] || '';

    reqParams['max-uploads'] = params['MaxUploads'];

    reqParams['key-marker'] = params['KeyMarker'];
    reqParams['upload-id-marker'] = params['UploadIdMarker'];

    reqParams = util.clearKey(reqParams);

    submitRequest.call(this, {
        Action: 'name/cos:ListMultipartUploads',
        ResourceKey: reqParams['prefix'],
        method: 'GET',
        Bucket: params.Bucket,
        Region: params.Region,
        headers: params.Headers,
        qs: reqParams,
        action: 'uploads',
    }, function (err, data) {
        if (err) {
            return callback(err);
        }

        if (data && data.ListMultipartUploadsResult) {
            var Upload = data.ListMultipartUploadsResult.Upload || [];

            var CommonPrefixes = data.ListMultipartUploadsResult.CommonPrefixes || [];

            CommonPrefixes = util.isArray(CommonPrefixes) ? CommonPrefixes : [CommonPrefixes];
            Upload = util.isArray(Upload) ? Upload : [Upload];

            data.ListMultipartUploadsResult.Upload = Upload;
            data.ListMultipartUploadsResult.CommonPrefixes = CommonPrefixes;
        }
        var result = util.clone(data.ListMultipartUploadsResult || {});
        util.extend(result, {
            statusCode: data.statusCode,
            headers: data.headers,
        });
        callback(null, result);
    });
}

/**
 * 上传的分块列表查询
 * @param  {Object}  params                                 参数对象，必须
 *     @param  {String}  params.Bucket                      Bucket名称，必须
 *     @param  {String}  params.Region                      地域名称，必须
 *     @param  {String}  params.Key                         object名称，必须
 *     @param  {String}  params.UploadId                    标示本次分块上传的ID，必须
 *     @param  {String}  params.EncodingType                规定返回值的编码方式，非必须
 *     @param  {String}  params.MaxParts                    单次返回最大的条目数量，默认1000，非必须
 *     @param  {String}  params.PartNumberMarker            默认以UTF-8二进制顺序列出条目，所有列出条目从marker开始，非必须
 * @param  {Function}  callback                             回调函数，必须
 * @return  {Object}  err                                   请求失败的错误，如果请求成功，则为空。https://cloud.tencent.com/document/product/436/7730
 * @return  {Object}  data                                  返回的数据
 *     @return  {Object}  data.ListMultipartUploadsResult   分块信息
 */
function multipartListPart(params, callback) {
    var reqParams = {};

    reqParams['uploadId'] = params['UploadId'];
    reqParams['encoding-type'] = params['EncodingType'];
    reqParams['max-parts'] = params['MaxParts'];
    reqParams['part-number-marker'] = params['PartNumberMarker'];

    submitRequest.call(this, {
        Action: 'name/cos:ListParts',
        method: 'GET',
        Bucket: params.Bucket,
        Region: params.Region,
        Key: params.Key,
        headers: params.Headers,
        qs: reqParams,
    }, function (err, data) {
        if (err) {
            return callback(err);
        }
        var ListPartsResult = data.ListPartsResult || {};
        var Part = ListPartsResult.Part || [];
        Part = util.isArray(Part) ? Part : [Part];

        ListPartsResult.Part = Part;
        var result = util.clone(ListPartsResult);
        util.extend(result, {
            statusCode: data.statusCode,
            headers: data.headers,
        });
        callback(null, result);
    });
}

/**
 * 抛弃分块上传
 * @param  {Object}  params                 参数对象，必须
 *     @param  {String}  params.Bucket      Bucket名称，必须
 *     @param  {String}  params.Region      地域名称，必须
 *     @param  {String}  params.Key         object名称，必须
 *     @param  {String}  params.UploadId    标示本次分块上传的ID，必须
 * @param  {Function}  callback             回调函数，必须
 *     @return  {Object}    err             请求失败的错误，如果请求成功，则为空。https://cloud.tencent.com/document/product/436/7730
 *     @return  {Object}    data            返回的数据
 */
function multipartAbort(params, callback) {
    var reqParams = {};

    reqParams['uploadId'] = params['UploadId'];
    submitRequest.call(this, {
        Action: 'name/cos:AbortMultipartUpload',
        method: 'DELETE',
        Bucket: params.Bucket,
        Region: params.Region,
        Key: params.Key,
        headers: params.Headers,
        qs: reqParams,
    }, function (err, data) {
        if (err) {
            return callback(err);
        }
        callback(null, {
            statusCode: data.statusCode,
            headers: data.headers,
        });
    });
}

/**
 * 获取签名
 * @param  {Object}  params             参数对象，必须
 *     @param  {String}  params.Method  请求方法，必须
 *     @param  {String}  params.Key     object名称，必须
 *     @param  {String}  params.Expires 名超时时间，单位秒，可选
 * @return  {String}  data              返回签名字符串
 */
function getAuth(params) {
    var self = this;
    return util.getAuth({
        SecretId: params.SecretId || this.options.SecretId || '',
        SecretKey: params.SecretKey || this.options.SecretKey || '',
        Method: params.Method,
        Key: params.Key,
        Query: params.Query,
        Headers: params.Headers,
        Expires: params.Expires,
        SystemClockOffset: self.options.SystemClockOffset,
    });
}

/**
 * 获取文件下载链接
 * @param  {Object}  params                 参数对象，必须
 *     @param  {String}  params.Bucket      Bucket名称，必须
 *     @param  {String}  params.Region      地域名称，必须
 *     @param  {String}  params.Key         object名称，必须
 *     @param  {String}  params.Method      请求的方法，可选
 *     @param  {String}  params.Expires     签名超时时间，单位秒，可选
 * @param  {Function}  callback             回调函数，必须
 *     @return  {Object}    err             请求失败的错误，如果请求成功，则为空。https://cloud.tencent.com/document/product/436/7730
 *     @return  {Object}    data            返回的数据
 */
function getObjectUrl(params, callback) {
    var self = this;
    var url = getUrl({
        ForcePathStyle: self.options.ForcePathStyle,
        protocol: params.Protocol || self.options.Protocol,
        domain: self.options.Domain,
        bucket: params.Bucket,
        region: params.Region,
        object: params.Key,
    });
    if (params.Sign !== undefined && !params.Sign) {
        callback(null, {Url: url});
        return url;
    }
    var AuthData = getAuthorizationAsync.call(this, {
        Action: ((params.Method || '').toUpperCase() === 'PUT' ? 'name/cos:PutObject' : 'name/cos:GetObject'),
        Bucket: params.Bucket || '',
        Region: params.Region || '',
        Method: params.Method || 'get',
        Key: params.Key,
        Expires: params.Expires,
    }, function (err, AuthData) {
        if (!callback) return;
        if (err) {
            callback(err);
            return;
        }
        var signUrl = url;
        signUrl += '?' + (AuthData.Authorization.indexOf('q-signature') > -1 ?
            AuthData.Authorization : 'sign=' + encodeURIComponent(AuthData.Authorization));
        AuthData.XCosSecurityToken && (signUrl += '&x-cos-security-token=' + AuthData.XCosSecurityToken);
        AuthData.ClientIP && (signUrl += '&clientIP=' + AuthData.ClientIP);
        AuthData.ClientUA && (signUrl += '&clientUA=' + AuthData.ClientUA);
        AuthData.Token && (signUrl += '&token=' + AuthData.Token);
        setTimeout(function () {
            callback(null, {Url: signUrl});
        });
    });
    if (AuthData) {
        return url + '?' + AuthData.Authorization +
            (AuthData.XCosSecurityToken ? '&x-cos-security-token=' + AuthData.XCosSecurityToken : '');
    } else {
        return url;
    }
}


/**
 * 私有方法
 */
function decodeAcl(AccessControlPolicy) {
    var result = {
        GrantFullControl: [],
        GrantWrite: [],
        GrantRead: [],
        GrantReadAcp: [],
        GrantWriteAcp: [],
        ACL: '',
    };
    var GrantMap = {
        'FULL_CONTROL': 'GrantFullControl',
        'WRITE': 'GrantWrite',
        'READ': 'GrantRead',
        'READ_ACP': 'GrantReadAcp',
        'WRITE_ACP': 'GrantWriteAcp',
    };
    var Grant = AccessControlPolicy.AccessControlList.Grant;
    if (Grant) {
        Grant = util.isArray(Grant) ? Grant : [Grant];
    }
    var PublicAcl = {READ: 0, WRITE: 0, FULL_CONTROL: 0};
    Grant.length && util.each(Grant, function (item) {
        if (item.Grantee.ID === 'qcs::cam::anyone:anyone' || item.Grantee.URI === 'http://cam.qcloud.com/groups/global/AllUsers') {
            PublicAcl[item.Permission] = 1;
        } else if (item.Grantee.ID !== AccessControlPolicy.Owner.ID) {
            result[GrantMap[item.Permission]].push('id="' + item.Grantee.ID + '"');
        }
    });
    if (PublicAcl.FULL_CONTROL || (PublicAcl.WRITE && PublicAcl.READ)) {
        result.ACL = 'public-read-write';
    } else if (PublicAcl.READ) {
        result.ACL = 'public-read';
    } else {
        result.ACL = 'private';
    }
    util.each(GrantMap, function (item) {
        result[item] = uniqGrant(result[item].join(','));
    });
    return result;
}

// Grant 去重
function uniqGrant(str) {
    var arr = str.split(',');
    var exist = {};
    var i, item;
    for (i = 0; i < arr.length; ) {
        item = arr[i].trim();
        if (exist[item]) {
            arr.splice(i, 1);
        } else {
            exist[item] = true;
            arr[i] = item;
            i++;
        }
    }
    return arr.join(',');
}

// 生成操作 url
function getUrl(params) {
    var longBucket = params.bucket;
    var shortBucket = longBucket.substr(0, longBucket.lastIndexOf('-'));
    var appId = longBucket.substr(longBucket.lastIndexOf('-') + 1);
    var domain = params.domain;
    var region = params.region;
    var object = params.object;
    var protocol = 'https:';
    if (!domain) {
        if (['cn-south', 'cn-south-2', 'cn-north', 'cn-east', 'cn-southwest', 'sg'].indexOf(region) > -1) {
            domain = '{Region}.myqcloud.com';
        } else {
            domain = 'cos.{Region}.myqcloud.com';
        }
        if (!params.ForcePathStyle) {
            domain = '{Bucket}.' + domain;
        }
    }
    domain = domain.replace(/\{\{AppId\}\}/ig, appId)
        .replace(/\{\{Bucket\}\}/ig, shortBucket)
        .replace(/\{\{Region\}\}/ig, region)
        .replace(/\{\{.*?\}\}/ig, '');
    domain = domain.replace(/\{AppId\}/ig, appId)
        .replace(/\{BucketName\}/ig, shortBucket)
        .replace(/\{Bucket\}/ig, longBucket)
        .replace(/\{Region\}/ig, region)
        .replace(/\{.*?\}/ig, '');
    if (!/^[a-zA-Z]+:\/\//.test(domain)) {
        domain = protocol + '//' + domain;
    }

    // 去掉域名最后的斜杆
    if (domain.slice(-1) === '/') {
        domain = domain.slice(0, -1);
    }
    var url = domain;

    if (params.ForcePathStyle) {
        url += '/' + longBucket;
    }
    url += '/';
    if (object) {
        url += util.camSafeUrlEncode(object).replace(/%2F/g, '/');
    }

    if (params.isLocation) {
        url = url.replace(/^https?:\/\//, '');
    }
    return url;
}

// 异步获取签名
function getAuthorizationAsync(params, callback) {

    var headers = util.clone(params.Headers);
    delete headers['Content-Type'];
    delete headers['Cache-Control'];
    util.each(headers, function (v, k) {
        v === '' && delete headers[k];
    });

    var cb = function (AuthData) {

        // 检查签名格式
        var formatAllow = false;
        var auth = AuthData.Authorization;
        if (auth) {
            if (auth.indexOf(' ') > -1) {
                formatAllow = false;
            } else if (auth.indexOf('q-sign-algorithm=') > -1 &&
                auth.indexOf('q-ak=') > -1 &&
                auth.indexOf('q-sign-time=') > -1 &&
                auth.indexOf('q-key-time=') > -1 &&
                auth.indexOf('q-url-param-list=') > -1) {
                formatAllow = true;
            } else {
                try {
                    auth = base64.atob(auth);
                    if (auth.indexOf('a=') > -1 &&
                        auth.indexOf('k=') > -1 &&
                        auth.indexOf('t=') > -1 &&
                        auth.indexOf('r=') > -1 &&
                        auth.indexOf('b=') > -1) {
                        formatAllow = true;
                    }
                } catch (e) {}
            }
        }
        if (formatAllow) {
            callback && callback(null, AuthData);
        } else {
            callback && callback('authorization error');
        }
    };

    var self = this;
    var Bucket = params.Bucket || '';
    var Region = params.Region || '';

    // PathName
    var KeyName = params.Action === 'name/cos:PostObject' || !params.Key ? '' : params.Key;
    if (self.options.ForcePathStyle && Bucket) {
        KeyName = Bucket + '/' + KeyName;
    }
    var Pathname = '/' + KeyName;

    // Action、ResourceKey
    var StsData = {};
    var Scope = params.Scope;
    if (!Scope) {
        var Action = params.Action || '';
        var ResourceKey = params.ResourceKey || params.Key || '';
        Scope = params.Scope || [{
            action: Action,
            bucket: Bucket,
            region: Region,
            prefix: ResourceKey,
        }];
    }
    var ScopeKey  = util.md5(JSON.stringify(Scope));

    // STS
    self._StsCache = self._StsCache ||[];
    (function () {
        var i, AuthData;
        for (i = self._StsCache.length - 1; i >= 0; i--) {
            AuthData = self._StsCache[i];
            var compareTime = Math.round(util.getSkewTime(self.options.SystemClockOffset) / 1000) + 30;
            if (AuthData.StartTime && compareTime < AuthData.StartTime || compareTime >= AuthData.ExpiredTime) {
                self._StsCache.splice(i, 1);
                continue;
            }
            if (!AuthData.ScopeLimit || AuthData.ScopeLimit && AuthData.ScopeKey === ScopeKey) {
                StsData = AuthData;
                break;
            }
        }
    })();

    var calcAuthByTmpKey = function () {
        var KeyTime = StsData.StartTime && StsData.ExpiredTime ? StsData.StartTime + ';' + StsData.ExpiredTime : '';
        var Authorization = util.getAuth({
            SecretId: StsData.TmpSecretId,
            SecretKey: StsData.TmpSecretKey,
            Method: params.Method,
            Pathname: Pathname,
            Query: params.Query,
            Headers: headers,
            Expires: params.Expires,
            SystemClockOffset: self.options.SystemClockOffset,
            KeyTime: KeyTime
        });
        var AuthData = {
            Authorization: Authorization,
            XCosSecurityToken: StsData.XCosSecurityToken || '',
            Token: StsData.Token || '',
            ClientIP: StsData.ClientIP || '',
            ClientUA: StsData.ClientUA || '',
        };
        cb(AuthData);
    };

    // 先判断是否有临时密钥
    if (StsData.ExpiredTime && StsData.ExpiredTime - (util.getSkewTime(self.options.SystemClockOffset) / 1000) > 60) { // 如果缓存的临时密钥有效，并还有超过60秒有效期就直接使用
        calcAuthByTmpKey();
    } else if (self.options.getAuthorization) { // 外部计算签名或获取临时密钥
        self.options.getAuthorization.call(self, {
            Bucket: Bucket,
            Region: Region,
            Method: params.Method,
            Key: KeyName,
            Pathname: Pathname,
            Query: params.Query,
            Headers: headers,
            Scope: Scope,
        }, function (AuthData) {
            if (typeof AuthData === 'string') {
                AuthData = {Authorization: AuthData};
            }
            if (AuthData.TmpSecretId &&
                AuthData.TmpSecretKey &&
                AuthData.XCosSecurityToken &&
                AuthData.ExpiredTime) {
                StsData = AuthData || {};
                StsData.Scope = Scope;
                StsData.ScopeKey = ScopeKey;
                self._StsCache.push(StsData);
                calcAuthByTmpKey();
            } else {
                cb(AuthData);
            }
        });
    } else if (self.options.getSTS) { // 外部获取临时密钥
        self.options.getSTS.call(self, {
            Bucket: Bucket,
            Region: Region,
        }, function (data) {
            StsData = data || {};
            StsData.Scope = Scope;
            StsData.ScopeKey = ScopeKey;
            StsData.TmpSecretId = StsData.SecretId;
            StsData.TmpSecretKey = StsData.SecretKey;
            self._StsCache.push(StsData);
            calcAuthByTmpKey();
        });
    } else { // 内部计算获取签名
        return (function () {
            var Authorization = util.getAuth({
                SecretId: params.SecretId || self.options.SecretId,
                SecretKey: params.SecretKey || self.options.SecretKey,
                Method: params.Method,
                Pathname: Pathname,
                Query: params.Query,
                Headers: headers,
                Expires: params.Expires,
                SystemClockOffset: self.options.SystemClockOffset,
            });
            var AuthData = {
                Authorization: Authorization,
                XCosSecurityToken: self.options.XCosSecurityToken,
            };
            cb(AuthData);
            return AuthData;
        })();
    }
    return '';
}

// 调整时间偏差
function allowRetry(err) {
    var allowRetry = false;
    var isTimeError = false;
    var serverDate = (err.headers && (err.headers.date || err.headers.Date)) || '';
    try {
        var errorCode = err.error.Code;
        var errorMessage = err.error.Message;
        if (errorCode === 'RequestTimeTooSkewed' ||
            (errorCode === 'AccessDenied' && errorMessage === 'Request has expired')) {
            isTimeError = true;
        }
    } catch (e) {
    }
    if (err) {
        if (isTimeError && serverDate) {
            var serverTime = Date.parse(serverDate);
            if (this.options.CorrectClockSkew && Math.abs(util.getSkewTime(this.options.SystemClockOffset) - serverTime) >= 30000) {
                console.error('error: Local time is too skewed.');
                this.options.SystemClockOffset = serverTime - Date.now();
                allowRetry = true;
            }
        } else if (Math.round(err.statusCode / 100) === 5) {
            allowRetry = true;
        }
    }
    return allowRetry;
}

// 获取签名并发起请求
function submitRequest(params, callback) {
    var self = this;

    // 处理 headers
    !params.headers && (params.headers = {});

    // 处理 query
    !params.qs && (params.qs = {});
    params.VersionId && (params.qs.versionId = params.VersionId);
    params.qs = util.clearKey(params.qs);

    // 清理 undefined 和 null 字段
    params.headers && (params.headers = util.clearKey(params.headers));
    params.qs && (params.qs = util.clearKey(params.qs));

    var Query = util.clone(params.qs);
    params.action && (Query[params.action] = '');

    var next = function (tryIndex) {
        var oldClockOffset = self.options.SystemClockOffset;
        getAuthorizationAsync.call(self, {
            Bucket: params.Bucket || '',
            Region: params.Region || '',
            Method: params.method,
            Key: params.Key,
            Query: Query,
            Headers: params.headers,
            Action: params.Action,
            ResourceKey: params.ResourceKey,
            Scope: params.Scope,
        }, function (err, AuthData) {
            params.AuthData = AuthData;
            _submitRequest.call(self, params, function (err, data) {
                if (err && tryIndex < 2 && (oldClockOffset !== self.options.SystemClockOffset || allowRetry.call(self, err))) {
                    if (params.headers) {
                        delete params.headers.Authorization;
                        delete params.headers['token'];
                        delete params.headers['clientIP'];
                        delete params.headers['clientUA'];
                        delete params.headers['x-cos-security-token'];
                    }
                    next(tryIndex + 1);
                } else {
                    callback(err, data);
                }
            });
        });
    };
    next(0);

}

// 发起请求
function _submitRequest(params, callback) {
    var self = this;
    var TaskId = params.TaskId;
    if (TaskId && !self._isRunningTask(TaskId)) return;

    var bucket = params.Bucket;
    var region = params.Region;
    var object = params.Key;
    var method = params.method || 'GET';
    var url = params.url;
    var body = params.body;
    var json = params.json;
    var rawBody = params.rawBody;

    // url
    url = url || getUrl({
        ForcePathStyle: self.options.ForcePathStyle,
        protocol: self.options.Protocol,
        domain: self.options.Domain,
        bucket: bucket,
        region: region,
        object: object,
    });
    if (params.action) {
        url = url + '?' + params.action;
    }

    var opt = {
        method: method,
        url: url,
        headers: params.headers,
        qs: params.qs,
        filePath: params.filePath,
        body: body,
        json: json,
    };

    // 获取签名
    opt.headers.Authorization = params.AuthData.Authorization;
    params.AuthData.Token && (opt.headers['token'] = params.AuthData.Token);
    params.AuthData.ClientIP && (opt.headers['clientIP'] = params.AuthData.ClientIP);
    params.AuthData.ClientUA && (opt.headers['clientUA'] = params.AuthData.ClientUA);
    params.AuthData.XCosSecurityToken && (opt.headers['x-cos-security-token'] = params.AuthData.XCosSecurityToken);

    // 清理 undefined 和 null 字段
    opt.headers && (opt.headers = util.clearKey(opt.headers));
    opt = util.clearKey(opt);

    // progress
    if (params.onProgress && typeof params.onProgress === 'function') {
        opt.onProgress = function (e) {
            if (TaskId && !self._isRunningTask(TaskId)) return;
            var loaded = e ? e.loaded : 0;
            params.onProgress({loaded: loaded, total: e.total});
        };
    }

    self.options.ForcePathStyle && (opt.pathStyle = self.options.ForcePathStyle);
    var sender = REQUEST(opt, function (err, response, body) {

        // 返回内容添加 状态码 和 headers
        var hasReturned;
        var cb = function (err, data) {
            TaskId && self.off('inner-kill-task', killTask);
            if (hasReturned) return;
            hasReturned = true;
            var attrs = {};
            response && response.statusCode && (attrs.statusCode = response.statusCode);
            response && response.headers && (attrs.headers = response.headers);
            if (err) {
                err = util.extend(err || {}, attrs);
                callback(err, null);
            } else {
                data = util.extend(data || {}, attrs);
                callback(null, data);
            }
        };

        // 请求错误，发生网络错误
        if (err) {
            cb({error: err});
            return;
        }

        var jsonRes;
        try {
            jsonRes = util.xml2json(body) || {};
        } catch (e) {
            jsonRes = body || {};
        }

        // 请求返回码不为 200
        var statusCode = response.statusCode;
        var statusSuccess = Math.floor(statusCode / 100) === 2; // 200 202 204 206
        if (!statusSuccess) {
            cb({error: jsonRes.Error || jsonRes});
            return;
        }

        // 不对 body 进行转换，body 直接挂载返回
        if (rawBody) {
            jsonRes = {};
            jsonRes.body = body;
        }

        if (jsonRes.Error) {
            cb({error: jsonRes.Error});
            return;
        }
        cb(null, jsonRes);
    });

    // kill task
    var killTask = function (data) {
        if (data.TaskId === TaskId) {
            sender && sender.abort && sender.abort();
            self.off('inner-kill-task', killTask);
        }
    };
    TaskId && self.on('inner-kill-task', killTask);

}


var API_MAP = {
    // Bucket 相关方法
    getService: getService,
    putBucket: putBucket,
    getBucket: getBucket,
    headBucket: headBucket,
    deleteBucket: deleteBucket,
    getBucketAcl: getBucketAcl,
    putBucketAcl: putBucketAcl,
    getBucketCors: getBucketCors,
    putBucketCors: putBucketCors,
    deleteBucketCors: deleteBucketCors,
    getBucketLocation: getBucketLocation,
    putBucketTagging: putBucketTagging,
    getBucketTagging: getBucketTagging,
    deleteBucketTagging: deleteBucketTagging,
    getBucketPolicy: getBucketPolicy,
    putBucketPolicy: putBucketPolicy,
    deleteBucketPolicy: deleteBucketPolicy,
    getBucketLifecycle: getBucketLifecycle,
    putBucketLifecycle: putBucketLifecycle,
    deleteBucketLifecycle: deleteBucketLifecycle,
    putBucketVersioning: putBucketVersioning,
    getBucketVersioning: getBucketVersioning,
    putBucketReplication: putBucketReplication,
    getBucketReplication: getBucketReplication,
    deleteBucketReplication: deleteBucketReplication,

    // Object 相关方法
    getObject: getObject,
    headObject: headObject,
    listObjectVersions: listObjectVersions,
    putObject: putObject,
    postObject: postObject,
    deleteObject: deleteObject,
    getObjectAcl: getObjectAcl,
    putObjectAcl: putObjectAcl,
    optionsObject: optionsObject,
    putObjectCopy: putObjectCopy,
    deleteMultipleObject: deleteMultipleObject,
    restoreObject: restoreObject,

    // 分块上传相关方法
    uploadPartCopy: uploadPartCopy,
    multipartInit: multipartInit,
    multipartUpload: multipartUpload,
    multipartComplete: multipartComplete,
    multipartList: multipartList,
    multipartListPart: multipartListPart,
    multipartAbort: multipartAbort,

    // 工具方法
    getObjectUrl: getObjectUrl,
    getAuth: getAuth,
};

module.exports.init = function (COS, task) {
    task.transferToTaskMethod(API_MAP, 'postObject');
    util.each(API_MAP, function (fn, apiName) {
        COS.prototype[apiName] = util.apiWrapper(apiName, fn);
    });
};


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

var util = __webpack_require__(0);

var originApiMap = {};
var transferToTaskMethod = function (apiMap, apiName) {
    originApiMap[apiName] = apiMap[apiName];
    apiMap[apiName] = function (params, callback) {
        if (params.SkipTask) {
            originApiMap[apiName].call(this, params, callback);
        } else {
            this._addTask(apiName, params, callback);
        }
    };
};

var initTask = function (cos) {

    var queue = [];
    var tasks = {};
    var uploadingFileCount = 0;
    var nextUploadIndex = 0;

    // 接口返回简略的任务信息
    var formatTask = function (task) {
        var t = {
            id: task.id,
            Bucket: task.Bucket,
            Region: task.Region,
            Key: task.Key,
            FilePath: task.FilePath,
            state: task.state,
            loaded: task.loaded,
            size: task.size,
            speed: task.speed,
            percent: task.percent,
            hashPercent: task.hashPercent,
            error: task.error,
        };
        if (task.FilePath) t.FilePath = task.FilePath;
        return t;
    };

    var emitListUpdate = function () {
        cos.emit('list-update', {list: util.map(queue, formatTask)});
    };

    var clearQueue = function () {
        if (queue.length > cos.options.UploadQueueSize) {
            var i;
            for (i = 0;
                 i < queue.length &&
                 queue.length > cos.options.UploadQueueSize && // 大于队列才处理
                 i < nextUploadIndex; // 小于当前操作的 index 才处理
                 i++) {
                if (!queue[i] || queue[i].state !== 'waiting') {
                    queue.splice(i, 1);
                    nextUploadIndex--;
                }
            }
        }
    };

    var startNextTask = function () {
        if (nextUploadIndex < queue.length &&
            uploadingFileCount < cos.options.FileParallelLimit) {
            var task = queue[nextUploadIndex];
            if (task.state === 'waiting') {
                uploadingFileCount++;
                task.state = 'checking';
                var apiParams = util.formatParams(task.api, task.params);
                originApiMap[task.api].call(cos, apiParams, function (err, data) {
                    if (!cos._isRunningTask(task.id)) return;
                    if (task.state === 'checking' || task.state === 'uploading') {
                        task.state = err ? 'error' : 'success';
                        err && (task.error = err);
                        uploadingFileCount--;
                        emitListUpdate();
                        startNextTask(cos);
                        task.callback && task.callback(err, data);
                        if (task.state === 'success') {
                            if (task.params) {
                                delete task.params.Body;
                                delete task.params;
                            }
                            delete task.callback;
                        }
                    }
                    clearQueue();
                });
                emitListUpdate();
            }
            nextUploadIndex++;
            startNextTask(cos);
        }
    };

    var killTask = function (id, switchToState) {
        var task = tasks[id];
        if (!task) return;
        var waiting = task && task.state === 'waiting';
        var running = task && (task.state === 'checking' || task.state === 'uploading');
        if (switchToState === 'canceled' && task.state !== 'canceled' ||
            switchToState === 'paused' && waiting ||
            switchToState === 'paused' && running) {
            if (switchToState === 'paused' && task.params.Body && typeof task.params.Body.pipe === 'function') {
                console.error('stream not support pause');
                return;
            }
            task.state = switchToState;
            cos.emit('inner-kill-task', {TaskId: id, toState: switchToState});
            emitListUpdate();
            if (running) {
                uploadingFileCount--;
                startNextTask(cos);
            }
            if (switchToState === 'canceled') {
                if (task.params) {
                    delete task.params.Body;
                    delete task.params;
                }
                delete task.callback;
            }
        }
        clearQueue();
    };

    cos._addTasks = function (taskList) {
        util.each(taskList, function (task) {
            cos._addTask(task.api, task.params, task.callback, true);
        });
        emitListUpdate();
    };

    cos._addTask = function (api, params, callback, ignoreAddEvent) {

        // 复制参数对象
        params = util.formatParams(api, params);

        // 生成 id
        var id = util.uuid();
        params.TaskId = id;
        params.TaskReady && params.TaskReady(id);

        var task = {
            // env
            params: params,
            callback: callback,
            api: api,
            index: queue.length,
            // task
            id: id,
            Bucket: params.Bucket,
            Region: params.Region,
            Key: params.Key,
            FilePath: params.FilePath || '',
            state: 'waiting',
            loaded: 0,
            size: 0,
            speed: 0,
            percent: 0,
            hashPercent: 0,
            error: null,
        };
        var onHashProgress = params.onHashProgress;
        params.onHashProgress = function (info) {
            if (!cos._isRunningTask(task.id)) return;
            task.hashPercent = info.percent;
            onHashProgress && onHashProgress(info);
            emitListUpdate();
        };
        var onProgress = params.onProgress;
        params.onProgress = function (info) {
            if (!cos._isRunningTask(task.id)) return;
            task.state === 'checking' && (task.state = 'uploading');
            task.loaded = info.loaded;
            task.size = info.total;
            task.speed = info.speed;
            task.percent = info.percent;
            onProgress && onProgress(info);
            emitListUpdate();
        };

        (function () {
            // 获取完文件大小再把任务加入队列
            tasks[id] = task;
            queue.push(task);
            task.size = params.FileSize;
            !ignoreAddEvent && emitListUpdate();
            startNextTask(cos);
            clearQueue();
        })();
        return id;
    };
    cos._isRunningTask = function (id) {
        var task = tasks[id];
        return !!(task && (task.state === 'checking' || task.state === 'uploading'));
    };
    cos.getTaskList = function () {
        return util.map(queue, formatTask);
    };
    cos.cancelTask = function (id) {
        killTask(id, 'canceled')
    };
    cos.pauseTask = function (id) {
        killTask(id, 'paused')
    };
    cos.restartTask = function (id) {
        var task = tasks[id];
        if (task && (task.state === 'paused' || task.state === 'error')) {
            task.state = 'waiting';
            emitListUpdate();
            nextUploadIndex = Math.min(nextUploadIndex, task.index);
            startNextTask();
        }
    };

};

module.exports.transferToTaskMethod = transferToTaskMethod;
module.exports.init = initTask;


/***/ })
/******/ ]);
});

/***/ }),
/* 122 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/*eslint-disable*/
var e="undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{},t=[],r=[],n="undefined"!=typeof Uint8Array?Uint8Array:Array,i=!1;function o(){i=!0;for(var e="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",n=0,o=e.length;n<o;++n)t[n]=e[n],r[e.charCodeAt(n)]=n;r["-".charCodeAt(0)]=62,r["_".charCodeAt(0)]=63}function a(e,r,n){for(var i,o,a=[],s=r;s<n;s+=3)i=(e[s]<<16)+(e[s+1]<<8)+e[s+2],a.push(t[(o=i)>>18&63]+t[o>>12&63]+t[o>>6&63]+t[63&o]);return a.join("")}function s(e){var r;i||o();for(var n=e.length,s=n%3,h="",l=[],f=0,c=n-s;f<c;f+=16383)l.push(a(e,f,f+16383>c?c:f+16383));return 1===s?(r=e[n-1],h+=t[r>>2],h+=t[r<<4&63],h+="=="):2===s&&(r=(e[n-2]<<8)+e[n-1],h+=t[r>>10],h+=t[r>>4&63],h+=t[r<<2&63],h+="="),l.push(h),l.join("")}function h(e,t,r,n,i){var o,a,s=8*i-n-1,h=(1<<s)-1,l=h>>1,f=-7,c=r?i-1:0,u=r?-1:1,d=e[t+c];for(c+=u,o=d&(1<<-f)-1,d>>=-f,f+=s;f>0;o=256*o+e[t+c],c+=u,f-=8);for(a=o&(1<<-f)-1,o>>=-f,f+=n;f>0;a=256*a+e[t+c],c+=u,f-=8);if(0===o)o=1-l;else{if(o===h)return a?NaN:1/0*(d?-1:1);a+=Math.pow(2,n),o-=l}return(d?-1:1)*a*Math.pow(2,o-n)}function l(e,t,r,n,i,o){var a,s,h,l=8*o-i-1,f=(1<<l)-1,c=f>>1,u=23===i?Math.pow(2,-24)-Math.pow(2,-77):0,d=n?0:o-1,p=n?1:-1,_=t<0||0===t&&1/t<0?1:0;for(t=Math.abs(t),isNaN(t)||t===1/0?(s=isNaN(t)?1:0,a=f):(a=Math.floor(Math.log(t)/Math.LN2),t*(h=Math.pow(2,-a))<1&&(a--,h*=2),(t+=a+c>=1?u/h:u*Math.pow(2,1-c))*h>=2&&(a++,h/=2),a+c>=f?(s=0,a=f):a+c>=1?(s=(t*h-1)*Math.pow(2,i),a+=c):(s=t*Math.pow(2,c-1)*Math.pow(2,i),a=0));i>=8;e[r+d]=255&s,d+=p,s/=256,i-=8);for(a=a<<i|s,l+=i;l>0;e[r+d]=255&a,d+=p,a/=256,l-=8);e[r+d-p]|=128*_}var f={}.toString,c=Array.isArray||function(e){return"[object Array]"==f.call(e)};function u(){return p.TYPED_ARRAY_SUPPORT?2147483647:1073741823}function d(e,t){if(u()<t)throw new RangeError("Invalid typed array length");return p.TYPED_ARRAY_SUPPORT?(e=new Uint8Array(t)).__proto__=p.prototype:(null===e&&(e=new p(t)),e.length=t),e}function p(e,t,r){if(!(p.TYPED_ARRAY_SUPPORT||this instanceof p))return new p(e,t,r);if("number"==typeof e){if("string"==typeof t)throw new Error("If encoding is specified then the first argument must be a string");return v(this,e)}return _(this,e,t,r)}function _(e,t,r,n){if("number"==typeof t)throw new TypeError('"value" argument must not be a number');return"undefined"!=typeof ArrayBuffer&&t instanceof ArrayBuffer?function(e,t,r,n){if(t.byteLength,r<0||t.byteLength<r)throw new RangeError("'offset' is out of bounds");if(t.byteLength<r+(n||0))throw new RangeError("'length' is out of bounds");t=void 0===r&&void 0===n?new Uint8Array(t):void 0===n?new Uint8Array(t,r):new Uint8Array(t,r,n);p.TYPED_ARRAY_SUPPORT?(e=t).__proto__=p.prototype:e=w(e,t);return e}(e,t,r,n):"string"==typeof t?function(e,t,r){"string"==typeof r&&""!==r||(r="utf8");if(!p.isEncoding(r))throw new TypeError('"encoding" must be a valid string encoding');var n=0|m(t,r),i=(e=d(e,n)).write(t,r);i!==n&&(e=e.slice(0,i));return e}(e,t,r):function(e,t){if(y(t)){var r=0|b(t.length);return 0===(e=d(e,r)).length?e:(t.copy(e,0,0,r),e)}if(t){if("undefined"!=typeof ArrayBuffer&&t.buffer instanceof ArrayBuffer||"length"in t)return"number"!=typeof t.length||(n=t.length)!=n?d(e,0):w(e,t);if("Buffer"===t.type&&c(t.data))return w(e,t.data)}var n;throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.")}(e,t)}function g(e){if("number"!=typeof e)throw new TypeError('"size" argument must be a number');if(e<0)throw new RangeError('"size" argument must not be negative')}function v(e,t){if(g(t),e=d(e,t<0?0:0|b(t)),!p.TYPED_ARRAY_SUPPORT)for(var r=0;r<t;++r)e[r]=0;return e}function w(e,t){var r=t.length<0?0:0|b(t.length);e=d(e,r);for(var n=0;n<r;n+=1)e[n]=255&t[n];return e}function b(e){if(e>=u())throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x"+u().toString(16)+" bytes");return 0|e}function y(e){return!(null==e||!e._isBuffer)}function m(e,t){if(y(e))return e.length;if("undefined"!=typeof ArrayBuffer&&"function"==typeof ArrayBuffer.isView&&(ArrayBuffer.isView(e)||e instanceof ArrayBuffer))return e.byteLength;"string"!=typeof e&&(e=""+e);var r=e.length;if(0===r)return 0;for(var n=!1;;)switch(t){case"ascii":case"latin1":case"binary":return r;case"utf8":case"utf-8":case void 0:return q(e).length;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return 2*r;case"hex":return r>>>1;case"base64":return V(e).length;default:if(n)return q(e).length;t=(""+t).toLowerCase(),n=!0}}function k(e,t,r){var n=!1;if((void 0===t||t<0)&&(t=0),t>this.length)return"";if((void 0===r||r>this.length)&&(r=this.length),r<=0)return"";if((r>>>=0)<=(t>>>=0))return"";for(e||(e="utf8");;)switch(e){case"hex":return O(this,t,r);case"utf8":case"utf-8":return C(this,t,r);case"ascii":return I(this,t,r);case"latin1":case"binary":return P(this,t,r);case"base64":return M(this,t,r);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return U(this,t,r);default:if(n)throw new TypeError("Unknown encoding: "+e);e=(e+"").toLowerCase(),n=!0}}function E(e,t,r){var n=e[t];e[t]=e[r],e[r]=n}function S(e,t,r,n,i){if(0===e.length)return-1;if("string"==typeof r?(n=r,r=0):r>2147483647?r=2147483647:r<-2147483648&&(r=-2147483648),r=+r,isNaN(r)&&(r=i?0:e.length-1),r<0&&(r=e.length+r),r>=e.length){if(i)return-1;r=e.length-1}else if(r<0){if(!i)return-1;r=0}if("string"==typeof t&&(t=p.from(t,n)),y(t))return 0===t.length?-1:x(e,t,r,n,i);if("number"==typeof t)return t&=255,p.TYPED_ARRAY_SUPPORT&&"function"==typeof Uint8Array.prototype.indexOf?i?Uint8Array.prototype.indexOf.call(e,t,r):Uint8Array.prototype.lastIndexOf.call(e,t,r):x(e,[t],r,n,i);throw new TypeError("val must be string, number or Buffer")}function x(e,t,r,n,i){var o,a=1,s=e.length,h=t.length;if(void 0!==n&&("ucs2"===(n=String(n).toLowerCase())||"ucs-2"===n||"utf16le"===n||"utf-16le"===n)){if(e.length<2||t.length<2)return-1;a=2,s/=2,h/=2,r/=2}function l(e,t){return 1===a?e[t]:e.readUInt16BE(t*a)}if(i){var f=-1;for(o=r;o<s;o++)if(l(e,o)===l(t,-1===f?0:o-f)){if(-1===f&&(f=o),o-f+1===h)return f*a}else-1!==f&&(o-=o-f),f=-1}else for(r+h>s&&(r=s-h),o=r;o>=0;o--){for(var c=!0,u=0;u<h;u++)if(l(e,o+u)!==l(t,u)){c=!1;break}if(c)return o}return-1}function R(e,t,r,n){r=Number(r)||0;var i=e.length-r;n?(n=Number(n))>i&&(n=i):n=i;var o=t.length;if(o%2!=0)throw new TypeError("Invalid hex string");n>o/2&&(n=o/2);for(var a=0;a<n;++a){var s=parseInt(t.substr(2*a,2),16);if(isNaN(s))return a;e[r+a]=s}return a}function A(e,t,r,n){return G(q(t,e.length-r),e,r,n)}function B(e,t,r,n){return G(function(e){for(var t=[],r=0;r<e.length;++r)t.push(255&e.charCodeAt(r));return t}(t),e,r,n)}function z(e,t,r,n){return B(e,t,r,n)}function L(e,t,r,n){return G(V(t),e,r,n)}function T(e,t,r,n){return G(function(e,t){for(var r,n,i,o=[],a=0;a<e.length&&!((t-=2)<0);++a)r=e.charCodeAt(a),n=r>>8,i=r%256,o.push(i),o.push(n);return o}(t,e.length-r),e,r,n)}function M(e,t,r){return 0===t&&r===e.length?s(e):s(e.slice(t,r))}function C(e,t,r){r=Math.min(e.length,r);for(var n=[],i=t;i<r;){var o,a,s,h,l=e[i],f=null,c=l>239?4:l>223?3:l>191?2:1;if(i+c<=r)switch(c){case 1:l<128&&(f=l);break;case 2:128==(192&(o=e[i+1]))&&(h=(31&l)<<6|63&o)>127&&(f=h);break;case 3:o=e[i+1],a=e[i+2],128==(192&o)&&128==(192&a)&&(h=(15&l)<<12|(63&o)<<6|63&a)>2047&&(h<55296||h>57343)&&(f=h);break;case 4:o=e[i+1],a=e[i+2],s=e[i+3],128==(192&o)&&128==(192&a)&&128==(192&s)&&(h=(15&l)<<18|(63&o)<<12|(63&a)<<6|63&s)>65535&&h<1114112&&(f=h)}null===f?(f=65533,c=1):f>65535&&(f-=65536,n.push(f>>>10&1023|55296),f=56320|1023&f),n.push(f),i+=c}return function(e){var t=e.length;if(t<=D)return String.fromCharCode.apply(String,e);var r="",n=0;for(;n<t;)r+=String.fromCharCode.apply(String,e.slice(n,n+=D));return r}(n)}p.TYPED_ARRAY_SUPPORT=void 0===e.TYPED_ARRAY_SUPPORT||e.TYPED_ARRAY_SUPPORT,p.poolSize=8192,p._augment=function(e){return e.__proto__=p.prototype,e},p.from=function(e,t,r){return _(null,e,t,r)},p.TYPED_ARRAY_SUPPORT&&(p.prototype.__proto__=Uint8Array.prototype,p.__proto__=Uint8Array),p.alloc=function(e,t,r){return function(e,t,r,n){return g(t),t<=0?d(e,t):void 0!==r?"string"==typeof n?d(e,t).fill(r,n):d(e,t).fill(r):d(e,t)}(null,e,t,r)},p.allocUnsafe=function(e){return v(null,e)},p.allocUnsafeSlow=function(e){return v(null,e)},p.isBuffer=$,p.compare=function(e,t){if(!y(e)||!y(t))throw new TypeError("Arguments must be Buffers");if(e===t)return 0;for(var r=e.length,n=t.length,i=0,o=Math.min(r,n);i<o;++i)if(e[i]!==t[i]){r=e[i],n=t[i];break}return r<n?-1:n<r?1:0},p.isEncoding=function(e){switch(String(e).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"latin1":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return!0;default:return!1}},p.concat=function(e,t){if(!c(e))throw new TypeError('"list" argument must be an Array of Buffers');if(0===e.length)return p.alloc(0);var r;if(void 0===t)for(t=0,r=0;r<e.length;++r)t+=e[r].length;var n=p.allocUnsafe(t),i=0;for(r=0;r<e.length;++r){var o=e[r];if(!y(o))throw new TypeError('"list" argument must be an Array of Buffers');o.copy(n,i),i+=o.length}return n},p.byteLength=m,p.prototype._isBuffer=!0,p.prototype.swap16=function(){var e=this.length;if(e%2!=0)throw new RangeError("Buffer size must be a multiple of 16-bits");for(var t=0;t<e;t+=2)E(this,t,t+1);return this},p.prototype.swap32=function(){var e=this.length;if(e%4!=0)throw new RangeError("Buffer size must be a multiple of 32-bits");for(var t=0;t<e;t+=4)E(this,t,t+3),E(this,t+1,t+2);return this},p.prototype.swap64=function(){var e=this.length;if(e%8!=0)throw new RangeError("Buffer size must be a multiple of 64-bits");for(var t=0;t<e;t+=8)E(this,t,t+7),E(this,t+1,t+6),E(this,t+2,t+5),E(this,t+3,t+4);return this},p.prototype.toString=function(){var e=0|this.length;return 0===e?"":0===arguments.length?C(this,0,e):k.apply(this,arguments)},p.prototype.equals=function(e){if(!y(e))throw new TypeError("Argument must be a Buffer");return this===e||0===p.compare(this,e)},p.prototype.inspect=function(){var e="";return this.length>0&&(e=this.toString("hex",0,50).match(/.{2}/g).join(" "),this.length>50&&(e+=" ... ")),"<Buffer "+e+">"},p.prototype.compare=function(e,t,r,n,i){if(!y(e))throw new TypeError("Argument must be a Buffer");if(void 0===t&&(t=0),void 0===r&&(r=e?e.length:0),void 0===n&&(n=0),void 0===i&&(i=this.length),t<0||r>e.length||n<0||i>this.length)throw new RangeError("out of range index");if(n>=i&&t>=r)return 0;if(n>=i)return-1;if(t>=r)return 1;if(this===e)return 0;for(var o=(i>>>=0)-(n>>>=0),a=(r>>>=0)-(t>>>=0),s=Math.min(o,a),h=this.slice(n,i),l=e.slice(t,r),f=0;f<s;++f)if(h[f]!==l[f]){o=h[f],a=l[f];break}return o<a?-1:a<o?1:0},p.prototype.includes=function(e,t,r){return-1!==this.indexOf(e,t,r)},p.prototype.indexOf=function(e,t,r){return S(this,e,t,r,!0)},p.prototype.lastIndexOf=function(e,t,r){return S(this,e,t,r,!1)},p.prototype.write=function(e,t,r,n){if(void 0===t)n="utf8",r=this.length,t=0;else if(void 0===r&&"string"==typeof t)n=t,r=this.length,t=0;else{if(!isFinite(t))throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");t|=0,isFinite(r)?(r|=0,void 0===n&&(n="utf8")):(n=r,r=void 0)}var i=this.length-t;if((void 0===r||r>i)&&(r=i),e.length>0&&(r<0||t<0)||t>this.length)throw new RangeError("Attempt to write outside buffer bounds");n||(n="utf8");for(var o=!1;;)switch(n){case"hex":return R(this,e,t,r);case"utf8":case"utf-8":return A(this,e,t,r);case"ascii":return B(this,e,t,r);case"latin1":case"binary":return z(this,e,t,r);case"base64":return L(this,e,t,r);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return T(this,e,t,r);default:if(o)throw new TypeError("Unknown encoding: "+n);n=(""+n).toLowerCase(),o=!0}},p.prototype.toJSON=function(){return{type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}};var D=4096;function I(e,t,r){var n="";r=Math.min(e.length,r);for(var i=t;i<r;++i)n+=String.fromCharCode(127&e[i]);return n}function P(e,t,r){var n="";r=Math.min(e.length,r);for(var i=t;i<r;++i)n+=String.fromCharCode(e[i]);return n}function O(e,t,r){var n=e.length;(!t||t<0)&&(t=0),(!r||r<0||r>n)&&(r=n);for(var i="",o=t;o<r;++o)i+=X(e[o]);return i}function U(e,t,r){for(var n=e.slice(t,r),i="",o=0;o<n.length;o+=2)i+=String.fromCharCode(n[o]+256*n[o+1]);return i}function H(e,t,r){if(e%1!=0||e<0)throw new RangeError("offset is not uint");if(e+t>r)throw new RangeError("Trying to access beyond buffer length")}function F(e,t,r,n,i,o){if(!y(e))throw new TypeError('"buffer" argument must be a Buffer instance');if(t>i||t<o)throw new RangeError('"value" argument is out of bounds');if(r+n>e.length)throw new RangeError("Index out of range")}function N(e,t,r,n){t<0&&(t=65535+t+1);for(var i=0,o=Math.min(e.length-r,2);i<o;++i)e[r+i]=(t&255<<8*(n?i:1-i))>>>8*(n?i:1-i)}function Z(e,t,r,n){t<0&&(t=4294967295+t+1);for(var i=0,o=Math.min(e.length-r,4);i<o;++i)e[r+i]=t>>>8*(n?i:3-i)&255}function j(e,t,r,n,i,o){if(r+n>e.length)throw new RangeError("Index out of range");if(r<0)throw new RangeError("Index out of range")}function W(e,t,r,n,i){return i||j(e,0,r,4),l(e,t,r,n,23,4),r+4}function Y(e,t,r,n,i){return i||j(e,0,r,8),l(e,t,r,n,52,8),r+8}p.prototype.slice=function(e,t){var r,n=this.length;if((e=~~e)<0?(e+=n)<0&&(e=0):e>n&&(e=n),(t=void 0===t?n:~~t)<0?(t+=n)<0&&(t=0):t>n&&(t=n),t<e&&(t=e),p.TYPED_ARRAY_SUPPORT)(r=this.subarray(e,t)).__proto__=p.prototype;else{var i=t-e;r=new p(i,void 0);for(var o=0;o<i;++o)r[o]=this[o+e]}return r},p.prototype.readUIntLE=function(e,t,r){e|=0,t|=0,r||H(e,t,this.length);for(var n=this[e],i=1,o=0;++o<t&&(i*=256);)n+=this[e+o]*i;return n},p.prototype.readUIntBE=function(e,t,r){e|=0,t|=0,r||H(e,t,this.length);for(var n=this[e+--t],i=1;t>0&&(i*=256);)n+=this[e+--t]*i;return n},p.prototype.readUInt8=function(e,t){return t||H(e,1,this.length),this[e]},p.prototype.readUInt16LE=function(e,t){return t||H(e,2,this.length),this[e]|this[e+1]<<8},p.prototype.readUInt16BE=function(e,t){return t||H(e,2,this.length),this[e]<<8|this[e+1]},p.prototype.readUInt32LE=function(e,t){return t||H(e,4,this.length),(this[e]|this[e+1]<<8|this[e+2]<<16)+16777216*this[e+3]},p.prototype.readUInt32BE=function(e,t){return t||H(e,4,this.length),16777216*this[e]+(this[e+1]<<16|this[e+2]<<8|this[e+3])},p.prototype.readIntLE=function(e,t,r){e|=0,t|=0,r||H(e,t,this.length);for(var n=this[e],i=1,o=0;++o<t&&(i*=256);)n+=this[e+o]*i;return n>=(i*=128)&&(n-=Math.pow(2,8*t)),n},p.prototype.readIntBE=function(e,t,r){e|=0,t|=0,r||H(e,t,this.length);for(var n=t,i=1,o=this[e+--n];n>0&&(i*=256);)o+=this[e+--n]*i;return o>=(i*=128)&&(o-=Math.pow(2,8*t)),o},p.prototype.readInt8=function(e,t){return t||H(e,1,this.length),128&this[e]?-1*(255-this[e]+1):this[e]},p.prototype.readInt16LE=function(e,t){t||H(e,2,this.length);var r=this[e]|this[e+1]<<8;return 32768&r?4294901760|r:r},p.prototype.readInt16BE=function(e,t){t||H(e,2,this.length);var r=this[e+1]|this[e]<<8;return 32768&r?4294901760|r:r},p.prototype.readInt32LE=function(e,t){return t||H(e,4,this.length),this[e]|this[e+1]<<8|this[e+2]<<16|this[e+3]<<24},p.prototype.readInt32BE=function(e,t){return t||H(e,4,this.length),this[e]<<24|this[e+1]<<16|this[e+2]<<8|this[e+3]},p.prototype.readFloatLE=function(e,t){return t||H(e,4,this.length),h(this,e,!0,23,4)},p.prototype.readFloatBE=function(e,t){return t||H(e,4,this.length),h(this,e,!1,23,4)},p.prototype.readDoubleLE=function(e,t){return t||H(e,8,this.length),h(this,e,!0,52,8)},p.prototype.readDoubleBE=function(e,t){return t||H(e,8,this.length),h(this,e,!1,52,8)},p.prototype.writeUIntLE=function(e,t,r,n){(e=+e,t|=0,r|=0,n)||F(this,e,t,r,Math.pow(2,8*r)-1,0);var i=1,o=0;for(this[t]=255&e;++o<r&&(i*=256);)this[t+o]=e/i&255;return t+r},p.prototype.writeUIntBE=function(e,t,r,n){(e=+e,t|=0,r|=0,n)||F(this,e,t,r,Math.pow(2,8*r)-1,0);var i=r-1,o=1;for(this[t+i]=255&e;--i>=0&&(o*=256);)this[t+i]=e/o&255;return t+r},p.prototype.writeUInt8=function(e,t,r){return e=+e,t|=0,r||F(this,e,t,1,255,0),p.TYPED_ARRAY_SUPPORT||(e=Math.floor(e)),this[t]=255&e,t+1},p.prototype.writeUInt16LE=function(e,t,r){return e=+e,t|=0,r||F(this,e,t,2,65535,0),p.TYPED_ARRAY_SUPPORT?(this[t]=255&e,this[t+1]=e>>>8):N(this,e,t,!0),t+2},p.prototype.writeUInt16BE=function(e,t,r){return e=+e,t|=0,r||F(this,e,t,2,65535,0),p.TYPED_ARRAY_SUPPORT?(this[t]=e>>>8,this[t+1]=255&e):N(this,e,t,!1),t+2},p.prototype.writeUInt32LE=function(e,t,r){return e=+e,t|=0,r||F(this,e,t,4,4294967295,0),p.TYPED_ARRAY_SUPPORT?(this[t+3]=e>>>24,this[t+2]=e>>>16,this[t+1]=e>>>8,this[t]=255&e):Z(this,e,t,!0),t+4},p.prototype.writeUInt32BE=function(e,t,r){return e=+e,t|=0,r||F(this,e,t,4,4294967295,0),p.TYPED_ARRAY_SUPPORT?(this[t]=e>>>24,this[t+1]=e>>>16,this[t+2]=e>>>8,this[t+3]=255&e):Z(this,e,t,!1),t+4},p.prototype.writeIntLE=function(e,t,r,n){if(e=+e,t|=0,!n){var i=Math.pow(2,8*r-1);F(this,e,t,r,i-1,-i)}var o=0,a=1,s=0;for(this[t]=255&e;++o<r&&(a*=256);)e<0&&0===s&&0!==this[t+o-1]&&(s=1),this[t+o]=(e/a>>0)-s&255;return t+r},p.prototype.writeIntBE=function(e,t,r,n){if(e=+e,t|=0,!n){var i=Math.pow(2,8*r-1);F(this,e,t,r,i-1,-i)}var o=r-1,a=1,s=0;for(this[t+o]=255&e;--o>=0&&(a*=256);)e<0&&0===s&&0!==this[t+o+1]&&(s=1),this[t+o]=(e/a>>0)-s&255;return t+r},p.prototype.writeInt8=function(e,t,r){return e=+e,t|=0,r||F(this,e,t,1,127,-128),p.TYPED_ARRAY_SUPPORT||(e=Math.floor(e)),e<0&&(e=255+e+1),this[t]=255&e,t+1},p.prototype.writeInt16LE=function(e,t,r){return e=+e,t|=0,r||F(this,e,t,2,32767,-32768),p.TYPED_ARRAY_SUPPORT?(this[t]=255&e,this[t+1]=e>>>8):N(this,e,t,!0),t+2},p.prototype.writeInt16BE=function(e,t,r){return e=+e,t|=0,r||F(this,e,t,2,32767,-32768),p.TYPED_ARRAY_SUPPORT?(this[t]=e>>>8,this[t+1]=255&e):N(this,e,t,!1),t+2},p.prototype.writeInt32LE=function(e,t,r){return e=+e,t|=0,r||F(this,e,t,4,2147483647,-2147483648),p.TYPED_ARRAY_SUPPORT?(this[t]=255&e,this[t+1]=e>>>8,this[t+2]=e>>>16,this[t+3]=e>>>24):Z(this,e,t,!0),t+4},p.prototype.writeInt32BE=function(e,t,r){return e=+e,t|=0,r||F(this,e,t,4,2147483647,-2147483648),e<0&&(e=4294967295+e+1),p.TYPED_ARRAY_SUPPORT?(this[t]=e>>>24,this[t+1]=e>>>16,this[t+2]=e>>>8,this[t+3]=255&e):Z(this,e,t,!1),t+4},p.prototype.writeFloatLE=function(e,t,r){return W(this,e,t,!0,r)},p.prototype.writeFloatBE=function(e,t,r){return W(this,e,t,!1,r)},p.prototype.writeDoubleLE=function(e,t,r){return Y(this,e,t,!0,r)},p.prototype.writeDoubleBE=function(e,t,r){return Y(this,e,t,!1,r)},p.prototype.copy=function(e,t,r,n){if(r||(r=0),n||0===n||(n=this.length),t>=e.length&&(t=e.length),t||(t=0),n>0&&n<r&&(n=r),n===r)return 0;if(0===e.length||0===this.length)return 0;if(t<0)throw new RangeError("targetStart out of bounds");if(r<0||r>=this.length)throw new RangeError("sourceStart out of bounds");if(n<0)throw new RangeError("sourceEnd out of bounds");n>this.length&&(n=this.length),e.length-t<n-r&&(n=e.length-t+r);var i,o=n-r;if(this===e&&r<t&&t<n)for(i=o-1;i>=0;--i)e[i+t]=this[i+r];else if(o<1e3||!p.TYPED_ARRAY_SUPPORT)for(i=0;i<o;++i)e[i+t]=this[i+r];else Uint8Array.prototype.set.call(e,this.subarray(r,r+o),t);return o},p.prototype.fill=function(e,t,r,n){if("string"==typeof e){if("string"==typeof t?(n=t,t=0,r=this.length):"string"==typeof r&&(n=r,r=this.length),1===e.length){var i=e.charCodeAt(0);i<256&&(e=i)}if(void 0!==n&&"string"!=typeof n)throw new TypeError("encoding must be a string");if("string"==typeof n&&!p.isEncoding(n))throw new TypeError("Unknown encoding: "+n)}else"number"==typeof e&&(e&=255);if(t<0||this.length<t||this.length<r)throw new RangeError("Out of range index");if(r<=t)return this;var o;if(t>>>=0,r=void 0===r?this.length:r>>>0,e||(e=0),"number"==typeof e)for(o=t;o<r;++o)this[o]=e;else{var a=y(e)?e:q(new p(e,n).toString()),s=a.length;for(o=0;o<r-t;++o)this[o+t]=a[o%s]}return this};var K=/[^+\/0-9A-Za-z-_]/g;function X(e){return e<16?"0"+e.toString(16):e.toString(16)}function q(e,t){var r;t=t||1/0;for(var n=e.length,i=null,o=[],a=0;a<n;++a){if((r=e.charCodeAt(a))>55295&&r<57344){if(!i){if(r>56319){(t-=3)>-1&&o.push(239,191,189);continue}if(a+1===n){(t-=3)>-1&&o.push(239,191,189);continue}i=r;continue}if(r<56320){(t-=3)>-1&&o.push(239,191,189),i=r;continue}r=65536+(i-55296<<10|r-56320)}else i&&(t-=3)>-1&&o.push(239,191,189);if(i=null,r<128){if((t-=1)<0)break;o.push(r)}else if(r<2048){if((t-=2)<0)break;o.push(r>>6|192,63&r|128)}else if(r<65536){if((t-=3)<0)break;o.push(r>>12|224,r>>6&63|128,63&r|128)}else{if(!(r<1114112))throw new Error("Invalid code point");if((t-=4)<0)break;o.push(r>>18|240,r>>12&63|128,r>>6&63|128,63&r|128)}}return o}function V(e){return function(e){var t,a,s,h,l,f;i||o();var c=e.length;if(c%4>0)throw new Error("Invalid string. Length must be a multiple of 4");l="="===e[c-2]?2:"="===e[c-1]?1:0,f=new n(3*c/4-l),s=l>0?c-4:c;var u=0;for(t=0,a=0;t<s;t+=4,a+=3)h=r[e.charCodeAt(t)]<<18|r[e.charCodeAt(t+1)]<<12|r[e.charCodeAt(t+2)]<<6|r[e.charCodeAt(t+3)],f[u++]=h>>16&255,f[u++]=h>>8&255,f[u++]=255&h;return 2===l?(h=r[e.charCodeAt(t)]<<2|r[e.charCodeAt(t+1)]>>4,f[u++]=255&h):1===l&&(h=r[e.charCodeAt(t)]<<10|r[e.charCodeAt(t+1)]<<4|r[e.charCodeAt(t+2)]>>2,f[u++]=h>>8&255,f[u++]=255&h),f}(function(e){if((e=function(e){return e.trim?e.trim():e.replace(/^\s+|\s+$/g,"")}(e).replace(K,"")).length<2)return"";for(;e.length%4!=0;)e+="=";return e}(e))}function G(e,t,r,n){for(var i=0;i<n&&!(i+r>=t.length||i>=e.length);++i)t[i+r]=e[i];return i}function $(e){return null!=e&&(!!e._isBuffer||J(e)||function(e){return"function"==typeof e.readFloatLE&&"function"==typeof e.slice&&J(e.slice(0,0))}(e))}function J(e){return!!e.constructor&&"function"==typeof e.constructor.isBuffer&&e.constructor.isBuffer(e)}"undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self&&self;function Q(e,t){return e(t={exports:{}},t.exports),t.exports}var ee=Q(function(e,t){var r;e.exports=(r=r||function(e,t){var r=Object.create||function(){function e(){}return function(t){var r;return e.prototype=t,r=new e,e.prototype=null,r}}(),n={},i=n.lib={},o=i.Base={extend:function(e){var t=r(this);return e&&t.mixIn(e),t.hasOwnProperty("init")&&this.init!==t.init||(t.init=function(){t.$super.init.apply(this,arguments)}),t.init.prototype=t,t.$super=this,t},create:function(){var e=this.extend();return e.init.apply(e,arguments),e},init:function(){},mixIn:function(e){for(var t in e)e.hasOwnProperty(t)&&(this[t]=e[t]);e.hasOwnProperty("toString")&&(this.toString=e.toString)},clone:function(){return this.init.prototype.extend(this)}},a=i.WordArray=o.extend({init:function(e,t){e=this.words=e||[],this.sigBytes=null!=t?t:4*e.length},toString:function(e){return(e||h).stringify(this)},concat:function(e){var t=this.words,r=e.words,n=this.sigBytes,i=e.sigBytes;if(this.clamp(),n%4)for(var o=0;o<i;o++){var a=r[o>>>2]>>>24-o%4*8&255;t[n+o>>>2]|=a<<24-(n+o)%4*8}else for(var o=0;o<i;o+=4)t[n+o>>>2]=r[o>>>2];return this.sigBytes+=i,this},clamp:function(){var t=this.words,r=this.sigBytes;t[r>>>2]&=4294967295<<32-r%4*8,t.length=e.ceil(r/4)},clone:function(){var e=o.clone.call(this);return e.words=this.words.slice(0),e},random:function(t){for(var r,n=[],i=function(t){var t=t,r=987654321,n=4294967295;return function(){var i=((r=36969*(65535&r)+(r>>16)&n)<<16)+(t=18e3*(65535&t)+(t>>16)&n)&n;return i/=4294967296,(i+=.5)*(e.random()>.5?1:-1)}},o=0;o<t;o+=4){var s=i(4294967296*(r||e.random()));r=987654071*s(),n.push(4294967296*s()|0)}return new a.init(n,t)}}),s=n.enc={},h=s.Hex={stringify:function(e){for(var t=e.words,r=e.sigBytes,n=[],i=0;i<r;i++){var o=t[i>>>2]>>>24-i%4*8&255;n.push((o>>>4).toString(16)),n.push((15&o).toString(16))}return n.join("")},parse:function(e){for(var t=e.length,r=[],n=0;n<t;n+=2)r[n>>>3]|=parseInt(e.substr(n,2),16)<<24-n%8*4;return new a.init(r,t/2)}},l=s.Latin1={stringify:function(e){for(var t=e.words,r=e.sigBytes,n=[],i=0;i<r;i++){var o=t[i>>>2]>>>24-i%4*8&255;n.push(String.fromCharCode(o))}return n.join("")},parse:function(e){for(var t=e.length,r=[],n=0;n<t;n++)r[n>>>2]|=(255&e.charCodeAt(n))<<24-n%4*8;return new a.init(r,t)}},f=s.Utf8={stringify:function(e){try{return decodeURIComponent(escape(l.stringify(e)))}catch(e){throw new Error("Malformed UTF-8 data")}},parse:function(e){return l.parse(unescape(encodeURIComponent(e)))}},c=i.BufferedBlockAlgorithm=o.extend({reset:function(){this._data=new a.init,this._nDataBytes=0},_append:function(e){"string"==typeof e&&(e=f.parse(e)),this._data.concat(e),this._nDataBytes+=e.sigBytes},_process:function(t){var r=this._data,n=r.words,i=r.sigBytes,o=this.blockSize,s=4*o,h=i/s,l=(h=t?e.ceil(h):e.max((0|h)-this._minBufferSize,0))*o,f=e.min(4*l,i);if(l){for(var c=0;c<l;c+=o)this._doProcessBlock(n,c);var u=n.splice(0,l);r.sigBytes-=f}return new a.init(u,f)},clone:function(){var e=o.clone.call(this);return e._data=this._data.clone(),e},_minBufferSize:0}),u=(i.Hasher=c.extend({cfg:o.extend(),init:function(e){this.cfg=this.cfg.extend(e),this.reset()},reset:function(){c.reset.call(this),this._doReset()},update:function(e){return this._append(e),this._process(),this},finalize:function(e){e&&this._append(e);var t=this._doFinalize();return t},blockSize:16,_createHelper:function(e){return function(t,r){return new e.init(r).finalize(t)}},_createHmacHelper:function(e){return function(t,r){return new u.HMAC.init(e,r).finalize(t)}}}),n.algo={});return n}(Math),r)}),te=(Q(function(e,t){var r,n,i,o,a,s;e.exports=(i=(n=r=ee).lib,o=i.Base,a=i.WordArray,(s=n.x64={}).Word=o.extend({init:function(e,t){this.high=e,this.low=t}}),s.WordArray=o.extend({init:function(e,t){e=this.words=e||[],this.sigBytes=null!=t?t:8*e.length},toX32:function(){for(var e=this.words,t=e.length,r=[],n=0;n<t;n++){var i=e[n];r.push(i.high),r.push(i.low)}return a.create(r,this.sigBytes)},clone:function(){for(var e=o.clone.call(this),t=e.words=this.words.slice(0),r=t.length,n=0;n<r;n++)t[n]=t[n].clone();return e}}),r)}),Q(function(e,t){var r;e.exports=(r=ee,function(){if("function"==typeof ArrayBuffer){var e=r.lib.WordArray,t=e.init;(e.init=function(e){if(e instanceof ArrayBuffer&&(e=new Uint8Array(e)),(e instanceof Int8Array||"undefined"!=typeof Uint8ClampedArray&&e instanceof Uint8ClampedArray||e instanceof Int16Array||e instanceof Uint16Array||e instanceof Int32Array||e instanceof Uint32Array||e instanceof Float32Array||e instanceof Float64Array)&&(e=new Uint8Array(e.buffer,e.byteOffset,e.byteLength)),e instanceof Uint8Array){for(var r=e.byteLength,n=[],i=0;i<r;i++)n[i>>>2]|=e[i]<<24-i%4*8;t.call(this,n,r)}else t.apply(this,arguments)}).prototype=e}}(),r.lib.WordArray)}),Q(function(e,t){var r;e.exports=(r=ee,function(){var e=r,t=e.lib.WordArray,n=e.enc;function i(e){return e<<8&4278255360|e>>>8&16711935}n.Utf16=n.Utf16BE={stringify:function(e){for(var t=e.words,r=e.sigBytes,n=[],i=0;i<r;i+=2){var o=t[i>>>2]>>>16-i%4*8&65535;n.push(String.fromCharCode(o))}return n.join("")},parse:function(e){for(var r=e.length,n=[],i=0;i<r;i++)n[i>>>1]|=e.charCodeAt(i)<<16-i%2*16;return t.create(n,2*r)}},n.Utf16LE={stringify:function(e){for(var t=e.words,r=e.sigBytes,n=[],o=0;o<r;o+=2){var a=i(t[o>>>2]>>>16-o%4*8&65535);n.push(String.fromCharCode(a))}return n.join("")},parse:function(e){for(var r=e.length,n=[],o=0;o<r;o++)n[o>>>1]|=i(e.charCodeAt(o)<<16-o%2*16);return t.create(n,2*r)}}}(),r.enc.Utf16)}),Q(function(e,t){var r,n,i;e.exports=(i=(n=r=ee).lib.WordArray,n.enc.Base64={stringify:function(e){var t=e.words,r=e.sigBytes,n=this._map;e.clamp();for(var i=[],o=0;o<r;o+=3)for(var a=(t[o>>>2]>>>24-o%4*8&255)<<16|(t[o+1>>>2]>>>24-(o+1)%4*8&255)<<8|t[o+2>>>2]>>>24-(o+2)%4*8&255,s=0;s<4&&o+.75*s<r;s++)i.push(n.charAt(a>>>6*(3-s)&63));var h=n.charAt(64);if(h)for(;i.length%4;)i.push(h);return i.join("")},parse:function(e){var t=e.length,r=this._map,n=this._reverseMap;if(!n){n=this._reverseMap=[];for(var o=0;o<r.length;o++)n[r.charCodeAt(o)]=o}var a=r.charAt(64);if(a){var s=e.indexOf(a);-1!==s&&(t=s)}return function(e,t,r){for(var n=[],o=0,a=0;a<t;a++)if(a%4){var s=r[e.charCodeAt(a-1)]<<a%4*2,h=r[e.charCodeAt(a)]>>>6-a%4*2;n[o>>>2]|=(s|h)<<24-o%4*8,o++}return i.create(n,o)}(e,t,n)},_map:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="},r.enc.Base64)}),Q(function(e,t){var r;e.exports=(r=ee,function(e){var t=r,n=t.lib,i=n.WordArray,o=n.Hasher,a=t.algo,s=[];!function(){for(var t=0;t<64;t++)s[t]=4294967296*e.abs(e.sin(t+1))|0}();var h=a.MD5=o.extend({_doReset:function(){this._hash=new i.init([1732584193,4023233417,2562383102,271733878])},_doProcessBlock:function(e,t){for(var r=0;r<16;r++){var n=t+r,i=e[n];e[n]=16711935&(i<<8|i>>>24)|4278255360&(i<<24|i>>>8)}var o=this._hash.words,a=e[t+0],h=e[t+1],d=e[t+2],p=e[t+3],_=e[t+4],g=e[t+5],v=e[t+6],w=e[t+7],b=e[t+8],y=e[t+9],m=e[t+10],k=e[t+11],E=e[t+12],S=e[t+13],x=e[t+14],R=e[t+15],A=o[0],B=o[1],z=o[2],L=o[3];A=l(A,B,z,L,a,7,s[0]),L=l(L,A,B,z,h,12,s[1]),z=l(z,L,A,B,d,17,s[2]),B=l(B,z,L,A,p,22,s[3]),A=l(A,B,z,L,_,7,s[4]),L=l(L,A,B,z,g,12,s[5]),z=l(z,L,A,B,v,17,s[6]),B=l(B,z,L,A,w,22,s[7]),A=l(A,B,z,L,b,7,s[8]),L=l(L,A,B,z,y,12,s[9]),z=l(z,L,A,B,m,17,s[10]),B=l(B,z,L,A,k,22,s[11]),A=l(A,B,z,L,E,7,s[12]),L=l(L,A,B,z,S,12,s[13]),z=l(z,L,A,B,x,17,s[14]),A=f(A,B=l(B,z,L,A,R,22,s[15]),z,L,h,5,s[16]),L=f(L,A,B,z,v,9,s[17]),z=f(z,L,A,B,k,14,s[18]),B=f(B,z,L,A,a,20,s[19]),A=f(A,B,z,L,g,5,s[20]),L=f(L,A,B,z,m,9,s[21]),z=f(z,L,A,B,R,14,s[22]),B=f(B,z,L,A,_,20,s[23]),A=f(A,B,z,L,y,5,s[24]),L=f(L,A,B,z,x,9,s[25]),z=f(z,L,A,B,p,14,s[26]),B=f(B,z,L,A,b,20,s[27]),A=f(A,B,z,L,S,5,s[28]),L=f(L,A,B,z,d,9,s[29]),z=f(z,L,A,B,w,14,s[30]),A=c(A,B=f(B,z,L,A,E,20,s[31]),z,L,g,4,s[32]),L=c(L,A,B,z,b,11,s[33]),z=c(z,L,A,B,k,16,s[34]),B=c(B,z,L,A,x,23,s[35]),A=c(A,B,z,L,h,4,s[36]),L=c(L,A,B,z,_,11,s[37]),z=c(z,L,A,B,w,16,s[38]),B=c(B,z,L,A,m,23,s[39]),A=c(A,B,z,L,S,4,s[40]),L=c(L,A,B,z,a,11,s[41]),z=c(z,L,A,B,p,16,s[42]),B=c(B,z,L,A,v,23,s[43]),A=c(A,B,z,L,y,4,s[44]),L=c(L,A,B,z,E,11,s[45]),z=c(z,L,A,B,R,16,s[46]),A=u(A,B=c(B,z,L,A,d,23,s[47]),z,L,a,6,s[48]),L=u(L,A,B,z,w,10,s[49]),z=u(z,L,A,B,x,15,s[50]),B=u(B,z,L,A,g,21,s[51]),A=u(A,B,z,L,E,6,s[52]),L=u(L,A,B,z,p,10,s[53]),z=u(z,L,A,B,m,15,s[54]),B=u(B,z,L,A,h,21,s[55]),A=u(A,B,z,L,b,6,s[56]),L=u(L,A,B,z,R,10,s[57]),z=u(z,L,A,B,v,15,s[58]),B=u(B,z,L,A,S,21,s[59]),A=u(A,B,z,L,_,6,s[60]),L=u(L,A,B,z,k,10,s[61]),z=u(z,L,A,B,d,15,s[62]),B=u(B,z,L,A,y,21,s[63]),o[0]=o[0]+A|0,o[1]=o[1]+B|0,o[2]=o[2]+z|0,o[3]=o[3]+L|0},_doFinalize:function(){var t=this._data,r=t.words,n=8*this._nDataBytes,i=8*t.sigBytes;r[i>>>5]|=128<<24-i%32;var o=e.floor(n/4294967296),a=n;r[15+(i+64>>>9<<4)]=16711935&(o<<8|o>>>24)|4278255360&(o<<24|o>>>8),r[14+(i+64>>>9<<4)]=16711935&(a<<8|a>>>24)|4278255360&(a<<24|a>>>8),t.sigBytes=4*(r.length+1),this._process();for(var s=this._hash,h=s.words,l=0;l<4;l++){var f=h[l];h[l]=16711935&(f<<8|f>>>24)|4278255360&(f<<24|f>>>8)}return s},clone:function(){var e=o.clone.call(this);return e._hash=this._hash.clone(),e}});function l(e,t,r,n,i,o,a){var s=e+(t&r|~t&n)+i+a;return(s<<o|s>>>32-o)+t}function f(e,t,r,n,i,o,a){var s=e+(t&n|r&~n)+i+a;return(s<<o|s>>>32-o)+t}function c(e,t,r,n,i,o,a){var s=e+(t^r^n)+i+a;return(s<<o|s>>>32-o)+t}function u(e,t,r,n,i,o,a){var s=e+(r^(t|~n))+i+a;return(s<<o|s>>>32-o)+t}t.MD5=o._createHelper(h),t.HmacMD5=o._createHmacHelper(h)}(Math),r.MD5)}),Q(function(e,t){var r,n,i,o,a,s,h,l;e.exports=(i=(n=r=ee).lib,o=i.WordArray,a=i.Hasher,s=n.algo,h=[],l=s.SHA1=a.extend({_doReset:function(){this._hash=new o.init([1732584193,4023233417,2562383102,271733878,3285377520])},_doProcessBlock:function(e,t){for(var r=this._hash.words,n=r[0],i=r[1],o=r[2],a=r[3],s=r[4],l=0;l<80;l++){if(l<16)h[l]=0|e[t+l];else{var f=h[l-3]^h[l-8]^h[l-14]^h[l-16];h[l]=f<<1|f>>>31}var c=(n<<5|n>>>27)+s+h[l];c+=l<20?1518500249+(i&o|~i&a):l<40?1859775393+(i^o^a):l<60?(i&o|i&a|o&a)-1894007588:(i^o^a)-899497514,s=a,a=o,o=i<<30|i>>>2,i=n,n=c}r[0]=r[0]+n|0,r[1]=r[1]+i|0,r[2]=r[2]+o|0,r[3]=r[3]+a|0,r[4]=r[4]+s|0},_doFinalize:function(){var e=this._data,t=e.words,r=8*this._nDataBytes,n=8*e.sigBytes;return t[n>>>5]|=128<<24-n%32,t[14+(n+64>>>9<<4)]=Math.floor(r/4294967296),t[15+(n+64>>>9<<4)]=r,e.sigBytes=4*t.length,this._process(),this._hash},clone:function(){var e=a.clone.call(this);return e._hash=this._hash.clone(),e}}),n.SHA1=a._createHelper(l),n.HmacSHA1=a._createHmacHelper(l),r.SHA1)}),Q(function(e,t){var r;e.exports=(r=ee,function(e){var t=r,n=t.lib,i=n.WordArray,o=n.Hasher,a=t.algo,s=[],h=[];!function(){function t(t){for(var r=e.sqrt(t),n=2;n<=r;n++)if(!(t%n))return!1;return!0}function r(e){return 4294967296*(e-(0|e))|0}for(var n=2,i=0;i<64;)t(n)&&(i<8&&(s[i]=r(e.pow(n,.5))),h[i]=r(e.pow(n,1/3)),i++),n++}();var l=[],f=a.SHA256=o.extend({_doReset:function(){this._hash=new i.init(s.slice(0))},_doProcessBlock:function(e,t){for(var r=this._hash.words,n=r[0],i=r[1],o=r[2],a=r[3],s=r[4],f=r[5],c=r[6],u=r[7],d=0;d<64;d++){if(d<16)l[d]=0|e[t+d];else{var p=l[d-15],_=(p<<25|p>>>7)^(p<<14|p>>>18)^p>>>3,g=l[d-2],v=(g<<15|g>>>17)^(g<<13|g>>>19)^g>>>10;l[d]=_+l[d-7]+v+l[d-16]}var w=n&i^n&o^i&o,b=(n<<30|n>>>2)^(n<<19|n>>>13)^(n<<10|n>>>22),y=u+((s<<26|s>>>6)^(s<<21|s>>>11)^(s<<7|s>>>25))+(s&f^~s&c)+h[d]+l[d];u=c,c=f,f=s,s=a+y|0,a=o,o=i,i=n,n=y+(b+w)|0}r[0]=r[0]+n|0,r[1]=r[1]+i|0,r[2]=r[2]+o|0,r[3]=r[3]+a|0,r[4]=r[4]+s|0,r[5]=r[5]+f|0,r[6]=r[6]+c|0,r[7]=r[7]+u|0},_doFinalize:function(){var t=this._data,r=t.words,n=8*this._nDataBytes,i=8*t.sigBytes;return r[i>>>5]|=128<<24-i%32,r[14+(i+64>>>9<<4)]=e.floor(n/4294967296),r[15+(i+64>>>9<<4)]=n,t.sigBytes=4*r.length,this._process(),this._hash},clone:function(){var e=o.clone.call(this);return e._hash=this._hash.clone(),e}});t.SHA256=o._createHelper(f),t.HmacSHA256=o._createHmacHelper(f)}(Math),r.SHA256)}),Q(function(e,t){var r,n,i,o,a,s;e.exports=(i=(n=r=ee).lib.WordArray,o=n.algo,a=o.SHA256,s=o.SHA224=a.extend({_doReset:function(){this._hash=new i.init([3238371032,914150663,812702999,4144912697,4290775857,1750603025,1694076839,3204075428])},_doFinalize:function(){var e=a._doFinalize.call(this);return e.sigBytes-=4,e}}),n.SHA224=a._createHelper(s),n.HmacSHA224=a._createHmacHelper(s),r.SHA224)}),Q(function(e,t){var r;e.exports=(r=ee,function(){var e=r,t=e.lib.Hasher,n=e.x64,i=n.Word,o=n.WordArray,a=e.algo;function s(){return i.create.apply(i,arguments)}var h=[s(1116352408,3609767458),s(1899447441,602891725),s(3049323471,3964484399),s(3921009573,2173295548),s(961987163,4081628472),s(1508970993,3053834265),s(2453635748,2937671579),s(2870763221,3664609560),s(3624381080,2734883394),s(310598401,1164996542),s(607225278,1323610764),s(1426881987,3590304994),s(1925078388,4068182383),s(2162078206,991336113),s(2614888103,633803317),s(3248222580,3479774868),s(3835390401,2666613458),s(4022224774,944711139),s(264347078,2341262773),s(604807628,2007800933),s(770255983,1495990901),s(1249150122,1856431235),s(1555081692,3175218132),s(1996064986,2198950837),s(2554220882,3999719339),s(2821834349,766784016),s(2952996808,2566594879),s(3210313671,3203337956),s(3336571891,1034457026),s(3584528711,2466948901),s(113926993,3758326383),s(338241895,168717936),s(666307205,1188179964),s(773529912,1546045734),s(1294757372,1522805485),s(1396182291,2643833823),s(1695183700,2343527390),s(1986661051,1014477480),s(2177026350,1206759142),s(2456956037,344077627),s(2730485921,1290863460),s(2820302411,3158454273),s(3259730800,3505952657),s(3345764771,106217008),s(3516065817,3606008344),s(3600352804,1432725776),s(4094571909,1467031594),s(275423344,851169720),s(430227734,3100823752),s(506948616,1363258195),s(659060556,3750685593),s(883997877,3785050280),s(958139571,3318307427),s(1322822218,3812723403),s(1537002063,2003034995),s(1747873779,3602036899),s(1955562222,1575990012),s(2024104815,1125592928),s(2227730452,2716904306),s(2361852424,442776044),s(2428436474,593698344),s(2756734187,3733110249),s(3204031479,2999351573),s(3329325298,3815920427),s(3391569614,3928383900),s(3515267271,566280711),s(3940187606,3454069534),s(4118630271,4000239992),s(116418474,1914138554),s(174292421,2731055270),s(289380356,3203993006),s(460393269,320620315),s(685471733,587496836),s(852142971,1086792851),s(1017036298,365543100),s(1126000580,2618297676),s(1288033470,3409855158),s(1501505948,4234509866),s(1607167915,987167468),s(1816402316,1246189591)],l=[];!function(){for(var e=0;e<80;e++)l[e]=s()}();var f=a.SHA512=t.extend({_doReset:function(){this._hash=new o.init([new i.init(1779033703,4089235720),new i.init(3144134277,2227873595),new i.init(1013904242,4271175723),new i.init(2773480762,1595750129),new i.init(1359893119,2917565137),new i.init(2600822924,725511199),new i.init(528734635,4215389547),new i.init(1541459225,327033209)])},_doProcessBlock:function(e,t){for(var r=this._hash.words,n=r[0],i=r[1],o=r[2],a=r[3],s=r[4],f=r[5],c=r[6],u=r[7],d=n.high,p=n.low,_=i.high,g=i.low,v=o.high,w=o.low,b=a.high,y=a.low,m=s.high,k=s.low,E=f.high,S=f.low,x=c.high,R=c.low,A=u.high,B=u.low,z=d,L=p,T=_,M=g,C=v,D=w,I=b,P=y,O=m,U=k,H=E,F=S,N=x,Z=R,j=A,W=B,Y=0;Y<80;Y++){var K=l[Y];if(Y<16)var X=K.high=0|e[t+2*Y],q=K.low=0|e[t+2*Y+1];else{var V=l[Y-15],G=V.high,$=V.low,J=(G>>>1|$<<31)^(G>>>8|$<<24)^G>>>7,Q=($>>>1|G<<31)^($>>>8|G<<24)^($>>>7|G<<25),ee=l[Y-2],te=ee.high,re=ee.low,ne=(te>>>19|re<<13)^(te<<3|re>>>29)^te>>>6,ie=(re>>>19|te<<13)^(re<<3|te>>>29)^(re>>>6|te<<26),oe=l[Y-7],ae=oe.high,se=oe.low,he=l[Y-16],le=he.high,fe=he.low;X=(X=(X=J+ae+((q=Q+se)>>>0<Q>>>0?1:0))+ne+((q+=ie)>>>0<ie>>>0?1:0))+le+((q+=fe)>>>0<fe>>>0?1:0),K.high=X,K.low=q}var ce,ue=O&H^~O&N,de=U&F^~U&Z,pe=z&T^z&C^T&C,_e=L&M^L&D^M&D,ge=(z>>>28|L<<4)^(z<<30|L>>>2)^(z<<25|L>>>7),ve=(L>>>28|z<<4)^(L<<30|z>>>2)^(L<<25|z>>>7),we=(O>>>14|U<<18)^(O>>>18|U<<14)^(O<<23|U>>>9),be=(U>>>14|O<<18)^(U>>>18|O<<14)^(U<<23|O>>>9),ye=h[Y],me=ye.high,ke=ye.low,Ee=j+we+((ce=W+be)>>>0<W>>>0?1:0),Se=ve+_e;j=N,W=Z,N=H,Z=F,H=O,F=U,O=I+(Ee=(Ee=(Ee=Ee+ue+((ce+=de)>>>0<de>>>0?1:0))+me+((ce+=ke)>>>0<ke>>>0?1:0))+X+((ce+=q)>>>0<q>>>0?1:0))+((U=P+ce|0)>>>0<P>>>0?1:0)|0,I=C,P=D,C=T,D=M,T=z,M=L,z=Ee+(ge+pe+(Se>>>0<ve>>>0?1:0))+((L=ce+Se|0)>>>0<ce>>>0?1:0)|0}p=n.low=p+L,n.high=d+z+(p>>>0<L>>>0?1:0),g=i.low=g+M,i.high=_+T+(g>>>0<M>>>0?1:0),w=o.low=w+D,o.high=v+C+(w>>>0<D>>>0?1:0),y=a.low=y+P,a.high=b+I+(y>>>0<P>>>0?1:0),k=s.low=k+U,s.high=m+O+(k>>>0<U>>>0?1:0),S=f.low=S+F,f.high=E+H+(S>>>0<F>>>0?1:0),R=c.low=R+Z,c.high=x+N+(R>>>0<Z>>>0?1:0),B=u.low=B+W,u.high=A+j+(B>>>0<W>>>0?1:0)},_doFinalize:function(){var e=this._data,t=e.words,r=8*this._nDataBytes,n=8*e.sigBytes;return t[n>>>5]|=128<<24-n%32,t[30+(n+128>>>10<<5)]=Math.floor(r/4294967296),t[31+(n+128>>>10<<5)]=r,e.sigBytes=4*t.length,this._process(),this._hash.toX32()},clone:function(){var e=t.clone.call(this);return e._hash=this._hash.clone(),e},blockSize:32});e.SHA512=t._createHelper(f),e.HmacSHA512=t._createHmacHelper(f)}(),r.SHA512)}),Q(function(e,t){var r,n,i,o,a,s,h,l;e.exports=(i=(n=r=ee).x64,o=i.Word,a=i.WordArray,s=n.algo,h=s.SHA512,l=s.SHA384=h.extend({_doReset:function(){this._hash=new a.init([new o.init(3418070365,3238371032),new o.init(1654270250,914150663),new o.init(2438529370,812702999),new o.init(355462360,4144912697),new o.init(1731405415,4290775857),new o.init(2394180231,1750603025),new o.init(3675008525,1694076839),new o.init(1203062813,3204075428)])},_doFinalize:function(){var e=h._doFinalize.call(this);return e.sigBytes-=16,e}}),n.SHA384=h._createHelper(l),n.HmacSHA384=h._createHmacHelper(l),r.SHA384)}),Q(function(e,t){var r;e.exports=(r=ee,function(e){var t=r,n=t.lib,i=n.WordArray,o=n.Hasher,a=t.x64.Word,s=t.algo,h=[],l=[],f=[];!function(){for(var e=1,t=0,r=0;r<24;r++){h[e+5*t]=(r+1)*(r+2)/2%64;var n=(2*e+3*t)%5;e=t%5,t=n}for(e=0;e<5;e++)for(t=0;t<5;t++)l[e+5*t]=t+(2*e+3*t)%5*5;for(var i=1,o=0;o<24;o++){for(var s=0,c=0,u=0;u<7;u++){if(1&i){var d=(1<<u)-1;d<32?c^=1<<d:s^=1<<d-32}128&i?i=i<<1^113:i<<=1}f[o]=a.create(s,c)}}();var c=[];!function(){for(var e=0;e<25;e++)c[e]=a.create()}();var u=s.SHA3=o.extend({cfg:o.cfg.extend({outputLength:512}),_doReset:function(){for(var e=this._state=[],t=0;t<25;t++)e[t]=new a.init;this.blockSize=(1600-2*this.cfg.outputLength)/32},_doProcessBlock:function(e,t){for(var r=this._state,n=this.blockSize/2,i=0;i<n;i++){var o=e[t+2*i],a=e[t+2*i+1];o=16711935&(o<<8|o>>>24)|4278255360&(o<<24|o>>>8),a=16711935&(a<<8|a>>>24)|4278255360&(a<<24|a>>>8),(B=r[i]).high^=a,B.low^=o}for(var s=0;s<24;s++){for(var u=0;u<5;u++){for(var d=0,p=0,_=0;_<5;_++)d^=(B=r[u+5*_]).high,p^=B.low;var g=c[u];g.high=d,g.low=p}for(u=0;u<5;u++){var v=c[(u+4)%5],w=c[(u+1)%5],b=w.high,y=w.low;for(d=v.high^(b<<1|y>>>31),p=v.low^(y<<1|b>>>31),_=0;_<5;_++)(B=r[u+5*_]).high^=d,B.low^=p}for(var m=1;m<25;m++){var k=(B=r[m]).high,E=B.low,S=h[m];S<32?(d=k<<S|E>>>32-S,p=E<<S|k>>>32-S):(d=E<<S-32|k>>>64-S,p=k<<S-32|E>>>64-S);var x=c[l[m]];x.high=d,x.low=p}var R=c[0],A=r[0];for(R.high=A.high,R.low=A.low,u=0;u<5;u++)for(_=0;_<5;_++){var B=r[m=u+5*_],z=c[m],L=c[(u+1)%5+5*_],T=c[(u+2)%5+5*_];B.high=z.high^~L.high&T.high,B.low=z.low^~L.low&T.low}B=r[0];var M=f[s];B.high^=M.high,B.low^=M.low}},_doFinalize:function(){var t=this._data,r=t.words,n=(this._nDataBytes,8*t.sigBytes),o=32*this.blockSize;r[n>>>5]|=1<<24-n%32,r[(e.ceil((n+1)/o)*o>>>5)-1]|=128,t.sigBytes=4*r.length,this._process();for(var a=this._state,s=this.cfg.outputLength/8,h=s/8,l=[],f=0;f<h;f++){var c=a[f],u=c.high,d=c.low;u=16711935&(u<<8|u>>>24)|4278255360&(u<<24|u>>>8),d=16711935&(d<<8|d>>>24)|4278255360&(d<<24|d>>>8),l.push(d),l.push(u)}return new i.init(l,s)},clone:function(){for(var e=o.clone.call(this),t=e._state=this._state.slice(0),r=0;r<25;r++)t[r]=t[r].clone();return e}});t.SHA3=o._createHelper(u),t.HmacSHA3=o._createHmacHelper(u)}(Math),r.SHA3)}),Q(function(e,t){var r;e.exports=(r=ee,function(e){var t=r,n=t.lib,i=n.WordArray,o=n.Hasher,a=t.algo,s=i.create([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,7,4,13,1,10,6,15,3,12,0,9,5,2,14,11,8,3,10,14,4,9,15,8,1,2,7,0,6,13,11,5,12,1,9,11,10,0,8,12,4,13,3,7,15,14,5,6,2,4,0,5,9,7,12,2,10,14,1,3,8,11,6,15,13]),h=i.create([5,14,7,0,9,2,11,4,13,6,15,8,1,10,3,12,6,11,3,7,0,13,5,10,14,15,8,12,4,9,1,2,15,5,1,3,7,14,6,9,11,8,12,2,10,0,4,13,8,6,4,1,3,11,15,0,5,12,2,13,9,7,10,14,12,15,10,4,1,5,8,7,6,2,13,14,0,3,9,11]),l=i.create([11,14,15,12,5,8,7,9,11,13,14,15,6,7,9,8,7,6,8,13,11,9,7,15,7,12,15,9,11,7,13,12,11,13,6,7,14,9,13,15,14,8,13,6,5,12,7,5,11,12,14,15,14,15,9,8,9,14,5,6,8,6,5,12,9,15,5,11,6,8,13,12,5,12,13,14,11,8,5,6]),f=i.create([8,9,9,11,13,15,15,5,7,7,8,11,14,14,12,6,9,13,15,7,12,8,9,11,7,7,12,7,6,15,13,11,9,7,15,11,8,6,6,14,12,13,5,14,13,13,7,5,15,5,8,11,14,14,6,14,6,9,12,9,12,5,15,8,8,5,12,9,12,5,14,6,8,13,6,5,15,13,11,11]),c=i.create([0,1518500249,1859775393,2400959708,2840853838]),u=i.create([1352829926,1548603684,1836072691,2053994217,0]),d=a.RIPEMD160=o.extend({_doReset:function(){this._hash=i.create([1732584193,4023233417,2562383102,271733878,3285377520])},_doProcessBlock:function(e,t){for(var r=0;r<16;r++){var n=t+r,i=e[n];e[n]=16711935&(i<<8|i>>>24)|4278255360&(i<<24|i>>>8)}var o,a,d,y,m,k,E,S,x,R,A,B=this._hash.words,z=c.words,L=u.words,T=s.words,M=h.words,C=l.words,D=f.words;for(k=o=B[0],E=a=B[1],S=d=B[2],x=y=B[3],R=m=B[4],r=0;r<80;r+=1)A=o+e[t+T[r]]|0,A+=r<16?p(a,d,y)+z[0]:r<32?_(a,d,y)+z[1]:r<48?g(a,d,y)+z[2]:r<64?v(a,d,y)+z[3]:w(a,d,y)+z[4],A=(A=b(A|=0,C[r]))+m|0,o=m,m=y,y=b(d,10),d=a,a=A,A=k+e[t+M[r]]|0,A+=r<16?w(E,S,x)+L[0]:r<32?v(E,S,x)+L[1]:r<48?g(E,S,x)+L[2]:r<64?_(E,S,x)+L[3]:p(E,S,x)+L[4],A=(A=b(A|=0,D[r]))+R|0,k=R,R=x,x=b(S,10),S=E,E=A;A=B[1]+d+x|0,B[1]=B[2]+y+R|0,B[2]=B[3]+m+k|0,B[3]=B[4]+o+E|0,B[4]=B[0]+a+S|0,B[0]=A},_doFinalize:function(){var e=this._data,t=e.words,r=8*this._nDataBytes,n=8*e.sigBytes;t[n>>>5]|=128<<24-n%32,t[14+(n+64>>>9<<4)]=16711935&(r<<8|r>>>24)|4278255360&(r<<24|r>>>8),e.sigBytes=4*(t.length+1),this._process();for(var i=this._hash,o=i.words,a=0;a<5;a++){var s=o[a];o[a]=16711935&(s<<8|s>>>24)|4278255360&(s<<24|s>>>8)}return i},clone:function(){var e=o.clone.call(this);return e._hash=this._hash.clone(),e}});function p(e,t,r){return e^t^r}function _(e,t,r){return e&t|~e&r}function g(e,t,r){return(e|~t)^r}function v(e,t,r){return e&r|t&~r}function w(e,t,r){return e^(t|~r)}function b(e,t){return e<<t|e>>>32-t}t.RIPEMD160=o._createHelper(d),t.HmacRIPEMD160=o._createHmacHelper(d)}(),r.RIPEMD160)}),Q(function(e,t){var r,n,i,o,a,s;e.exports=(n=(r=ee).lib,i=n.Base,o=r.enc,a=o.Utf8,s=r.algo,void(s.HMAC=i.extend({init:function(e,t){e=this._hasher=new e.init,"string"==typeof t&&(t=a.parse(t));var r=e.blockSize,n=4*r;t.sigBytes>n&&(t=e.finalize(t)),t.clamp();for(var i=this._oKey=t.clone(),o=this._iKey=t.clone(),s=i.words,h=o.words,l=0;l<r;l++)s[l]^=1549556828,h[l]^=909522486;i.sigBytes=o.sigBytes=n,this.reset()},reset:function(){var e=this._hasher;e.reset(),e.update(this._iKey)},update:function(e){return this._hasher.update(e),this},finalize:function(e){var t=this._hasher,r=t.finalize(e);t.reset();var n=t.finalize(this._oKey.clone().concat(r));return n}})))}),Q(function(e,t){var r,n,i,o,a,s,h,l,f;e.exports=(i=(n=r=ee).lib,o=i.Base,a=i.WordArray,s=n.algo,h=s.SHA1,l=s.HMAC,f=s.PBKDF2=o.extend({cfg:o.extend({keySize:4,hasher:h,iterations:1}),init:function(e){this.cfg=this.cfg.extend(e)},compute:function(e,t){for(var r=this.cfg,n=l.create(r.hasher,e),i=a.create(),o=a.create([1]),s=i.words,h=o.words,f=r.keySize,c=r.iterations;s.length<f;){var u=n.update(t).finalize(o);n.reset();for(var d=u.words,p=d.length,_=u,g=1;g<c;g++){_=n.finalize(_),n.reset();for(var v=_.words,w=0;w<p;w++)d[w]^=v[w]}i.concat(u),h[0]++}return i.sigBytes=4*f,i}}),n.PBKDF2=function(e,t,r){return f.create(r).compute(e,t)},r.PBKDF2)}),Q(function(e,t){var r,n,i,o,a,s,h,l;e.exports=(i=(n=r=ee).lib,o=i.Base,a=i.WordArray,s=n.algo,h=s.MD5,l=s.EvpKDF=o.extend({cfg:o.extend({keySize:4,hasher:h,iterations:1}),init:function(e){this.cfg=this.cfg.extend(e)},compute:function(e,t){for(var r=this.cfg,n=r.hasher.create(),i=a.create(),o=i.words,s=r.keySize,h=r.iterations;o.length<s;){l&&n.update(l);var l=n.update(e).finalize(t);n.reset();for(var f=1;f<h;f++)l=n.finalize(l),n.reset();i.concat(l)}return i.sigBytes=4*s,i}}),n.EvpKDF=function(e,t,r){return l.create(r).compute(e,t)},r.EvpKDF)}),Q(function(e,t){var r,n,i,o,a,s,h,l,f,c,u,d,p,_,g,v,w,b,y,m,k,E,S,x;e.exports=void((r=ee).lib.Cipher||(i=r,o=i.lib,a=o.Base,s=o.WordArray,h=o.BufferedBlockAlgorithm,l=i.enc,l.Utf8,f=l.Base64,c=i.algo,u=c.EvpKDF,d=o.Cipher=h.extend({cfg:a.extend(),createEncryptor:function(e,t){return this.create(this._ENC_XFORM_MODE,e,t)},createDecryptor:function(e,t){return this.create(this._DEC_XFORM_MODE,e,t)},init:function(e,t,r){this.cfg=this.cfg.extend(r),this._xformMode=e,this._key=t,this.reset()},reset:function(){h.reset.call(this),this._doReset()},process:function(e){return this._append(e),this._process()},finalize:function(e){e&&this._append(e);var t=this._doFinalize();return t},keySize:4,ivSize:4,_ENC_XFORM_MODE:1,_DEC_XFORM_MODE:2,_createHelper:function(){function e(e){return"string"==typeof e?x:k}return function(t){return{encrypt:function(r,n,i){return e(n).encrypt(t,r,n,i)},decrypt:function(r,n,i){return e(n).decrypt(t,r,n,i)}}}}()}),o.StreamCipher=d.extend({_doFinalize:function(){var e=this._process(!0);return e},blockSize:1}),p=i.mode={},_=o.BlockCipherMode=a.extend({createEncryptor:function(e,t){return this.Encryptor.create(e,t)},createDecryptor:function(e,t){return this.Decryptor.create(e,t)},init:function(e,t){this._cipher=e,this._iv=t}}),g=p.CBC=function(){var e=_.extend();function t(e,t,r){var i=this._iv;if(i){var o=i;this._iv=n}else var o=this._prevBlock;for(var a=0;a<r;a++)e[t+a]^=o[a]}return e.Encryptor=e.extend({processBlock:function(e,r){var n=this._cipher,i=n.blockSize;t.call(this,e,r,i),n.encryptBlock(e,r),this._prevBlock=e.slice(r,r+i)}}),e.Decryptor=e.extend({processBlock:function(e,r){var n=this._cipher,i=n.blockSize,o=e.slice(r,r+i);n.decryptBlock(e,r),t.call(this,e,r,i),this._prevBlock=o}}),e}(),v=i.pad={},w=v.Pkcs7={pad:function(e,t){for(var r=4*t,n=r-e.sigBytes%r,i=n<<24|n<<16|n<<8|n,o=[],a=0;a<n;a+=4)o.push(i);var h=s.create(o,n);e.concat(h)},unpad:function(e){var t=255&e.words[e.sigBytes-1>>>2];e.sigBytes-=t}},o.BlockCipher=d.extend({cfg:d.cfg.extend({mode:g,padding:w}),reset:function(){d.reset.call(this);var e=this.cfg,t=e.iv,r=e.mode;if(this._xformMode==this._ENC_XFORM_MODE)var n=r.createEncryptor;else{var n=r.createDecryptor;this._minBufferSize=1}this._mode&&this._mode.__creator==n?this._mode.init(this,t&&t.words):(this._mode=n.call(r,this,t&&t.words),this._mode.__creator=n)},_doProcessBlock:function(e,t){this._mode.processBlock(e,t)},_doFinalize:function(){var e=this.cfg.padding;if(this._xformMode==this._ENC_XFORM_MODE){e.pad(this._data,this.blockSize);var t=this._process(!0)}else{var t=this._process(!0);e.unpad(t)}return t},blockSize:4}),b=o.CipherParams=a.extend({init:function(e){this.mixIn(e)},toString:function(e){return(e||this.formatter).stringify(this)}}),y=i.format={},m=y.OpenSSL={stringify:function(e){var t=e.ciphertext,r=e.salt;if(r)var n=s.create([1398893684,1701076831]).concat(r).concat(t);else var n=t;return n.toString(f)},parse:function(e){var t=f.parse(e),r=t.words;if(1398893684==r[0]&&1701076831==r[1]){var n=s.create(r.slice(2,4));r.splice(0,4),t.sigBytes-=16}return b.create({ciphertext:t,salt:n})}},k=o.SerializableCipher=a.extend({cfg:a.extend({format:m}),encrypt:function(e,t,r,n){n=this.cfg.extend(n);var i=e.createEncryptor(r,n),o=i.finalize(t),a=i.cfg;return b.create({ciphertext:o,key:r,iv:a.iv,algorithm:e,mode:a.mode,padding:a.padding,blockSize:e.blockSize,formatter:n.format})},decrypt:function(e,t,r,n){n=this.cfg.extend(n),t=this._parse(t,n.format);var i=e.createDecryptor(r,n).finalize(t.ciphertext);return i},_parse:function(e,t){return"string"==typeof e?t.parse(e,this):e}}),E=i.kdf={},S=E.OpenSSL={execute:function(e,t,r,n){n||(n=s.random(8));var i=u.create({keySize:t+r}).compute(e,n),o=s.create(i.words.slice(t),4*r);return i.sigBytes=4*t,b.create({key:i,iv:o,salt:n})}},x=o.PasswordBasedCipher=k.extend({cfg:k.cfg.extend({kdf:S}),encrypt:function(e,t,r,n){var i=(n=this.cfg.extend(n)).kdf.execute(r,e.keySize,e.ivSize);n.iv=i.iv;var o=k.encrypt.call(this,e,t,i.key,n);return o.mixIn(i),o},decrypt:function(e,t,r,n){n=this.cfg.extend(n),t=this._parse(t,n.format);var i=n.kdf.execute(r,e.keySize,e.ivSize,t.salt);n.iv=i.iv;var o=k.decrypt.call(this,e,t,i.key,n);return o}})))}),Q(function(e,t){var r;e.exports=((r=ee).mode.CFB=function(){var e=r.lib.BlockCipherMode.extend();function t(e,t,r,n){var i=this._iv;if(i){var o=i.slice(0);this._iv=void 0}else o=this._prevBlock;n.encryptBlock(o,0);for(var a=0;a<r;a++)e[t+a]^=o[a]}return e.Encryptor=e.extend({processBlock:function(e,r){var n=this._cipher,i=n.blockSize;t.call(this,e,r,i,n),this._prevBlock=e.slice(r,r+i)}}),e.Decryptor=e.extend({processBlock:function(e,r){var n=this._cipher,i=n.blockSize,o=e.slice(r,r+i);t.call(this,e,r,i,n),this._prevBlock=o}}),e}(),r.mode.CFB)}),Q(function(e,t){var r,n,i;e.exports=((r=ee).mode.CTR=(n=r.lib.BlockCipherMode.extend(),i=n.Encryptor=n.extend({processBlock:function(e,t){var r=this._cipher,n=r.blockSize,i=this._iv,o=this._counter;i&&(o=this._counter=i.slice(0),this._iv=void 0);var a=o.slice(0);r.encryptBlock(a,0),o[n-1]=o[n-1]+1|0;for(var s=0;s<n;s++)e[t+s]^=a[s]}}),n.Decryptor=i,n),r.mode.CTR)}),Q(function(e,t){var r;e.exports=((r=ee).mode.CTRGladman=function(){var e=r.lib.BlockCipherMode.extend();function t(e){if(255==(e>>24&255)){var t=e>>16&255,r=e>>8&255,n=255&e;255===t?(t=0,255===r?(r=0,255===n?n=0:++n):++r):++t,e=0,e+=t<<16,e+=r<<8,e+=n}else e+=1<<24;return e}var n=e.Encryptor=e.extend({processBlock:function(e,r){var n=this._cipher,i=n.blockSize,o=this._iv,a=this._counter;o&&(a=this._counter=o.slice(0),this._iv=void 0),function(e){0===(e[0]=t(e[0]))&&(e[1]=t(e[1]))}(a);var s=a.slice(0);n.encryptBlock(s,0);for(var h=0;h<i;h++)e[r+h]^=s[h]}});return e.Decryptor=n,e}(),r.mode.CTRGladman)}),Q(function(e,t){var r,n,i;e.exports=((r=ee).mode.OFB=(n=r.lib.BlockCipherMode.extend(),i=n.Encryptor=n.extend({processBlock:function(e,t){var r=this._cipher,n=r.blockSize,i=this._iv,o=this._keystream;i&&(o=this._keystream=i.slice(0),this._iv=void 0),r.encryptBlock(o,0);for(var a=0;a<n;a++)e[t+a]^=o[a]}}),n.Decryptor=i,n),r.mode.OFB)}),Q(function(e,t){var r,n;e.exports=((r=ee).mode.ECB=((n=r.lib.BlockCipherMode.extend()).Encryptor=n.extend({processBlock:function(e,t){this._cipher.encryptBlock(e,t)}}),n.Decryptor=n.extend({processBlock:function(e,t){this._cipher.decryptBlock(e,t)}}),n),r.mode.ECB)}),Q(function(e,t){var r;e.exports=((r=ee).pad.AnsiX923={pad:function(e,t){var r=e.sigBytes,n=4*t,i=n-r%n,o=r+i-1;e.clamp(),e.words[o>>>2]|=i<<24-o%4*8,e.sigBytes+=i},unpad:function(e){var t=255&e.words[e.sigBytes-1>>>2];e.sigBytes-=t}},r.pad.Ansix923)}),Q(function(e,t){var r;e.exports=((r=ee).pad.Iso10126={pad:function(e,t){var n=4*t,i=n-e.sigBytes%n;e.concat(r.lib.WordArray.random(i-1)).concat(r.lib.WordArray.create([i<<24],1))},unpad:function(e){var t=255&e.words[e.sigBytes-1>>>2];e.sigBytes-=t}},r.pad.Iso10126)}),Q(function(e,t){var r;e.exports=((r=ee).pad.Iso97971={pad:function(e,t){e.concat(r.lib.WordArray.create([2147483648],1)),r.pad.ZeroPadding.pad(e,t)},unpad:function(e){r.pad.ZeroPadding.unpad(e),e.sigBytes--}},r.pad.Iso97971)}),Q(function(e,t){var r;e.exports=((r=ee).pad.ZeroPadding={pad:function(e,t){var r=4*t;e.clamp(),e.sigBytes+=r-(e.sigBytes%r||r)},unpad:function(e){for(var t=e.words,r=e.sigBytes-1;!(t[r>>>2]>>>24-r%4*8&255);)r--;e.sigBytes=r+1}},r.pad.ZeroPadding)}),Q(function(e,t){var r;e.exports=((r=ee).pad.NoPadding={pad:function(){},unpad:function(){}},r.pad.NoPadding)}),Q(function(e,t){var r,n,i,o;e.exports=(i=(n=r=ee).lib.CipherParams,o=n.enc.Hex,n.format.Hex={stringify:function(e){return e.ciphertext.toString(o)},parse:function(e){var t=o.parse(e);return i.create({ciphertext:t})}},r.format.Hex)}),Q(function(e,t){var r;e.exports=(r=ee,function(){var e=r,t=e.lib.BlockCipher,n=e.algo,i=[],o=[],a=[],s=[],h=[],l=[],f=[],c=[],u=[],d=[];!function(){for(var e=[],t=0;t<256;t++)e[t]=t<128?t<<1:t<<1^283;var r=0,n=0;for(t=0;t<256;t++){var p=n^n<<1^n<<2^n<<3^n<<4;p=p>>>8^255&p^99,i[r]=p,o[p]=r;var _=e[r],g=e[_],v=e[g],w=257*e[p]^16843008*p;a[r]=w<<24|w>>>8,s[r]=w<<16|w>>>16,h[r]=w<<8|w>>>24,l[r]=w,w=16843009*v^65537*g^257*_^16843008*r,f[p]=w<<24|w>>>8,c[p]=w<<16|w>>>16,u[p]=w<<8|w>>>24,d[p]=w,r?(r=_^e[e[e[v^_]]],n^=e[e[n]]):r=n=1}}();var p=[0,1,2,4,8,16,32,64,128,27,54],_=n.AES=t.extend({_doReset:function(){if(!this._nRounds||this._keyPriorReset!==this._key){for(var e=this._keyPriorReset=this._key,t=e.words,r=e.sigBytes/4,n=4*((this._nRounds=r+6)+1),o=this._keySchedule=[],a=0;a<n;a++)if(a<r)o[a]=t[a];else{var s=o[a-1];a%r?r>6&&a%r==4&&(s=i[s>>>24]<<24|i[s>>>16&255]<<16|i[s>>>8&255]<<8|i[255&s]):(s=i[(s=s<<8|s>>>24)>>>24]<<24|i[s>>>16&255]<<16|i[s>>>8&255]<<8|i[255&s],s^=p[a/r|0]<<24),o[a]=o[a-r]^s}for(var h=this._invKeySchedule=[],l=0;l<n;l++)a=n-l,s=l%4?o[a]:o[a-4],h[l]=l<4||a<=4?s:f[i[s>>>24]]^c[i[s>>>16&255]]^u[i[s>>>8&255]]^d[i[255&s]]}},encryptBlock:function(e,t){this._doCryptBlock(e,t,this._keySchedule,a,s,h,l,i)},decryptBlock:function(e,t){var r=e[t+1];e[t+1]=e[t+3],e[t+3]=r,this._doCryptBlock(e,t,this._invKeySchedule,f,c,u,d,o),r=e[t+1],e[t+1]=e[t+3],e[t+3]=r},_doCryptBlock:function(e,t,r,n,i,o,a,s){for(var h=this._nRounds,l=e[t]^r[0],f=e[t+1]^r[1],c=e[t+2]^r[2],u=e[t+3]^r[3],d=4,p=1;p<h;p++){var _=n[l>>>24]^i[f>>>16&255]^o[c>>>8&255]^a[255&u]^r[d++],g=n[f>>>24]^i[c>>>16&255]^o[u>>>8&255]^a[255&l]^r[d++],v=n[c>>>24]^i[u>>>16&255]^o[l>>>8&255]^a[255&f]^r[d++],w=n[u>>>24]^i[l>>>16&255]^o[f>>>8&255]^a[255&c]^r[d++];l=_,f=g,c=v,u=w}_=(s[l>>>24]<<24|s[f>>>16&255]<<16|s[c>>>8&255]<<8|s[255&u])^r[d++],g=(s[f>>>24]<<24|s[c>>>16&255]<<16|s[u>>>8&255]<<8|s[255&l])^r[d++],v=(s[c>>>24]<<24|s[u>>>16&255]<<16|s[l>>>8&255]<<8|s[255&f])^r[d++],w=(s[u>>>24]<<24|s[l>>>16&255]<<16|s[f>>>8&255]<<8|s[255&c])^r[d++],e[t]=_,e[t+1]=g,e[t+2]=v,e[t+3]=w},keySize:8});e.AES=t._createHelper(_)}(),r.AES)}),Q(function(e,t){var r;e.exports=(r=ee,function(){var e=r,t=e.lib,n=t.WordArray,i=t.BlockCipher,o=e.algo,a=[57,49,41,33,25,17,9,1,58,50,42,34,26,18,10,2,59,51,43,35,27,19,11,3,60,52,44,36,63,55,47,39,31,23,15,7,62,54,46,38,30,22,14,6,61,53,45,37,29,21,13,5,28,20,12,4],s=[14,17,11,24,1,5,3,28,15,6,21,10,23,19,12,4,26,8,16,7,27,20,13,2,41,52,31,37,47,55,30,40,51,45,33,48,44,49,39,56,34,53,46,42,50,36,29,32],h=[1,2,4,6,8,10,12,14,15,17,19,21,23,25,27,28],l=[{0:8421888,268435456:32768,536870912:8421378,805306368:2,1073741824:512,1342177280:8421890,1610612736:8389122,1879048192:8388608,2147483648:514,2415919104:8389120,2684354560:33280,2952790016:8421376,3221225472:32770,3489660928:8388610,3758096384:0,4026531840:33282,134217728:0,402653184:8421890,671088640:33282,939524096:32768,1207959552:8421888,1476395008:512,1744830464:8421378,2013265920:2,2281701376:8389120,2550136832:33280,2818572288:8421376,3087007744:8389122,3355443200:8388610,3623878656:32770,3892314112:514,4160749568:8388608,1:32768,268435457:2,536870913:8421888,805306369:8388608,1073741825:8421378,1342177281:33280,1610612737:512,1879048193:8389122,2147483649:8421890,2415919105:8421376,2684354561:8388610,2952790017:33282,3221225473:514,3489660929:8389120,3758096385:32770,4026531841:0,134217729:8421890,402653185:8421376,671088641:8388608,939524097:512,1207959553:32768,1476395009:8388610,1744830465:2,2013265921:33282,2281701377:32770,2550136833:8389122,2818572289:514,3087007745:8421888,3355443201:8389120,3623878657:0,3892314113:33280,4160749569:8421378},{0:1074282512,16777216:16384,33554432:524288,50331648:1074266128,67108864:1073741840,83886080:1074282496,100663296:1073758208,117440512:16,134217728:540672,150994944:1073758224,167772160:1073741824,184549376:540688,201326592:524304,218103808:0,234881024:16400,251658240:1074266112,8388608:1073758208,25165824:540688,41943040:16,58720256:1073758224,75497472:1074282512,92274688:1073741824,109051904:524288,125829120:1074266128,142606336:524304,159383552:0,176160768:16384,192937984:1074266112,209715200:1073741840,226492416:540672,243269632:1074282496,260046848:16400,268435456:0,285212672:1074266128,301989888:1073758224,318767104:1074282496,335544320:1074266112,352321536:16,369098752:540688,385875968:16384,402653184:16400,419430400:524288,436207616:524304,452984832:1073741840,469762048:540672,486539264:1073758208,503316480:1073741824,520093696:1074282512,276824064:540688,293601280:524288,310378496:1074266112,327155712:16384,343932928:1073758208,360710144:1074282512,377487360:16,394264576:1073741824,411041792:1074282496,427819008:1073741840,444596224:1073758224,461373440:524304,478150656:0,494927872:16400,511705088:1074266128,528482304:540672},{0:260,1048576:0,2097152:67109120,3145728:65796,4194304:65540,5242880:67108868,6291456:67174660,7340032:67174400,8388608:67108864,9437184:67174656,10485760:65792,11534336:67174404,12582912:67109124,13631488:65536,14680064:4,15728640:256,524288:67174656,1572864:67174404,2621440:0,3670016:67109120,4718592:67108868,5767168:65536,6815744:65540,7864320:260,8912896:4,9961472:256,11010048:67174400,12058624:65796,13107200:65792,14155776:67109124,15204352:67174660,16252928:67108864,16777216:67174656,17825792:65540,18874368:65536,19922944:67109120,20971520:256,22020096:67174660,23068672:67108868,24117248:0,25165824:67109124,26214400:67108864,27262976:4,28311552:65792,29360128:67174400,30408704:260,31457280:65796,32505856:67174404,17301504:67108864,18350080:260,19398656:67174656,20447232:0,21495808:65540,22544384:67109120,23592960:256,24641536:67174404,25690112:65536,26738688:67174660,27787264:65796,28835840:67108868,29884416:67109124,30932992:67174400,31981568:4,33030144:65792},{0:2151682048,65536:2147487808,131072:4198464,196608:2151677952,262144:0,327680:4198400,393216:2147483712,458752:4194368,524288:2147483648,589824:4194304,655360:64,720896:2147487744,786432:2151678016,851968:4160,917504:4096,983040:2151682112,32768:2147487808,98304:64,163840:2151678016,229376:2147487744,294912:4198400,360448:2151682112,425984:0,491520:2151677952,557056:4096,622592:2151682048,688128:4194304,753664:4160,819200:2147483648,884736:4194368,950272:4198464,1015808:2147483712,1048576:4194368,1114112:4198400,1179648:2147483712,1245184:0,1310720:4160,1376256:2151678016,1441792:2151682048,1507328:2147487808,1572864:2151682112,1638400:2147483648,1703936:2151677952,1769472:4198464,1835008:2147487744,1900544:4194304,1966080:64,2031616:4096,1081344:2151677952,1146880:2151682112,1212416:0,1277952:4198400,1343488:4194368,1409024:2147483648,1474560:2147487808,1540096:64,1605632:2147483712,1671168:4096,1736704:2147487744,1802240:2151678016,1867776:4160,1933312:2151682048,1998848:4194304,2064384:4198464},{0:128,4096:17039360,8192:262144,12288:536870912,16384:537133184,20480:16777344,24576:553648256,28672:262272,32768:16777216,36864:537133056,40960:536871040,45056:553910400,49152:553910272,53248:0,57344:17039488,61440:553648128,2048:17039488,6144:553648256,10240:128,14336:17039360,18432:262144,22528:537133184,26624:553910272,30720:536870912,34816:537133056,38912:0,43008:553910400,47104:16777344,51200:536871040,55296:553648128,59392:16777216,63488:262272,65536:262144,69632:128,73728:536870912,77824:553648256,81920:16777344,86016:553910272,90112:537133184,94208:16777216,98304:553910400,102400:553648128,106496:17039360,110592:537133056,114688:262272,118784:536871040,122880:0,126976:17039488,67584:553648256,71680:16777216,75776:17039360,79872:537133184,83968:536870912,88064:17039488,92160:128,96256:553910272,100352:262272,104448:553910400,108544:0,112640:553648128,116736:16777344,120832:262144,124928:537133056,129024:536871040},{0:268435464,256:8192,512:270532608,768:270540808,1024:268443648,1280:2097152,1536:2097160,1792:268435456,2048:0,2304:268443656,2560:2105344,2816:8,3072:270532616,3328:2105352,3584:8200,3840:270540800,128:270532608,384:270540808,640:8,896:2097152,1152:2105352,1408:268435464,1664:268443648,1920:8200,2176:2097160,2432:8192,2688:268443656,2944:270532616,3200:0,3456:270540800,3712:2105344,3968:268435456,4096:268443648,4352:270532616,4608:270540808,4864:8200,5120:2097152,5376:268435456,5632:268435464,5888:2105344,6144:2105352,6400:0,6656:8,6912:270532608,7168:8192,7424:268443656,7680:270540800,7936:2097160,4224:8,4480:2105344,4736:2097152,4992:268435464,5248:268443648,5504:8200,5760:270540808,6016:270532608,6272:270540800,6528:270532616,6784:8192,7040:2105352,7296:2097160,7552:0,7808:268435456,8064:268443656},{0:1048576,16:33555457,32:1024,48:1049601,64:34604033,80:0,96:1,112:34603009,128:33555456,144:1048577,160:33554433,176:34604032,192:34603008,208:1025,224:1049600,240:33554432,8:34603009,24:0,40:33555457,56:34604032,72:1048576,88:33554433,104:33554432,120:1025,136:1049601,152:33555456,168:34603008,184:1048577,200:1024,216:34604033,232:1,248:1049600,256:33554432,272:1048576,288:33555457,304:34603009,320:1048577,336:33555456,352:34604032,368:1049601,384:1025,400:34604033,416:1049600,432:1,448:0,464:34603008,480:33554433,496:1024,264:1049600,280:33555457,296:34603009,312:1,328:33554432,344:1048576,360:1025,376:34604032,392:33554433,408:34603008,424:0,440:34604033,456:1049601,472:1024,488:33555456,504:1048577},{0:134219808,1:131072,2:134217728,3:32,4:131104,5:134350880,6:134350848,7:2048,8:134348800,9:134219776,10:133120,11:134348832,12:2080,13:0,14:134217760,15:133152,2147483648:2048,2147483649:134350880,2147483650:134219808,2147483651:134217728,2147483652:134348800,2147483653:133120,2147483654:133152,2147483655:32,2147483656:134217760,2147483657:2080,2147483658:131104,2147483659:134350848,2147483660:0,2147483661:134348832,2147483662:134219776,2147483663:131072,16:133152,17:134350848,18:32,19:2048,20:134219776,21:134217760,22:134348832,23:131072,24:0,25:131104,26:134348800,27:134219808,28:134350880,29:133120,30:2080,31:134217728,2147483664:131072,2147483665:2048,2147483666:134348832,2147483667:133152,2147483668:32,2147483669:134348800,2147483670:134217728,2147483671:134219808,2147483672:134350880,2147483673:134217760,2147483674:134219776,2147483675:0,2147483676:133120,2147483677:2080,2147483678:131104,2147483679:134350848}],f=[4160749569,528482304,33030144,2064384,129024,8064,504,2147483679],c=o.DES=i.extend({_doReset:function(){for(var e=this._key.words,t=[],r=0;r<56;r++){var n=a[r]-1;t[r]=e[n>>>5]>>>31-n%32&1}for(var i=this._subKeys=[],o=0;o<16;o++){var l=i[o]=[],f=h[o];for(r=0;r<24;r++)l[r/6|0]|=t[(s[r]-1+f)%28]<<31-r%6,l[4+(r/6|0)]|=t[28+(s[r+24]-1+f)%28]<<31-r%6;for(l[0]=l[0]<<1|l[0]>>>31,r=1;r<7;r++)l[r]=l[r]>>>4*(r-1)+3;l[7]=l[7]<<5|l[7]>>>27}var c=this._invSubKeys=[];for(r=0;r<16;r++)c[r]=i[15-r]},encryptBlock:function(e,t){this._doCryptBlock(e,t,this._subKeys)},decryptBlock:function(e,t){this._doCryptBlock(e,t,this._invSubKeys)},_doCryptBlock:function(e,t,r){this._lBlock=e[t],this._rBlock=e[t+1],u.call(this,4,252645135),u.call(this,16,65535),d.call(this,2,858993459),d.call(this,8,16711935),u.call(this,1,1431655765);for(var n=0;n<16;n++){for(var i=r[n],o=this._lBlock,a=this._rBlock,s=0,h=0;h<8;h++)s|=l[h][((a^i[h])&f[h])>>>0];this._lBlock=a,this._rBlock=o^s}var c=this._lBlock;this._lBlock=this._rBlock,this._rBlock=c,u.call(this,1,1431655765),d.call(this,8,16711935),d.call(this,2,858993459),u.call(this,16,65535),u.call(this,4,252645135),e[t]=this._lBlock,e[t+1]=this._rBlock},keySize:2,ivSize:2,blockSize:2});function u(e,t){var r=(this._lBlock>>>e^this._rBlock)&t;this._rBlock^=r,this._lBlock^=r<<e}function d(e,t){var r=(this._rBlock>>>e^this._lBlock)&t;this._lBlock^=r,this._rBlock^=r<<e}e.DES=i._createHelper(c);var p=o.TripleDES=i.extend({_doReset:function(){var e=this._key.words;this._des1=c.createEncryptor(n.create(e.slice(0,2))),this._des2=c.createEncryptor(n.create(e.slice(2,4))),this._des3=c.createEncryptor(n.create(e.slice(4,6)))},encryptBlock:function(e,t){this._des1.encryptBlock(e,t),this._des2.decryptBlock(e,t),this._des3.encryptBlock(e,t)},decryptBlock:function(e,t){this._des3.decryptBlock(e,t),this._des2.encryptBlock(e,t),this._des1.decryptBlock(e,t)},keySize:6,ivSize:2,blockSize:2});e.TripleDES=i._createHelper(p)}(),r.TripleDES)}),Q(function(e,t){var r;e.exports=(r=ee,function(){var e=r,t=e.lib.StreamCipher,n=e.algo,i=n.RC4=t.extend({_doReset:function(){for(var e=this._key,t=e.words,r=e.sigBytes,n=this._S=[],i=0;i<256;i++)n[i]=i;i=0;for(var o=0;i<256;i++){var a=i%r,s=t[a>>>2]>>>24-a%4*8&255;o=(o+n[i]+s)%256;var h=n[i];n[i]=n[o],n[o]=h}this._i=this._j=0},_doProcessBlock:function(e,t){e[t]^=o.call(this)},keySize:8,ivSize:0});function o(){for(var e=this._S,t=this._i,r=this._j,n=0,i=0;i<4;i++){r=(r+e[t=(t+1)%256])%256;var o=e[t];e[t]=e[r],e[r]=o,n|=e[(e[t]+e[r])%256]<<24-8*i}return this._i=t,this._j=r,n}e.RC4=t._createHelper(i);var a=n.RC4Drop=i.extend({cfg:i.cfg.extend({drop:192}),_doReset:function(){i._doReset.call(this);for(var e=this.cfg.drop;e>0;e--)o.call(this)}});e.RC4Drop=t._createHelper(a)}(),r.RC4)}),Q(function(e,t){var r;e.exports=(r=ee,function(){var e=r,t=e.lib.StreamCipher,n=e.algo,i=[],o=[],a=[],s=n.Rabbit=t.extend({_doReset:function(){for(var e=this._key.words,t=this.cfg.iv,r=0;r<4;r++)e[r]=16711935&(e[r]<<8|e[r]>>>24)|4278255360&(e[r]<<24|e[r]>>>8);var n=this._X=[e[0],e[3]<<16|e[2]>>>16,e[1],e[0]<<16|e[3]>>>16,e[2],e[1]<<16|e[0]>>>16,e[3],e[2]<<16|e[1]>>>16],i=this._C=[e[2]<<16|e[2]>>>16,4294901760&e[0]|65535&e[1],e[3]<<16|e[3]>>>16,4294901760&e[1]|65535&e[2],e[0]<<16|e[0]>>>16,4294901760&e[2]|65535&e[3],e[1]<<16|e[1]>>>16,4294901760&e[3]|65535&e[0]];for(this._b=0,r=0;r<4;r++)h.call(this);for(r=0;r<8;r++)i[r]^=n[r+4&7];if(t){var o=t.words,a=o[0],s=o[1],l=16711935&(a<<8|a>>>24)|4278255360&(a<<24|a>>>8),f=16711935&(s<<8|s>>>24)|4278255360&(s<<24|s>>>8),c=l>>>16|4294901760&f,u=f<<16|65535&l;for(i[0]^=l,i[1]^=c,i[2]^=f,i[3]^=u,i[4]^=l,i[5]^=c,i[6]^=f,i[7]^=u,r=0;r<4;r++)h.call(this)}},_doProcessBlock:function(e,t){var r=this._X;h.call(this),i[0]=r[0]^r[5]>>>16^r[3]<<16,i[1]=r[2]^r[7]>>>16^r[5]<<16,i[2]=r[4]^r[1]>>>16^r[7]<<16,i[3]=r[6]^r[3]>>>16^r[1]<<16;for(var n=0;n<4;n++)i[n]=16711935&(i[n]<<8|i[n]>>>24)|4278255360&(i[n]<<24|i[n]>>>8),e[t+n]^=i[n]},blockSize:4,ivSize:2});function h(){for(var e=this._X,t=this._C,r=0;r<8;r++)o[r]=t[r];for(t[0]=t[0]+1295307597+this._b|0,t[1]=t[1]+3545052371+(t[0]>>>0<o[0]>>>0?1:0)|0,t[2]=t[2]+886263092+(t[1]>>>0<o[1]>>>0?1:0)|0,t[3]=t[3]+1295307597+(t[2]>>>0<o[2]>>>0?1:0)|0,t[4]=t[4]+3545052371+(t[3]>>>0<o[3]>>>0?1:0)|0,t[5]=t[5]+886263092+(t[4]>>>0<o[4]>>>0?1:0)|0,t[6]=t[6]+1295307597+(t[5]>>>0<o[5]>>>0?1:0)|0,t[7]=t[7]+3545052371+(t[6]>>>0<o[6]>>>0?1:0)|0,this._b=t[7]>>>0<o[7]>>>0?1:0,r=0;r<8;r++){var n=e[r]+t[r],i=65535&n,s=n>>>16,h=((i*i>>>17)+i*s>>>15)+s*s,l=((4294901760&n)*n|0)+((65535&n)*n|0);a[r]=h^l}e[0]=a[0]+(a[7]<<16|a[7]>>>16)+(a[6]<<16|a[6]>>>16)|0,e[1]=a[1]+(a[0]<<8|a[0]>>>24)+a[7]|0,e[2]=a[2]+(a[1]<<16|a[1]>>>16)+(a[0]<<16|a[0]>>>16)|0,e[3]=a[3]+(a[2]<<8|a[2]>>>24)+a[1]|0,e[4]=a[4]+(a[3]<<16|a[3]>>>16)+(a[2]<<16|a[2]>>>16)|0,e[5]=a[5]+(a[4]<<8|a[4]>>>24)+a[3]|0,e[6]=a[6]+(a[5]<<16|a[5]>>>16)+(a[4]<<16|a[4]>>>16)|0,e[7]=a[7]+(a[6]<<8|a[6]>>>24)+a[5]|0}e.Rabbit=t._createHelper(s)}(),r.Rabbit)}),Q(function(e,t){var r;e.exports=(r=ee,function(){var e=r,t=e.lib.StreamCipher,n=e.algo,i=[],o=[],a=[],s=n.RabbitLegacy=t.extend({_doReset:function(){var e=this._key.words,t=this.cfg.iv,r=this._X=[e[0],e[3]<<16|e[2]>>>16,e[1],e[0]<<16|e[3]>>>16,e[2],e[1]<<16|e[0]>>>16,e[3],e[2]<<16|e[1]>>>16],n=this._C=[e[2]<<16|e[2]>>>16,4294901760&e[0]|65535&e[1],e[3]<<16|e[3]>>>16,4294901760&e[1]|65535&e[2],e[0]<<16|e[0]>>>16,4294901760&e[2]|65535&e[3],e[1]<<16|e[1]>>>16,4294901760&e[3]|65535&e[0]];this._b=0;for(var i=0;i<4;i++)h.call(this);for(i=0;i<8;i++)n[i]^=r[i+4&7];if(t){var o=t.words,a=o[0],s=o[1],l=16711935&(a<<8|a>>>24)|4278255360&(a<<24|a>>>8),f=16711935&(s<<8|s>>>24)|4278255360&(s<<24|s>>>8),c=l>>>16|4294901760&f,u=f<<16|65535&l;for(n[0]^=l,n[1]^=c,n[2]^=f,n[3]^=u,n[4]^=l,n[5]^=c,n[6]^=f,n[7]^=u,i=0;i<4;i++)h.call(this)}},_doProcessBlock:function(e,t){var r=this._X;h.call(this),i[0]=r[0]^r[5]>>>16^r[3]<<16,i[1]=r[2]^r[7]>>>16^r[5]<<16,i[2]=r[4]^r[1]>>>16^r[7]<<16,i[3]=r[6]^r[3]>>>16^r[1]<<16;for(var n=0;n<4;n++)i[n]=16711935&(i[n]<<8|i[n]>>>24)|4278255360&(i[n]<<24|i[n]>>>8),e[t+n]^=i[n]},blockSize:4,ivSize:2});function h(){for(var e=this._X,t=this._C,r=0;r<8;r++)o[r]=t[r];for(t[0]=t[0]+1295307597+this._b|0,t[1]=t[1]+3545052371+(t[0]>>>0<o[0]>>>0?1:0)|0,t[2]=t[2]+886263092+(t[1]>>>0<o[1]>>>0?1:0)|0,t[3]=t[3]+1295307597+(t[2]>>>0<o[2]>>>0?1:0)|0,t[4]=t[4]+3545052371+(t[3]>>>0<o[3]>>>0?1:0)|0,t[5]=t[5]+886263092+(t[4]>>>0<o[4]>>>0?1:0)|0,t[6]=t[6]+1295307597+(t[5]>>>0<o[5]>>>0?1:0)|0,t[7]=t[7]+3545052371+(t[6]>>>0<o[6]>>>0?1:0)|0,this._b=t[7]>>>0<o[7]>>>0?1:0,r=0;r<8;r++){var n=e[r]+t[r],i=65535&n,s=n>>>16,h=((i*i>>>17)+i*s>>>15)+s*s,l=((4294901760&n)*n|0)+((65535&n)*n|0);a[r]=h^l}e[0]=a[0]+(a[7]<<16|a[7]>>>16)+(a[6]<<16|a[6]>>>16)|0,e[1]=a[1]+(a[0]<<8|a[0]>>>24)+a[7]|0,e[2]=a[2]+(a[1]<<16|a[1]>>>16)+(a[0]<<16|a[0]>>>16)|0,e[3]=a[3]+(a[2]<<8|a[2]>>>24)+a[1]|0,e[4]=a[4]+(a[3]<<16|a[3]>>>16)+(a[2]<<16|a[2]>>>16)|0,e[5]=a[5]+(a[4]<<8|a[4]>>>24)+a[3]|0,e[6]=a[6]+(a[5]<<16|a[5]>>>16)+(a[4]<<16|a[4]>>>16)|0,e[7]=a[7]+(a[6]<<8|a[6]>>>24)+a[5]|0}e.RabbitLegacy=t._createHelper(s)}(),r.RabbitLegacy)}),Q(function(e,t){e.exports=ee}));function re(){throw new Error("setTimeout has not been defined")}function ne(){throw new Error("clearTimeout has not been defined")}var ie=re,oe=ne;function ae(e){if(ie===setTimeout)return setTimeout(e,0);if((ie===re||!ie)&&setTimeout)return ie=setTimeout,setTimeout(e,0);try{return ie(e,0)}catch(t){try{return ie.call(null,e,0)}catch(t){return ie.call(this,e,0)}}}"function"==typeof e.setTimeout&&(ie=setTimeout),"function"==typeof e.clearTimeout&&(oe=clearTimeout);var se,he=[],le=!1,fe=-1;function ce(){le&&se&&(le=!1,se.length?he=se.concat(he):fe=-1,he.length&&ue())}function ue(){if(!le){var e=ae(ce);le=!0;for(var t=he.length;t;){for(se=he,he=[];++fe<t;)se&&se[fe].run();fe=-1,t=he.length}se=null,le=!1,function(e){if(oe===clearTimeout)return clearTimeout(e);if((oe===ne||!oe)&&clearTimeout)return oe=clearTimeout,clearTimeout(e);try{oe(e)}catch(t){try{return oe.call(null,e)}catch(t){return oe.call(this,e)}}}(e)}}function de(e){var t=new Array(arguments.length-1);if(arguments.length>1)for(var r=1;r<arguments.length;r++)t[r-1]=arguments[r];he.push(new pe(e,t)),1!==he.length||le||ae(ue)}function pe(e,t){this.fun=e,this.array=t}pe.prototype.run=function(){this.fun.apply(null,this.array)};var _e=e.performance||{};_e.now||_e.mozNow||_e.msNow||_e.oNow||_e.webkitNow;function ge(){}function ve(){ve.init.call(this)}function we(e){return void 0===e._maxListeners?ve.defaultMaxListeners:e._maxListeners}function be(e,t,r){if(t)e.call(r);else for(var n=e.length,i=Ae(e,n),o=0;o<n;++o)i[o].call(r)}function ye(e,t,r,n){if(t)e.call(r,n);else for(var i=e.length,o=Ae(e,i),a=0;a<i;++a)o[a].call(r,n)}function me(e,t,r,n,i){if(t)e.call(r,n,i);else for(var o=e.length,a=Ae(e,o),s=0;s<o;++s)a[s].call(r,n,i)}function ke(e,t,r,n,i,o){if(t)e.call(r,n,i,o);else for(var a=e.length,s=Ae(e,a),h=0;h<a;++h)s[h].call(r,n,i,o)}function Ee(e,t,r,n){if(t)e.apply(r,n);else for(var i=e.length,o=Ae(e,i),a=0;a<i;++a)o[a].apply(r,n)}function Se(e,t,r,n){var i,o,a,s;if("function"!=typeof r)throw new TypeError('"listener" argument must be a function');if((o=e._events)?(o.newListener&&(e.emit("newListener",t,r.listener?r.listener:r),o=e._events),a=o[t]):(o=e._events=new ge,e._eventsCount=0),a){if("function"==typeof a?a=o[t]=n?[r,a]:[a,r]:n?a.unshift(r):a.push(r),!a.warned&&(i=we(e))&&i>0&&a.length>i){a.warned=!0;var h=new Error("Possible EventEmitter memory leak detected. "+a.length+" "+t+" listeners added. Use emitter.setMaxListeners() to increase limit");h.name="MaxListenersExceededWarning",h.emitter=e,h.type=t,h.count=a.length,s=h,"function"==typeof console.warn?console.warn(s):console.log(s)}}else a=o[t]=r,++e._eventsCount;return e}function xe(e,t,r){var n=!1;function i(){e.removeListener(t,i),n||(n=!0,r.apply(e,arguments))}return i.listener=r,i}function Re(e){var t=this._events;if(t){var r=t[e];if("function"==typeof r)return 1;if(r)return r.length}return 0}function Ae(e,t){for(var r=new Array(t);t--;)r[t]=e[t];return r}ge.prototype=Object.create(null),ve.EventEmitter=ve,ve.usingDomains=!1,ve.prototype.domain=void 0,ve.prototype._events=void 0,ve.prototype._maxListeners=void 0,ve.defaultMaxListeners=10,ve.init=function(){this.domain=null,ve.usingDomains&&(void 0).active&&(void 0).Domain,this._events&&this._events!==Object.getPrototypeOf(this)._events||(this._events=new ge,this._eventsCount=0),this._maxListeners=this._maxListeners||void 0},ve.prototype.setMaxListeners=function(e){if("number"!=typeof e||e<0||isNaN(e))throw new TypeError('"n" argument must be a positive number');return this._maxListeners=e,this},ve.prototype.getMaxListeners=function(){return we(this)},ve.prototype.emit=function(e){var t,r,n,i,o,a,s,h="error"===e;if(a=this._events)h=h&&null==a.error;else if(!h)return!1;if(s=this.domain,h){if(t=arguments[1],!s){if(t instanceof Error)throw t;var l=new Error('Uncaught, unspecified "error" event. ('+t+")");throw l.context=t,l}return t||(t=new Error('Uncaught, unspecified "error" event')),t.domainEmitter=this,t.domain=s,t.domainThrown=!1,s.emit("error",t),!1}if(!(r=a[e]))return!1;var f="function"==typeof r;switch(n=arguments.length){case 1:be(r,f,this);break;case 2:ye(r,f,this,arguments[1]);break;case 3:me(r,f,this,arguments[1],arguments[2]);break;case 4:ke(r,f,this,arguments[1],arguments[2],arguments[3]);break;default:for(i=new Array(n-1),o=1;o<n;o++)i[o-1]=arguments[o];Ee(r,f,this,i)}return!0},ve.prototype.addListener=function(e,t){return Se(this,e,t,!1)},ve.prototype.on=ve.prototype.addListener,ve.prototype.prependListener=function(e,t){return Se(this,e,t,!0)},ve.prototype.once=function(e,t){if("function"!=typeof t)throw new TypeError('"listener" argument must be a function');return this.on(e,xe(this,e,t)),this},ve.prototype.prependOnceListener=function(e,t){if("function"!=typeof t)throw new TypeError('"listener" argument must be a function');return this.prependListener(e,xe(this,e,t)),this},ve.prototype.removeListener=function(e,t){var r,n,i,o,a;if("function"!=typeof t)throw new TypeError('"listener" argument must be a function');if(!(n=this._events))return this;if(!(r=n[e]))return this;if(r===t||r.listener&&r.listener===t)0==--this._eventsCount?this._events=new ge:(delete n[e],n.removeListener&&this.emit("removeListener",e,r.listener||t));else if("function"!=typeof r){for(i=-1,o=r.length;o-- >0;)if(r[o]===t||r[o].listener&&r[o].listener===t){a=r[o].listener,i=o;break}if(i<0)return this;if(1===r.length){if(r[0]=void 0,0==--this._eventsCount)return this._events=new ge,this;delete n[e]}else!function(e,t){for(var r=t,n=r+1,i=e.length;n<i;r+=1,n+=1)e[r]=e[n];e.pop()}(r,i);n.removeListener&&this.emit("removeListener",e,a||t)}return this},ve.prototype.removeAllListeners=function(e){var t,r;if(!(r=this._events))return this;if(!r.removeListener)return 0===arguments.length?(this._events=new ge,this._eventsCount=0):r[e]&&(0==--this._eventsCount?this._events=new ge:delete r[e]),this;if(0===arguments.length){for(var n,i=Object.keys(r),o=0;o<i.length;++o)"removeListener"!==(n=i[o])&&this.removeAllListeners(n);return this.removeAllListeners("removeListener"),this._events=new ge,this._eventsCount=0,this}if("function"==typeof(t=r[e]))this.removeListener(e,t);else if(t)do{this.removeListener(e,t[t.length-1])}while(t[0]);return this},ve.prototype.listeners=function(e){var t,r=this._events;return r&&(t=r[e])?"function"==typeof t?[t.listener||t]:function(e){for(var t=new Array(e.length),r=0;r<t.length;++r)t[r]=e[r].listener||e[r];return t}(t):[]},ve.listenerCount=function(e,t){return"function"==typeof e.listenerCount?e.listenerCount(t):Re.call(e,t)},ve.prototype.listenerCount=Re,ve.prototype.eventNames=function(){return this._eventsCount>0?Reflect.ownKeys(this._events):[]};var Be="function"==typeof Object.create?function(e,t){e.super_=t,e.prototype=Object.create(t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}})}:function(e,t){e.super_=t;var r=function(){};r.prototype=t.prototype,e.prototype=new r,e.prototype.constructor=e},ze=/%[sdj%]/g;function Le(e){if(!Ze(e)){for(var t=[],r=0;r<arguments.length;r++)t.push(De(arguments[r]));return t.join(" ")}r=1;for(var n=arguments,i=n.length,o=String(e).replace(ze,function(e){if("%%"===e)return"%";if(r>=i)return e;switch(e){case"%s":return String(n[r++]);case"%d":return Number(n[r++]);case"%j":try{return JSON.stringify(n[r++])}catch(e){return"[Circular]"}default:return e}}),a=n[r];r<i;a=n[++r])Ne(a)||!Ye(a)?o+=" "+a:o+=" "+De(a);return o}function Te(t,r){if(je(e.process))return function(){return Te(t,r).apply(this,arguments)};var n=!1;return function(){return n||(console.error(r),n=!0),t.apply(this,arguments)}}var Me,Ce={};function De(e,t){var r={seen:[],stylize:Pe};return arguments.length>=3&&(r.depth=arguments[2]),arguments.length>=4&&(r.colors=arguments[3]),Fe(t)?r.showHidden=t:t&&function(e,t){if(!t||!Ye(t))return e;var r=Object.keys(t),n=r.length;for(;n--;)e[r[n]]=t[r[n]]}(r,t),je(r.showHidden)&&(r.showHidden=!1),je(r.depth)&&(r.depth=2),je(r.colors)&&(r.colors=!1),je(r.customInspect)&&(r.customInspect=!0),r.colors&&(r.stylize=Ie),Oe(r,e,r.depth)}function Ie(e,t){var r=De.styles[t];return r?"["+De.colors[r][0]+"m"+e+"["+De.colors[r][1]+"m":e}function Pe(e,t){return e}function Oe(e,t,r){if(e.customInspect&&t&&qe(t.inspect)&&t.inspect!==De&&(!t.constructor||t.constructor.prototype!==t)){var n=t.inspect(r,e);return Ze(n)||(n=Oe(e,n,r)),n}var i=function(e,t){if(je(t))return e.stylize("undefined","undefined");if(Ze(t)){var r="'"+JSON.stringify(t).replace(/^"|"$/g,"").replace(/'/g,"\\'").replace(/\\"/g,'"')+"'";return e.stylize(r,"string")}if(n=t,"number"==typeof n)return e.stylize(""+t,"number");var n;if(Fe(t))return e.stylize(""+t,"boolean");if(Ne(t))return e.stylize("null","null")}(e,t);if(i)return i;var o=Object.keys(t),a=function(e){var t={};return e.forEach(function(e,r){t[e]=!0}),t}(o);if(e.showHidden&&(o=Object.getOwnPropertyNames(t)),Xe(t)&&(o.indexOf("message")>=0||o.indexOf("description")>=0))return Ue(t);if(0===o.length){if(qe(t)){var s=t.name?": "+t.name:"";return e.stylize("[Function"+s+"]","special")}if(We(t))return e.stylize(RegExp.prototype.toString.call(t),"regexp");if(Ke(t))return e.stylize(Date.prototype.toString.call(t),"date");if(Xe(t))return Ue(t)}var h,l,f="",c=!1,u=["{","}"];(h=t,Array.isArray(h)&&(c=!0,u=["[","]"]),qe(t))&&(f=" [Function"+(t.name?": "+t.name:"")+"]");return We(t)&&(f=" "+RegExp.prototype.toString.call(t)),Ke(t)&&(f=" "+Date.prototype.toUTCString.call(t)),Xe(t)&&(f=" "+Ue(t)),0!==o.length||c&&0!=t.length?r<0?We(t)?e.stylize(RegExp.prototype.toString.call(t),"regexp"):e.stylize("[Object]","special"):(e.seen.push(t),l=c?function(e,t,r,n,i){for(var o=[],a=0,s=t.length;a<s;++a)Ge(t,String(a))?o.push(He(e,t,r,n,String(a),!0)):o.push("");return i.forEach(function(i){i.match(/^\d+$/)||o.push(He(e,t,r,n,i,!0))}),o}(e,t,r,a,o):o.map(function(n){return He(e,t,r,a,n,c)}),e.seen.pop(),function(e,t,r){if(e.reduce(function(e,t){return t.indexOf("\n"),e+t.replace(/\u001b\[\d\d?m/g,"").length+1},0)>60)return r[0]+(""===t?"":t+"\n ")+" "+e.join(",\n  ")+" "+r[1];return r[0]+t+" "+e.join(", ")+" "+r[1]}(l,f,u)):u[0]+f+u[1]}function Ue(e){return"["+Error.prototype.toString.call(e)+"]"}function He(e,t,r,n,i,o){var a,s,h;if((h=Object.getOwnPropertyDescriptor(t,i)||{value:t[i]}).get?s=h.set?e.stylize("[Getter/Setter]","special"):e.stylize("[Getter]","special"):h.set&&(s=e.stylize("[Setter]","special")),Ge(n,i)||(a="["+i+"]"),s||(e.seen.indexOf(h.value)<0?(s=Ne(r)?Oe(e,h.value,null):Oe(e,h.value,r-1)).indexOf("\n")>-1&&(s=o?s.split("\n").map(function(e){return"  "+e}).join("\n").substr(2):"\n"+s.split("\n").map(function(e){return"   "+e}).join("\n")):s=e.stylize("[Circular]","special")),je(a)){if(o&&i.match(/^\d+$/))return s;(a=JSON.stringify(""+i)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)?(a=a.substr(1,a.length-2),a=e.stylize(a,"name")):(a=a.replace(/'/g,"\\'").replace(/\\"/g,'"').replace(/(^"|"$)/g,"'"),a=e.stylize(a,"string"))}return a+": "+s}function Fe(e){return"boolean"==typeof e}function Ne(e){return null===e}function Ze(e){return"string"==typeof e}function je(e){return void 0===e}function We(e){return Ye(e)&&"[object RegExp]"===Ve(e)}function Ye(e){return"object"==typeof e&&null!==e}function Ke(e){return Ye(e)&&"[object Date]"===Ve(e)}function Xe(e){return Ye(e)&&("[object Error]"===Ve(e)||e instanceof Error)}function qe(e){return"function"==typeof e}function Ve(e){return Object.prototype.toString.call(e)}function Ge(e,t){return Object.prototype.hasOwnProperty.call(e,t)}function $e(){this.head=null,this.tail=null,this.length=0}De.colors={bold:[1,22],italic:[3,23],underline:[4,24],inverse:[7,27],white:[37,39],grey:[90,39],black:[30,39],blue:[34,39],cyan:[36,39],green:[32,39],magenta:[35,39],red:[31,39],yellow:[33,39]},De.styles={special:"cyan",number:"yellow",boolean:"yellow",undefined:"grey",null:"bold",string:"green",date:"magenta",regexp:"red"},$e.prototype.push=function(e){var t={data:e,next:null};this.length>0?this.tail.next=t:this.head=t,this.tail=t,++this.length},$e.prototype.unshift=function(e){var t={data:e,next:this.head};0===this.length&&(this.tail=t),this.head=t,++this.length},$e.prototype.shift=function(){if(0!==this.length){var e=this.head.data;return 1===this.length?this.head=this.tail=null:this.head=this.head.next,--this.length,e}},$e.prototype.clear=function(){this.head=this.tail=null,this.length=0},$e.prototype.join=function(e){if(0===this.length)return"";for(var t=this.head,r=""+t.data;t=t.next;)r+=e+t.data;return r},$e.prototype.concat=function(e){if(0===this.length)return p.alloc(0);if(1===this.length)return this.head.data;for(var t=p.allocUnsafe(e>>>0),r=this.head,n=0;r;)r.data.copy(t,n),n+=r.data.length,r=r.next;return t};var Je=p.isEncoding||function(e){switch(e&&e.toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":case"raw":return!0;default:return!1}};function Qe(e){switch(this.encoding=(e||"utf8").toLowerCase().replace(/[-_]/,""),function(e){if(e&&!Je(e))throw new Error("Unknown encoding: "+e)}(e),this.encoding){case"utf8":this.surrogateSize=3;break;case"ucs2":case"utf16le":this.surrogateSize=2,this.detectIncompleteChar=tt;break;case"base64":this.surrogateSize=3,this.detectIncompleteChar=rt;break;default:return void(this.write=et)}this.charBuffer=new p(6),this.charReceived=0,this.charLength=0}function et(e){return e.toString(this.encoding)}function tt(e){this.charReceived=e.length%2,this.charLength=this.charReceived?2:0}function rt(e){this.charReceived=e.length%3,this.charLength=this.charReceived?3:0}Qe.prototype.write=function(e){for(var t="";this.charLength;){var r=e.length>=this.charLength-this.charReceived?this.charLength-this.charReceived:e.length;if(e.copy(this.charBuffer,this.charReceived,0,r),this.charReceived+=r,this.charReceived<this.charLength)return"";if(e=e.slice(r,e.length),!((i=(t=this.charBuffer.slice(0,this.charLength).toString(this.encoding)).charCodeAt(t.length-1))>=55296&&i<=56319)){if(this.charReceived=this.charLength=0,0===e.length)return t;break}this.charLength+=this.surrogateSize,t=""}this.detectIncompleteChar(e);var n=e.length;this.charLength&&(e.copy(this.charBuffer,0,e.length-this.charReceived,n),n-=this.charReceived);var i;n=(t+=e.toString(this.encoding,0,n)).length-1;if((i=t.charCodeAt(n))>=55296&&i<=56319){var o=this.surrogateSize;return this.charLength+=o,this.charReceived+=o,this.charBuffer.copy(this.charBuffer,o,0,o),e.copy(this.charBuffer,0,0,o),t.substring(0,n)}return t},Qe.prototype.detectIncompleteChar=function(e){for(var t=e.length>=3?3:e.length;t>0;t--){var r=e[e.length-t];if(1==t&&r>>5==6){this.charLength=2;break}if(t<=2&&r>>4==14){this.charLength=3;break}if(t<=3&&r>>3==30){this.charLength=4;break}}this.charReceived=t},Qe.prototype.end=function(e){var t="";if(e&&e.length&&(t=this.write(e)),this.charReceived){var r=this.charReceived,n=this.charBuffer,i=this.encoding;t+=n.slice(0,r).toString(i)}return t},ot.ReadableState=it;var nt=function(e){je(Me)&&(Me=""),e=e.toUpperCase(),Ce[e]||(new RegExp("\\b"+e+"\\b","i").test(Me)?Ce[e]=function(){var t=Le.apply(null,arguments);console.error("%s %d: %s",e,0,t)}:Ce[e]=function(){});return Ce[e]}("stream");function it(e,t){e=e||{},this.objectMode=!!e.objectMode,t instanceof Ct&&(this.objectMode=this.objectMode||!!e.readableObjectMode);var r=e.highWaterMark,n=this.objectMode?16:16384;this.highWaterMark=r||0===r?r:n,this.highWaterMark=~~this.highWaterMark,this.buffer=new $e,this.length=0,this.pipes=null,this.pipesCount=0,this.flowing=null,this.ended=!1,this.endEmitted=!1,this.reading=!1,this.sync=!0,this.needReadable=!1,this.emittedReadable=!1,this.readableListening=!1,this.resumeScheduled=!1,this.defaultEncoding=e.defaultEncoding||"utf8",this.ranOut=!1,this.awaitDrain=0,this.readingMore=!1,this.decoder=null,this.encoding=null,e.encoding&&(this.decoder=new Qe(e.encoding),this.encoding=e.encoding)}function ot(e){if(!(this instanceof ot))return new ot(e);this._readableState=new it(e,this),this.readable=!0,e&&"function"==typeof e.read&&(this._read=e.read),ve.call(this)}function at(e,t,r,n,i){var o=function(e,t){var r=null;$(t)||"string"==typeof t||null==t||e.objectMode||(r=new TypeError("Invalid non-string/buffer chunk"));return r}(t,r);if(o)e.emit("error",o);else if(null===r)t.reading=!1,function(e,t){if(t.ended)return;if(t.decoder){var r=t.decoder.end();r&&r.length&&(t.buffer.push(r),t.length+=t.objectMode?1:r.length)}t.ended=!0,lt(e)}(e,t);else if(t.objectMode||r&&r.length>0)if(t.ended&&!i){var a=new Error("stream.push() after EOF");e.emit("error",a)}else if(t.endEmitted&&i){var s=new Error("stream.unshift() after end event");e.emit("error",s)}else{var h;!t.decoder||i||n||(r=t.decoder.write(r),h=!t.objectMode&&0===r.length),i||(t.reading=!1),h||(t.flowing&&0===t.length&&!t.sync?(e.emit("data",r),e.read(0)):(t.length+=t.objectMode?1:r.length,i?t.buffer.unshift(r):t.buffer.push(r),t.needReadable&&lt(e))),function(e,t){t.readingMore||(t.readingMore=!0,de(ct,e,t))}(e,t)}else i||(t.reading=!1);return function(e){return!e.ended&&(e.needReadable||e.length<e.highWaterMark||0===e.length)}(t)}Be(ot,ve),ot.prototype.push=function(e,t){var r=this._readableState;return r.objectMode||"string"!=typeof e||(t=t||r.defaultEncoding)!==r.encoding&&(e=p.from(e,t),t=""),at(this,r,e,t,!1)},ot.prototype.unshift=function(e){return at(this,this._readableState,e,"",!0)},ot.prototype.isPaused=function(){return!1===this._readableState.flowing},ot.prototype.setEncoding=function(e){return this._readableState.decoder=new Qe(e),this._readableState.encoding=e,this};var st=8388608;function ht(e,t){return e<=0||0===t.length&&t.ended?0:t.objectMode?1:e!=e?t.flowing&&t.length?t.buffer.head.data.length:t.length:(e>t.highWaterMark&&(t.highWaterMark=function(e){return e>=st?e=st:(e--,e|=e>>>1,e|=e>>>2,e|=e>>>4,e|=e>>>8,e|=e>>>16,e++),e}(e)),e<=t.length?e:t.ended?t.length:(t.needReadable=!0,0))}function lt(e){var t=e._readableState;t.needReadable=!1,t.emittedReadable||(nt("emitReadable",t.flowing),t.emittedReadable=!0,t.sync?de(ft,e):ft(e))}function ft(e){nt("emit readable"),e.emit("readable"),pt(e)}function ct(e,t){for(var r=t.length;!t.reading&&!t.flowing&&!t.ended&&t.length<t.highWaterMark&&(nt("maybeReadMore read 0"),e.read(0),r!==t.length);)r=t.length;t.readingMore=!1}function ut(e){nt("readable nexttick read 0"),e.read(0)}function dt(e,t){t.reading||(nt("resume read 0"),e.read(0)),t.resumeScheduled=!1,t.awaitDrain=0,e.emit("resume"),pt(e),t.flowing&&!t.reading&&e.read(0)}function pt(e){var t=e._readableState;for(nt("flow",t.flowing);t.flowing&&null!==e.read(););}function _t(e,t){return 0===t.length?null:(t.objectMode?r=t.buffer.shift():!e||e>=t.length?(r=t.decoder?t.buffer.join(""):1===t.buffer.length?t.buffer.head.data:t.buffer.concat(t.length),t.buffer.clear()):r=function(e,t,r){var n;e<t.head.data.length?(n=t.head.data.slice(0,e),t.head.data=t.head.data.slice(e)):n=e===t.head.data.length?t.shift():r?function(e,t){var r=t.head,n=1,i=r.data;e-=i.length;for(;r=r.next;){var o=r.data,a=e>o.length?o.length:e;if(a===o.length?i+=o:i+=o.slice(0,e),0===(e-=a)){a===o.length?(++n,r.next?t.head=r.next:t.head=t.tail=null):(t.head=r,r.data=o.slice(a));break}++n}return t.length-=n,i}(e,t):function(e,t){var r=p.allocUnsafe(e),n=t.head,i=1;n.data.copy(r),e-=n.data.length;for(;n=n.next;){var o=n.data,a=e>o.length?o.length:e;if(o.copy(r,r.length-e,0,a),0===(e-=a)){a===o.length?(++i,n.next?t.head=n.next:t.head=t.tail=null):(t.head=n,n.data=o.slice(a));break}++i}return t.length-=i,r}(e,t);return n}(e,t.buffer,t.decoder),r);var r}function gt(e){var t=e._readableState;if(t.length>0)throw new Error('"endReadable()" called on non-empty stream');t.endEmitted||(t.ended=!0,de(vt,t,e))}function vt(e,t){e.endEmitted||0!==e.length||(e.endEmitted=!0,t.readable=!1,t.emit("end"))}function wt(e,t){for(var r=0,n=e.length;r<n;r++)if(e[r]===t)return r;return-1}function bt(){}function yt(e,t,r){this.chunk=e,this.encoding=t,this.callback=r,this.next=null}function mt(e,t){Object.defineProperty(this,"buffer",{get:Te(function(){return this.getBuffer()},"_writableState.buffer is deprecated. Use _writableState.getBuffer instead.")}),e=e||{},this.objectMode=!!e.objectMode,t instanceof Ct&&(this.objectMode=this.objectMode||!!e.writableObjectMode);var r=e.highWaterMark,n=this.objectMode?16:16384;this.highWaterMark=r||0===r?r:n,this.highWaterMark=~~this.highWaterMark,this.needDrain=!1,this.ending=!1,this.ended=!1,this.finished=!1;var i=!1===e.decodeStrings;this.decodeStrings=!i,this.defaultEncoding=e.defaultEncoding||"utf8",this.length=0,this.writing=!1,this.corked=0,this.sync=!0,this.bufferProcessing=!1,this.onwrite=function(e){!function(e,t){var r=e._writableState,n=r.sync,i=r.writecb;if(function(e){e.writing=!1,e.writecb=null,e.length-=e.writelen,e.writelen=0}(r),t)!function(e,t,r,n,i){--t.pendingcb,r?de(i,n):i(n);e._writableState.errorEmitted=!0,e.emit("error",n)}(e,r,n,t,i);else{var o=Rt(r);o||r.corked||r.bufferProcessing||!r.bufferedRequest||xt(e,r),n?de(St,e,r,o,i):St(e,r,o,i)}}(t,e)},this.writecb=null,this.writelen=0,this.bufferedRequest=null,this.lastBufferedRequest=null,this.pendingcb=0,this.prefinished=!1,this.errorEmitted=!1,this.bufferedRequestCount=0,this.corkedRequestsFree=new zt(this)}function kt(e){if(!(this instanceof kt||this instanceof Ct))return new kt(e);this._writableState=new mt(e,this),this.writable=!0,e&&("function"==typeof e.write&&(this._write=e.write),"function"==typeof e.writev&&(this._writev=e.writev)),ve.call(this)}function Et(e,t,r,n,i,o,a){t.writelen=n,t.writecb=a,t.writing=!0,t.sync=!0,r?e._writev(i,t.onwrite):e._write(i,o,t.onwrite),t.sync=!1}function St(e,t,r,n){r||function(e,t){0===t.length&&t.needDrain&&(t.needDrain=!1,e.emit("drain"))}(e,t),t.pendingcb--,n(),Bt(e,t)}function xt(e,t){t.bufferProcessing=!0;var r=t.bufferedRequest;if(e._writev&&r&&r.next){var n=t.bufferedRequestCount,i=new Array(n),o=t.corkedRequestsFree;o.entry=r;for(var a=0;r;)i[a]=r,r=r.next,a+=1;Et(e,t,!0,t.length,i,"",o.finish),t.pendingcb++,t.lastBufferedRequest=null,o.next?(t.corkedRequestsFree=o.next,o.next=null):t.corkedRequestsFree=new zt(t)}else{for(;r;){var s=r.chunk,h=r.encoding,l=r.callback;if(Et(e,t,!1,t.objectMode?1:s.length,s,h,l),r=r.next,t.writing)break}null===r&&(t.lastBufferedRequest=null)}t.bufferedRequestCount=0,t.bufferedRequest=r,t.bufferProcessing=!1}function Rt(e){return e.ending&&0===e.length&&null===e.bufferedRequest&&!e.finished&&!e.writing}function At(e,t){t.prefinished||(t.prefinished=!0,e.emit("prefinish"))}function Bt(e,t){var r=Rt(t);return r&&(0===t.pendingcb?(At(e,t),t.finished=!0,e.emit("finish")):At(e,t)),r}function zt(e){var t=this;this.next=null,this.entry=null,this.finish=function(r){var n=t.entry;for(t.entry=null;n;){var i=n.callback;e.pendingcb--,i(r),n=n.next}e.corkedRequestsFree?e.corkedRequestsFree.next=t:e.corkedRequestsFree=t}}ot.prototype.read=function(e){nt("read",e),e=parseInt(e,10);var t=this._readableState,r=e;if(0!==e&&(t.emittedReadable=!1),0===e&&t.needReadable&&(t.length>=t.highWaterMark||t.ended))return nt("read: emitReadable",t.length,t.ended),0===t.length&&t.ended?gt(this):lt(this),null;if(0===(e=ht(e,t))&&t.ended)return 0===t.length&&gt(this),null;var n,i=t.needReadable;return nt("need readable",i),(0===t.length||t.length-e<t.highWaterMark)&&nt("length less than watermark",i=!0),t.ended||t.reading?nt("reading or ended",i=!1):i&&(nt("do read"),t.reading=!0,t.sync=!0,0===t.length&&(t.needReadable=!0),this._read(t.highWaterMark),t.sync=!1,t.reading||(e=ht(r,t))),null===(n=e>0?_t(e,t):null)?(t.needReadable=!0,e=0):t.length-=e,0===t.length&&(t.ended||(t.needReadable=!0),r!==e&&t.ended&&gt(this)),null!==n&&this.emit("data",n),n},ot.prototype._read=function(e){this.emit("error",new Error("not implemented"))},ot.prototype.pipe=function(e,t){var r=this,n=this._readableState;switch(n.pipesCount){case 0:n.pipes=e;break;case 1:n.pipes=[n.pipes,e];break;default:n.pipes.push(e)}n.pipesCount+=1,nt("pipe count=%d opts=%j",n.pipesCount,t);var i=!t||!1!==t.end?a:l;function o(e){nt("onunpipe"),e===r&&l()}function a(){nt("onend"),e.end()}n.endEmitted?de(i):r.once("end",i),e.on("unpipe",o);var s=function(e){return function(){var t=e._readableState;nt("pipeOnDrain",t.awaitDrain),t.awaitDrain&&t.awaitDrain--,0===t.awaitDrain&&e.listeners("data").length&&(t.flowing=!0,pt(e))}}(r);e.on("drain",s);var h=!1;function l(){nt("cleanup"),e.removeListener("close",d),e.removeListener("finish",p),e.removeListener("drain",s),e.removeListener("error",u),e.removeListener("unpipe",o),r.removeListener("end",a),r.removeListener("end",l),r.removeListener("data",c),h=!0,!n.awaitDrain||e._writableState&&!e._writableState.needDrain||s()}var f=!1;function c(t){nt("ondata"),f=!1,!1!==e.write(t)||f||((1===n.pipesCount&&n.pipes===e||n.pipesCount>1&&-1!==wt(n.pipes,e))&&!h&&(nt("false write response, pause",r._readableState.awaitDrain),r._readableState.awaitDrain++,f=!0),r.pause())}function u(t){var r;nt("onerror",t),_(),e.removeListener("error",u),0===(r="error",e.listeners(r).length)&&e.emit("error",t)}function d(){e.removeListener("finish",p),_()}function p(){nt("onfinish"),e.removeListener("close",d),_()}function _(){nt("unpipe"),r.unpipe(e)}return r.on("data",c),function(e,t,r){if("function"==typeof e.prependListener)return e.prependListener(t,r);e._events&&e._events[t]?Array.isArray(e._events[t])?e._events[t].unshift(r):e._events[t]=[r,e._events[t]]:e.on(t,r)}(e,"error",u),e.once("close",d),e.once("finish",p),e.emit("pipe",r),n.flowing||(nt("pipe resume"),r.resume()),e},ot.prototype.unpipe=function(e){var t=this._readableState;if(0===t.pipesCount)return this;if(1===t.pipesCount)return e&&e!==t.pipes?this:(e||(e=t.pipes),t.pipes=null,t.pipesCount=0,t.flowing=!1,e&&e.emit("unpipe",this),this);if(!e){var r=t.pipes,n=t.pipesCount;t.pipes=null,t.pipesCount=0,t.flowing=!1;for(var i=0;i<n;i++)r[i].emit("unpipe",this);return this}var o=wt(t.pipes,e);return-1===o?this:(t.pipes.splice(o,1),t.pipesCount-=1,1===t.pipesCount&&(t.pipes=t.pipes[0]),e.emit("unpipe",this),this)},ot.prototype.on=function(e,t){var r=ve.prototype.on.call(this,e,t);if("data"===e)!1!==this._readableState.flowing&&this.resume();else if("readable"===e){var n=this._readableState;n.endEmitted||n.readableListening||(n.readableListening=n.needReadable=!0,n.emittedReadable=!1,n.reading?n.length&&lt(this):de(ut,this))}return r},ot.prototype.addListener=ot.prototype.on,ot.prototype.resume=function(){var e=this._readableState;return e.flowing||(nt("resume"),e.flowing=!0,function(e,t){t.resumeScheduled||(t.resumeScheduled=!0,de(dt,e,t))}(this,e)),this},ot.prototype.pause=function(){return nt("call pause flowing=%j",this._readableState.flowing),!1!==this._readableState.flowing&&(nt("pause"),this._readableState.flowing=!1,this.emit("pause")),this},ot.prototype.wrap=function(e){var t=this._readableState,r=!1,n=this;for(var i in e.on("end",function(){if(nt("wrapped end"),t.decoder&&!t.ended){var e=t.decoder.end();e&&e.length&&n.push(e)}n.push(null)}),e.on("data",function(i){(nt("wrapped data"),t.decoder&&(i=t.decoder.write(i)),t.objectMode&&null==i)||(t.objectMode||i&&i.length)&&(n.push(i)||(r=!0,e.pause()))}),e)void 0===this[i]&&"function"==typeof e[i]&&(this[i]=function(t){return function(){return e[t].apply(e,arguments)}}(i));return function(e,t){for(var r=0,n=e.length;r<n;r++)t(e[r],r)}(["error","close","destroy","pause","resume"],function(t){e.on(t,n.emit.bind(n,t))}),n._read=function(t){nt("wrapped _read",t),r&&(r=!1,e.resume())},n},ot._fromList=_t,kt.WritableState=mt,Be(kt,ve),mt.prototype.getBuffer=function(){for(var e=this.bufferedRequest,t=[];e;)t.push(e),e=e.next;return t},kt.prototype.pipe=function(){this.emit("error",new Error("Cannot pipe, not readable"))},kt.prototype.write=function(e,t,r){var n=this._writableState,i=!1;return"function"==typeof t&&(r=t,t=null),p.isBuffer(e)?t="buffer":t||(t=n.defaultEncoding),"function"!=typeof r&&(r=bt),n.ended?function(e,t){var r=new Error("write after end");e.emit("error",r),de(t,r)}(this,r):function(e,t,r,n){var i=!0,o=!1;return null===r?o=new TypeError("May not write null values to stream"):p.isBuffer(r)||"string"==typeof r||void 0===r||t.objectMode||(o=new TypeError("Invalid non-string/buffer chunk")),o&&(e.emit("error",o),de(n,o),i=!1),i}(this,n,e,r)&&(n.pendingcb++,i=function(e,t,r,n,i){r=function(e,t,r){return e.objectMode||!1===e.decodeStrings||"string"!=typeof t||(t=p.from(t,r)),t}(t,r,n),p.isBuffer(r)&&(n="buffer");var o=t.objectMode?1:r.length;t.length+=o;var a=t.length<t.highWaterMark;a||(t.needDrain=!0);if(t.writing||t.corked){var s=t.lastBufferedRequest;t.lastBufferedRequest=new yt(r,n,i),s?s.next=t.lastBufferedRequest:t.bufferedRequest=t.lastBufferedRequest,t.bufferedRequestCount+=1}else Et(e,t,!1,o,r,n,i);return a}(this,n,e,t,r)),i},kt.prototype.cork=function(){this._writableState.corked++},kt.prototype.uncork=function(){var e=this._writableState;e.corked&&(e.corked--,e.writing||e.corked||e.finished||e.bufferProcessing||!e.bufferedRequest||xt(this,e))},kt.prototype.setDefaultEncoding=function(e){if("string"==typeof e&&(e=e.toLowerCase()),!(["hex","utf8","utf-8","ascii","binary","base64","ucs2","ucs-2","utf16le","utf-16le","raw"].indexOf((e+"").toLowerCase())>-1))throw new TypeError("Unknown encoding: "+e);return this._writableState.defaultEncoding=e,this},kt.prototype._write=function(e,t,r){r(new Error("not implemented"))},kt.prototype._writev=null,kt.prototype.end=function(e,t,r){var n=this._writableState;"function"==typeof e?(r=e,e=null,t=null):"function"==typeof t&&(r=t,t=null),null!=e&&this.write(e,t),n.corked&&(n.corked=1,this.uncork()),n.ending||n.finished||function(e,t,r){t.ending=!0,Bt(e,t),r&&(t.finished?de(r):e.once("finish",r));t.ended=!0,e.writable=!1}(this,n,r)},Be(Ct,ot);for(var Lt=Object.keys(kt.prototype),Tt=0;Tt<Lt.length;Tt++){var Mt=Lt[Tt];Ct.prototype[Mt]||(Ct.prototype[Mt]=kt.prototype[Mt])}function Ct(e){if(!(this instanceof Ct))return new Ct(e);ot.call(this,e),kt.call(this,e),e&&!1===e.readable&&(this.readable=!1),e&&!1===e.writable&&(this.writable=!1),this.allowHalfOpen=!0,e&&!1===e.allowHalfOpen&&(this.allowHalfOpen=!1),this.once("end",Dt)}function Dt(){this.allowHalfOpen||this._writableState.ended||de(It,this)}function It(e){e.end()}function Pt(e){this.afterTransform=function(t,r){return function(e,t,r){var n=e._transformState;n.transforming=!1;var i=n.writecb;if(!i)return e.emit("error",new Error("no writecb in Transform class"));n.writechunk=null,n.writecb=null,null!=r&&e.push(r);i(t);var o=e._readableState;o.reading=!1,(o.needReadable||o.length<o.highWaterMark)&&e._read(o.highWaterMark)}(e,t,r)},this.needTransform=!1,this.transforming=!1,this.writecb=null,this.writechunk=null,this.writeencoding=null}function Ot(e){if(!(this instanceof Ot))return new Ot(e);Ct.call(this,e),this._transformState=new Pt(this);var t=this;this._readableState.needReadable=!0,this._readableState.sync=!1,e&&("function"==typeof e.transform&&(this._transform=e.transform),"function"==typeof e.flush&&(this._flush=e.flush)),this.once("prefinish",function(){"function"==typeof this._flush?this._flush(function(e){Ut(t,e)}):Ut(t)})}function Ut(e,t){if(t)return e.emit("error",t);var r=e._writableState,n=e._transformState;if(r.length)throw new Error("Calling transform done when ws.length != 0");if(n.transforming)throw new Error("Calling transform done when still transforming");return e.push(null)}function Ht(e){if(!(this instanceof Ht))return new Ht(e);Ot.call(this,e)}function Ft(){ve.call(this)}Be(Ot,Ct),Ot.prototype.push=function(e,t){return this._transformState.needTransform=!1,Ct.prototype.push.call(this,e,t)},Ot.prototype._transform=function(e,t,r){throw new Error("Not implemented")},Ot.prototype._write=function(e,t,r){var n=this._transformState;if(n.writecb=r,n.writechunk=e,n.writeencoding=t,!n.transforming){var i=this._readableState;(n.needTransform||i.needReadable||i.length<i.highWaterMark)&&this._read(i.highWaterMark)}},Ot.prototype._read=function(e){var t=this._transformState;null!==t.writechunk&&t.writecb&&!t.transforming?(t.transforming=!0,this._transform(t.writechunk,t.writeencoding,t.afterTransform)):t.needTransform=!0},Be(Ht,Ot),Ht.prototype._transform=function(e,t,r){r(null,e)},Be(Ft,ve),Ft.Readable=ot,Ft.Writable=kt,Ft.Duplex=Ct,Ft.Transform=Ot,Ft.PassThrough=Ht,Ft.Stream=Ft,Ft.prototype.pipe=function(e,t){var r=this;function n(t){e.writable&&!1===e.write(t)&&r.pause&&r.pause()}function i(){r.readable&&r.resume&&r.resume()}r.on("data",n),e.on("drain",i),e._isStdio||t&&!1===t.end||(r.on("end",a),r.on("close",s));var o=!1;function a(){o||(o=!0,e.end())}function s(){o||(o=!0,"function"==typeof e.destroy&&e.destroy())}function h(e){if(l(),0===ve.listenerCount(this,"error"))throw e}function l(){r.removeListener("data",n),e.removeListener("drain",i),r.removeListener("end",a),r.removeListener("close",s),r.removeListener("error",h),e.removeListener("error",h),r.removeListener("end",l),r.removeListener("close",l),e.removeListener("close",l)}return r.on("error",h),e.on("error",h),r.on("end",l),r.on("close",l),e.on("close",l),e.emit("pipe",r),e};var Nt={2:"need dictionary",1:"stream end",0:"","-1":"file error","-2":"stream error","-3":"data error","-4":"insufficient memory","-5":"buffer error","-6":"incompatible version"};function Zt(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg="",this.state=null,this.data_type=2,this.adler=0}function jt(e,t,r,n,i){if(t.subarray&&e.subarray)e.set(t.subarray(r,r+n),i);else for(var o=0;o<n;o++)e[i+o]=t[r+o]}var Wt=Uint8Array,Yt=Uint16Array,Kt=Int32Array,Xt=4,qt=0,Vt=1,Gt=2;function $t(e){for(var t=e.length;--t>=0;)e[t]=0}var Jt=0,Qt=1,er=2,tr=29,rr=256,nr=rr+1+tr,ir=30,or=19,ar=2*nr+1,sr=15,hr=16,lr=7,fr=256,cr=16,ur=17,dr=18,pr=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0],_r=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13],gr=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7],vr=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],wr=new Array(2*(nr+2));$t(wr);var br=new Array(2*ir);$t(br);var yr=new Array(512);$t(yr);var mr=new Array(256);$t(mr);var kr=new Array(tr);$t(kr);var Er,Sr,xr,Rr=new Array(ir);function Ar(e,t,r,n,i){this.static_tree=e,this.extra_bits=t,this.extra_base=r,this.elems=n,this.max_length=i,this.has_stree=e&&e.length}function Br(e,t){this.dyn_tree=e,this.max_code=0,this.stat_desc=t}function zr(e){return e<256?yr[e]:yr[256+(e>>>7)]}function Lr(e,t){e.pending_buf[e.pending++]=255&t,e.pending_buf[e.pending++]=t>>>8&255}function Tr(e,t,r){e.bi_valid>hr-r?(e.bi_buf|=t<<e.bi_valid&65535,Lr(e,e.bi_buf),e.bi_buf=t>>hr-e.bi_valid,e.bi_valid+=r-hr):(e.bi_buf|=t<<e.bi_valid&65535,e.bi_valid+=r)}function Mr(e,t,r){Tr(e,r[2*t],r[2*t+1])}function Cr(e,t){var r=0;do{r|=1&e,e>>>=1,r<<=1}while(--t>0);return r>>>1}function Dr(e,t,r){var n,i,o=new Array(sr+1),a=0;for(n=1;n<=sr;n++)o[n]=a=a+r[n-1]<<1;for(i=0;i<=t;i++){var s=e[2*i+1];0!==s&&(e[2*i]=Cr(o[s]++,s))}}function Ir(e){var t;for(t=0;t<nr;t++)e.dyn_ltree[2*t]=0;for(t=0;t<ir;t++)e.dyn_dtree[2*t]=0;for(t=0;t<or;t++)e.bl_tree[2*t]=0;e.dyn_ltree[2*fr]=1,e.opt_len=e.static_len=0,e.last_lit=e.matches=0}function Pr(e){e.bi_valid>8?Lr(e,e.bi_buf):e.bi_valid>0&&(e.pending_buf[e.pending++]=e.bi_buf),e.bi_buf=0,e.bi_valid=0}function Or(e,t,r,n){var i=2*t,o=2*r;return e[i]<e[o]||e[i]===e[o]&&n[t]<=n[r]}function Ur(e,t,r){for(var n=e.heap[r],i=r<<1;i<=e.heap_len&&(i<e.heap_len&&Or(t,e.heap[i+1],e.heap[i],e.depth)&&i++,!Or(t,n,e.heap[i],e.depth));)e.heap[r]=e.heap[i],r=i,i<<=1;e.heap[r]=n}function Hr(e,t,r){var n,i,o,a,s=0;if(0!==e.last_lit)do{n=e.pending_buf[e.d_buf+2*s]<<8|e.pending_buf[e.d_buf+2*s+1],i=e.pending_buf[e.l_buf+s],s++,0===n?Mr(e,i,t):(Mr(e,(o=mr[i])+rr+1,t),0!==(a=pr[o])&&Tr(e,i-=kr[o],a),Mr(e,o=zr(--n),r),0!==(a=_r[o])&&Tr(e,n-=Rr[o],a))}while(s<e.last_lit);Mr(e,fr,t)}function Fr(e,t){var r,n,i,o=t.dyn_tree,a=t.stat_desc.static_tree,s=t.stat_desc.has_stree,h=t.stat_desc.elems,l=-1;for(e.heap_len=0,e.heap_max=ar,r=0;r<h;r++)0!==o[2*r]?(e.heap[++e.heap_len]=l=r,e.depth[r]=0):o[2*r+1]=0;for(;e.heap_len<2;)o[2*(i=e.heap[++e.heap_len]=l<2?++l:0)]=1,e.depth[i]=0,e.opt_len--,s&&(e.static_len-=a[2*i+1]);for(t.max_code=l,r=e.heap_len>>1;r>=1;r--)Ur(e,o,r);i=h;do{r=e.heap[1],e.heap[1]=e.heap[e.heap_len--],Ur(e,o,1),n=e.heap[1],e.heap[--e.heap_max]=r,e.heap[--e.heap_max]=n,o[2*i]=o[2*r]+o[2*n],e.depth[i]=(e.depth[r]>=e.depth[n]?e.depth[r]:e.depth[n])+1,o[2*r+1]=o[2*n+1]=i,e.heap[1]=i++,Ur(e,o,1)}while(e.heap_len>=2);e.heap[--e.heap_max]=e.heap[1],function(e,t){var r,n,i,o,a,s,h=t.dyn_tree,l=t.max_code,f=t.stat_desc.static_tree,c=t.stat_desc.has_stree,u=t.stat_desc.extra_bits,d=t.stat_desc.extra_base,p=t.stat_desc.max_length,_=0;for(o=0;o<=sr;o++)e.bl_count[o]=0;for(h[2*e.heap[e.heap_max]+1]=0,r=e.heap_max+1;r<ar;r++)(o=h[2*h[2*(n=e.heap[r])+1]+1]+1)>p&&(o=p,_++),h[2*n+1]=o,n>l||(e.bl_count[o]++,a=0,n>=d&&(a=u[n-d]),s=h[2*n],e.opt_len+=s*(o+a),c&&(e.static_len+=s*(f[2*n+1]+a)));if(0!==_){do{for(o=p-1;0===e.bl_count[o];)o--;e.bl_count[o]--,e.bl_count[o+1]+=2,e.bl_count[p]--,_-=2}while(_>0);for(o=p;0!==o;o--)for(n=e.bl_count[o];0!==n;)(i=e.heap[--r])>l||(h[2*i+1]!==o&&(e.opt_len+=(o-h[2*i+1])*h[2*i],h[2*i+1]=o),n--)}}(e,t),Dr(o,l,e.bl_count)}function Nr(e,t,r){var n,i,o=-1,a=t[1],s=0,h=7,l=4;for(0===a&&(h=138,l=3),t[2*(r+1)+1]=65535,n=0;n<=r;n++)i=a,a=t[2*(n+1)+1],++s<h&&i===a||(s<l?e.bl_tree[2*i]+=s:0!==i?(i!==o&&e.bl_tree[2*i]++,e.bl_tree[2*cr]++):s<=10?e.bl_tree[2*ur]++:e.bl_tree[2*dr]++,s=0,o=i,0===a?(h=138,l=3):i===a?(h=6,l=3):(h=7,l=4))}function Zr(e,t,r){var n,i,o=-1,a=t[1],s=0,h=7,l=4;for(0===a&&(h=138,l=3),n=0;n<=r;n++)if(i=a,a=t[2*(n+1)+1],!(++s<h&&i===a)){if(s<l)do{Mr(e,i,e.bl_tree)}while(0!=--s);else 0!==i?(i!==o&&(Mr(e,i,e.bl_tree),s--),Mr(e,cr,e.bl_tree),Tr(e,s-3,2)):s<=10?(Mr(e,ur,e.bl_tree),Tr(e,s-3,3)):(Mr(e,dr,e.bl_tree),Tr(e,s-11,7));s=0,o=i,0===a?(h=138,l=3):i===a?(h=6,l=3):(h=7,l=4)}}$t(Rr);var jr=!1;function Wr(e){jr||(!function(){var e,t,r,n,i,o=new Array(sr+1);for(r=0,n=0;n<tr-1;n++)for(kr[n]=r,e=0;e<1<<pr[n];e++)mr[r++]=n;for(mr[r-1]=n,i=0,n=0;n<16;n++)for(Rr[n]=i,e=0;e<1<<_r[n];e++)yr[i++]=n;for(i>>=7;n<ir;n++)for(Rr[n]=i<<7,e=0;e<1<<_r[n]-7;e++)yr[256+i++]=n;for(t=0;t<=sr;t++)o[t]=0;for(e=0;e<=143;)wr[2*e+1]=8,e++,o[8]++;for(;e<=255;)wr[2*e+1]=9,e++,o[9]++;for(;e<=279;)wr[2*e+1]=7,e++,o[7]++;for(;e<=287;)wr[2*e+1]=8,e++,o[8]++;for(Dr(wr,nr+1,o),e=0;e<ir;e++)br[2*e+1]=5,br[2*e]=Cr(e,5);Er=new Ar(wr,pr,rr+1,nr,sr),Sr=new Ar(br,_r,0,ir,sr),xr=new Ar(new Array(0),gr,0,or,lr)}(),jr=!0),e.l_desc=new Br(e.dyn_ltree,Er),e.d_desc=new Br(e.dyn_dtree,Sr),e.bl_desc=new Br(e.bl_tree,xr),e.bi_buf=0,e.bi_valid=0,Ir(e)}function Yr(e,t,r,n){Tr(e,(Jt<<1)+(n?1:0),3),function(e,t,r,n){Pr(e),n&&(Lr(e,r),Lr(e,~r)),jt(e.pending_buf,e.window,t,r,e.pending),e.pending+=r}(e,t,r,!0)}function Kr(e){Tr(e,Qt<<1,3),Mr(e,fr,wr),function(e){16===e.bi_valid?(Lr(e,e.bi_buf),e.bi_buf=0,e.bi_valid=0):e.bi_valid>=8&&(e.pending_buf[e.pending++]=255&e.bi_buf,e.bi_buf>>=8,e.bi_valid-=8)}(e)}function Xr(e,t,r,n){var i,o,a=0;e.level>0?(e.strm.data_type===Gt&&(e.strm.data_type=function(e){var t,r=4093624447;for(t=0;t<=31;t++,r>>>=1)if(1&r&&0!==e.dyn_ltree[2*t])return qt;if(0!==e.dyn_ltree[18]||0!==e.dyn_ltree[20]||0!==e.dyn_ltree[26])return Vt;for(t=32;t<rr;t++)if(0!==e.dyn_ltree[2*t])return Vt;return qt}(e)),Fr(e,e.l_desc),Fr(e,e.d_desc),a=function(e){var t;for(Nr(e,e.dyn_ltree,e.l_desc.max_code),Nr(e,e.dyn_dtree,e.d_desc.max_code),Fr(e,e.bl_desc),t=or-1;t>=3&&0===e.bl_tree[2*vr[t]+1];t--);return e.opt_len+=3*(t+1)+5+5+4,t}(e),i=e.opt_len+3+7>>>3,(o=e.static_len+3+7>>>3)<=i&&(i=o)):i=o=r+5,r+4<=i&&-1!==t?Yr(e,t,r,n):e.strategy===Xt||o===i?(Tr(e,(Qt<<1)+(n?1:0),3),Hr(e,wr,br)):(Tr(e,(er<<1)+(n?1:0),3),function(e,t,r,n){var i;for(Tr(e,t-257,5),Tr(e,r-1,5),Tr(e,n-4,4),i=0;i<n;i++)Tr(e,e.bl_tree[2*vr[i]+1],3);Zr(e,e.dyn_ltree,t-1),Zr(e,e.dyn_dtree,r-1)}(e,e.l_desc.max_code+1,e.d_desc.max_code+1,a+1),Hr(e,e.dyn_ltree,e.dyn_dtree)),Ir(e),n&&Pr(e)}function qr(e,t,r){return e.pending_buf[e.d_buf+2*e.last_lit]=t>>>8&255,e.pending_buf[e.d_buf+2*e.last_lit+1]=255&t,e.pending_buf[e.l_buf+e.last_lit]=255&r,e.last_lit++,0===t?e.dyn_ltree[2*r]++:(e.matches++,t--,e.dyn_ltree[2*(mr[r]+rr+1)]++,e.dyn_dtree[2*zr(t)]++),e.last_lit===e.lit_bufsize-1}function Vr(e,t,r,n){for(var i=65535&e|0,o=e>>>16&65535|0,a=0;0!==r;){r-=a=r>2e3?2e3:r;do{o=o+(i=i+t[n++]|0)|0}while(--a);i%=65521,o%=65521}return i|o<<16|0}var Gr=function(){for(var e,t=[],r=0;r<256;r++){e=r;for(var n=0;n<8;n++)e=1&e?3988292384^e>>>1:e>>>1;t[r]=e}return t}();function $r(e,t,r,n){var i=Gr,o=n+r;e^=-1;for(var a=n;a<o;a++)e=e>>>8^i[255&(e^t[a])];return-1^e}var Jr,Qr=0,en=1,tn=3,rn=4,nn=5,on=0,an=1,sn=-2,hn=-3,ln=-5,fn=-1,cn=1,un=2,dn=3,pn=4,_n=2,gn=8,vn=9,wn=286,bn=30,yn=19,mn=2*wn+1,kn=15,En=3,Sn=258,xn=Sn+En+1,Rn=32,An=42,Bn=69,zn=73,Ln=91,Tn=103,Mn=113,Cn=666,Dn=1,In=2,Pn=3,On=4,Un=3;function Hn(e,t){return e.msg=Nt[t],t}function Fn(e){return(e<<1)-(e>4?9:0)}function Nn(e){for(var t=e.length;--t>=0;)e[t]=0}function Zn(e){var t=e.state,r=t.pending;r>e.avail_out&&(r=e.avail_out),0!==r&&(jt(e.output,t.pending_buf,t.pending_out,r,e.next_out),e.next_out+=r,t.pending_out+=r,e.total_out+=r,e.avail_out-=r,t.pending-=r,0===t.pending&&(t.pending_out=0))}function jn(e,t){Xr(e,e.block_start>=0?e.block_start:-1,e.strstart-e.block_start,t),e.block_start=e.strstart,Zn(e.strm)}function Wn(e,t){e.pending_buf[e.pending++]=t}function Yn(e,t){e.pending_buf[e.pending++]=t>>>8&255,e.pending_buf[e.pending++]=255&t}function Kn(e,t){var r,n,i=e.max_chain_length,o=e.strstart,a=e.prev_length,s=e.nice_match,h=e.strstart>e.w_size-xn?e.strstart-(e.w_size-xn):0,l=e.window,f=e.w_mask,c=e.prev,u=e.strstart+Sn,d=l[o+a-1],p=l[o+a];e.prev_length>=e.good_match&&(i>>=2),s>e.lookahead&&(s=e.lookahead);do{if(l[(r=t)+a]===p&&l[r+a-1]===d&&l[r]===l[o]&&l[++r]===l[o+1]){o+=2,r++;do{}while(l[++o]===l[++r]&&l[++o]===l[++r]&&l[++o]===l[++r]&&l[++o]===l[++r]&&l[++o]===l[++r]&&l[++o]===l[++r]&&l[++o]===l[++r]&&l[++o]===l[++r]&&o<u);if(n=Sn-(u-o),o=u-Sn,n>a){if(e.match_start=t,a=n,n>=s)break;d=l[o+a-1],p=l[o+a]}}}while((t=c[t&f])>h&&0!=--i);return a<=e.lookahead?a:e.lookahead}function Xn(e){var t,r,n,i,o,a,s,h,l,f,c=e.w_size;do{if(i=e.window_size-e.lookahead-e.strstart,e.strstart>=c+(c-xn)){jt(e.window,e.window,c,c,0),e.match_start-=c,e.strstart-=c,e.block_start-=c,t=r=e.hash_size;do{n=e.head[--t],e.head[t]=n>=c?n-c:0}while(--r);t=r=c;do{n=e.prev[--t],e.prev[t]=n>=c?n-c:0}while(--r);i+=c}if(0===e.strm.avail_in)break;if(a=e.strm,s=e.window,h=e.strstart+e.lookahead,l=i,f=void 0,(f=a.avail_in)>l&&(f=l),r=0===f?0:(a.avail_in-=f,jt(s,a.input,a.next_in,f,h),1===a.state.wrap?a.adler=Vr(a.adler,s,f,h):2===a.state.wrap&&(a.adler=$r(a.adler,s,f,h)),a.next_in+=f,a.total_in+=f,f),e.lookahead+=r,e.lookahead+e.insert>=En)for(o=e.strstart-e.insert,e.ins_h=e.window[o],e.ins_h=(e.ins_h<<e.hash_shift^e.window[o+1])&e.hash_mask;e.insert&&(e.ins_h=(e.ins_h<<e.hash_shift^e.window[o+En-1])&e.hash_mask,e.prev[o&e.w_mask]=e.head[e.ins_h],e.head[e.ins_h]=o,o++,e.insert--,!(e.lookahead+e.insert<En)););}while(e.lookahead<xn&&0!==e.strm.avail_in)}function qn(e,t){for(var r,n;;){if(e.lookahead<xn){if(Xn(e),e.lookahead<xn&&t===Qr)return Dn;if(0===e.lookahead)break}if(r=0,e.lookahead>=En&&(e.ins_h=(e.ins_h<<e.hash_shift^e.window[e.strstart+En-1])&e.hash_mask,r=e.prev[e.strstart&e.w_mask]=e.head[e.ins_h],e.head[e.ins_h]=e.strstart),0!==r&&e.strstart-r<=e.w_size-xn&&(e.match_length=Kn(e,r)),e.match_length>=En)if(n=qr(e,e.strstart-e.match_start,e.match_length-En),e.lookahead-=e.match_length,e.match_length<=e.max_lazy_match&&e.lookahead>=En){e.match_length--;do{e.strstart++,e.ins_h=(e.ins_h<<e.hash_shift^e.window[e.strstart+En-1])&e.hash_mask,r=e.prev[e.strstart&e.w_mask]=e.head[e.ins_h],e.head[e.ins_h]=e.strstart}while(0!=--e.match_length);e.strstart++}else e.strstart+=e.match_length,e.match_length=0,e.ins_h=e.window[e.strstart],e.ins_h=(e.ins_h<<e.hash_shift^e.window[e.strstart+1])&e.hash_mask;else n=qr(e,0,e.window[e.strstart]),e.lookahead--,e.strstart++;if(n&&(jn(e,!1),0===e.strm.avail_out))return Dn}return e.insert=e.strstart<En-1?e.strstart:En-1,t===rn?(jn(e,!0),0===e.strm.avail_out?Pn:On):e.last_lit&&(jn(e,!1),0===e.strm.avail_out)?Dn:In}function Vn(e,t){for(var r,n,i;;){if(e.lookahead<xn){if(Xn(e),e.lookahead<xn&&t===Qr)return Dn;if(0===e.lookahead)break}if(r=0,e.lookahead>=En&&(e.ins_h=(e.ins_h<<e.hash_shift^e.window[e.strstart+En-1])&e.hash_mask,r=e.prev[e.strstart&e.w_mask]=e.head[e.ins_h],e.head[e.ins_h]=e.strstart),e.prev_length=e.match_length,e.prev_match=e.match_start,e.match_length=En-1,0!==r&&e.prev_length<e.max_lazy_match&&e.strstart-r<=e.w_size-xn&&(e.match_length=Kn(e,r),e.match_length<=5&&(e.strategy===cn||e.match_length===En&&e.strstart-e.match_start>4096)&&(e.match_length=En-1)),e.prev_length>=En&&e.match_length<=e.prev_length){i=e.strstart+e.lookahead-En,n=qr(e,e.strstart-1-e.prev_match,e.prev_length-En),e.lookahead-=e.prev_length-1,e.prev_length-=2;do{++e.strstart<=i&&(e.ins_h=(e.ins_h<<e.hash_shift^e.window[e.strstart+En-1])&e.hash_mask,r=e.prev[e.strstart&e.w_mask]=e.head[e.ins_h],e.head[e.ins_h]=e.strstart)}while(0!=--e.prev_length);if(e.match_available=0,e.match_length=En-1,e.strstart++,n&&(jn(e,!1),0===e.strm.avail_out))return Dn}else if(e.match_available){if((n=qr(e,0,e.window[e.strstart-1]))&&jn(e,!1),e.strstart++,e.lookahead--,0===e.strm.avail_out)return Dn}else e.match_available=1,e.strstart++,e.lookahead--}return e.match_available&&(n=qr(e,0,e.window[e.strstart-1]),e.match_available=0),e.insert=e.strstart<En-1?e.strstart:En-1,t===rn?(jn(e,!0),0===e.strm.avail_out?Pn:On):e.last_lit&&(jn(e,!1),0===e.strm.avail_out)?Dn:In}function Gn(e,t,r,n,i){this.good_length=e,this.max_lazy=t,this.nice_length=r,this.max_chain=n,this.func=i}function $n(){this.strm=null,this.status=0,this.pending_buf=null,this.pending_buf_size=0,this.pending_out=0,this.pending=0,this.wrap=0,this.gzhead=null,this.gzindex=0,this.method=gn,this.last_flush=-1,this.w_size=0,this.w_bits=0,this.w_mask=0,this.window=null,this.window_size=0,this.prev=null,this.head=null,this.ins_h=0,this.hash_size=0,this.hash_bits=0,this.hash_mask=0,this.hash_shift=0,this.block_start=0,this.match_length=0,this.prev_match=0,this.match_available=0,this.strstart=0,this.match_start=0,this.lookahead=0,this.prev_length=0,this.max_chain_length=0,this.max_lazy_match=0,this.level=0,this.strategy=0,this.good_match=0,this.nice_match=0,this.dyn_ltree=new Yt(2*mn),this.dyn_dtree=new Yt(2*(2*bn+1)),this.bl_tree=new Yt(2*(2*yn+1)),Nn(this.dyn_ltree),Nn(this.dyn_dtree),Nn(this.bl_tree),this.l_desc=null,this.d_desc=null,this.bl_desc=null,this.bl_count=new Yt(kn+1),this.heap=new Yt(2*wn+1),Nn(this.heap),this.heap_len=0,this.heap_max=0,this.depth=new Yt(2*wn+1),Nn(this.depth),this.l_buf=0,this.lit_bufsize=0,this.last_lit=0,this.d_buf=0,this.opt_len=0,this.static_len=0,this.matches=0,this.insert=0,this.bi_buf=0,this.bi_valid=0}function Jn(e){var t,r=function(e){var t;return e&&e.state?(e.total_in=e.total_out=0,e.data_type=_n,(t=e.state).pending=0,t.pending_out=0,t.wrap<0&&(t.wrap=-t.wrap),t.status=t.wrap?An:Mn,e.adler=2===t.wrap?0:1,t.last_flush=Qr,Wr(t),on):Hn(e,sn)}(e);return r===on&&((t=e.state).window_size=2*t.w_size,Nn(t.head),t.max_lazy_match=Jr[t.level].max_lazy,t.good_match=Jr[t.level].good_length,t.nice_match=Jr[t.level].nice_length,t.max_chain_length=Jr[t.level].max_chain,t.strstart=0,t.block_start=0,t.lookahead=0,t.insert=0,t.match_length=t.prev_length=En-1,t.match_available=0,t.ins_h=0),r}function Qn(e,t){var r,n,i,o;if(!e||!e.state||t>nn||t<0)return e?Hn(e,sn):sn;if(n=e.state,!e.output||!e.input&&0!==e.avail_in||n.status===Cn&&t!==rn)return Hn(e,0===e.avail_out?ln:sn);if(n.strm=e,r=n.last_flush,n.last_flush=t,n.status===An)if(2===n.wrap)e.adler=0,Wn(n,31),Wn(n,139),Wn(n,8),n.gzhead?(Wn(n,(n.gzhead.text?1:0)+(n.gzhead.hcrc?2:0)+(n.gzhead.extra?4:0)+(n.gzhead.name?8:0)+(n.gzhead.comment?16:0)),Wn(n,255&n.gzhead.time),Wn(n,n.gzhead.time>>8&255),Wn(n,n.gzhead.time>>16&255),Wn(n,n.gzhead.time>>24&255),Wn(n,9===n.level?2:n.strategy>=un||n.level<2?4:0),Wn(n,255&n.gzhead.os),n.gzhead.extra&&n.gzhead.extra.length&&(Wn(n,255&n.gzhead.extra.length),Wn(n,n.gzhead.extra.length>>8&255)),n.gzhead.hcrc&&(e.adler=$r(e.adler,n.pending_buf,n.pending,0)),n.gzindex=0,n.status=Bn):(Wn(n,0),Wn(n,0),Wn(n,0),Wn(n,0),Wn(n,0),Wn(n,9===n.level?2:n.strategy>=un||n.level<2?4:0),Wn(n,Un),n.status=Mn);else{var a=gn+(n.w_bits-8<<4)<<8;a|=(n.strategy>=un||n.level<2?0:n.level<6?1:6===n.level?2:3)<<6,0!==n.strstart&&(a|=Rn),a+=31-a%31,n.status=Mn,Yn(n,a),0!==n.strstart&&(Yn(n,e.adler>>>16),Yn(n,65535&e.adler)),e.adler=1}if(n.status===Bn)if(n.gzhead.extra){for(i=n.pending;n.gzindex<(65535&n.gzhead.extra.length)&&(n.pending!==n.pending_buf_size||(n.gzhead.hcrc&&n.pending>i&&(e.adler=$r(e.adler,n.pending_buf,n.pending-i,i)),Zn(e),i=n.pending,n.pending!==n.pending_buf_size));)Wn(n,255&n.gzhead.extra[n.gzindex]),n.gzindex++;n.gzhead.hcrc&&n.pending>i&&(e.adler=$r(e.adler,n.pending_buf,n.pending-i,i)),n.gzindex===n.gzhead.extra.length&&(n.gzindex=0,n.status=zn)}else n.status=zn;if(n.status===zn)if(n.gzhead.name){i=n.pending;do{if(n.pending===n.pending_buf_size&&(n.gzhead.hcrc&&n.pending>i&&(e.adler=$r(e.adler,n.pending_buf,n.pending-i,i)),Zn(e),i=n.pending,n.pending===n.pending_buf_size)){o=1;break}o=n.gzindex<n.gzhead.name.length?255&n.gzhead.name.charCodeAt(n.gzindex++):0,Wn(n,o)}while(0!==o);n.gzhead.hcrc&&n.pending>i&&(e.adler=$r(e.adler,n.pending_buf,n.pending-i,i)),0===o&&(n.gzindex=0,n.status=Ln)}else n.status=Ln;if(n.status===Ln)if(n.gzhead.comment){i=n.pending;do{if(n.pending===n.pending_buf_size&&(n.gzhead.hcrc&&n.pending>i&&(e.adler=$r(e.adler,n.pending_buf,n.pending-i,i)),Zn(e),i=n.pending,n.pending===n.pending_buf_size)){o=1;break}o=n.gzindex<n.gzhead.comment.length?255&n.gzhead.comment.charCodeAt(n.gzindex++):0,Wn(n,o)}while(0!==o);n.gzhead.hcrc&&n.pending>i&&(e.adler=$r(e.adler,n.pending_buf,n.pending-i,i)),0===o&&(n.status=Tn)}else n.status=Tn;if(n.status===Tn&&(n.gzhead.hcrc?(n.pending+2>n.pending_buf_size&&Zn(e),n.pending+2<=n.pending_buf_size&&(Wn(n,255&e.adler),Wn(n,e.adler>>8&255),e.adler=0,n.status=Mn)):n.status=Mn),0!==n.pending){if(Zn(e),0===e.avail_out)return n.last_flush=-1,on}else if(0===e.avail_in&&Fn(t)<=Fn(r)&&t!==rn)return Hn(e,ln);if(n.status===Cn&&0!==e.avail_in)return Hn(e,ln);if(0!==e.avail_in||0!==n.lookahead||t!==Qr&&n.status!==Cn){var s=n.strategy===un?function(e,t){for(var r;;){if(0===e.lookahead&&(Xn(e),0===e.lookahead)){if(t===Qr)return Dn;break}if(e.match_length=0,r=qr(e,0,e.window[e.strstart]),e.lookahead--,e.strstart++,r&&(jn(e,!1),0===e.strm.avail_out))return Dn}return e.insert=0,t===rn?(jn(e,!0),0===e.strm.avail_out?Pn:On):e.last_lit&&(jn(e,!1),0===e.strm.avail_out)?Dn:In}(n,t):n.strategy===dn?function(e,t){for(var r,n,i,o,a=e.window;;){if(e.lookahead<=Sn){if(Xn(e),e.lookahead<=Sn&&t===Qr)return Dn;if(0===e.lookahead)break}if(e.match_length=0,e.lookahead>=En&&e.strstart>0&&(n=a[i=e.strstart-1])===a[++i]&&n===a[++i]&&n===a[++i]){o=e.strstart+Sn;do{}while(n===a[++i]&&n===a[++i]&&n===a[++i]&&n===a[++i]&&n===a[++i]&&n===a[++i]&&n===a[++i]&&n===a[++i]&&i<o);e.match_length=Sn-(o-i),e.match_length>e.lookahead&&(e.match_length=e.lookahead)}if(e.match_length>=En?(r=qr(e,1,e.match_length-En),e.lookahead-=e.match_length,e.strstart+=e.match_length,e.match_length=0):(r=qr(e,0,e.window[e.strstart]),e.lookahead--,e.strstart++),r&&(jn(e,!1),0===e.strm.avail_out))return Dn}return e.insert=0,t===rn?(jn(e,!0),0===e.strm.avail_out?Pn:On):e.last_lit&&(jn(e,!1),0===e.strm.avail_out)?Dn:In}(n,t):Jr[n.level].func(n,t);if(s!==Pn&&s!==On||(n.status=Cn),s===Dn||s===Pn)return 0===e.avail_out&&(n.last_flush=-1),on;if(s===In&&(t===en?Kr(n):t!==nn&&(Yr(n,0,0,!1),t===tn&&(Nn(n.head),0===n.lookahead&&(n.strstart=0,n.block_start=0,n.insert=0))),Zn(e),0===e.avail_out))return n.last_flush=-1,on}return t!==rn?on:n.wrap<=0?an:(2===n.wrap?(Wn(n,255&e.adler),Wn(n,e.adler>>8&255),Wn(n,e.adler>>16&255),Wn(n,e.adler>>24&255),Wn(n,255&e.total_in),Wn(n,e.total_in>>8&255),Wn(n,e.total_in>>16&255),Wn(n,e.total_in>>24&255)):(Yn(n,e.adler>>>16),Yn(n,65535&e.adler)),Zn(e),n.wrap>0&&(n.wrap=-n.wrap),0!==n.pending?on:an)}Jr=[new Gn(0,0,0,0,function(e,t){var r=65535;for(r>e.pending_buf_size-5&&(r=e.pending_buf_size-5);;){if(e.lookahead<=1){if(Xn(e),0===e.lookahead&&t===Qr)return Dn;if(0===e.lookahead)break}e.strstart+=e.lookahead,e.lookahead=0;var n=e.block_start+r;if((0===e.strstart||e.strstart>=n)&&(e.lookahead=e.strstart-n,e.strstart=n,jn(e,!1),0===e.strm.avail_out))return Dn;if(e.strstart-e.block_start>=e.w_size-xn&&(jn(e,!1),0===e.strm.avail_out))return Dn}return e.insert=0,t===rn?(jn(e,!0),0===e.strm.avail_out?Pn:On):(e.strstart>e.block_start&&(jn(e,!1),e.strm.avail_out),Dn)}),new Gn(4,4,8,4,qn),new Gn(4,5,16,8,qn),new Gn(4,6,32,32,qn),new Gn(4,4,16,16,Vn),new Gn(8,16,32,32,Vn),new Gn(8,16,128,128,Vn),new Gn(8,32,128,256,Vn),new Gn(32,128,258,1024,Vn),new Gn(32,258,258,4096,Vn)];var ei=30,ti=12;function ri(e,t){var r,n,i,o,a,s,h,l,f,c,u,d,p,_,g,v,w,b,y,m,k,E,S,x,R;r=e.state,n=e.next_in,x=e.input,i=n+(e.avail_in-5),o=e.next_out,R=e.output,a=o-(t-e.avail_out),s=o+(e.avail_out-257),h=r.dmax,l=r.wsize,f=r.whave,c=r.wnext,u=r.window,d=r.hold,p=r.bits,_=r.lencode,g=r.distcode,v=(1<<r.lenbits)-1,w=(1<<r.distbits)-1;e:do{p<15&&(d+=x[n++]<<p,p+=8,d+=x[n++]<<p,p+=8),b=_[d&v];t:for(;;){if(d>>>=y=b>>>24,p-=y,0===(y=b>>>16&255))R[o++]=65535&b;else{if(!(16&y)){if(0==(64&y)){b=_[(65535&b)+(d&(1<<y)-1)];continue t}if(32&y){r.mode=ti;break e}e.msg="invalid literal/length code",r.mode=ei;break e}m=65535&b,(y&=15)&&(p<y&&(d+=x[n++]<<p,p+=8),m+=d&(1<<y)-1,d>>>=y,p-=y),p<15&&(d+=x[n++]<<p,p+=8,d+=x[n++]<<p,p+=8),b=g[d&w];r:for(;;){if(d>>>=y=b>>>24,p-=y,!(16&(y=b>>>16&255))){if(0==(64&y)){b=g[(65535&b)+(d&(1<<y)-1)];continue r}e.msg="invalid distance code",r.mode=ei;break e}if(k=65535&b,p<(y&=15)&&(d+=x[n++]<<p,(p+=8)<y&&(d+=x[n++]<<p,p+=8)),(k+=d&(1<<y)-1)>h){e.msg="invalid distance too far back",r.mode=ei;break e}if(d>>>=y,p-=y,k>(y=o-a)){if((y=k-y)>f&&r.sane){e.msg="invalid distance too far back",r.mode=ei;break e}if(E=0,S=u,0===c){if(E+=l-y,y<m){m-=y;do{R[o++]=u[E++]}while(--y);E=o-k,S=R}}else if(c<y){if(E+=l+c-y,(y-=c)<m){m-=y;do{R[o++]=u[E++]}while(--y);if(E=0,c<m){m-=y=c;do{R[o++]=u[E++]}while(--y);E=o-k,S=R}}}else if(E+=c-y,y<m){m-=y;do{R[o++]=u[E++]}while(--y);E=o-k,S=R}for(;m>2;)R[o++]=S[E++],R[o++]=S[E++],R[o++]=S[E++],m-=3;m&&(R[o++]=S[E++],m>1&&(R[o++]=S[E++]))}else{E=o-k;do{R[o++]=R[E++],R[o++]=R[E++],R[o++]=R[E++],m-=3}while(m>2);m&&(R[o++]=R[E++],m>1&&(R[o++]=R[E++]))}break}}break}}while(n<i&&o<s);n-=m=p>>3,d&=(1<<(p-=m<<3))-1,e.next_in=n,e.next_out=o,e.avail_in=n<i?i-n+5:5-(n-i),e.avail_out=o<s?s-o+257:257-(o-s),r.hold=d,r.bits=p}var ni=15,ii=852,oi=592,ai=0,si=1,hi=2,li=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0],fi=[16,16,16,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,16,72,78],ci=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0],ui=[16,16,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,64,64];function di(e,t,r,n,i,o,a,s){var h,l,f,c,u,d,p,_,g,v=s.bits,w=0,b=0,y=0,m=0,k=0,E=0,S=0,x=0,R=0,A=0,B=null,z=0,L=new Yt(ni+1),T=new Yt(ni+1),M=null,C=0;for(w=0;w<=ni;w++)L[w]=0;for(b=0;b<n;b++)L[t[r+b]]++;for(k=v,m=ni;m>=1&&0===L[m];m--);if(k>m&&(k=m),0===m)return i[o++]=20971520,i[o++]=20971520,s.bits=1,0;for(y=1;y<m&&0===L[y];y++);for(k<y&&(k=y),x=1,w=1;w<=ni;w++)if(x<<=1,(x-=L[w])<0)return-1;if(x>0&&(e===ai||1!==m))return-1;for(T[1]=0,w=1;w<ni;w++)T[w+1]=T[w]+L[w];for(b=0;b<n;b++)0!==t[r+b]&&(a[T[t[r+b]]++]=b);if(e===ai?(B=M=a,d=19):e===si?(B=li,z-=257,M=fi,C-=257,d=256):(B=ci,M=ui,d=-1),A=0,b=0,w=y,u=o,E=k,S=0,f=-1,c=(R=1<<k)-1,e===si&&R>ii||e===hi&&R>oi)return 1;for(;;){p=w-S,a[b]<d?(_=0,g=a[b]):a[b]>d?(_=M[C+a[b]],g=B[z+a[b]]):(_=96,g=0),h=1<<w-S,y=l=1<<E;do{i[u+(A>>S)+(l-=h)]=p<<24|_<<16|g|0}while(0!==l);for(h=1<<w-1;A&h;)h>>=1;if(0!==h?(A&=h-1,A+=h):A=0,b++,0==--L[w]){if(w===m)break;w=t[r+a[b]]}if(w>k&&(A&c)!==f){for(0===S&&(S=k),u+=y,x=1<<(E=w-S);E+S<m&&!((x-=L[E+S])<=0);)E++,x<<=1;if(R+=1<<E,e===si&&R>ii||e===hi&&R>oi)return 1;i[f=A&c]=k<<24|E<<16|u-o|0}}return 0!==A&&(i[u+A]=w-S<<24|64<<16|0),s.bits=k,0}var pi=0,_i=1,gi=2,vi=4,wi=5,bi=6,yi=0,mi=1,ki=2,Ei=-2,Si=-3,xi=-4,Ri=-5,Ai=8,Bi=1,zi=2,Li=3,Ti=4,Mi=5,Ci=6,Di=7,Ii=8,Pi=9,Oi=10,Ui=11,Hi=12,Fi=13,Ni=14,Zi=15,ji=16,Wi=17,Yi=18,Ki=19,Xi=20,qi=21,Vi=22,Gi=23,$i=24,Ji=25,Qi=26,eo=27,to=28,ro=29,no=30,io=31,oo=32,ao=852,so=592;function ho(e){return(e>>>24&255)+(e>>>8&65280)+((65280&e)<<8)+((255&e)<<24)}function lo(){this.mode=0,this.last=!1,this.wrap=0,this.havedict=!1,this.flags=0,this.dmax=0,this.check=0,this.total=0,this.head=null,this.wbits=0,this.wsize=0,this.whave=0,this.wnext=0,this.window=null,this.hold=0,this.bits=0,this.length=0,this.offset=0,this.extra=0,this.lencode=null,this.distcode=null,this.lenbits=0,this.distbits=0,this.ncode=0,this.nlen=0,this.ndist=0,this.have=0,this.next=null,this.lens=new Yt(320),this.work=new Yt(288),this.lendyn=null,this.distdyn=null,this.sane=0,this.back=0,this.was=0}function fo(e){var t;return e&&e.state?((t=e.state).wsize=0,t.whave=0,t.wnext=0,function(e){var t;return e&&e.state?(t=e.state,e.total_in=e.total_out=t.total=0,e.msg="",t.wrap&&(e.adler=1&t.wrap),t.mode=Bi,t.last=0,t.havedict=0,t.dmax=32768,t.head=null,t.hold=0,t.bits=0,t.lencode=t.lendyn=new Kt(ao),t.distcode=t.distdyn=new Kt(so),t.sane=1,t.back=-1,yi):Ei}(e)):Ei}function co(e,t){var r,n;return e?(n=new lo,e.state=n,n.window=null,(r=function(e,t){var r,n;return e&&e.state?(n=e.state,t<0?(r=0,t=-t):(r=1+(t>>4),t<48&&(t&=15)),t&&(t<8||t>15)?Ei:(null!==n.window&&n.wbits!==t&&(n.window=null),n.wrap=r,n.wbits=t,fo(e))):Ei}(e,t))!==yi&&(e.state=null),r):Ei}var uo,po,_o=!0;function go(e){if(_o){var t;for(uo=new Kt(512),po=new Kt(32),t=0;t<144;)e.lens[t++]=8;for(;t<256;)e.lens[t++]=9;for(;t<280;)e.lens[t++]=7;for(;t<288;)e.lens[t++]=8;for(di(_i,e.lens,0,288,uo,0,e.work,{bits:9}),t=0;t<32;)e.lens[t++]=5;di(gi,e.lens,0,32,po,0,e.work,{bits:5}),_o=!1}e.lencode=uo,e.lenbits=9,e.distcode=po,e.distbits=5}function vo(e,t){var r,n,i,o,a,s,h,l,f,c,u,d,p,_,g,v,w,b,y,m,k,E,S,x,R=0,A=new Wt(4),B=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];if(!e||!e.state||!e.output||!e.input&&0!==e.avail_in)return Ei;(r=e.state).mode===Hi&&(r.mode=Fi),a=e.next_out,i=e.output,h=e.avail_out,o=e.next_in,n=e.input,s=e.avail_in,l=r.hold,f=r.bits,c=s,u=h,E=yi;e:for(;;)switch(r.mode){case Bi:if(0===r.wrap){r.mode=Fi;break}for(;f<16;){if(0===s)break e;s--,l+=n[o++]<<f,f+=8}if(2&r.wrap&&35615===l){r.check=0,A[0]=255&l,A[1]=l>>>8&255,r.check=$r(r.check,A,2,0),l=0,f=0,r.mode=zi;break}if(r.flags=0,r.head&&(r.head.done=!1),!(1&r.wrap)||(((255&l)<<8)+(l>>8))%31){e.msg="incorrect header check",r.mode=no;break}if((15&l)!==Ai){e.msg="unknown compression method",r.mode=no;break}if(f-=4,k=8+(15&(l>>>=4)),0===r.wbits)r.wbits=k;else if(k>r.wbits){e.msg="invalid window size",r.mode=no;break}r.dmax=1<<k,e.adler=r.check=1,r.mode=512&l?Oi:Hi,l=0,f=0;break;case zi:for(;f<16;){if(0===s)break e;s--,l+=n[o++]<<f,f+=8}if(r.flags=l,(255&r.flags)!==Ai){e.msg="unknown compression method",r.mode=no;break}if(57344&r.flags){e.msg="unknown header flags set",r.mode=no;break}r.head&&(r.head.text=l>>8&1),512&r.flags&&(A[0]=255&l,A[1]=l>>>8&255,r.check=$r(r.check,A,2,0)),l=0,f=0,r.mode=Li;case Li:for(;f<32;){if(0===s)break e;s--,l+=n[o++]<<f,f+=8}r.head&&(r.head.time=l),512&r.flags&&(A[0]=255&l,A[1]=l>>>8&255,A[2]=l>>>16&255,A[3]=l>>>24&255,r.check=$r(r.check,A,4,0)),l=0,f=0,r.mode=Ti;case Ti:for(;f<16;){if(0===s)break e;s--,l+=n[o++]<<f,f+=8}r.head&&(r.head.xflags=255&l,r.head.os=l>>8),512&r.flags&&(A[0]=255&l,A[1]=l>>>8&255,r.check=$r(r.check,A,2,0)),l=0,f=0,r.mode=Mi;case Mi:if(1024&r.flags){for(;f<16;){if(0===s)break e;s--,l+=n[o++]<<f,f+=8}r.length=l,r.head&&(r.head.extra_len=l),512&r.flags&&(A[0]=255&l,A[1]=l>>>8&255,r.check=$r(r.check,A,2,0)),l=0,f=0}else r.head&&(r.head.extra=null);r.mode=Ci;case Ci:if(1024&r.flags&&((d=r.length)>s&&(d=s),d&&(r.head&&(k=r.head.extra_len-r.length,r.head.extra||(r.head.extra=new Array(r.head.extra_len)),jt(r.head.extra,n,o,d,k)),512&r.flags&&(r.check=$r(r.check,n,d,o)),s-=d,o+=d,r.length-=d),r.length))break e;r.length=0,r.mode=Di;case Di:if(2048&r.flags){if(0===s)break e;d=0;do{k=n[o+d++],r.head&&k&&r.length<65536&&(r.head.name+=String.fromCharCode(k))}while(k&&d<s);if(512&r.flags&&(r.check=$r(r.check,n,d,o)),s-=d,o+=d,k)break e}else r.head&&(r.head.name=null);r.length=0,r.mode=Ii;case Ii:if(4096&r.flags){if(0===s)break e;d=0;do{k=n[o+d++],r.head&&k&&r.length<65536&&(r.head.comment+=String.fromCharCode(k))}while(k&&d<s);if(512&r.flags&&(r.check=$r(r.check,n,d,o)),s-=d,o+=d,k)break e}else r.head&&(r.head.comment=null);r.mode=Pi;case Pi:if(512&r.flags){for(;f<16;){if(0===s)break e;s--,l+=n[o++]<<f,f+=8}if(l!==(65535&r.check)){e.msg="header crc mismatch",r.mode=no;break}l=0,f=0}r.head&&(r.head.hcrc=r.flags>>9&1,r.head.done=!0),e.adler=r.check=0,r.mode=Hi;break;case Oi:for(;f<32;){if(0===s)break e;s--,l+=n[o++]<<f,f+=8}e.adler=r.check=ho(l),l=0,f=0,r.mode=Ui;case Ui:if(0===r.havedict)return e.next_out=a,e.avail_out=h,e.next_in=o,e.avail_in=s,r.hold=l,r.bits=f,ki;e.adler=r.check=1,r.mode=Hi;case Hi:if(t===wi||t===bi)break e;case Fi:if(r.last){l>>>=7&f,f-=7&f,r.mode=eo;break}for(;f<3;){if(0===s)break e;s--,l+=n[o++]<<f,f+=8}switch(r.last=1&l,f-=1,3&(l>>>=1)){case 0:r.mode=Ni;break;case 1:if(go(r),r.mode=Xi,t===bi){l>>>=2,f-=2;break e}break;case 2:r.mode=Wi;break;case 3:e.msg="invalid block type",r.mode=no}l>>>=2,f-=2;break;case Ni:for(l>>>=7&f,f-=7&f;f<32;){if(0===s)break e;s--,l+=n[o++]<<f,f+=8}if((65535&l)!=(l>>>16^65535)){e.msg="invalid stored block lengths",r.mode=no;break}if(r.length=65535&l,l=0,f=0,r.mode=Zi,t===bi)break e;case Zi:r.mode=ji;case ji:if(d=r.length){if(d>s&&(d=s),d>h&&(d=h),0===d)break e;jt(i,n,o,d,a),s-=d,o+=d,h-=d,a+=d,r.length-=d;break}r.mode=Hi;break;case Wi:for(;f<14;){if(0===s)break e;s--,l+=n[o++]<<f,f+=8}if(r.nlen=257+(31&l),l>>>=5,f-=5,r.ndist=1+(31&l),l>>>=5,f-=5,r.ncode=4+(15&l),l>>>=4,f-=4,r.nlen>286||r.ndist>30){e.msg="too many length or distance symbols",r.mode=no;break}r.have=0,r.mode=Yi;case Yi:for(;r.have<r.ncode;){for(;f<3;){if(0===s)break e;s--,l+=n[o++]<<f,f+=8}r.lens[B[r.have++]]=7&l,l>>>=3,f-=3}for(;r.have<19;)r.lens[B[r.have++]]=0;if(r.lencode=r.lendyn,r.lenbits=7,S={bits:r.lenbits},E=di(pi,r.lens,0,19,r.lencode,0,r.work,S),r.lenbits=S.bits,E){e.msg="invalid code lengths set",r.mode=no;break}r.have=0,r.mode=Ki;case Ki:for(;r.have<r.nlen+r.ndist;){for(;v=(R=r.lencode[l&(1<<r.lenbits)-1])>>>16&255,w=65535&R,!((g=R>>>24)<=f);){if(0===s)break e;s--,l+=n[o++]<<f,f+=8}if(w<16)l>>>=g,f-=g,r.lens[r.have++]=w;else{if(16===w){for(x=g+2;f<x;){if(0===s)break e;s--,l+=n[o++]<<f,f+=8}if(l>>>=g,f-=g,0===r.have){e.msg="invalid bit length repeat",r.mode=no;break}k=r.lens[r.have-1],d=3+(3&l),l>>>=2,f-=2}else if(17===w){for(x=g+3;f<x;){if(0===s)break e;s--,l+=n[o++]<<f,f+=8}f-=g,k=0,d=3+(7&(l>>>=g)),l>>>=3,f-=3}else{for(x=g+7;f<x;){if(0===s)break e;s--,l+=n[o++]<<f,f+=8}f-=g,k=0,d=11+(127&(l>>>=g)),l>>>=7,f-=7}if(r.have+d>r.nlen+r.ndist){e.msg="invalid bit length repeat",r.mode=no;break}for(;d--;)r.lens[r.have++]=k}}if(r.mode===no)break;if(0===r.lens[256]){e.msg="invalid code -- missing end-of-block",r.mode=no;break}if(r.lenbits=9,S={bits:r.lenbits},E=di(_i,r.lens,0,r.nlen,r.lencode,0,r.work,S),r.lenbits=S.bits,E){e.msg="invalid literal/lengths set",r.mode=no;break}if(r.distbits=6,r.distcode=r.distdyn,S={bits:r.distbits},E=di(gi,r.lens,r.nlen,r.ndist,r.distcode,0,r.work,S),r.distbits=S.bits,E){e.msg="invalid distances set",r.mode=no;break}if(r.mode=Xi,t===bi)break e;case Xi:r.mode=qi;case qi:if(s>=6&&h>=258){e.next_out=a,e.avail_out=h,e.next_in=o,e.avail_in=s,r.hold=l,r.bits=f,ri(e,u),a=e.next_out,i=e.output,h=e.avail_out,o=e.next_in,n=e.input,s=e.avail_in,l=r.hold,f=r.bits,r.mode===Hi&&(r.back=-1);break}for(r.back=0;v=(R=r.lencode[l&(1<<r.lenbits)-1])>>>16&255,w=65535&R,!((g=R>>>24)<=f);){if(0===s)break e;s--,l+=n[o++]<<f,f+=8}if(v&&0==(240&v)){for(b=g,y=v,m=w;v=(R=r.lencode[m+((l&(1<<b+y)-1)>>b)])>>>16&255,w=65535&R,!(b+(g=R>>>24)<=f);){if(0===s)break e;s--,l+=n[o++]<<f,f+=8}l>>>=b,f-=b,r.back+=b}if(l>>>=g,f-=g,r.back+=g,r.length=w,0===v){r.mode=Qi;break}if(32&v){r.back=-1,r.mode=Hi;break}if(64&v){e.msg="invalid literal/length code",r.mode=no;break}r.extra=15&v,r.mode=Vi;case Vi:if(r.extra){for(x=r.extra;f<x;){if(0===s)break e;s--,l+=n[o++]<<f,f+=8}r.length+=l&(1<<r.extra)-1,l>>>=r.extra,f-=r.extra,r.back+=r.extra}r.was=r.length,r.mode=Gi;case Gi:for(;v=(R=r.distcode[l&(1<<r.distbits)-1])>>>16&255,w=65535&R,!((g=R>>>24)<=f);){if(0===s)break e;s--,l+=n[o++]<<f,f+=8}if(0==(240&v)){for(b=g,y=v,m=w;v=(R=r.distcode[m+((l&(1<<b+y)-1)>>b)])>>>16&255,w=65535&R,!(b+(g=R>>>24)<=f);){if(0===s)break e;s--,l+=n[o++]<<f,f+=8}l>>>=b,f-=b,r.back+=b}if(l>>>=g,f-=g,r.back+=g,64&v){e.msg="invalid distance code",r.mode=no;break}r.offset=w,r.extra=15&v,r.mode=$i;case $i:if(r.extra){for(x=r.extra;f<x;){if(0===s)break e;s--,l+=n[o++]<<f,f+=8}r.offset+=l&(1<<r.extra)-1,l>>>=r.extra,f-=r.extra,r.back+=r.extra}if(r.offset>r.dmax){e.msg="invalid distance too far back",r.mode=no;break}r.mode=Ji;case Ji:if(0===h)break e;if(d=u-h,r.offset>d){if((d=r.offset-d)>r.whave&&r.sane){e.msg="invalid distance too far back",r.mode=no;break}d>r.wnext?(d-=r.wnext,p=r.wsize-d):p=r.wnext-d,d>r.length&&(d=r.length),_=r.window}else _=i,p=a-r.offset,d=r.length;d>h&&(d=h),h-=d,r.length-=d;do{i[a++]=_[p++]}while(--d);0===r.length&&(r.mode=qi);break;case Qi:if(0===h)break e;i[a++]=r.length,h--,r.mode=qi;break;case eo:if(r.wrap){for(;f<32;){if(0===s)break e;s--,l|=n[o++]<<f,f+=8}if(u-=h,e.total_out+=u,r.total+=u,u&&(e.adler=r.check=r.flags?$r(r.check,i,u,a-u):Vr(r.check,i,u,a-u)),u=h,(r.flags?l:ho(l))!==r.check){e.msg="incorrect data check",r.mode=no;break}l=0,f=0}r.mode=to;case to:if(r.wrap&&r.flags){for(;f<32;){if(0===s)break e;s--,l+=n[o++]<<f,f+=8}if(l!==(4294967295&r.total)){e.msg="incorrect length check",r.mode=no;break}l=0,f=0}r.mode=ro;case ro:E=mi;break e;case no:E=Si;break e;case io:return xi;case oo:default:return Ei}return e.next_out=a,e.avail_out=h,e.next_in=o,e.avail_in=s,r.hold=l,r.bits=f,(r.wsize||u!==e.avail_out&&r.mode<no&&(r.mode<eo||t!==vi))&&function(e,t,r,n){var i,o=e.state;null===o.window&&(o.wsize=1<<o.wbits,o.wnext=0,o.whave=0,o.window=new Wt(o.wsize)),n>=o.wsize?(jt(o.window,t,r-o.wsize,o.wsize,0),o.wnext=0,o.whave=o.wsize):((i=o.wsize-o.wnext)>n&&(i=n),jt(o.window,t,r-n,i,o.wnext),(n-=i)?(jt(o.window,t,r-n,n,0),o.wnext=n,o.whave=o.wsize):(o.wnext+=i,o.wnext===o.wsize&&(o.wnext=0),o.whave<o.wsize&&(o.whave+=i)))}(e,e.output,e.next_out,u-e.avail_out),c-=e.avail_in,u-=e.avail_out,e.total_in+=c,e.total_out+=u,r.total+=u,r.wrap&&u&&(e.adler=r.check=r.flags?$r(r.check,i,u,e.next_out-u):Vr(r.check,i,u,e.next_out-u)),e.data_type=r.bits+(r.last?64:0)+(r.mode===Hi?128:0)+(r.mode===Xi||r.mode===Zi?256:0),(0===c&&0===u||t===vi)&&E===yi&&(E=Ri),E}var wo,bo=1,yo=7;function mo(e){if(e<bo||e>yo)throw new TypeError("Bad argument");this.mode=e,this.init_done=!1,this.write_in_progress=!1,this.pending_close=!1,this.windowBits=0,this.level=0,this.memLevel=0,this.strategy=0,this.dictionary=null}function ko(e,t){for(var r=0;r<e.length;r++)this[t+r]=e[r]}mo.prototype.init=function(e,t,r,n,i){var o;switch(this.windowBits=e,this.level=t,this.memLevel=r,this.strategy=n,3!==this.mode&&4!==this.mode||(this.windowBits+=16),this.mode===yo&&(this.windowBits+=32),5!==this.mode&&6!==this.mode||(this.windowBits=-this.windowBits),this.strm=new Zt,this.mode){case bo:case 3:case 5:o=function(e,t,r,n,i,o){if(!e)return sn;var a=1;if(t===fn&&(t=6),n<0?(a=0,n=-n):n>15&&(a=2,n-=16),i<1||i>vn||r!==gn||n<8||n>15||t<0||t>9||o<0||o>pn)return Hn(e,sn);8===n&&(n=9);var s=new $n;return e.state=s,s.strm=e,s.wrap=a,s.gzhead=null,s.w_bits=n,s.w_size=1<<s.w_bits,s.w_mask=s.w_size-1,s.hash_bits=i+7,s.hash_size=1<<s.hash_bits,s.hash_mask=s.hash_size-1,s.hash_shift=~~((s.hash_bits+En-1)/En),s.window=new Wt(2*s.w_size),s.head=new Yt(s.hash_size),s.prev=new Yt(s.w_size),s.lit_bufsize=1<<i+6,s.pending_buf_size=4*s.lit_bufsize,s.pending_buf=new Wt(s.pending_buf_size),s.d_buf=1*s.lit_bufsize,s.l_buf=3*s.lit_bufsize,s.level=t,s.strategy=o,s.method=r,Jn(e)}(this.strm,this.level,8,this.windowBits,this.memLevel,this.strategy);break;case 2:case 4:case 6:case yo:o=co(this.strm,this.windowBits);break;default:throw new Error("Unknown mode "+this.mode)}0===o?(this.write_in_progress=!1,this.init_done=!0):this._error(o)},mo.prototype.params=function(){throw new Error("deflateParams Not supported")},mo.prototype._writeCheck=function(){if(!this.init_done)throw new Error("write before init");if(0===this.mode)throw new Error("already finalized");if(this.write_in_progress)throw new Error("write already in progress");if(this.pending_close)throw new Error("close is pending")},mo.prototype.write=function(e,t,r,n,i,o,a){this._writeCheck(),this.write_in_progress=!0;var s=this;return de(function(){s.write_in_progress=!1;var h=s._write(e,t,r,n,i,o,a);s.callback(h[0],h[1]),s.pending_close&&s.close()}),this},mo.prototype.writeSync=function(e,t,r,n,i,o,a){return this._writeCheck(),this._write(e,t,r,n,i,o,a)},mo.prototype._write=function(e,t,r,n,i,o,a){if(this.write_in_progress=!0,0!==e&&1!==e&&2!==e&&3!==e&&4!==e&&5!==e)throw new Error("Invalid flush value");null==t&&(t=new p(0),n=0,r=0),i._set?i.set=i._set:i.set=ko;var s,h=this.strm;switch(h.avail_in=n,h.input=t,h.next_in=r,h.avail_out=a,h.output=i,h.next_out=o,this.mode){case bo:case 3:case 5:s=Qn(h,e);break;case yo:case 2:case 4:case 6:s=vo(h,e);break;default:throw new Error("Unknown mode "+this.mode)}return 1!==s&&0!==s&&this._error(s),this.write_in_progress=!1,[h.avail_in,h.avail_out]},mo.prototype.close=function(){this.write_in_progress?this.pending_close=!0:(this.pending_close=!1,this.mode===bo||3===this.mode||5===this.mode?function(e){var t;e&&e.state&&((t=e.state.status)!==An&&t!==Bn&&t!==zn&&t!==Ln&&t!==Tn&&t!==Mn&&t!==Cn?Hn(e,sn):(e.state=null,t===Mn&&Hn(e,hn)))}(this.strm):function(e){if(!e||!e.state)return Ei;var t=e.state;t.window&&(t.window=null),e.state=null}(this.strm),this.mode=0)},mo.prototype.reset=function(){switch(this.mode){case bo:case 5:wo=Jn(this.strm);break;case 2:case 6:wo=fo(this.strm)}0!==wo&&this._error(wo)},mo.prototype._error=function(e){this.onerror(Nt[e]+": "+this.strm.msg,e),this.write_in_progress=!1,this.pending_close&&this.close()};var Eo=Object.freeze({NONE:0,DEFLATE:bo,INFLATE:2,GZIP:3,GUNZIP:4,DEFLATERAW:5,INFLATERAW:6,UNZIP:yo,Z_NO_FLUSH:0,Z_PARTIAL_FLUSH:1,Z_SYNC_FLUSH:2,Z_FULL_FLUSH:3,Z_FINISH:4,Z_BLOCK:5,Z_TREES:6,Z_OK:0,Z_STREAM_END:1,Z_NEED_DICT:2,Z_ERRNO:-1,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_BUF_ERROR:-5,Z_NO_COMPRESSION:0,Z_BEST_SPEED:1,Z_BEST_COMPRESSION:9,Z_DEFAULT_COMPRESSION:-1,Z_FILTERED:1,Z_HUFFMAN_ONLY:2,Z_RLE:3,Z_FIXED:4,Z_DEFAULT_STRATEGY:0,Z_BINARY:0,Z_TEXT:1,Z_UNKNOWN:2,Z_DEFLATED:8,Zlib:mo});var So={};Object.keys(Eo).forEach(function(e){So[e]=Eo[e]}),So.Z_MIN_WINDOWBITS=8,So.Z_MAX_WINDOWBITS=15,So.Z_DEFAULT_WINDOWBITS=15,So.Z_MIN_CHUNK=64,So.Z_MAX_CHUNK=1/0,So.Z_DEFAULT_CHUNK=16384,So.Z_MIN_MEMLEVEL=1,So.Z_MAX_MEMLEVEL=9,So.Z_DEFAULT_MEMLEVEL=8,So.Z_MIN_LEVEL=-1,So.Z_MAX_LEVEL=9,So.Z_DEFAULT_LEVEL=So.Z_DEFAULT_COMPRESSION;var xo={Z_OK:So.Z_OK,Z_STREAM_END:So.Z_STREAM_END,Z_NEED_DICT:So.Z_NEED_DICT,Z_ERRNO:So.Z_ERRNO,Z_STREAM_ERROR:So.Z_STREAM_ERROR,Z_DATA_ERROR:So.Z_DATA_ERROR,Z_MEM_ERROR:So.Z_MEM_ERROR,Z_BUF_ERROR:So.Z_BUF_ERROR,Z_VERSION_ERROR:So.Z_VERSION_ERROR};function Ro(e,t,r){var n=[],i=0;function o(){for(var t;null!==(t=e.read());)n.push(t),i+=t.length;e.once("readable",o)}function a(){var t=p.concat(n,i);n=[],r(null,t),e.close()}e.on("error",function(t){e.removeListener("end",a),e.removeListener("readable",o),r(t)}),e.on("end",a),e.end(t),o()}function Ao(e,t){if("string"==typeof t&&(t=new p(t)),!$(t))throw new TypeError("Not a string or buffer");var r=So.Z_FINISH;return e._processChunk(t,r)}function Bo(e){if(!(this instanceof Bo))return new Bo(e);Io.call(this,e,So.DEFLATE)}function zo(e){if(!(this instanceof zo))return new zo(e);Io.call(this,e,So.INFLATE)}function Lo(e){if(!(this instanceof Lo))return new Lo(e);Io.call(this,e,So.GZIP)}function To(e){if(!(this instanceof To))return new To(e);Io.call(this,e,So.GUNZIP)}function Mo(e){if(!(this instanceof Mo))return new Mo(e);Io.call(this,e,So.DEFLATERAW)}function Co(e){if(!(this instanceof Co))return new Co(e);Io.call(this,e,So.INFLATERAW)}function Do(e){if(!(this instanceof Do))return new Do(e);Io.call(this,e,So.UNZIP)}function Io(e,t){if(this._opts=e=e||{},this._chunkSize=e.chunkSize||So.Z_DEFAULT_CHUNK,Ot.call(this,e),e.flush&&e.flush!==So.Z_NO_FLUSH&&e.flush!==So.Z_PARTIAL_FLUSH&&e.flush!==So.Z_SYNC_FLUSH&&e.flush!==So.Z_FULL_FLUSH&&e.flush!==So.Z_FINISH&&e.flush!==So.Z_BLOCK)throw new Error("Invalid flush flag: "+e.flush);if(this._flushFlag=e.flush||So.Z_NO_FLUSH,e.chunkSize&&(e.chunkSize<So.Z_MIN_CHUNK||e.chunkSize>So.Z_MAX_CHUNK))throw new Error("Invalid chunk size: "+e.chunkSize);if(e.windowBits&&(e.windowBits<So.Z_MIN_WINDOWBITS||e.windowBits>So.Z_MAX_WINDOWBITS))throw new Error("Invalid windowBits: "+e.windowBits);if(e.level&&(e.level<So.Z_MIN_LEVEL||e.level>So.Z_MAX_LEVEL))throw new Error("Invalid compression level: "+e.level);if(e.memLevel&&(e.memLevel<So.Z_MIN_MEMLEVEL||e.memLevel>So.Z_MAX_MEMLEVEL))throw new Error("Invalid memLevel: "+e.memLevel);if(e.strategy&&e.strategy!=So.Z_FILTERED&&e.strategy!=So.Z_HUFFMAN_ONLY&&e.strategy!=So.Z_RLE&&e.strategy!=So.Z_FIXED&&e.strategy!=So.Z_DEFAULT_STRATEGY)throw new Error("Invalid strategy: "+e.strategy);if(e.dictionary&&!$(e.dictionary))throw new Error("Invalid dictionary: it should be a Buffer instance");this._binding=new So.Zlib(t);var r=this;this._hadError=!1,this._binding.onerror=function(e,t){r._binding=null,r._hadError=!0;var n=new Error(e);n.errno=t,n.code=So.codes[t],r.emit("error",n)};var n=So.Z_DEFAULT_COMPRESSION;"number"==typeof e.level&&(n=e.level);var i=So.Z_DEFAULT_STRATEGY;"number"==typeof e.strategy&&(i=e.strategy),this._binding.init(e.windowBits||So.Z_DEFAULT_WINDOWBITS,n,e.memLevel||So.Z_DEFAULT_MEMLEVEL,i,e.dictionary),this._buffer=new p(this._chunkSize),this._offset=0,this._closed=!1,this._level=n,this._strategy=i,this.once("end",this.close)}Object.keys(xo).forEach(function(e){xo[xo[e]]=e}),Be(Io,Ot),Io.prototype.params=function(e,t,r){if(e<So.Z_MIN_LEVEL||e>So.Z_MAX_LEVEL)throw new RangeError("Invalid compression level: "+e);if(t!=So.Z_FILTERED&&t!=So.Z_HUFFMAN_ONLY&&t!=So.Z_RLE&&t!=So.Z_FIXED&&t!=So.Z_DEFAULT_STRATEGY)throw new TypeError("Invalid strategy: "+t);if(this._level!==e||this._strategy!==t){var n=this;this.flush(So.Z_SYNC_FLUSH,function(){n._binding.params(e,t),n._hadError||(n._level=e,n._strategy=t,r&&r())})}else de(r)},Io.prototype.reset=function(){return this._binding.reset()},Io.prototype._flush=function(e){this._transform(new p(0),"",e)},Io.prototype.flush=function(e,t){var r=this._writableState;if(("function"==typeof e||void 0===e&&!t)&&(t=e,e=So.Z_FULL_FLUSH),r.ended)t&&de(t);else if(r.ending)t&&this.once("end",t);else if(r.needDrain){var n=this;this.once("drain",function(){n.flush(t)})}else this._flushFlag=e,this.write(new p(0),"",t)},Io.prototype.close=function(e){if(e&&de(e),!this._closed){this._closed=!0,this._binding.close();var t=this;de(function(){t.emit("close")})}},Io.prototype._transform=function(e,t,r){var n,i=this._writableState,o=(i.ending||i.ended)&&(!e||i.length===e.length);if(null===!e&&!$(e))return r(new Error("invalid input"));o?n=So.Z_FINISH:(n=this._flushFlag,e.length>=i.length&&(this._flushFlag=this._opts.flush||So.Z_NO_FLUSH)),this._processChunk(e,n,r)},Io.prototype._processChunk=function(e,t,r){var n=e&&e.length,i=this._chunkSize-this._offset,o=0,a=this,s="function"==typeof r;if(!s){var h,l=[],f=0;this.on("error",function(e){h=e});do{var c=this._binding.writeSync(t,e,o,n,this._buffer,this._offset,i)}while(!this._hadError&&_(c[0],c[1]));if(this._hadError)throw h;var u=p.concat(l,f);return this.close(),u}var d=this._binding.write(t,e,o,n,this._buffer,this._offset,i);function _(h,c){if(!a._hadError){var u=i-c;if(function(e,t){if(!e)throw new Error(t)}(u>=0,"have should not go down"),u>0){var d=a._buffer.slice(a._offset,a._offset+u);a._offset+=u,s?a.push(d):(l.push(d),f+=d.length)}if((0===c||a._offset>=a._chunkSize)&&(i=a._chunkSize,a._offset=0,a._buffer=new p(a._chunkSize)),0===c){if(o+=n-h,n=h,!s)return!0;var g=a._binding.write(t,e,o,n,a._buffer,a._offset,a._chunkSize);return g.callback=_,void(g.buffer=e)}if(!s)return!1;r()}}d.buffer=e,d.callback=_},Be(Bo,Io),Be(zo,Io),Be(Lo,Io),Be(To,Io),Be(Mo,Io),Be(Co,Io),Be(Do,Io);var Po={codes:xo,createDeflate:function(e){return new Bo(e)},createInflate:function(e){return new zo(e)},createDeflateRaw:function(e){return new Mo(e)},createInflateRaw:function(e){return new Co(e)},createGzip:function(e){return new Lo(e)},createGunzip:function(e){return new To(e)},createUnzip:function(e){return new Do(e)},deflate:function(e,t,r){return"function"==typeof t&&(r=t,t={}),Ro(new Bo(t),e,r)},deflateSync:function(e,t){return Ao(new Bo(t),e)},gzip:function(e,t,r){return"function"==typeof t&&(r=t,t={}),Ro(new Lo(t),e,r)},gzipSync:function(e,t){return Ao(new Lo(t),e)},deflateRaw:function(e,t,r){return"function"==typeof t&&(r=t,t={}),Ro(new Mo(t),e,r)},deflateRawSync:function(e,t){return Ao(new Mo(t),e)},unzip:function(e,t,r){return"function"==typeof t&&(r=t,t={}),Ro(new Do(t),e,r)},unzipSync:function(e,t){return Ao(new Do(t),e)},inflate:function(e,t,r){return"function"==typeof t&&(r=t,t={}),Ro(new zo(t),e,r)},inflateSync:function(e,t){return Ao(new zo(t),e)},gunzip:function(e,t,r){return"function"==typeof t&&(r=t,t={}),Ro(new To(t),e,r)},gunzipSync:function(e,t){return Ao(new To(t),e)},inflateRaw:function(e,t,r){return"function"==typeof t&&(r=t,t={}),Ro(new Co(t),e,r)},inflateRawSync:function(e,t){return Ao(new Co(t),e)},Deflate:Bo,Inflate:zo,Gzip:Lo,Gunzip:To,DeflateRaw:Mo,InflateRaw:Co,Unzip:Do,Zlib:Io};/* harmony default export */ __webpack_exports__["a"] = (class{constructor(e,t,r){this.SDKAPPID=e,this.EXPIRETIME=r,this.PRIVATEKEY=t}genTestUserSig(e){return this._isNumber(this.SDKAPPID)?this._isString(this.PRIVATEKEY)?this._isString(e)?this._isNumber(this.EXPIRETIME)?(console.log("SDKAppID="+this.SDKAPPID+" key="+this.PRIVATEKEY+" userID="+e+" expire="+this.EXPIRETIME),this.genSigWithUserbuf(e,this.EXPIRETIME,null)):(console.error("expireTime must be a number"),""):(console.error("userID must be a string"),""):(console.error("privateKey must be a string"),""):(console.error("SDKAppID must be a number"),"")}newBuffer(e,t){return p.from?p.from(e,t):new p(e,t)}unescape(e){return e.replace(/_/g,"=").replace(/\-/g,"/").replace(/\*/g,"+")}escape(e){return e.replace(/\+/g,"*").replace(/\//g,"-").replace(/=/g,"_")}encode(e){return this.escape(this.newBuffer(e).toString("base64"))}decode(e){return this.newBuffer(this.unescape(e),"base64")}base64encode(e){return this.newBuffer(e).toString("base64")}base64decode(e){return this.newBuffer(e,"base64").toString()}_hmacsha256(e,t,r,n){let i="TLS.identifier:"+e+"\n";i+="TLS.sdkappid:"+this.SDKAPPID+"\n",i+="TLS.time:"+t+"\n",i+="TLS.expire:"+r+"\n",null!=n&&(i+="TLS.userbuf:"+n+"\n");let o=te.HmacSHA256(i,this.PRIVATEKEY);return te.enc.Base64.stringify(o)}_utc(){return Math.round(Date.now()/1e3)}_isNumber(e){return null!==e&&("number"==typeof e&&!isNaN(e-0)||"object"==typeof e&&e.constructor===Number)}_isString(e){return"string"==typeof e}genSigWithUserbuf(e,t,r){let n=this._utc(),i={"TLS.ver":"2.0","TLS.identifier":e,"TLS.sdkappid":this.SDKAPPID,"TLS.time":n,"TLS.expire":t},o="";if(null!=r){let a=this.base64encode(r);i["TLS.userbuf"]=a,o=this._hmacsha256(e,n,t,a)}else o=this._hmacsha256(e,n,t,null);i["TLS.sig"]=o;let a=JSON.stringify(i),s=Po.deflateSync(this.newBuffer(a)).toString("base64"),h=this.escape(s);return console.log("ret="+h),h}validate(e){let t=this.decode(e),r=Po.inflateSync(t);console.log("validate ret="+r)}});

/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(26)))

/***/ }),
/* 123 */,
/* 124 */,
/* 125 */,
/* 126 */,
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(128);
module.exports = __webpack_require__(6).Object.assign;


/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.1 Object.assign(target, source)
var $export = __webpack_require__(7);

$export($export.S + $export.F, 'Object', { assign: __webpack_require__(129) });


/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 19.1.2.1 Object.assign(target, source, ...)
var DESCRIPTORS = __webpack_require__(10);
var getKeys = __webpack_require__(28);
var gOPS = __webpack_require__(52);
var pIE = __webpack_require__(32);
var toObject = __webpack_require__(24);
var IObject = __webpack_require__(40);
var $assign = Object.assign;

// should work with symbols and should have deterministic property order (V8 bug)
module.exports = !$assign || __webpack_require__(15)(function () {
  var A = {};
  var B = {};
  // eslint-disable-next-line no-undef
  var S = Symbol();
  var K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function (k) { B[k] = k; });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source) { // eslint-disable-line no-unused-vars
  var T = toObject(target);
  var aLen = arguments.length;
  var index = 1;
  var getSymbols = gOPS.f;
  var isEnum = pIE.f;
  while (aLen > index) {
    var S = IObject(arguments[index++]);
    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
    var length = keys.length;
    var j = 0;
    var key;
    while (length > j) {
      key = keys[j++];
      if (!DESCRIPTORS || isEnum.call(S, key)) T[key] = S[key];
    }
  } return T;
} : $assign;


/***/ }),
/* 130 */,
/* 131 */,
/* 132 */,
/* 133 */,
/* 134 */,
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

var core = __webpack_require__(6);
var $JSON = core.JSON || (core.JSON = { stringify: JSON.stringify });
module.exports = function stringify(it) { // eslint-disable-line no-unused-vars
  return $JSON.stringify.apply($JSON, arguments);
};


/***/ }),
/* 136 */,
/* 137 */,
/* 138 */,
/* 139 */,
/* 140 */,
/* 141 */,
/* 142 */,
/* 143 */,
/* 144 */,
/* 145 */,
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(147), __esModule: true };

/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(33);
__webpack_require__(27);
__webpack_require__(44);
__webpack_require__(148);
__webpack_require__(154);
__webpack_require__(157);
__webpack_require__(159);
module.exports = __webpack_require__(6).Map;


/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var strong = __webpack_require__(149);
var validate = __webpack_require__(77);
var MAP = 'Map';

// 23.1 Map Objects
module.exports = __webpack_require__(150)(MAP, function (get) {
  return function Map() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.1.3.6 Map.prototype.get(key)
  get: function get(key) {
    var entry = strong.getEntry(validate(this, MAP), key);
    return entry && entry.v;
  },
  // 23.1.3.9 Map.prototype.set(key, value)
  set: function set(key, value) {
    return strong.def(validate(this, MAP), key === 0 ? 0 : key, value);
  }
}, strong, true);


/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var dP = __webpack_require__(8).f;
var create = __webpack_require__(39);
var redefineAll = __webpack_require__(48);
var ctx = __webpack_require__(11);
var anInstance = __webpack_require__(46);
var forOf = __webpack_require__(25);
var $iterDefine = __webpack_require__(36);
var step = __webpack_require__(61);
var setSpecies = __webpack_require__(69);
var DESCRIPTORS = __webpack_require__(10);
var fastKey = __webpack_require__(50).fastKey;
var validate = __webpack_require__(77);
var SIZE = DESCRIPTORS ? '_s' : 'size';

var getEntry = function (that, key) {
  // fast case
  var index = fastKey(key);
  var entry;
  if (index !== 'F') return that._i[index];
  // frozen object case
  for (entry = that._f; entry; entry = entry.n) {
    if (entry.k == key) return entry;
  }
};

module.exports = {
  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, NAME, '_i');
      that._t = NAME;         // collection type
      that._i = create(null); // index
      that._f = undefined;    // first entry
      that._l = undefined;    // last entry
      that[SIZE] = 0;         // size
      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.1.3.1 Map.prototype.clear()
      // 23.2.3.2 Set.prototype.clear()
      clear: function clear() {
        for (var that = validate(this, NAME), data = that._i, entry = that._f; entry; entry = entry.n) {
          entry.r = true;
          if (entry.p) entry.p = entry.p.n = undefined;
          delete data[entry.i];
        }
        that._f = that._l = undefined;
        that[SIZE] = 0;
      },
      // 23.1.3.3 Map.prototype.delete(key)
      // 23.2.3.4 Set.prototype.delete(value)
      'delete': function (key) {
        var that = validate(this, NAME);
        var entry = getEntry(that, key);
        if (entry) {
          var next = entry.n;
          var prev = entry.p;
          delete that._i[entry.i];
          entry.r = true;
          if (prev) prev.n = next;
          if (next) next.p = prev;
          if (that._f == entry) that._f = next;
          if (that._l == entry) that._l = prev;
          that[SIZE]--;
        } return !!entry;
      },
      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
      forEach: function forEach(callbackfn /* , that = undefined */) {
        validate(this, NAME);
        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
        var entry;
        while (entry = entry ? entry.n : this._f) {
          f(entry.v, entry.k, this);
          // revert to the last existing entry
          while (entry && entry.r) entry = entry.p;
        }
      },
      // 23.1.3.7 Map.prototype.has(key)
      // 23.2.3.7 Set.prototype.has(value)
      has: function has(key) {
        return !!getEntry(validate(this, NAME), key);
      }
    });
    if (DESCRIPTORS) dP(C.prototype, 'size', {
      get: function () {
        return validate(this, NAME)[SIZE];
      }
    });
    return C;
  },
  def: function (that, key, value) {
    var entry = getEntry(that, key);
    var prev, index;
    // change existing entry
    if (entry) {
      entry.v = value;
    // create new entry
    } else {
      that._l = entry = {
        i: index = fastKey(key, true), // <- index
        k: key,                        // <- key
        v: value,                      // <- value
        p: prev = that._l,             // <- previous entry
        n: undefined,                  // <- next entry
        r: false                       // <- removed
      };
      if (!that._f) that._f = entry;
      if (prev) prev.n = entry;
      that[SIZE]++;
      // add to index
      if (index !== 'F') that._i[index] = entry;
    } return that;
  },
  getEntry: getEntry,
  setStrong: function (C, NAME, IS_MAP) {
    // add .keys, .values, .entries, [@@iterator]
    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
    $iterDefine(C, NAME, function (iterated, kind) {
      this._t = validate(iterated, NAME); // target
      this._k = kind;                     // kind
      this._l = undefined;                // previous
    }, function () {
      var that = this;
      var kind = that._k;
      var entry = that._l;
      // revert to the last existing entry
      while (entry && entry.r) entry = entry.p;
      // get next entry
      if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
        // or finish the iteration
        that._t = undefined;
        return step(1);
      }
      // return step by kind
      if (kind == 'keys') return step(0, entry.k);
      if (kind == 'values') return step(0, entry.v);
      return step(0, [entry.k, entry.v]);
    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);

    // add [@@species], 23.1.2.2, 23.2.2.2
    setSpecies(NAME);
  }
};


/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global = __webpack_require__(3);
var $export = __webpack_require__(7);
var meta = __webpack_require__(50);
var fails = __webpack_require__(15);
var hide = __webpack_require__(12);
var redefineAll = __webpack_require__(48);
var forOf = __webpack_require__(25);
var anInstance = __webpack_require__(46);
var isObject = __webpack_require__(9);
var setToStringTag = __webpack_require__(23);
var dP = __webpack_require__(8).f;
var each = __webpack_require__(151)(0);
var DESCRIPTORS = __webpack_require__(10);

module.exports = function (NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
  var Base = global[NAME];
  var C = Base;
  var ADDER = IS_MAP ? 'set' : 'add';
  var proto = C && C.prototype;
  var O = {};
  if (!DESCRIPTORS || typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function () {
    new C().entries().next();
  }))) {
    // create collection constructor
    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
    redefineAll(C.prototype, methods);
    meta.NEED = true;
  } else {
    C = wrapper(function (target, iterable) {
      anInstance(target, C, NAME, '_c');
      target._c = new Base();
      if (iterable != undefined) forOf(iterable, IS_MAP, target[ADDER], target);
    });
    each('add,clear,delete,forEach,get,has,set,keys,values,entries,toJSON'.split(','), function (KEY) {
      var IS_ADDER = KEY == 'add' || KEY == 'set';
      if (KEY in proto && !(IS_WEAK && KEY == 'clear')) hide(C.prototype, KEY, function (a, b) {
        anInstance(this, C, KEY);
        if (!IS_ADDER && IS_WEAK && !isObject(a)) return KEY == 'get' ? undefined : false;
        var result = this._c[KEY](a === 0 ? 0 : a, b);
        return IS_ADDER ? this : result;
      });
    });
    IS_WEAK || dP(C.prototype, 'size', {
      get: function () {
        return this._c.size;
      }
    });
  }

  setToStringTag(C, NAME);

  O[NAME] = C;
  $export($export.G + $export.W + $export.F, O);

  if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);

  return C;
};


/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

// 0 -> Array#forEach
// 1 -> Array#map
// 2 -> Array#filter
// 3 -> Array#some
// 4 -> Array#every
// 5 -> Array#find
// 6 -> Array#findIndex
var ctx = __webpack_require__(11);
var IObject = __webpack_require__(40);
var toObject = __webpack_require__(24);
var toLength = __webpack_require__(29);
var asc = __webpack_require__(152);
module.exports = function (TYPE, $create) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  var create = $create || asc;
  return function ($this, callbackfn, that) {
    var O = toObject($this);
    var self = IObject(O);
    var f = ctx(callbackfn, that, 3);
    var length = toLength(self.length);
    var index = 0;
    var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
    var val, res;
    for (;length > index; index++) if (NO_HOLES || index in self) {
      val = self[index];
      res = f(val, index, O);
      if (TYPE) {
        if (IS_MAP) result[index] = res;   // map
        else if (res) switch (TYPE) {
          case 3: return true;             // some
          case 5: return val;              // find
          case 6: return index;            // findIndex
          case 2: result.push(val);        // filter
        } else if (IS_EVERY) return false; // every
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
  };
};


/***/ }),
/* 152 */
/***/ (function(module, exports, __webpack_require__) {

// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
var speciesConstructor = __webpack_require__(153);

module.exports = function (original, length) {
  return new (speciesConstructor(original))(length);
};


/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(9);
var isArray = __webpack_require__(71);
var SPECIES = __webpack_require__(5)('species');

module.exports = function (original) {
  var C;
  if (isArray(original)) {
    C = original.constructor;
    // cross-realm fallback
    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;
    if (isObject(C)) {
      C = C[SPECIES];
      if (C === null) C = undefined;
    }
  } return C === undefined ? Array : C;
};


/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $export = __webpack_require__(7);

$export($export.P + $export.R, 'Map', { toJSON: __webpack_require__(155)('Map') });


/***/ }),
/* 155 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var classof = __webpack_require__(45);
var from = __webpack_require__(156);
module.exports = function (NAME) {
  return function toJSON() {
    if (classof(this) != NAME) throw TypeError(NAME + "#toJSON isn't generic");
    return from(this);
  };
};


/***/ }),
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

var forOf = __webpack_require__(25);

module.exports = function (iter, ITERATOR) {
  var result = [];
  forOf(iter, false, result.push, result, ITERATOR);
  return result;
};


/***/ }),
/* 157 */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-map.of
__webpack_require__(158)('Map');


/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://tc39.github.io/proposal-setmap-offrom/
var $export = __webpack_require__(7);

module.exports = function (COLLECTION) {
  $export($export.S, COLLECTION, { of: function of() {
    var length = arguments.length;
    var A = new Array(length);
    while (length--) A[length] = arguments[length];
    return new this(A);
  } });
};


/***/ }),
/* 159 */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-map.from
__webpack_require__(160)('Map');


/***/ }),
/* 160 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://tc39.github.io/proposal-setmap-offrom/
var $export = __webpack_require__(7);
var aFunction = __webpack_require__(19);
var ctx = __webpack_require__(11);
var forOf = __webpack_require__(25);

module.exports = function (COLLECTION) {
  $export($export.S, COLLECTION, { from: function from(source /* , mapFn, thisArg */) {
    var mapFn = arguments[1];
    var mapping, A, n, cb;
    aFunction(this);
    mapping = mapFn !== undefined;
    if (mapping) aFunction(mapFn);
    if (source == undefined) return new this();
    A = [];
    if (mapping) {
      n = 0;
      cb = ctx(mapFn, arguments[2], 2);
      forOf(source, false, function (nextItem) {
        A.push(cb(nextItem, n++));
      });
    } else {
      forOf(source, false, A.push, A);
    }
    return new this(A);
  } });
};


/***/ })
]);