global.webpackJsonpMpvue([0],{

/***/ "+E39":
/***/ (function(module, exports, __webpack_require__) {

// Thank's IE8 for his funny defineProperty
module.exports = !__webpack_require__("S82l")(function () {
  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),

/***/ "+ZMJ":
/***/ (function(module, exports, __webpack_require__) {

// optional / simple context binding
var aFunction = __webpack_require__("lOnJ");
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};


/***/ }),

/***/ "/bQp":
/***/ (function(module, exports) {

module.exports = {};


/***/ }),

/***/ "0xDb":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = formatTime;
/* harmony export (immutable) */ __webpack_exports__["b"] = throttle;
function formatNumber(n) {
  var str = n.toString();
  return str[1] ? str : '0' + str;
}

function formatTime(date) {
  var year = date.getFullYear();
  var month = date.getMonth() + 1;
  var day = date.getDate();

  var hour = date.getHours();
  var minute = date.getMinutes();

  var t1 = [year, month, day].map(formatNumber).join('-');
  var t2 = [hour, minute].map(formatNumber).join(':');

  return t1 + ' ' + t2;
}

function throttle(func, wait) {
  var timeout = void 0;
  return function () {
    var that = this;
    var args = arguments;

    if (!timeout) {
      timeout = setTimeout(function () {
        timeout = null;
        func.apply(that, args);
      }, wait);
    }
  };
}

/* unused harmony default export */ var _unused_webpack_default_export = ({
  formatNumber: formatNumber,
  formatTime: formatTime,
  throttle: throttle
});

/***/ }),

/***/ "1kS7":
/***/ (function(module, exports) {

exports.f = Object.getOwnPropertySymbols;


/***/ }),

/***/ "3Eo+":
/***/ (function(module, exports) {

var id = 0;
var px = Math.random();
module.exports = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};


/***/ }),

/***/ "3fs2":
/***/ (function(module, exports, __webpack_require__) {

var classof = __webpack_require__("RY/4");
var ITERATOR = __webpack_require__("dSzd")('iterator');
var Iterators = __webpack_require__("/bQp");
module.exports = __webpack_require__("FeBl").getIteratorMethod = function (it) {
  if (it != undefined) return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};


/***/ }),

/***/ "52gC":
/***/ (function(module, exports) {

// 7.2.1 RequireObjectCoercible(argument)
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};


/***/ }),

/***/ "5nAL":
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// fix env
try {
  if (!global) global = {};
  global.process = global.process || {};
  global.process.env = global.process.env || {};
  global.App = global.App || App;
  global.Page = global.Page || Page;
  global.Component = global.Component || Component;
  global.getApp = global.getApp || getApp;

  if (typeof wx !== 'undefined') {
    global.mpvue = wx;
    global.mpvuePlatform = 'wx';
  } else if (typeof swan !== 'undefined') {
    global.mpvue = swan;
    global.mpvuePlatform = 'swan';
  }else if (typeof tt !== 'undefined') {
    global.mpvue = tt;
    global.mpvuePlatform = 'tt';
  }else if (typeof my !== 'undefined') {
    global.mpvue = my;
    global.mpvuePlatform = 'my';
  }
} catch (e) {}

(function (global, factory) {
	 true ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global.Vue = factory());
}(this, (function () { 'use strict';

/*  */

// these helpers produces better vm code in JS engines due to their
// explicitness and function inlining
function isUndef (v) {
  return v === undefined || v === null
}

function isDef (v) {
  return v !== undefined && v !== null
}

function isTrue (v) {
  return v === true
}

function isFalse (v) {
  return v === false
}

/**
 * Check if value is primitive
 */
function isPrimitive (value) {
  return typeof value === 'string' || typeof value === 'number'
}

/**
 * Quick object check - this is primarily used to tell
 * Objects from primitive values when we know the value
 * is a JSON-compliant type.
 */
function isObject (obj) {
  return obj !== null && typeof obj === 'object'
}

var _toString = Object.prototype.toString;

/**
 * Strict object type check. Only returns true
 * for plain JavaScript objects.
 */
function isPlainObject (obj) {
  return _toString.call(obj) === '[object Object]'
}

function isRegExp (v) {
  return _toString.call(v) === '[object RegExp]'
}

/**
 * Check if val is a valid array index.
 */
function isValidArrayIndex (val) {
  var n = parseFloat(val);
  return n >= 0 && Math.floor(n) === n && isFinite(val)
}

/**
 * Convert a value to a string that is actually rendered.
 */
function toString (val) {
  return val == null
    ? ''
    : typeof val === 'object'
      ? JSON.stringify(val, null, 2)
      : String(val)
}

/**
 * Convert a input value to a number for persistence.
 * If the conversion fails, return original string.
 */
function toNumber (val) {
  var n = parseFloat(val);
  return isNaN(n) ? val : n
}

/**
 * Make a map and return a function for checking if a key
 * is in that map.
 */
function makeMap (
  str,
  expectsLowerCase
) {
  var map = Object.create(null);
  var list = str.split(',');
  for (var i = 0; i < list.length; i++) {
    map[list[i]] = true;
  }
  return expectsLowerCase
    ? function (val) { return map[val.toLowerCase()]; }
    : function (val) { return map[val]; }
}

/**
 * Check if a tag is a built-in tag.
 */
var isBuiltInTag = makeMap('slot,component', true);

/**
 * Check if a attribute is a reserved attribute.
 */
var isReservedAttribute = makeMap('key,ref,slot,is');

/**
 * Remove an item from an array
 */
function remove (arr, item) {
  if (arr.length) {
    var index = arr.indexOf(item);
    if (index > -1) {
      return arr.splice(index, 1)
    }
  }
}

/**
 * Check whether the object has the property.
 */
var hasOwnProperty = Object.prototype.hasOwnProperty;
function hasOwn (obj, key) {
  return hasOwnProperty.call(obj, key)
}

/**
 * Create a cached version of a pure function.
 */
function cached (fn) {
  var cache = Object.create(null);
  return (function cachedFn (str) {
    var hit = cache[str];
    return hit || (cache[str] = fn(str))
  })
}

/**
 * Camelize a hyphen-delimited string.
 */
var camelizeRE = /-(\w)/g;
var camelize = cached(function (str) {
  return str.replace(camelizeRE, function (_, c) { return c ? c.toUpperCase() : ''; })
});

/**
 * Capitalize a string.
 */
var capitalize = cached(function (str) {
  return str.charAt(0).toUpperCase() + str.slice(1)
});

/**
 * Hyphenate a camelCase string.
 */
var hyphenateRE = /([^-])([A-Z])/g;
var hyphenate = cached(function (str) {
  return str
    .replace(hyphenateRE, '$1-$2')
    .replace(hyphenateRE, '$1-$2')
    .toLowerCase()
});

/**
 * Simple bind, faster than native
 */
function bind (fn, ctx) {
  function boundFn (a) {
    var l = arguments.length;
    return l
      ? l > 1
        ? fn.apply(ctx, arguments)
        : fn.call(ctx, a)
      : fn.call(ctx)
  }
  // record original fn length
  boundFn._length = fn.length;
  return boundFn
}

/**
 * Convert an Array-like object to a real Array.
 */
function toArray (list, start) {
  start = start || 0;
  var i = list.length - start;
  var ret = new Array(i);
  while (i--) {
    ret[i] = list[i + start];
  }
  return ret
}

/**
 * Mix properties into target object.
 */
function extend (to, _from) {
  for (var key in _from) {
    to[key] = _from[key];
  }
  return to
}

/**
 * Merge an Array of Objects into a single Object.
 */
function toObject (arr) {
  var res = {};
  for (var i = 0; i < arr.length; i++) {
    if (arr[i]) {
      extend(res, arr[i]);
    }
  }
  return res
}

/**
 * Perform no operation.
 * Stubbing args to make Flow happy without leaving useless transpiled code
 * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/)
 */
function noop (a, b, c) {}

/**
 * Always return false.
 */
var no = function (a, b, c) { return false; };

/**
 * Return same value
 */
var identity = function (_) { return _; };

/**
 * Generate a static keys string from compiler modules.
 */


/**
 * Check if two values are loosely equal - that is,
 * if they are plain objects, do they have the same shape?
 */
function looseEqual (a, b) {
  var isObjectA = isObject(a);
  var isObjectB = isObject(b);
  if (isObjectA && isObjectB) {
    try {
      return JSON.stringify(a) === JSON.stringify(b)
    } catch (e) {
      // possible circular reference
      return a === b
    }
  } else if (!isObjectA && !isObjectB) {
    return String(a) === String(b)
  } else {
    return false
  }
}

function looseIndexOf (arr, val) {
  for (var i = 0; i < arr.length; i++) {
    if (looseEqual(arr[i], val)) { return i }
  }
  return -1
}

/**
 * Ensure a function is called only once.
 */
function once (fn) {
  var called = false;
  return function () {
    if (!called) {
      called = true;
      fn.apply(this, arguments);
    }
  }
}

var SSR_ATTR = 'data-server-rendered';

var ASSET_TYPES = [
  'component',
  'directive',
  'filter'
];

var LIFECYCLE_HOOKS = [
  'beforeCreate',
  'created',
  'beforeMount',
  'mounted',
  'beforeUpdate',
  'updated',
  'beforeDestroy',
  'destroyed',
  'activated',
  'deactivated', 'onLaunch',
  'onLoad',
  'onShow',
  'onReady',
  'onHide',
  'onUnload',
  'onPullDownRefresh',
  'onReachBottom',
  'onShareAppMessage',
  'onPageScroll',
  'onTabItemTap',
  'attached',
  'ready',
  'moved',
  'detached'
];

/*  */

var config = ({
  /**
   * Option merge strategies (used in core/util/options)
   */
  optionMergeStrategies: Object.create(null),

  /**
   * Whether to suppress warnings.
   */
  silent: false,

  /**
   * Show production mode tip message on boot?
   */
  productionTip: "production" !== 'production',

  /**
   * Whether to enable devtools
   */
  devtools: "production" !== 'production',

  /**
   * Whether to record perf
   */
  performance: false,

  /**
   * Error handler for watcher errors
   */
  errorHandler: null,

  /**
   * Warn handler for watcher warns
   */
  warnHandler: null,

  /**
   * Ignore certain custom elements
   */
  ignoredElements: [],

  /**
   * Custom user key aliases for v-on
   */
  keyCodes: Object.create(null),

  /**
   * Check if a tag is reserved so that it cannot be registered as a
   * component. This is platform-dependent and may be overwritten.
   */
  isReservedTag: no,

  /**
   * Check if an attribute is reserved so that it cannot be used as a component
   * prop. This is platform-dependent and may be overwritten.
   */
  isReservedAttr: no,

  /**
   * Check if a tag is an unknown element.
   * Platform-dependent.
   */
  isUnknownElement: no,

  /**
   * Get the namespace of an element
   */
  getTagNamespace: noop,

  /**
   * Parse the real tag name for the specific platform.
   */
  parsePlatformTagName: identity,

  /**
   * Check if an attribute must be bound using property, e.g. value
   * Platform-dependent.
   */
  mustUseProp: no,

  /**
   * Exposed for legacy reasons
   */
  _lifecycleHooks: LIFECYCLE_HOOKS
});

/*  */

var emptyObject = Object.freeze({});

/**
 * Check if a string starts with $ or _
 */
function isReserved (str) {
  var c = (str + '').charCodeAt(0);
  return c === 0x24 || c === 0x5F
}

/**
 * Define a property.
 */
function def (obj, key, val, enumerable) {
  Object.defineProperty(obj, key, {
    value: val,
    enumerable: !!enumerable,
    writable: true,
    configurable: true
  });
}

/**
 * Parse simple path.
 */
var bailRE = /[^\w.$]/;
function parsePath (path) {
  if (bailRE.test(path)) {
    return
  }
  var segments = path.split('.');
  return function (obj) {
    for (var i = 0; i < segments.length; i++) {
      if (!obj) { return }
      obj = obj[segments[i]];
    }
    return obj
  }
}

/*  */

var warn = noop;

var formatComponentName = (null); // work around flow check

/*  */

function handleError (err, vm, info) {
  if (config.errorHandler) {
    config.errorHandler.call(null, err, vm, info);
  } else {
    if (inBrowser && typeof console !== 'undefined') {
      console.error(err);
    } else {
      throw err
    }
  }
}

/*  */

// can we use __proto__?
var hasProto = '__proto__' in {};

// Browser environment sniffing
var inBrowser = typeof window !== 'undefined';
var UA = ['mpvue-runtime'].join();
var isIE = UA && /msie|trident/.test(UA);
var isIE9 = UA && UA.indexOf('msie 9.0') > 0;
var isEdge = UA && UA.indexOf('edge/') > 0;
var isAndroid = UA && UA.indexOf('android') > 0;
var isIOS = UA && /iphone|ipad|ipod|ios/.test(UA);
var isChrome = UA && /chrome\/\d+/.test(UA) && !isEdge;

// Firefix has a "watch" function on Object.prototype...
var nativeWatch = ({}).watch;

var supportsPassive = false;
if (inBrowser) {
  try {
    var opts = {};
    Object.defineProperty(opts, 'passive', ({
      get: function get () {
        /* istanbul ignore next */
        supportsPassive = true;
      }
    })); // https://github.com/facebook/flow/issues/285
    window.addEventListener('test-passive', null, opts);
  } catch (e) {}
}

// this needs to be lazy-evaled because vue may be required before
// vue-server-renderer can set VUE_ENV
var _isServer;
var isServerRendering = function () {
  if (_isServer === undefined) {
    /* istanbul ignore if */
    if (!inBrowser && typeof global !== 'undefined') {
      // detect presence of vue-server-renderer and avoid
      // Webpack shimming the process
      _isServer = global['process'].env.VUE_ENV === 'server';
    } else {
      _isServer = false;
    }
  }
  return _isServer
};

// detect devtools
var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;

/* istanbul ignore next */
function isNative (Ctor) {
  return typeof Ctor === 'function' && /native code/.test(Ctor.toString())
}

var hasSymbol =
  typeof Symbol !== 'undefined' && isNative(Symbol) &&
  typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);

/**
 * Defer a task to execute it asynchronously.
 */
var nextTick = (function () {
  var callbacks = [];
  var pending = false;
  var timerFunc;

  function nextTickHandler () {
    pending = false;
    var copies = callbacks.slice(0);
    callbacks.length = 0;
    for (var i = 0; i < copies.length; i++) {
      copies[i]();
    }
  }

  // the nextTick behavior leverages the microtask queue, which can be accessed
  // via either native Promise.then or MutationObserver.
  // MutationObserver has wider support, however it is seriously bugged in
  // UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It
  // completely stops working after triggering a few times... so, if native
  // Promise is available, we will use it:
  /* istanbul ignore if */
  if (typeof Promise !== 'undefined' && isNative(Promise)) {
    var p = Promise.resolve();
    var logError = function (err) { console.error(err); };
    timerFunc = function () {
      p.then(nextTickHandler).catch(logError);
      // in problematic UIWebViews, Promise.then doesn't completely break, but
      // it can get stuck in a weird state where callbacks are pushed into the
      // microtask queue but the queue isn't being flushed, until the browser
      // needs to do some other work, e.g. handle a timer. Therefore we can
      // "force" the microtask queue to be flushed by adding an empty timer.
      if (isIOS) { setTimeout(noop); }
    };
  // } else if (typeof MutationObserver !== 'undefined' && (
  //   isNative(MutationObserver) ||
  //   // PhantomJS and iOS 7.x
  //   MutationObserver.toString() === '[object MutationObserverConstructor]'
  // )) {
  //   // use MutationObserver where native Promise is not available,
  //   // e.g. PhantomJS IE11, iOS7, Android 4.4
  //   var counter = 1
  //   var observer = new MutationObserver(nextTickHandler)
  //   var textNode = document.createTextNode(String(counter))
  //   observer.observe(textNode, {
  //     characterData: true
  //   })
  //   timerFunc = () => {
  //     counter = (counter + 1) % 2
  //     textNode.data = String(counter)
  //   }
  } else {
    // fallback to setTimeout
    /* istanbul ignore next */
    timerFunc = function () {
      setTimeout(nextTickHandler, 0);
    };
  }

  return function queueNextTick (cb, ctx) {
    var _resolve;
    callbacks.push(function () {
      if (cb) {
        try {
          cb.call(ctx);
        } catch (e) {
          handleError(e, ctx, 'nextTick');
        }
      } else if (_resolve) {
        _resolve(ctx);
      }
    });
    if (!pending) {
      pending = true;
      timerFunc();
    }
    if (!cb && typeof Promise !== 'undefined') {
      return new Promise(function (resolve, reject) {
        _resolve = resolve;
      })
    }
  }
})();

var _Set;
/* istanbul ignore if */
if (typeof Set !== 'undefined' && isNative(Set)) {
  // use native Set when available.
  _Set = Set;
} else {
  // a non-standard Set polyfill that only works with primitive keys.
  _Set = (function () {
    function Set () {
      this.set = Object.create(null);
    }
    Set.prototype.has = function has (key) {
      return this.set[key] === true
    };
    Set.prototype.add = function add (key) {
      this.set[key] = true;
    };
    Set.prototype.clear = function clear () {
      this.set = Object.create(null);
    };

    return Set;
  }());
}

/*  */


var uid$1 = 0;

/**
 * A dep is an observable that can have multiple
 * directives subscribing to it.
 */
var Dep = function Dep () {
  this.id = uid$1++;
  this.subs = [];
};

Dep.prototype.addSub = function addSub (sub) {
  this.subs.push(sub);
};

Dep.prototype.removeSub = function removeSub (sub) {
  remove(this.subs, sub);
};

Dep.prototype.depend = function depend () {
  if (Dep.target) {
    Dep.target.addDep(this);
  }
};

Dep.prototype.notify = function notify () {
  // stabilize the subscriber list first
  var subs = this.subs.slice();
  for (var i = 0, l = subs.length; i < l; i++) {
    subs[i].update();
  }
};

// the current target watcher being evaluated.
// this is globally unique because there could be only one
// watcher being evaluated at any time.
Dep.target = null;
var targetStack = [];

function pushTarget (_target) {
  if (Dep.target) { targetStack.push(Dep.target); }
  Dep.target = _target;
}

function popTarget () {
  Dep.target = targetStack.pop();
}

/*
 * not type checking this file because flow doesn't play well with
 * dynamically accessing methods on Array prototype
 */

var arrayProto = Array.prototype;
var arrayMethods = Object.create(arrayProto);[
  'push',
  'pop',
  'shift',
  'unshift',
  'splice',
  'sort',
  'reverse'
]
.forEach(function (method) {
  // cache original method
  var original = arrayProto[method];
  def(arrayMethods, method, function mutator () {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

    var result = original.apply(this, args);
    var ob = this.__ob__;
    var inserted;
    switch (method) {
      case 'push':
      case 'unshift':
        inserted = args;
        break
      case 'splice':
        inserted = args.slice(2);
        break
    }
    if (inserted) { ob.observeArray(inserted); }
    // notify change
    ob.dep.notify();
    return result
  });
});

/*  */

var arrayKeys = Object.getOwnPropertyNames(arrayMethods);

/**
 * By default, when a reactive property is set, the new value is
 * also converted to become reactive. However when passing down props,
 * we don't want to force conversion because the value may be a nested value
 * under a frozen data structure. Converting it would defeat the optimization.
 */
var observerState = {
  shouldConvert: true
};

/**
 * Observer class that are attached to each observed
 * object. Once attached, the observer converts target
 * object's property keys into getter/setters that
 * collect dependencies and dispatches updates.
 */
var Observer = function Observer (value, key) {
  this.value = value;
  this.dep = new Dep();
  this.vmCount = 0;
  if (key) {
    this.key = key;
  }
  def(value, '__ob__', this);
  if (Array.isArray(value)) {
    var augment = hasProto
      ? protoAugment
      : copyAugment;
    augment(value, arrayMethods, arrayKeys);
    this.observeArray(value);
  } else {
    this.walk(value);
  }
};

/**
 * Walk through each property and convert them into
 * getter/setters. This method should only be called when
 * value type is Object.
 */
Observer.prototype.walk = function walk (obj) {
  var keys = Object.keys(obj);
  for (var i = 0; i < keys.length; i++) {
    defineReactive$$1(obj, keys[i], obj[keys[i]]);
  }
};

/**
 * Observe a list of Array items.
 */
Observer.prototype.observeArray = function observeArray (items) {
  for (var i = 0, l = items.length; i < l; i++) {
    observe(items[i]);
  }
};

// helpers

/**
 * Augment an target Object or Array by intercepting
 * the prototype chain using __proto__
 */
function protoAugment (target, src, keys) {
  /* eslint-disable no-proto */
  target.__proto__ = src;
  /* eslint-enable no-proto */
}

/**
 * Augment an target Object or Array by defining
 * hidden properties.
 */
/* istanbul ignore next */
function copyAugment (target, src, keys) {
  for (var i = 0, l = keys.length; i < l; i++) {
    var key = keys[i];
    def(target, key, src[key]);
  }
}

/**
 * Attempt to create an observer instance for a value,
 * returns the new observer if successfully observed,
 * or the existing observer if the value already has one.
 */
function observe (value, asRootData, key) {
  if (!isObject(value)) {
    return
  }
  var ob;
  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
    ob = value.__ob__;
  } else if (
    observerState.shouldConvert &&
    !isServerRendering() &&
    (Array.isArray(value) || isPlainObject(value)) &&
    Object.isExtensible(value) &&
    !value._isVue
  ) {
    ob = new Observer(value, key);
  }
  if (asRootData && ob) {
    ob.vmCount++;
  }
  return ob
}

/**
 * Define a reactive property on an Object.
 */
function defineReactive$$1 (
  obj,
  key,
  val,
  customSetter,
  shallow
) {
  var dep = new Dep();

  var property = Object.getOwnPropertyDescriptor(obj, key);
  if (property && property.configurable === false) {
    return
  }

  // cater for pre-defined getter/setters
  var getter = property && property.get;
  var setter = property && property.set;

  var childOb = !shallow && observe(val, undefined, key);
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter () {
      var value = getter ? getter.call(obj) : val;
      if (Dep.target) {
        dep.depend();
        if (childOb) {
          childOb.dep.depend();
        }
        if (Array.isArray(value)) {
          dependArray(value);
        }
      }
      return value
    },
    set: function reactiveSetter (newVal) {
      var value = getter ? getter.call(obj) : val;
      /* eslint-disable no-self-compare */
      if (newVal === value || (newVal !== newVal && value !== value)) {
        return
      }

      /* eslint-enable no-self-compare */
      if (false) {
        customSetter();
      }
      if (setter) {
        setter.call(obj, newVal);
      } else {
        val = newVal;
      }
      childOb = !shallow && observe(newVal, undefined, key);
      dep.notify();

      if (!obj.__keyPath) {
        def(obj, '__keyPath', {}, false);
      }
      obj.__keyPath[key] = true;
      if (newVal instanceof Object && !(newVal instanceof Array)) {
        // 标记是否是通过this.Obj = {} 赋值印发的改动，解决少更新问题#1305
        def(newVal, '__newReference', true, false);
      }
    }
  });
}

/**
 * Set a property on an object. Adds the new property and
 * triggers change notification if the property doesn't
 * already exist.
 */
function set (target, key, val) {
  if (Array.isArray(target) && isValidArrayIndex(key)) {
    target.length = Math.max(target.length, key);
    target.splice(key, 1, val);
    return val
  }
  if (hasOwn(target, key)) {
    target[key] = val;
    return val
  }
  var ob = (target).__ob__;
  if (target._isVue || (ob && ob.vmCount)) {
    "production" !== 'production' && warn(
      'Avoid adding reactive properties to a Vue instance or its root $data ' +
      'at runtime - declare it upfront in the data option.'
    );
    return val
  }
  if (!ob) {
    target[key] = val;
    return val
  }
  defineReactive$$1(ob.value, key, val);
  // Vue.set 添加对象属性，渲染时候把 val 传给小程序渲染
  if (!target.__keyPath) {
    def(target, '__keyPath', {}, false);
  }
  target.__keyPath[key] = true;
  ob.dep.notify();
  return val
}

/**
 * Delete a property and trigger change if necessary.
 */
function del (target, key) {
  if (Array.isArray(target) && isValidArrayIndex(key)) {
    target.splice(key, 1);
    return
  }
  var ob = (target).__ob__;
  if (target._isVue || (ob && ob.vmCount)) {
    "production" !== 'production' && warn(
      'Avoid deleting properties on a Vue instance or its root $data ' +
      '- just set it to null.'
    );
    return
  }
  if (!hasOwn(target, key)) {
    return
  }
  delete target[key];
  if (!ob) {
    return
  }
  if (!target.__keyPath) {
    def(target, '__keyPath', {}, false);
  }
  // Vue.del 删除对象属性，渲染时候把这个属性设置为 undefined
  target.__keyPath[key] = 'del';
  ob.dep.notify();
}

/**
 * Collect dependencies on array elements when the array is touched, since
 * we cannot intercept array element access like property getters.
 */
function dependArray (value) {
  for (var e = (void 0), i = 0, l = value.length; i < l; i++) {
    e = value[i];
    e && e.__ob__ && e.__ob__.dep.depend();
    if (Array.isArray(e)) {
      dependArray(e);
    }
  }
}

/*  */

/**
 * Option overwriting strategies are functions that handle
 * how to merge a parent option value and a child option
 * value into the final value.
 */
var strats = config.optionMergeStrategies;

/**
 * Options with restrictions
 */
/**
 * Helper that recursively merges two data objects together.
 */
function mergeData (to, from) {
  if (!from) { return to }
  var key, toVal, fromVal;
  var keys = Object.keys(from);
  for (var i = 0; i < keys.length; i++) {
    key = keys[i];
    toVal = to[key];
    fromVal = from[key];
    if (!hasOwn(to, key)) {
      set(to, key, fromVal);
    } else if (isPlainObject(toVal) && isPlainObject(fromVal)) {
      mergeData(toVal, fromVal);
    }
  }
  return to
}

/**
 * Data
 */
function mergeDataOrFn (
  parentVal,
  childVal,
  vm
) {
  if (!vm) {
    // in a Vue.extend merge, both should be functions
    if (!childVal) {
      return parentVal
    }
    if (!parentVal) {
      return childVal
    }
    // when parentVal & childVal are both present,
    // we need to return a function that returns the
    // merged result of both functions... no need to
    // check if parentVal is a function here because
    // it has to be a function to pass previous merges.
    return function mergedDataFn () {
      return mergeData(
        typeof childVal === 'function' ? childVal.call(this) : childVal,
        parentVal.call(this)
      )
    }
  } else if (parentVal || childVal) {
    return function mergedInstanceDataFn () {
      // instance merge
      var instanceData = typeof childVal === 'function'
        ? childVal.call(vm)
        : childVal;
      var defaultData = typeof parentVal === 'function'
        ? parentVal.call(vm)
        : undefined;
      if (instanceData) {
        return mergeData(instanceData, defaultData)
      } else {
        return defaultData
      }
    }
  }
}

strats.data = function (
  parentVal,
  childVal,
  vm
) {
  if (!vm) {
    if (childVal && typeof childVal !== 'function') {
      "production" !== 'production' && warn(
        'The "data" option should be a function ' +
        'that returns a per-instance value in component ' +
        'definitions.',
        vm
      );

      return parentVal
    }
    return mergeDataOrFn.call(this, parentVal, childVal)
  }

  return mergeDataOrFn(parentVal, childVal, vm)
};

/**
 * Hooks and props are merged as arrays.
 */
function mergeHook (
  parentVal,
  childVal
) {
  return childVal
    ? parentVal
      ? parentVal.concat(childVal)
      : Array.isArray(childVal)
        ? childVal
        : [childVal]
    : parentVal
}

LIFECYCLE_HOOKS.forEach(function (hook) {
  strats[hook] = mergeHook;
});

/**
 * Assets
 *
 * When a vm is present (instance creation), we need to do
 * a three-way merge between constructor options, instance
 * options and parent options.
 */
function mergeAssets (parentVal, childVal) {
  var res = Object.create(parentVal || null);
  return childVal
    ? extend(res, childVal)
    : res
}

ASSET_TYPES.forEach(function (type) {
  strats[type + 's'] = mergeAssets;
});

/**
 * Watchers.
 *
 * Watchers hashes should not overwrite one
 * another, so we merge them as arrays.
 */
strats.watch = function (parentVal, childVal) {
  // work around Firefox's Object.prototype.watch...
  if (parentVal === nativeWatch) { parentVal = undefined; }
  if (childVal === nativeWatch) { childVal = undefined; }
  /* istanbul ignore if */
  if (!childVal) { return Object.create(parentVal || null) }
  if (!parentVal) { return childVal }
  var ret = {};
  extend(ret, parentVal);
  for (var key in childVal) {
    var parent = ret[key];
    var child = childVal[key];
    if (parent && !Array.isArray(parent)) {
      parent = [parent];
    }
    ret[key] = parent
      ? parent.concat(child)
      : Array.isArray(child) ? child : [child];
  }
  return ret
};

/**
 * Other object hashes.
 */
strats.props =
strats.methods =
strats.inject =
strats.computed = function (parentVal, childVal) {
  if (!childVal) { return Object.create(parentVal || null) }
  if (!parentVal) { return childVal }
  var ret = Object.create(null);
  extend(ret, parentVal);
  extend(ret, childVal);
  return ret
};
strats.provide = mergeDataOrFn;

/**
 * Default strategy.
 */
var defaultStrat = function (parentVal, childVal) {
  return childVal === undefined
    ? parentVal
    : childVal
};

/**
 * Ensure all props option syntax are normalized into the
 * Object-based format.
 */
function normalizeProps (options) {
  var props = options.props;
  if (!props) { return }
  var res = {};
  var i, val, name;
  if (Array.isArray(props)) {
    i = props.length;
    while (i--) {
      val = props[i];
      if (typeof val === 'string') {
        name = camelize(val);
        res[name] = { type: null };
      } else {}
    }
  } else if (isPlainObject(props)) {
    for (var key in props) {
      val = props[key];
      name = camelize(key);
      res[name] = isPlainObject(val)
        ? val
        : { type: val };
    }
  }
  options.props = res;
}

/**
 * Normalize all injections into Object-based format
 */
function normalizeInject (options) {
  var inject = options.inject;
  if (Array.isArray(inject)) {
    var normalized = options.inject = {};
    for (var i = 0; i < inject.length; i++) {
      normalized[inject[i]] = inject[i];
    }
  }
}

/**
 * Normalize raw function directives into object format.
 */
function normalizeDirectives (options) {
  var dirs = options.directives;
  if (dirs) {
    for (var key in dirs) {
      var def = dirs[key];
      if (typeof def === 'function') {
        dirs[key] = { bind: def, update: def };
      }
    }
  }
}

/**
 * Merge two option objects into a new one.
 * Core utility used in both instantiation and inheritance.
 */
function mergeOptions (
  parent,
  child,
  vm
) {
  if (typeof child === 'function') {
    child = child.options;
  }

  normalizeProps(child);
  normalizeInject(child);
  normalizeDirectives(child);
  var extendsFrom = child.extends;
  if (extendsFrom) {
    parent = mergeOptions(parent, extendsFrom, vm);
  }
  if (child.mixins) {
    for (var i = 0, l = child.mixins.length; i < l; i++) {
      parent = mergeOptions(parent, child.mixins[i], vm);
    }
  }
  var options = {};
  var key;
  for (key in parent) {
    mergeField(key);
  }
  for (key in child) {
    if (!hasOwn(parent, key)) {
      mergeField(key);
    }
  }
  function mergeField (key) {
    var strat = strats[key] || defaultStrat;
    options[key] = strat(parent[key], child[key], vm, key);
  }
  return options
}

/**
 * Resolve an asset.
 * This function is used because child instances need access
 * to assets defined in its ancestor chain.
 */
function resolveAsset (
  options,
  type,
  id,
  warnMissing
) {
  /* istanbul ignore if */
  if (typeof id !== 'string') {
    return
  }
  var assets = options[type];
  // check local registration variations first
  if (hasOwn(assets, id)) { return assets[id] }
  var camelizedId = camelize(id);
  if (hasOwn(assets, camelizedId)) { return assets[camelizedId] }
  var PascalCaseId = capitalize(camelizedId);
  if (hasOwn(assets, PascalCaseId)) { return assets[PascalCaseId] }
  // fallback to prototype chain
  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];
  if (false) {
    warn(
      'Failed to resolve ' + type.slice(0, -1) + ': ' + id,
      options
    );
  }
  return res
}

/*  */

function validateProp (
  key,
  propOptions,
  propsData,
  vm
) {
  var prop = propOptions[key];
  var absent = !hasOwn(propsData, key);
  var value = propsData[key];
  // handle boolean props
  if (isType(Boolean, prop.type)) {
    if (absent && !hasOwn(prop, 'default')) {
      value = false;
    } else if (!isType(String, prop.type) && (value === '' || value === hyphenate(key))) {
      value = true;
    }
  }
  // check default value
  if (value === undefined) {
    value = getPropDefaultValue(vm, prop, key);
    // since the default value is a fresh copy,
    // make sure to observe it.
    var prevShouldConvert = observerState.shouldConvert;
    observerState.shouldConvert = true;
    observe(value);
    observerState.shouldConvert = prevShouldConvert;
  }
  return value
}

/**
 * Get the default value of a prop.
 */
function getPropDefaultValue (vm, prop, key) {
  // no default, return undefined
  if (!hasOwn(prop, 'default')) {
    return undefined
  }
  var def = prop.default;
  // warn against non-factory defaults for Object & Array
  if (false) {
    warn(
      'Invalid default value for prop "' + key + '": ' +
      'Props with type Object/Array must use a factory function ' +
      'to return the default value.',
      vm
    );
  }
  // the raw prop value was also undefined from previous render,
  // return previous default value to avoid unnecessary watcher trigger
  if (vm && vm.$options.propsData &&
    vm.$options.propsData[key] === undefined &&
    vm._props[key] !== undefined
  ) {
    return vm._props[key]
  }
  // call factory function for non-Function types
  // a value is Function if its prototype is function even across different execution context
  return typeof def === 'function' && getType(prop.type) !== 'Function'
    ? def.call(vm)
    : def
}

/**
 * Use function string name to check built-in types,
 * because a simple equality check will fail when running
 * across different vms / iframes.
 */
function getType (fn) {
  var match = fn && fn.toString().match(/^\s*function (\w+)/);
  return match ? match[1] : ''
}

function isType (type, fn) {
  if (!Array.isArray(fn)) {
    return getType(fn) === getType(type)
  }
  for (var i = 0, len = fn.length; i < len; i++) {
    if (getType(fn[i]) === getType(type)) {
      return true
    }
  }
  /* istanbul ignore next */
  return false
}

/*  */

/* not type checking this file because flow doesn't play well with Proxy */

var mark;
var measure;

/*  */

var VNode = function VNode (
  tag,
  data,
  children,
  text,
  elm,
  context,
  componentOptions,
  asyncFactory
) {
  this.tag = tag;
  this.data = data;
  this.children = children;
  this.text = text;
  this.elm = elm;
  this.ns = undefined;
  this.context = context;
  this.functionalContext = undefined;
  this.key = data && data.key;
  this.componentOptions = componentOptions;
  this.componentInstance = undefined;
  this.parent = undefined;
  this.raw = false;
  this.isStatic = false;
  this.isRootInsert = true;
  this.isComment = false;
  this.isCloned = false;
  this.isOnce = false;
  this.asyncFactory = asyncFactory;
  this.asyncMeta = undefined;
  this.isAsyncPlaceholder = false;
};

var prototypeAccessors = { child: {} };

// DEPRECATED: alias for componentInstance for backwards compat.
/* istanbul ignore next */
prototypeAccessors.child.get = function () {
  return this.componentInstance
};

Object.defineProperties( VNode.prototype, prototypeAccessors );

var createEmptyVNode = function (text) {
  if ( text === void 0 ) text = '';

  var node = new VNode();
  node.text = text;
  node.isComment = true;
  return node
};

function createTextVNode (val) {
  return new VNode(undefined, undefined, undefined, String(val))
}

// optimized shallow clone
// used for static nodes and slot nodes because they may be reused across
// multiple renders, cloning them avoids errors when DOM manipulations rely
// on their elm reference.
function cloneVNode (vnode) {
  var cloned = new VNode(
    vnode.tag,
    vnode.data,
    vnode.children,
    vnode.text,
    vnode.elm,
    vnode.context,
    vnode.componentOptions,
    vnode.asyncFactory
  );
  cloned.ns = vnode.ns;
  cloned.isStatic = vnode.isStatic;
  cloned.key = vnode.key;
  cloned.isComment = vnode.isComment;
  cloned.isCloned = true;
  return cloned
}

function cloneVNodes (vnodes) {
  var len = vnodes.length;
  var res = new Array(len);
  for (var i = 0; i < len; i++) {
    res[i] = cloneVNode(vnodes[i]);
  }
  return res
}

/*  */

var normalizeEvent = cached(function (name) {
  var passive = name.charAt(0) === '&';
  name = passive ? name.slice(1) : name;
  var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first
  name = once$$1 ? name.slice(1) : name;
  var capture = name.charAt(0) === '!';
  name = capture ? name.slice(1) : name;
  return {
    name: name,
    once: once$$1,
    capture: capture,
    passive: passive
  }
});

function createFnInvoker (fns) {
  function invoker () {
    var arguments$1 = arguments;

    var fns = invoker.fns;
    if (Array.isArray(fns)) {
      var cloned = fns.slice();
      for (var i = 0; i < cloned.length; i++) {
        cloned[i].apply(null, arguments$1);
      }
    } else {
      // return handler return value for single handlers
      return fns.apply(null, arguments)
    }
  }
  invoker.fns = fns;
  return invoker
}

function updateListeners (
  on,
  oldOn,
  add,
  remove$$1,
  vm
) {
  var name, cur, old, event;
  for (name in on) {
    cur = on[name];
    old = oldOn[name];
    event = normalizeEvent(name);
    if (isUndef(cur)) {
      "production" !== 'production' && warn(
        "Invalid handler for event \"" + (event.name) + "\": got " + String(cur),
        vm
      );
    } else if (isUndef(old)) {
      if (isUndef(cur.fns)) {
        cur = on[name] = createFnInvoker(cur);
      }
      add(event.name, cur, event.once, event.capture, event.passive);
    } else if (cur !== old) {
      old.fns = cur;
      on[name] = old;
    }
  }
  for (name in oldOn) {
    if (isUndef(on[name])) {
      event = normalizeEvent(name);
      remove$$1(event.name, oldOn[name], event.capture);
    }
  }
}

/*  */

/*  */

function extractPropsFromVNodeData (
  data,
  Ctor,
  tag
) {
  // we are only extracting raw values here.
  // validation and default values are handled in the child
  // component itself.
  var propOptions = Ctor.options.props;
  if (isUndef(propOptions)) {
    return
  }
  var res = {};
  var attrs = data.attrs;
  var props = data.props;
  if (isDef(attrs) || isDef(props)) {
    for (var key in propOptions) {
      var altKey = hyphenate(key);
      checkProp(res, props, key, altKey, true) ||
      checkProp(res, attrs, key, altKey, false);
    }
  }
  return res
}

function checkProp (
  res,
  hash,
  key,
  altKey,
  preserve
) {
  if (isDef(hash)) {
    if (hasOwn(hash, key)) {
      res[key] = hash[key];
      if (!preserve) {
        delete hash[key];
      }
      return true
    } else if (hasOwn(hash, altKey)) {
      res[key] = hash[altKey];
      if (!preserve) {
        delete hash[altKey];
      }
      return true
    }
  }
  return false
}

/*  */

// The template compiler attempts to minimize the need for normalization by
// statically analyzing the template at compile time.
//
// For plain HTML markup, normalization can be completely skipped because the
// generated render function is guaranteed to return Array<VNode>. There are
// two cases where extra normalization is needed:

// 1. When the children contains components - because a functional component
// may return an Array instead of a single root. In this case, just a simple
// normalization is needed - if any child is an Array, we flatten the whole
// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep
// because functional components already normalize their own children.
function simpleNormalizeChildren (children) {
  for (var i = 0; i < children.length; i++) {
    if (Array.isArray(children[i])) {
      return Array.prototype.concat.apply([], children)
    }
  }
  return children
}

// 2. When the children contains constructs that always generated nested Arrays,
// e.g. <template>, <slot>, v-for, or when the children is provided by user
// with hand-written render functions / JSX. In such cases a full normalization
// is needed to cater to all possible types of children values.
function normalizeChildren (children) {
  return isPrimitive(children)
    ? [createTextVNode(children)]
    : Array.isArray(children)
      ? normalizeArrayChildren(children)
      : undefined
}

function isTextNode (node) {
  return isDef(node) && isDef(node.text) && isFalse(node.isComment)
}

function normalizeArrayChildren (children, nestedIndex) {
  var res = [];
  var i, c, last;
  for (i = 0; i < children.length; i++) {
    c = children[i];
    if (isUndef(c) || typeof c === 'boolean') { continue }
    last = res[res.length - 1];
    //  nested
    if (Array.isArray(c)) {
      res.push.apply(res, normalizeArrayChildren(c, ((nestedIndex || '') + "_" + i)));
    } else if (isPrimitive(c)) {
      if (isTextNode(last)) {
        // merge adjacent text nodes
        // this is necessary for SSR hydration because text nodes are
        // essentially merged when rendered to HTML strings
        (last).text += String(c);
      } else if (c !== '') {
        // convert primitive to vnode
        res.push(createTextVNode(c));
      }
    } else {
      if (isTextNode(c) && isTextNode(last)) {
        // merge adjacent text nodes
        res[res.length - 1] = createTextVNode(last.text + c.text);
      } else {
        // default key for nested array children (likely generated by v-for)
        if (isTrue(children._isVList) &&
          isDef(c.tag) &&
          isUndef(c.key) &&
          isDef(nestedIndex)) {
          c.key = "__vlist" + nestedIndex + "_" + i + "__";
        }
        res.push(c);
      }
    }
  }
  return res
}

/*  */

function ensureCtor (comp, base) {
  if (comp.__esModule && comp.default) {
    comp = comp.default;
  }
  return isObject(comp)
    ? base.extend(comp)
    : comp
}

function createAsyncPlaceholder (
  factory,
  data,
  context,
  children,
  tag
) {
  var node = createEmptyVNode();
  node.asyncFactory = factory;
  node.asyncMeta = { data: data, context: context, children: children, tag: tag };
  return node
}

function resolveAsyncComponent (
  factory,
  baseCtor,
  context
) {
  if (isTrue(factory.error) && isDef(factory.errorComp)) {
    return factory.errorComp
  }

  if (isDef(factory.resolved)) {
    return factory.resolved
  }

  if (isTrue(factory.loading) && isDef(factory.loadingComp)) {
    return factory.loadingComp
  }

  if (isDef(factory.contexts)) {
    // already pending
    factory.contexts.push(context);
  } else {
    var contexts = factory.contexts = [context];
    var sync = true;

    var forceRender = function () {
      for (var i = 0, l = contexts.length; i < l; i++) {
        contexts[i].$forceUpdate();
      }
    };

    var resolve = once(function (res) {
      // cache resolved
      factory.resolved = ensureCtor(res, baseCtor);
      // invoke callbacks only if this is not a synchronous resolve
      // (async resolves are shimmed as synchronous during SSR)
      if (!sync) {
        forceRender();
      }
    });

    var reject = once(function (reason) {
      "production" !== 'production' && warn(
        "Failed to resolve async component: " + (String(factory)) +
        (reason ? ("\nReason: " + reason) : '')
      );
      if (isDef(factory.errorComp)) {
        factory.error = true;
        forceRender();
      }
    });

    var res = factory(resolve, reject);

    if (isObject(res)) {
      if (typeof res.then === 'function') {
        // () => Promise
        if (isUndef(factory.resolved)) {
          res.then(resolve, reject);
        }
      } else if (isDef(res.component) && typeof res.component.then === 'function') {
        res.component.then(resolve, reject);

        if (isDef(res.error)) {
          factory.errorComp = ensureCtor(res.error, baseCtor);
        }

        if (isDef(res.loading)) {
          factory.loadingComp = ensureCtor(res.loading, baseCtor);
          if (res.delay === 0) {
            factory.loading = true;
          } else {
            setTimeout(function () {
              if (isUndef(factory.resolved) && isUndef(factory.error)) {
                factory.loading = true;
                forceRender();
              }
            }, res.delay || 200);
          }
        }

        if (isDef(res.timeout)) {
          setTimeout(function () {
            if (isUndef(factory.resolved)) {
              reject(
                null
              );
            }
          }, res.timeout);
        }
      }
    }

    sync = false;
    // return in case resolved synchronously
    return factory.loading
      ? factory.loadingComp
      : factory.resolved
  }
}

/*  */

function getFirstComponentChild (children) {
  if (Array.isArray(children)) {
    for (var i = 0; i < children.length; i++) {
      var c = children[i];
      if (isDef(c) && isDef(c.componentOptions)) {
        return c
      }
    }
  }
}

/*  */

/*  */

function initEvents (vm) {
  vm._events = Object.create(null);
  vm._hasHookEvent = false;
  // init parent attached events
  var listeners = vm.$options._parentListeners;
  if (listeners) {
    updateComponentListeners(vm, listeners);
  }
}

var target;

function add (event, fn, once$$1) {
  if (once$$1) {
    target.$once(event, fn);
  } else {
    target.$on(event, fn);
  }
}

function remove$1 (event, fn) {
  target.$off(event, fn);
}

function updateComponentListeners (
  vm,
  listeners,
  oldListeners
) {
  target = vm;
  updateListeners(listeners, oldListeners || {}, add, remove$1, vm);
}

function eventsMixin (Vue) {
  var hookRE = /^hook:/;
  Vue.prototype.$on = function (event, fn) {
    var this$1 = this;

    var vm = this;
    if (Array.isArray(event)) {
      for (var i = 0, l = event.length; i < l; i++) {
        this$1.$on(event[i], fn);
      }
    } else {
      (vm._events[event] || (vm._events[event] = [])).push(fn);
      // optimize hook:event cost by using a boolean flag marked at registration
      // instead of a hash lookup
      if (hookRE.test(event)) {
        vm._hasHookEvent = true;
      }
    }
    return vm
  };

  Vue.prototype.$once = function (event, fn) {
    var vm = this;
    function on () {
      vm.$off(event, on);
      fn.apply(vm, arguments);
    }
    on.fn = fn;
    vm.$on(event, on);
    return vm
  };

  Vue.prototype.$off = function (event, fn) {
    var this$1 = this;

    var vm = this;
    // all
    if (!arguments.length) {
      vm._events = Object.create(null);
      return vm
    }
    // array of events
    if (Array.isArray(event)) {
      for (var i$1 = 0, l = event.length; i$1 < l; i$1++) {
        this$1.$off(event[i$1], fn);
      }
      return vm
    }
    // specific event
    var cbs = vm._events[event];
    if (!cbs) {
      return vm
    }
    if (arguments.length === 1) {
      vm._events[event] = null;
      return vm
    }
    // specific handler
    var cb;
    var i = cbs.length;
    while (i--) {
      cb = cbs[i];
      if (cb === fn || cb.fn === fn) {
        cbs.splice(i, 1);
        break
      }
    }
    return vm
  };

  Vue.prototype.$emit = function (event) {
    var vm = this;
    var cbs = vm._events[event];
    if (cbs) {
      cbs = cbs.length > 1 ? toArray(cbs) : cbs;
      var args = toArray(arguments, 1);
      for (var i = 0, l = cbs.length; i < l; i++) {
        try {
          cbs[i].apply(vm, args);
        } catch (e) {
          handleError(e, vm, ("event handler for \"" + event + "\""));
        }
      }
    }
    return vm
  };
}

/*  */

/**
 * Runtime helper for resolving raw children VNodes into a slot object.
 */
function resolveSlots (
  children,
  context
) {
  var slots = {};
  if (!children) {
    return slots
  }
  var defaultSlot = [];
  for (var i = 0, l = children.length; i < l; i++) {
    var child = children[i];
    // named slots should only be respected if the vnode was rendered in the
    // same context.
    if ((child.context === context || child.functionalContext === context) &&
      child.data && child.data.slot != null
    ) {
      var name = child.data.slot;
      var slot = (slots[name] || (slots[name] = []));
      if (child.tag === 'template') {
        slot.push.apply(slot, child.children);
      } else {
        slot.push(child);
      }
    } else {
      defaultSlot.push(child);
    }
  }
  // ignore whitespace
  if (!defaultSlot.every(isWhitespace)) {
    slots.default = defaultSlot;
  }
  return slots
}

function isWhitespace (node) {
  return node.isComment || node.text === ' '
}

function resolveScopedSlots (
  fns, // see flow/vnode
  res
) {
  res = res || {};
  for (var i = 0; i < fns.length; i++) {
    if (Array.isArray(fns[i])) {
      resolveScopedSlots(fns[i], res);
    } else {
      res[fns[i].key] = fns[i].fn;
    }
  }
  return res
}

/*  */

var activeInstance = null;


function initLifecycle (vm) {
  var options = vm.$options;

  // locate first non-abstract parent
  var parent = options.parent;
  if (parent && !options.abstract) {
    while (parent.$options.abstract && parent.$parent) {
      parent = parent.$parent;
    }
    parent.$children.push(vm);
  }

  vm.$parent = parent;
  vm.$root = parent ? parent.$root : vm;

  vm.$children = [];
  vm.$refs = {};

  vm._watcher = null;
  vm._inactive = null;
  vm._directInactive = false;
  vm._isMounted = false;
  vm._isDestroyed = false;
  vm._isBeingDestroyed = false;
}

function lifecycleMixin (Vue) {
  Vue.prototype._update = function (vnode, hydrating) {
    var vm = this;
    if (vm._isMounted) {
      callHook(vm, 'beforeUpdate');
    }
    var prevEl = vm.$el;
    var prevVnode = vm._vnode;
    var prevActiveInstance = activeInstance;
    activeInstance = vm;
    vm._vnode = vnode;
    // Vue.prototype.__patch__ is injected in entry points
    // based on the rendering backend used.
    if (!prevVnode) {
      // initial render
      vm.$el = vm.__patch__(
        vm.$el, vnode, hydrating, false /* removeOnly */,
        vm.$options._parentElm,
        vm.$options._refElm
      );
      // no need for the ref nodes after initial patch
      // this prevents keeping a detached DOM tree in memory (#5851)
      vm.$options._parentElm = vm.$options._refElm = null;
    } else {
      // updates
      vm.$el = vm.__patch__(prevVnode, vnode);
    }
    activeInstance = prevActiveInstance;
    // update __vue__ reference
    if (prevEl) {
      prevEl.__vue__ = null;
    }
    if (vm.$el) {
      vm.$el.__vue__ = vm;
    }
    // if parent is an HOC, update its $el as well
    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
      vm.$parent.$el = vm.$el;
    }
    // updated hook is called by the scheduler to ensure that children are
    // updated in a parent's updated hook.
  };

  Vue.prototype.$forceUpdate = function () {
    var vm = this;
    if (vm._watcher) {
      vm._watcher.update();
    }
  };

  Vue.prototype.$destroy = function () {
    var vm = this;
    if (vm._isBeingDestroyed) {
      return
    }
    callHook(vm, 'beforeDestroy');
    vm._isBeingDestroyed = true;
    // remove self from parent
    var parent = vm.$parent;
    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
      remove(parent.$children, vm);
    }
    // teardown watchers
    if (vm._watcher) {
      vm._watcher.teardown();
    }
    var i = vm._watchers.length;
    while (i--) {
      vm._watchers[i].teardown();
    }
    // remove reference from data ob
    // frozen object may not have observer.
    if (vm._data.__ob__) {
      vm._data.__ob__.vmCount--;
    }
    // call the last hook...
    vm._isDestroyed = true;
    // invoke destroy hooks on current rendered tree
    vm.__patch__(vm._vnode, null);
    // fire destroyed hook
    callHook(vm, 'destroyed');
    // turn off all instance listeners.
    vm.$off();
    // remove __vue__ reference
    if (vm.$el) {
      vm.$el.__vue__ = null;
    }
  };
}

function mountComponent (
  vm,
  el,
  hydrating
) {
  vm.$el = el;
  if (!vm.$options.render) {
    vm.$options.render = createEmptyVNode;
    
  }
  callHook(vm, 'beforeMount');

  var updateComponent;
  /* istanbul ignore if */
  if (false) {
    updateComponent = function () {
      var name = vm._name;
      var id = vm._uid;
      var startTag = "vue-perf-start:" + id;
      var endTag = "vue-perf-end:" + id;

      mark(startTag);
      var vnode = vm._render();
      mark(endTag);
      measure((name + " render"), startTag, endTag);

      mark(startTag);
      vm._update(vnode, hydrating);
      mark(endTag);
      measure((name + " patch"), startTag, endTag);
    };
  } else {
    updateComponent = function () {
      vm._update(vm._render(), hydrating);
    };
  }

  vm._watcher = new Watcher(vm, updateComponent, noop);
  hydrating = false;

  // manually mounted instance, call mounted on self
  // mounted is called for render-created child components in its inserted hook
  if (vm.$vnode == null) {
    vm._isMounted = true;
    callHook(vm, 'mounted');
  }
  return vm
}

function updateChildComponent (
  vm,
  propsData,
  listeners,
  parentVnode,
  renderChildren
) {
  var hasChildren = !!(
    renderChildren ||               // has new static slots
    vm.$options._renderChildren ||  // has old static slots
    parentVnode.data.scopedSlots || // has new scoped slots
    vm.$scopedSlots !== emptyObject // has old scoped slots
  );

  vm.$options._parentVnode = parentVnode;
  vm.$vnode = parentVnode; // update vm's placeholder node without re-render

  if (vm._vnode) { // update child tree's parent
    vm._vnode.parent = parentVnode;
  }
  vm.$options._renderChildren = renderChildren;

  // update $attrs and $listensers hash
  // these are also reactive so they may trigger child update if the child
  // used them during render
  vm.$attrs = parentVnode.data && parentVnode.data.attrs;
  vm.$listeners = listeners;

  // update props
  if (propsData && vm.$options.props) {
    observerState.shouldConvert = false;
    var props = vm._props;
    var propKeys = vm.$options._propKeys || [];
    for (var i = 0; i < propKeys.length; i++) {
      var key = propKeys[i];
      props[key] = validateProp(key, vm.$options.props, propsData, vm);
    }
    observerState.shouldConvert = true;
    // keep a copy of raw propsData
    vm.$options.propsData = propsData;
  }

  // update listeners
  if (listeners) {
    var oldListeners = vm.$options._parentListeners;
    vm.$options._parentListeners = listeners;
    updateComponentListeners(vm, listeners, oldListeners);
  }
  // resolve slots + force update if has children
  if (hasChildren) {
    vm.$slots = resolveSlots(renderChildren, parentVnode.context);
    vm.$forceUpdate();
  }

  
}

function isInInactiveTree (vm) {
  while (vm && (vm = vm.$parent)) {
    if (vm._inactive) { return true }
  }
  return false
}

function activateChildComponent (vm, direct) {
  if (direct) {
    vm._directInactive = false;
    if (isInInactiveTree(vm)) {
      return
    }
  } else if (vm._directInactive) {
    return
  }
  if (vm._inactive || vm._inactive === null) {
    vm._inactive = false;
    for (var i = 0; i < vm.$children.length; i++) {
      activateChildComponent(vm.$children[i]);
    }
    callHook(vm, 'activated');
  }
}

function deactivateChildComponent (vm, direct) {
  if (direct) {
    vm._directInactive = true;
    if (isInInactiveTree(vm)) {
      return
    }
  }
  if (!vm._inactive) {
    vm._inactive = true;
    for (var i = 0; i < vm.$children.length; i++) {
      deactivateChildComponent(vm.$children[i]);
    }
    callHook(vm, 'deactivated');
  }
}

function callHook (vm, hook) {
  var handlers = vm.$options[hook];
  if (handlers) {
    for (var i = 0, j = handlers.length; i < j; i++) {
      try {
        handlers[i].call(vm);
      } catch (e) {
        handleError(e, vm, (hook + " hook"));
      }
    }
  }
  if (vm._hasHookEvent) {
    vm.$emit('hook:' + hook);
  }
}

/*  */


var MAX_UPDATE_COUNT = 100;

var queue = [];
var activatedChildren = [];
var has = {};
var circular = {};
var waiting = false;
var flushing = false;
var index = 0;

/**
 * Reset the scheduler's state.
 */
function resetSchedulerState () {
  index = queue.length = activatedChildren.length = 0;
  has = {};
  waiting = flushing = false;
}

/**
 * Flush both queues and run the watchers.
 */
function flushSchedulerQueue () {
  flushing = true;
  var watcher, id;

  // Sort queue before flush.
  // This ensures that:
  // 1. Components are updated from parent to child. (because parent is always
  //    created before the child)
  // 2. A component's user watchers are run before its render watcher (because
  //    user watchers are created before the render watcher)
  // 3. If a component is destroyed during a parent component's watcher run,
  //    its watchers can be skipped.
  queue.sort(function (a, b) { return a.id - b.id; });

  // do not cache length because more watchers might be pushed
  // as we run existing watchers
  for (index = 0; index < queue.length; index++) {
    watcher = queue[index];
    id = watcher.id;
    has[id] = null;
    watcher.run();
    // in dev build, check and stop circular updates.
    if (false) {
      circular[id] = (circular[id] || 0) + 1;
      if (circular[id] > MAX_UPDATE_COUNT) {
        warn(
          'You may have an infinite update loop ' + (
            watcher.user
              ? ("in watcher with expression \"" + (watcher.expression) + "\"")
              : "in a component render function."
          ),
          watcher.vm
        );
        break
      }
    }
  }

  // keep copies of post queues before resetting state
  var activatedQueue = activatedChildren.slice();
  var updatedQueue = queue.slice();

  resetSchedulerState();

  // call component updated and activated hooks
  callActivatedHooks(activatedQueue);
  callUpdatedHooks(updatedQueue);

  // devtool hook
  /* istanbul ignore if */
  if (devtools && config.devtools) {
    devtools.emit('flush');
  }
}

function callUpdatedHooks (queue) {
  var i = queue.length;
  while (i--) {
    var watcher = queue[i];
    var vm = watcher.vm;
    if (vm._watcher === watcher && vm._isMounted) {
      callHook(vm, 'updated');
    }
  }
}

/**
 * Queue a kept-alive component that was activated during patch.
 * The queue will be processed after the entire tree has been patched.
 */
function queueActivatedComponent (vm) {
  // setting _inactive to false here so that a render function can
  // rely on checking whether it's in an inactive tree (e.g. router-view)
  vm._inactive = false;
  activatedChildren.push(vm);
}

function callActivatedHooks (queue) {
  for (var i = 0; i < queue.length; i++) {
    queue[i]._inactive = true;
    activateChildComponent(queue[i], true /* true */);
  }
}

/**
 * Push a watcher into the watcher queue.
 * Jobs with duplicate IDs will be skipped unless it's
 * pushed when the queue is being flushed.
 */
function queueWatcher (watcher) {
  var id = watcher.id;
  if (has[id] == null) {
    has[id] = true;
    if (!flushing) {
      queue.push(watcher);
    } else {
      // if already flushing, splice the watcher based on its id
      // if already past its id, it will be run next immediately.
      var i = queue.length - 1;
      while (i > index && queue[i].id > watcher.id) {
        i--;
      }
      queue.splice(i + 1, 0, watcher);
    }
    // queue the flush
    if (!waiting) {
      waiting = true;
      nextTick(flushSchedulerQueue);
    }
  }
}

/*  */

var uid$2 = 0;

/**
 * A watcher parses an expression, collects dependencies,
 * and fires callback when the expression value changes.
 * This is used for both the $watch() api and directives.
 */
var Watcher = function Watcher (
  vm,
  expOrFn,
  cb,
  options
) {
  this.vm = vm;
  vm._watchers.push(this);
  // options
  if (options) {
    this.deep = !!options.deep;
    this.user = !!options.user;
    this.lazy = !!options.lazy;
    this.sync = !!options.sync;
  } else {
    this.deep = this.user = this.lazy = this.sync = false;
  }
  this.cb = cb;
  this.id = ++uid$2; // uid for batching
  this.active = true;
  this.dirty = this.lazy; // for lazy watchers
  this.deps = [];
  this.newDeps = [];
  this.depIds = new _Set();
  this.newDepIds = new _Set();
  this.expression = '';
  // parse expression for getter
  if (typeof expOrFn === 'function') {
    this.getter = expOrFn;
  } else {
    this.getter = parsePath(expOrFn);
    if (!this.getter) {
      this.getter = function () {};
      "production" !== 'production' && warn(
        "Failed watching path: \"" + expOrFn + "\" " +
        'Watcher only accepts simple dot-delimited paths. ' +
        'For full control, use a function instead.',
        vm
      );
    }
  }
  this.value = this.lazy
    ? undefined
    : this.get();
};

/**
 * Evaluate the getter, and re-collect dependencies.
 */
Watcher.prototype.get = function get () {
  pushTarget(this);
  var value;
  var vm = this.vm;
  try {
    value = this.getter.call(vm, vm);
  } catch (e) {
    if (this.user) {
      handleError(e, vm, ("getter for watcher \"" + (this.expression) + "\""));
    } else {
      throw e
    }
  } finally {
    // "touch" every property so they are all tracked as
    // dependencies for deep watching
    if (this.deep) {
      traverse(value);
    }
    popTarget();
    this.cleanupDeps();
  }
  return value
};

/**
 * Add a dependency to this directive.
 */
Watcher.prototype.addDep = function addDep (dep) {
  var id = dep.id;
  if (!this.newDepIds.has(id)) {
    this.newDepIds.add(id);
    this.newDeps.push(dep);
    if (!this.depIds.has(id)) {
      dep.addSub(this);
    }
  }
};

/**
 * Clean up for dependency collection.
 */
Watcher.prototype.cleanupDeps = function cleanupDeps () {
    var this$1 = this;

  var i = this.deps.length;
  while (i--) {
    var dep = this$1.deps[i];
    if (!this$1.newDepIds.has(dep.id)) {
      dep.removeSub(this$1);
    }
  }
  var tmp = this.depIds;
  this.depIds = this.newDepIds;
  this.newDepIds = tmp;
  this.newDepIds.clear();
  tmp = this.deps;
  this.deps = this.newDeps;
  this.newDeps = tmp;
  this.newDeps.length = 0;
};

/**
 * Subscriber interface.
 * Will be called when a dependency changes.
 */
Watcher.prototype.update = function update () {
  /* istanbul ignore else */
  if (this.lazy) {
    this.dirty = true;
  } else if (this.sync) {
    this.run();
  } else {
    queueWatcher(this);
  }
};

/**
 * Scheduler job interface.
 * Will be called by the scheduler.
 */
Watcher.prototype.run = function run () {
  if (this.active) {
    var value = this.get();
    if (
      value !== this.value ||
      // Deep watchers and watchers on Object/Arrays should fire even
      // when the value is the same, because the value may
      // have mutated.
      isObject(value) ||
      this.deep
    ) {
      // set new value
      var oldValue = this.value;
      this.value = value;
      if (this.user) {
        try {
          this.cb.call(this.vm, value, oldValue);
        } catch (e) {
          handleError(e, this.vm, ("callback for watcher \"" + (this.expression) + "\""));
        }
      } else {
        this.cb.call(this.vm, value, oldValue);
      }
    }
  }
};

/**
 * Evaluate the value of the watcher.
 * This only gets called for lazy watchers.
 */
Watcher.prototype.evaluate = function evaluate () {
  this.value = this.get();
  this.dirty = false;
};

/**
 * Depend on all deps collected by this watcher.
 */
Watcher.prototype.depend = function depend () {
    var this$1 = this;

  var i = this.deps.length;
  while (i--) {
    this$1.deps[i].depend();
  }
};

/**
 * Remove self from all dependencies' subscriber list.
 */
Watcher.prototype.teardown = function teardown () {
    var this$1 = this;

  if (this.active) {
    // remove self from vm's watcher list
    // this is a somewhat expensive operation so we skip it
    // if the vm is being destroyed.
    if (!this.vm._isBeingDestroyed) {
      remove(this.vm._watchers, this);
    }
    var i = this.deps.length;
    while (i--) {
      this$1.deps[i].removeSub(this$1);
    }
    this.active = false;
  }
};

/**
 * Recursively traverse an object to evoke all converted
 * getters, so that every nested property inside the object
 * is collected as a "deep" dependency.
 */
var seenObjects = new _Set();
function traverse (val) {
  seenObjects.clear();
  _traverse(val, seenObjects);
}

function _traverse (val, seen) {
  var i, keys;
  var isA = Array.isArray(val);
  if ((!isA && !isObject(val)) || !Object.isExtensible(val)) {
    return
  }
  if (val.__ob__) {
    var depId = val.__ob__.dep.id;
    if (seen.has(depId)) {
      return
    }
    seen.add(depId);
  }
  if (isA) {
    i = val.length;
    while (i--) { _traverse(val[i], seen); }
  } else {
    keys = Object.keys(val);
    i = keys.length;
    while (i--) { _traverse(val[keys[i]], seen); }
  }
}

/*  */

var sharedPropertyDefinition = {
  enumerable: true,
  configurable: true,
  get: noop,
  set: noop
};

function proxy (target, sourceKey, key) {
  sharedPropertyDefinition.get = function proxyGetter () {
    return this[sourceKey][key]
  };
  sharedPropertyDefinition.set = function proxySetter (val) {
    this[sourceKey][key] = val;
  };
  Object.defineProperty(target, key, sharedPropertyDefinition);
}

function initState (vm) {
  vm._watchers = [];
  var opts = vm.$options;
  if (opts.props) { initProps(vm, opts.props); }
  if (opts.methods) { initMethods(vm, opts.methods); }
  if (opts.data) {
    initData(vm);
  } else {
    observe(vm._data = {}, true /* asRootData */);
  }
  if (opts.computed) { initComputed(vm, opts.computed); }
  if (opts.watch && opts.watch !== nativeWatch) {
    initWatch(vm, opts.watch);
  }
}

function checkOptionType (vm, name) {
  var option = vm.$options[name];
  if (!isPlainObject(option)) {
    warn(
      ("component option \"" + name + "\" should be an object."),
      vm
    );
  }
}

function initProps (vm, propsOptions) {
  var propsData = vm.$options.propsData || {};
  var props = vm._props = {};
  // cache prop keys so that future props updates can iterate using Array
  // instead of dynamic object key enumeration.
  var keys = vm.$options._propKeys = [];
  var isRoot = !vm.$parent;
  // root instance props should be converted
  observerState.shouldConvert = isRoot;
  var loop = function ( key ) {
    keys.push(key);
    var value = validateProp(key, propsOptions, propsData, vm);
    /* istanbul ignore else */
    {
      defineReactive$$1(props, key, value);
    }
    // static props are already proxied on the component's prototype
    // during Vue.extend(). We only need to proxy props defined at
    // instantiation here.
    if (!(key in vm)) {
      proxy(vm, "_props", key);
    }
  };

  for (var key in propsOptions) loop( key );
  observerState.shouldConvert = true;
}

function initData (vm) {
  var data = vm.$options.data;
  data = vm._data = typeof data === 'function'
    ? getData(data, vm)
    : data || {};
  if (!isPlainObject(data)) {
    data = {};
    "production" !== 'production' && warn(
      'data functions should return an object:\n' +
      'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function',
      vm
    );
  }
  // proxy data on instance
  var keys = Object.keys(data);
  var props = vm.$options.props;
  var methods = vm.$options.methods;
  var i = keys.length;
  while (i--) {
    var key = keys[i];
    if (props && hasOwn(props, key)) {
      "production" !== 'production' && warn(
        "The data property \"" + key + "\" is already declared as a prop. " +
        "Use prop default value instead.",
        vm
      );
    } else if (!isReserved(key)) {
      proxy(vm, "_data", key);
    }
  }
  // observe data
  observe(data, true /* asRootData */);
}

function getData (data, vm) {
  try {
    return data.call(vm)
  } catch (e) {
    handleError(e, vm, "data()");
    return {}
  }
}

var computedWatcherOptions = { lazy: true };

function initComputed (vm, computed) {
  "production" !== 'production' && checkOptionType(vm, 'computed');
  var watchers = vm._computedWatchers = Object.create(null);

  for (var key in computed) {
    var userDef = computed[key];
    var getter = typeof userDef === 'function' ? userDef : userDef.get;
    watchers[key] = new Watcher(vm, getter, noop, computedWatcherOptions);

    // component-defined computed properties are already defined on the
    // component prototype. We only need to define computed properties defined
    // at instantiation here.
    if (!(key in vm)) {
      defineComputed(vm, key, userDef);
    } else {}
  }
}

function defineComputed (target, key, userDef) {
  if (typeof userDef === 'function') {
    sharedPropertyDefinition.get = createComputedGetter(key);
    sharedPropertyDefinition.set = noop;
  } else {
    sharedPropertyDefinition.get = userDef.get
      ? userDef.cache !== false
        ? createComputedGetter(key)
        : userDef.get
      : noop;
    sharedPropertyDefinition.set = userDef.set
      ? userDef.set
      : noop;
  }
  Object.defineProperty(target, key, sharedPropertyDefinition);
}

function createComputedGetter (key) {
  return function computedGetter () {
    var watcher = this._computedWatchers && this._computedWatchers[key];
    if (watcher) {
      if (watcher.dirty) {
        watcher.evaluate();
      }
      if (Dep.target) {
        watcher.depend();
      }
      return watcher.value
    }
  }
}

function initMethods (vm, methods) {
  "production" !== 'production' && checkOptionType(vm, 'methods');
  var props = vm.$options.props;
  for (var key in methods) {
    vm[key] = methods[key] == null ? noop : bind(methods[key], vm);
    
  }
}

function initWatch (vm, watch) {
  "production" !== 'production' && checkOptionType(vm, 'watch');
  for (var key in watch) {
    var handler = watch[key];
    if (Array.isArray(handler)) {
      for (var i = 0; i < handler.length; i++) {
        createWatcher(vm, key, handler[i]);
      }
    } else {
      createWatcher(vm, key, handler);
    }
  }
}

function createWatcher (
  vm,
  keyOrFn,
  handler,
  options
) {
  if (isPlainObject(handler)) {
    options = handler;
    handler = handler.handler;
  }
  if (typeof handler === 'string') {
    handler = vm[handler];
  }
  return vm.$watch(keyOrFn, handler, options)
}

function stateMixin (Vue) {
  // flow somehow has problems with directly declared definition object
  // when using Object.defineProperty, so we have to procedurally build up
  // the object here.
  var dataDef = {};
  dataDef.get = function () { return this._data };
  var propsDef = {};
  propsDef.get = function () { return this._props };
  Object.defineProperty(Vue.prototype, '$data', dataDef);
  Object.defineProperty(Vue.prototype, '$props', propsDef);

  Vue.prototype.$set = set;
  Vue.prototype.$delete = del;

  Vue.prototype.$watch = function (
    expOrFn,
    cb,
    options
  ) {
    var vm = this;
    if (isPlainObject(cb)) {
      return createWatcher(vm, expOrFn, cb, options)
    }
    options = options || {};
    options.user = true;
    var watcher = new Watcher(vm, expOrFn, cb, options);
    if (options.immediate) {
      cb.call(vm, watcher.value);
    }
    return function unwatchFn () {
      watcher.teardown();
    }
  };
}

/*  */

function initProvide (vm) {
  var provide = vm.$options.provide;
  if (provide) {
    vm._provided = typeof provide === 'function'
      ? provide.call(vm)
      : provide;
  }
}

function initInjections (vm) {
  var result = resolveInject(vm.$options.inject, vm);
  if (result) {
    observerState.shouldConvert = false;
    Object.keys(result).forEach(function (key) {
      /* istanbul ignore else */
      {
        defineReactive$$1(vm, key, result[key]);
      }
    });
    observerState.shouldConvert = true;
  }
}

function resolveInject (inject, vm) {
  if (inject) {
    // inject is :any because flow is not smart enough to figure out cached
    var result = Object.create(null);
    var keys = hasSymbol
        ? Reflect.ownKeys(inject)
        : Object.keys(inject);

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      var provideKey = inject[key];
      var source = vm;
      while (source) {
        if (source._provided && provideKey in source._provided) {
          result[key] = source._provided[provideKey];
          break
        }
        source = source.$parent;
      }
      if (false) {
        warn(("Injection \"" + key + "\" not found"), vm);
      }
    }
    return result
  }
}

/*  */

function createFunctionalComponent (
  Ctor,
  propsData,
  data,
  context,
  children
) {
  var props = {};
  var propOptions = Ctor.options.props;
  if (isDef(propOptions)) {
    for (var key in propOptions) {
      props[key] = validateProp(key, propOptions, propsData || {});
    }
  } else {
    if (isDef(data.attrs)) { mergeProps(props, data.attrs); }
    if (isDef(data.props)) { mergeProps(props, data.props); }
  }
  // ensure the createElement function in functional components
  // gets a unique context - this is necessary for correct named slot check
  var _context = Object.create(context);
  var h = function (a, b, c, d) { return createElement(_context, a, b, c, d, true); };
  var vnode = Ctor.options.render.call(null, h, {
    data: data,
    props: props,
    children: children,
    parent: context,
    listeners: data.on || {},
    injections: resolveInject(Ctor.options.inject, context),
    slots: function () { return resolveSlots(children, context); }
  });
  if (vnode instanceof VNode) {
    vnode.functionalContext = context;
    vnode.functionalOptions = Ctor.options;
    if (data.slot) {
      (vnode.data || (vnode.data = {})).slot = data.slot;
    }
  }
  return vnode
}

function mergeProps (to, from) {
  for (var key in from) {
    to[camelize(key)] = from[key];
  }
}

/*  */

// hooks to be invoked on component VNodes during patch
var componentVNodeHooks = {
  init: function init (
    vnode,
    hydrating,
    parentElm,
    refElm
  ) {
    if (!vnode.componentInstance || vnode.componentInstance._isDestroyed) {
      var child = vnode.componentInstance = createComponentInstanceForVnode(
        vnode,
        activeInstance,
        parentElm,
        refElm
      );
      child.$mount(hydrating ? vnode.elm : undefined, hydrating);
    } else if (vnode.data.keepAlive) {
      // kept-alive components, treat as a patch
      var mountedNode = vnode; // work around flow
      componentVNodeHooks.prepatch(mountedNode, mountedNode);
    }
  },

  prepatch: function prepatch (oldVnode, vnode) {
    var options = vnode.componentOptions;
    var child = vnode.componentInstance = oldVnode.componentInstance;
    updateChildComponent(
      child,
      options.propsData, // updated props
      options.listeners, // updated listeners
      vnode, // new parent vnode
      options.children // new children
    );
  },

  insert: function insert (vnode) {
    var context = vnode.context;
    var componentInstance = vnode.componentInstance;

    if (!componentInstance._isMounted) {
      componentInstance._isMounted = true;
      callHook(componentInstance, 'mounted');
    }
    if (vnode.data.keepAlive) {
      if (context._isMounted) {
        // vue-router#1212
        // During updates, a kept-alive component's child components may
        // change, so directly walking the tree here may call activated hooks
        // on incorrect children. Instead we push them into a queue which will
        // be processed after the whole patch process ended.
        queueActivatedComponent(componentInstance);
      } else {
        activateChildComponent(componentInstance, true /* direct */);
      }
    }
  },

  destroy: function destroy (vnode) {
    var componentInstance = vnode.componentInstance;
    if (!componentInstance._isDestroyed) {
      if (!vnode.data.keepAlive) {
        componentInstance.$destroy();
      } else {
        deactivateChildComponent(componentInstance, true /* direct */);
      }
    }
  }
};

var hooksToMerge = Object.keys(componentVNodeHooks);

function createComponent (
  Ctor,
  data,
  context,
  children,
  tag
) {
  if (isUndef(Ctor)) {
    return
  }

  var baseCtor = context.$options._base;

  // plain options object: turn it into a constructor
  if (isObject(Ctor)) {
    Ctor = baseCtor.extend(Ctor);
  }

  // if at this stage it's not a constructor or an async component factory,
  // reject.
  if (typeof Ctor !== 'function') {
    return
  }

  // async component
  var asyncFactory;
  if (isUndef(Ctor.cid)) {
    asyncFactory = Ctor;
    Ctor = resolveAsyncComponent(asyncFactory, baseCtor, context);
    if (Ctor === undefined) {
      // return a placeholder node for async component, which is rendered
      // as a comment node but preserves all the raw information for the node.
      // the information will be used for async server-rendering and hydration.
      return createAsyncPlaceholder(
        asyncFactory,
        data,
        context,
        children,
        tag
      )
    }
  }

  data = data || {};

  // resolve constructor options in case global mixins are applied after
  // component constructor creation
  resolveConstructorOptions(Ctor);

  // transform component v-model data into props & events
  if (isDef(data.model)) {
    transformModel(Ctor.options, data);
  }

  // extract props
  var propsData = extractPropsFromVNodeData(data, Ctor, tag);

  // functional component
  if (isTrue(Ctor.options.functional)) {
    return createFunctionalComponent(Ctor, propsData, data, context, children)
  }

  // keep listeners
  var listeners = data.on;

  if (isTrue(Ctor.options.abstract)) {
    // abstract components do not keep anything
    // other than props & listeners & slot

    // work around flow
    var slot = data.slot;
    data = {};
    if (slot) {
      data.slot = slot;
    }
  }

  // merge component management hooks onto the placeholder node
  mergeHooks(data);

  // return a placeholder vnode
  var name = Ctor.options.name || tag;
  var vnode = new VNode(
    ("vue-component-" + (Ctor.cid) + (name ? ("-" + name) : '')),
    data, undefined, undefined, undefined, context,
    { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children },
    asyncFactory
  );
  return vnode
}

function createComponentInstanceForVnode (
  vnode, // we know it's MountedComponentVNode but flow doesn't
  parent, // activeInstance in lifecycle state
  parentElm,
  refElm
) {
  var vnodeComponentOptions = vnode.componentOptions;
  var options = {
    _isComponent: true,
    parent: parent,
    propsData: vnodeComponentOptions.propsData,
    _componentTag: vnodeComponentOptions.tag,
    _parentVnode: vnode,
    _parentListeners: vnodeComponentOptions.listeners,
    _renderChildren: vnodeComponentOptions.children,
    _parentElm: parentElm || null,
    _refElm: refElm || null
  };
  // check inline-template render functions
  var inlineTemplate = vnode.data.inlineTemplate;
  if (isDef(inlineTemplate)) {
    options.render = inlineTemplate.render;
    options.staticRenderFns = inlineTemplate.staticRenderFns;
  }
  return new vnodeComponentOptions.Ctor(options)
}

function mergeHooks (data) {
  if (!data.hook) {
    data.hook = {};
  }
  for (var i = 0; i < hooksToMerge.length; i++) {
    var key = hooksToMerge[i];
    var fromParent = data.hook[key];
    var ours = componentVNodeHooks[key];
    data.hook[key] = fromParent ? mergeHook$1(ours, fromParent) : ours;
  }
}

function mergeHook$1 (one, two) {
  return function (a, b, c, d) {
    one(a, b, c, d);
    two(a, b, c, d);
  }
}

// transform component v-model info (value and callback) into
// prop and event handler respectively.
function transformModel (options, data) {
  var prop = (options.model && options.model.prop) || 'value';
  var event = (options.model && options.model.event) || 'input';(data.props || (data.props = {}))[prop] = data.model.value;
  var on = data.on || (data.on = {});
  if (isDef(on[event])) {
    on[event] = [data.model.callback].concat(on[event]);
  } else {
    on[event] = data.model.callback;
  }
}

/*  */

var SIMPLE_NORMALIZE = 1;
var ALWAYS_NORMALIZE = 2;

// wrapper function for providing a more flexible interface
// without getting yelled at by flow
function createElement (
  context,
  tag,
  data,
  children,
  normalizationType,
  alwaysNormalize
) {
  if (Array.isArray(data) || isPrimitive(data)) {
    normalizationType = children;
    children = data;
    data = undefined;
  }
  if (isTrue(alwaysNormalize)) {
    normalizationType = ALWAYS_NORMALIZE;
  }
  return _createElement(context, tag, data, children, normalizationType)
}

function _createElement (
  context,
  tag,
  data,
  children,
  normalizationType
) {
  if (isDef(data) && isDef((data).__ob__)) {
    "production" !== 'production' && warn(
      "Avoid using observed data object as vnode data: " + (JSON.stringify(data)) + "\n" +
      'Always create fresh vnode data objects in each render!',
      context
    );
    return createEmptyVNode()
  }
  // object syntax in v-bind
  if (isDef(data) && isDef(data.is)) {
    tag = data.is;
  }
  if (!tag) {
    // in case of component :is set to falsy value
    return createEmptyVNode()
  }
  // warn against non-primitive key
  if (false
  ) {
    warn(
      'Avoid using non-primitive value as key, ' +
      'use string/number value instead.',
      context
    );
  }
  // support single function children as default scoped slot
  if (Array.isArray(children) &&
    typeof children[0] === 'function'
  ) {
    data = data || {};
    data.scopedSlots = { default: children[0] };
    children.length = 0;
  }
  if (normalizationType === ALWAYS_NORMALIZE) {
    children = normalizeChildren(children);
  } else if (normalizationType === SIMPLE_NORMALIZE) {
    children = simpleNormalizeChildren(children);
  }
  var vnode, ns;
  if (typeof tag === 'string') {
    var Ctor;
    ns = config.getTagNamespace(tag);
    if (config.isReservedTag(tag)) {
      // platform built-in elements
      vnode = new VNode(
        config.parsePlatformTagName(tag), data, children,
        undefined, undefined, context
      );
    } else if (isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {
      // component
      vnode = createComponent(Ctor, data, context, children, tag);
    } else {
      // unknown or unlisted namespaced elements
      // check at runtime because it may get assigned a namespace when its
      // parent normalizes children
      vnode = new VNode(
        tag, data, children,
        undefined, undefined, context
      );
    }
  } else {
    // direct component options / constructor
    vnode = createComponent(tag, data, context, children);
  }
  if (isDef(vnode)) {
    if (ns) { applyNS(vnode, ns); }
    return vnode
  } else {
    return createEmptyVNode()
  }
}

function applyNS (vnode, ns) {
  vnode.ns = ns;
  if (vnode.tag === 'foreignObject') {
    // use default namespace inside foreignObject
    return
  }
  if (isDef(vnode.children)) {
    for (var i = 0, l = vnode.children.length; i < l; i++) {
      var child = vnode.children[i];
      if (isDef(child.tag) && isUndef(child.ns)) {
        applyNS(child, ns);
      }
    }
  }
}

/*  */

/**
 * Runtime helper for rendering v-for lists.
 */
function renderList (
  val,
  render
) {
  var ret, i, l, keys, key;
  if (Array.isArray(val) || typeof val === 'string') {
    ret = new Array(val.length);
    for (i = 0, l = val.length; i < l; i++) {
      ret[i] = render(val[i], i);
    }
  } else if (typeof val === 'number') {
    ret = new Array(val);
    for (i = 0; i < val; i++) {
      ret[i] = render(i + 1, i);
    }
  } else if (isObject(val)) {
    keys = Object.keys(val);
    ret = new Array(keys.length);
    for (i = 0, l = keys.length; i < l; i++) {
      key = keys[i];
      ret[i] = render(val[key], key, i);
    }
  }
  if (isDef(ret)) {
    (ret)._isVList = true;
  }
  return ret
}

/*  */

/**
 * Runtime helper for rendering <slot>
 */
function renderSlot (
  name,
  fallback,
  props,
  bindObject
) {
  var scopedSlotFn = this.$scopedSlots[name];
  if (scopedSlotFn) { // scoped slot
    props = props || {};
    if (bindObject) {
      props = extend(extend({}, bindObject), props);
    }
    return scopedSlotFn(props) || fallback
  } else {
    var slotNodes = this.$slots[name];
    // warn duplicate slot usage
    if (slotNodes && "production" !== 'production') {
      slotNodes._rendered && warn(
        "Duplicate presence of slot \"" + name + "\" found in the same render tree " +
        "- this will likely cause render errors.",
        this
      );
      slotNodes._rendered = true;
    }
    return slotNodes || fallback
  }
}

/*  */

/**
 * Runtime helper for resolving filters
 */
function resolveFilter (id) {
  return resolveAsset(this.$options, 'filters', id, true) || identity
}

/*  */

/**
 * Runtime helper for checking keyCodes from config.
 */
function checkKeyCodes (
  eventKeyCode,
  key,
  builtInAlias
) {
  var keyCodes = config.keyCodes[key] || builtInAlias;
  if (Array.isArray(keyCodes)) {
    return keyCodes.indexOf(eventKeyCode) === -1
  } else {
    return keyCodes !== eventKeyCode
  }
}

/*  */

/**
 * Runtime helper for merging v-bind="object" into a VNode's data.
 */
function bindObjectProps (
  data,
  tag,
  value,
  asProp,
  isSync
) {
  if (value) {
    if (!isObject(value)) {
      "production" !== 'production' && warn(
        'v-bind without argument expects an Object or Array value',
        this
      );
    } else {
      if (Array.isArray(value)) {
        value = toObject(value);
      }
      var hash;
      var loop = function ( key ) {
        if (
          key === 'class' ||
          key === 'style' ||
          isReservedAttribute(key)
        ) {
          hash = data;
        } else {
          var type = data.attrs && data.attrs.type;
          hash = asProp || config.mustUseProp(tag, type, key)
            ? data.domProps || (data.domProps = {})
            : data.attrs || (data.attrs = {});
        }
        if (!(key in hash)) {
          hash[key] = value[key];

          if (isSync) {
            var on = data.on || (data.on = {});
            on[("update:" + key)] = function ($event) {
              value[key] = $event;
            };
          }
        }
      };

      for (var key in value) loop( key );
    }
  }
  return data
}

/*  */

/**
 * Runtime helper for rendering static trees.
 */
function renderStatic (
  index,
  isInFor
) {
  var tree = this._staticTrees[index];
  // if has already-rendered static tree and not inside v-for,
  // we can reuse the same tree by doing a shallow clone.
  if (tree && !isInFor) {
    return Array.isArray(tree)
      ? cloneVNodes(tree)
      : cloneVNode(tree)
  }
  // otherwise, render a fresh tree.
  tree = this._staticTrees[index] =
    this.$options.staticRenderFns[index].call(this._renderProxy);
  markStatic(tree, ("__static__" + index), false);
  return tree
}

/**
 * Runtime helper for v-once.
 * Effectively it means marking the node as static with a unique key.
 */
function markOnce (
  tree,
  index,
  key
) {
  markStatic(tree, ("__once__" + index + (key ? ("_" + key) : "")), true);
  return tree
}

function markStatic (
  tree,
  key,
  isOnce
) {
  if (Array.isArray(tree)) {
    for (var i = 0; i < tree.length; i++) {
      if (tree[i] && typeof tree[i] !== 'string') {
        markStaticNode(tree[i], (key + "_" + i), isOnce);
      }
    }
  } else {
    markStaticNode(tree, key, isOnce);
  }
}

function markStaticNode (node, key, isOnce) {
  node.isStatic = true;
  node.key = key;
  node.isOnce = isOnce;
}

/*  */

function bindObjectListeners (data, value) {
  if (value) {
    if (!isPlainObject(value)) {
      "production" !== 'production' && warn(
        'v-on without argument expects an Object value',
        this
      );
    } else {
      var on = data.on = data.on ? extend({}, data.on) : {};
      for (var key in value) {
        var existing = on[key];
        var ours = value[key];
        on[key] = existing ? [].concat(ours, existing) : ours;
      }
    }
  }
  return data
}

/*  */

function initRender (vm) {
  vm._vnode = null; // the root of the child tree
  vm._staticTrees = null;
  var parentVnode = vm.$vnode = vm.$options._parentVnode; // the placeholder node in parent tree
  var renderContext = parentVnode && parentVnode.context;
  vm.$slots = resolveSlots(vm.$options._renderChildren, renderContext);
  vm.$scopedSlots = emptyObject;
  // bind the createElement fn to this instance
  // so that we get proper render context inside it.
  // args order: tag, data, children, normalizationType, alwaysNormalize
  // internal version is used by render functions compiled from templates
  vm._c = function (a, b, c, d) { return createElement(vm, a, b, c, d, false); };
  // normalization is always applied for the public version, used in
  // user-written render functions.
  vm.$createElement = function (a, b, c, d) { return createElement(vm, a, b, c, d, true); };

  // $attrs & $listeners are exposed for easier HOC creation.
  // they need to be reactive so that HOCs using them are always updated
  var parentData = parentVnode && parentVnode.data;
  /* istanbul ignore else */
  {
    defineReactive$$1(vm, '$attrs', parentData && parentData.attrs, null, true);
    defineReactive$$1(vm, '$listeners', parentData && parentData.on, null, true);
  }
}

function renderMixin (Vue) {
  Vue.prototype.$nextTick = function (fn) {
    return nextTick(fn, this)
  };

  Vue.prototype._render = function () {
    var vm = this;
    var ref = vm.$options;
    var render = ref.render;
    var staticRenderFns = ref.staticRenderFns;
    var _parentVnode = ref._parentVnode;

    if (vm._isMounted) {
      // clone slot nodes on re-renders
      for (var key in vm.$slots) {
        vm.$slots[key] = cloneVNodes(vm.$slots[key]);
      }
    }

    vm.$scopedSlots = (_parentVnode && _parentVnode.data.scopedSlots) || emptyObject;

    if (staticRenderFns && !vm._staticTrees) {
      vm._staticTrees = [];
    }
    // set parent vnode. this allows render functions to have access
    // to the data on the placeholder node.
    vm.$vnode = _parentVnode;
    // render self
    var vnode;
    try {
      vnode = render.call(vm._renderProxy, vm.$createElement);
    } catch (e) {
      handleError(e, vm, "render function");
      // return error render result,
      // or previous vnode to prevent render error causing blank component
      /* istanbul ignore else */
      {
        vnode = vm._vnode;
      }
    }
    // return empty vnode in case the render function errored out
    if (!(vnode instanceof VNode)) {
      if (false) {
        warn(
          'Multiple root nodes returned from render function. Render function ' +
          'should return a single root node.',
          vm
        );
      }
      vnode = createEmptyVNode();
    }
    // set parent
    vnode.parent = _parentVnode;
    return vnode
  };

  // internal render helpers.
  // these are exposed on the instance prototype to reduce generated render
  // code size.
  Vue.prototype._o = markOnce;
  Vue.prototype._n = toNumber;
  Vue.prototype._s = toString;
  Vue.prototype._l = renderList;
  Vue.prototype._t = renderSlot;
  Vue.prototype._q = looseEqual;
  Vue.prototype._i = looseIndexOf;
  Vue.prototype._m = renderStatic;
  Vue.prototype._f = resolveFilter;
  Vue.prototype._k = checkKeyCodes;
  Vue.prototype._b = bindObjectProps;
  Vue.prototype._v = createTextVNode;
  Vue.prototype._e = createEmptyVNode;
  Vue.prototype._u = resolveScopedSlots;
  Vue.prototype._g = bindObjectListeners;
}

/*  */

var uid = 0;

function initMixin (Vue) {
  Vue.prototype._init = function (options) {
    var vm = this;
    // a uid
    vm._uid = uid++;

    var startTag, endTag;
    /* istanbul ignore if */
    if (false) {
      startTag = "vue-perf-init:" + (vm._uid);
      endTag = "vue-perf-end:" + (vm._uid);
      mark(startTag);
    }

    // a flag to avoid this being observed
    vm._isVue = true;
    // merge options
    if (options && options._isComponent) {
      // optimize internal component instantiation
      // since dynamic options merging is pretty slow, and none of the
      // internal component options needs special treatment.
      initInternalComponent(vm, options);
    } else {
      vm.$options = mergeOptions(
        resolveConstructorOptions(vm.constructor),
        options || {},
        vm
      );
    }
    /* istanbul ignore else */
    {
      vm._renderProxy = vm;
    }
    // expose real self
    vm._self = vm;
    initLifecycle(vm);
    initEvents(vm);
    initRender(vm);
    callHook(vm, 'beforeCreate');
    initInjections(vm); // resolve injections before data/props
    initState(vm);
    initProvide(vm); // resolve provide after data/props
    callHook(vm, 'created');

    /* istanbul ignore if */
    if (false) {
      vm._name = formatComponentName(vm, false);
      mark(endTag);
      measure(((vm._name) + " init"), startTag, endTag);
    }

    if (vm.$options.el) {
      vm.$mount(vm.$options.el);
    }
  };
}

function initInternalComponent (vm, options) {
  var opts = vm.$options = Object.create(vm.constructor.options);
  // doing this because it's faster than dynamic enumeration.
  opts.parent = options.parent;
  opts.propsData = options.propsData;
  opts._parentVnode = options._parentVnode;
  opts._parentListeners = options._parentListeners;
  opts._renderChildren = options._renderChildren;
  opts._componentTag = options._componentTag;
  opts._parentElm = options._parentElm;
  opts._refElm = options._refElm;
  if (options.render) {
    opts.render = options.render;
    opts.staticRenderFns = options.staticRenderFns;
  }
}

function resolveConstructorOptions (Ctor) {
  var options = Ctor.options;
  if (Ctor.super) {
    var superOptions = resolveConstructorOptions(Ctor.super);
    var cachedSuperOptions = Ctor.superOptions;
    if (superOptions !== cachedSuperOptions) {
      // super option changed,
      // need to resolve new options.
      Ctor.superOptions = superOptions;
      // check if there are any late-modified/attached options (#4976)
      var modifiedOptions = resolveModifiedOptions(Ctor);
      // update base extend options
      if (modifiedOptions) {
        extend(Ctor.extendOptions, modifiedOptions);
      }
      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);
      if (options.name) {
        options.components[options.name] = Ctor;
      }
    }
  }
  return options
}

function resolveModifiedOptions (Ctor) {
  var modified;
  var latest = Ctor.options;
  var extended = Ctor.extendOptions;
  var sealed = Ctor.sealedOptions;
  for (var key in latest) {
    if (latest[key] !== sealed[key]) {
      if (!modified) { modified = {}; }
      modified[key] = dedupe(latest[key], extended[key], sealed[key]);
    }
  }
  return modified
}

function dedupe (latest, extended, sealed) {
  // compare latest and sealed to ensure lifecycle hooks won't be duplicated
  // between merges
  if (Array.isArray(latest)) {
    var res = [];
    sealed = Array.isArray(sealed) ? sealed : [sealed];
    extended = Array.isArray(extended) ? extended : [extended];
    for (var i = 0; i < latest.length; i++) {
      // push original options and not sealed options to exclude duplicated options
      if (extended.indexOf(latest[i]) >= 0 || sealed.indexOf(latest[i]) < 0) {
        res.push(latest[i]);
      }
    }
    return res
  } else {
    return latest
  }
}

function Vue$3 (options) {
  if (false
  ) {
    warn('Vue is a constructor and should be called with the `new` keyword');
  }
  this._init(options);
}

initMixin(Vue$3);
stateMixin(Vue$3);
eventsMixin(Vue$3);
lifecycleMixin(Vue$3);
renderMixin(Vue$3);

/*  */

function initUse (Vue) {
  Vue.use = function (plugin) {
    var installedPlugins = (this._installedPlugins || (this._installedPlugins = []));
    if (installedPlugins.indexOf(plugin) > -1) {
      return this
    }

    // additional parameters
    var args = toArray(arguments, 1);
    args.unshift(this);
    if (typeof plugin.install === 'function') {
      plugin.install.apply(plugin, args);
    } else if (typeof plugin === 'function') {
      plugin.apply(null, args);
    }
    installedPlugins.push(plugin);
    return this
  };
}

/*  */

function initMixin$1 (Vue) {
  Vue.mixin = function (mixin) {
    this.options = mergeOptions(this.options, mixin);
    return this
  };
}

/*  */

function initExtend (Vue) {
  /**
   * Each instance constructor, including Vue, has a unique
   * cid. This enables us to create wrapped "child
   * constructors" for prototypal inheritance and cache them.
   */
  Vue.cid = 0;
  var cid = 1;

  /**
   * Class inheritance
   */
  Vue.extend = function (extendOptions) {
    extendOptions = extendOptions || {};
    var Super = this;
    var SuperId = Super.cid;
    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});
    if (cachedCtors[SuperId]) {
      return cachedCtors[SuperId]
    }

    var name = extendOptions.name || Super.options.name;
    var Sub = function VueComponent (options) {
      this._init(options);
    };
    Sub.prototype = Object.create(Super.prototype);
    Sub.prototype.constructor = Sub;
    Sub.cid = cid++;
    Sub.options = mergeOptions(
      Super.options,
      extendOptions
    );
    Sub['super'] = Super;

    // For props and computed properties, we define the proxy getters on
    // the Vue instances at extension time, on the extended prototype. This
    // avoids Object.defineProperty calls for each instance created.
    if (Sub.options.props) {
      initProps$1(Sub);
    }
    if (Sub.options.computed) {
      initComputed$1(Sub);
    }

    // allow further extension/mixin/plugin usage
    Sub.extend = Super.extend;
    Sub.mixin = Super.mixin;
    Sub.use = Super.use;

    // create asset registers, so extended classes
    // can have their private assets too.
    ASSET_TYPES.forEach(function (type) {
      Sub[type] = Super[type];
    });
    // enable recursive self-lookup
    if (name) {
      Sub.options.components[name] = Sub;
    }

    // keep a reference to the super options at extension time.
    // later at instantiation we can check if Super's options have
    // been updated.
    Sub.superOptions = Super.options;
    Sub.extendOptions = extendOptions;
    Sub.sealedOptions = extend({}, Sub.options);

    // cache constructor
    cachedCtors[SuperId] = Sub;
    return Sub
  };
}

function initProps$1 (Comp) {
  var props = Comp.options.props;
  for (var key in props) {
    proxy(Comp.prototype, "_props", key);
  }
}

function initComputed$1 (Comp) {
  var computed = Comp.options.computed;
  for (var key in computed) {
    defineComputed(Comp.prototype, key, computed[key]);
  }
}

/*  */

function initAssetRegisters (Vue) {
  /**
   * Create asset registration methods.
   */
  ASSET_TYPES.forEach(function (type) {
    Vue[type] = function (
      id,
      definition
    ) {
      if (!definition) {
        return this.options[type + 's'][id]
      } else {
        /* istanbul ignore if */
        if (type === 'component' && isPlainObject(definition)) {
          definition.name = definition.name || id;
          definition = this.options._base.extend(definition);
        }
        if (type === 'directive' && typeof definition === 'function') {
          definition = { bind: definition, update: definition };
        }
        this.options[type + 's'][id] = definition;
        return definition
      }
    };
  });
}

/*  */

var patternTypes = [String, RegExp, Array];

function getComponentName (opts) {
  return opts && (opts.Ctor.options.name || opts.tag)
}

function matches (pattern, name) {
  if (Array.isArray(pattern)) {
    return pattern.indexOf(name) > -1
  } else if (typeof pattern === 'string') {
    return pattern.split(',').indexOf(name) > -1
  } else if (isRegExp(pattern)) {
    return pattern.test(name)
  }
  /* istanbul ignore next */
  return false
}

function pruneCache (cache, current, filter) {
  for (var key in cache) {
    var cachedNode = cache[key];
    if (cachedNode) {
      var name = getComponentName(cachedNode.componentOptions);
      if (name && !filter(name)) {
        if (cachedNode !== current) {
          pruneCacheEntry(cachedNode);
        }
        cache[key] = null;
      }
    }
  }
}

function pruneCacheEntry (vnode) {
  if (vnode) {
    vnode.componentInstance.$destroy();
  }
}

var KeepAlive = {
  name: 'keep-alive',
  abstract: true,

  props: {
    include: patternTypes,
    exclude: patternTypes
  },

  created: function created () {
    this.cache = Object.create(null);
  },

  destroyed: function destroyed () {
    var this$1 = this;

    for (var key in this$1.cache) {
      pruneCacheEntry(this$1.cache[key]);
    }
  },

  watch: {
    include: function include (val) {
      pruneCache(this.cache, this._vnode, function (name) { return matches(val, name); });
    },
    exclude: function exclude (val) {
      pruneCache(this.cache, this._vnode, function (name) { return !matches(val, name); });
    }
  },

  render: function render () {
    var vnode = getFirstComponentChild(this.$slots.default);
    var componentOptions = vnode && vnode.componentOptions;
    if (componentOptions) {
      // check pattern
      var name = getComponentName(componentOptions);
      if (name && (
        (this.include && !matches(this.include, name)) ||
        (this.exclude && matches(this.exclude, name))
      )) {
        return vnode
      }
      var key = vnode.key == null
        // same constructor may get registered as different local components
        // so cid alone is not enough (#3269)
        ? componentOptions.Ctor.cid + (componentOptions.tag ? ("::" + (componentOptions.tag)) : '')
        : vnode.key;
      if (this.cache[key]) {
        vnode.componentInstance = this.cache[key].componentInstance;
      } else {
        this.cache[key] = vnode;
      }
      vnode.data.keepAlive = true;
    }
    return vnode
  }
};

var builtInComponents = {
  KeepAlive: KeepAlive
};

/*  */

function initGlobalAPI (Vue) {
  // config
  var configDef = {};
  configDef.get = function () { return config; };
  Object.defineProperty(Vue, 'config', configDef);

  // exposed util methods.
  // NOTE: these are not considered part of the public API - avoid relying on
  // them unless you are aware of the risk.
  Vue.util = {
    warn: warn,
    extend: extend,
    mergeOptions: mergeOptions,
    defineReactive: defineReactive$$1
  };

  Vue.set = set;
  Vue.delete = del;
  Vue.nextTick = nextTick;

  Vue.options = Object.create(null);
  ASSET_TYPES.forEach(function (type) {
    Vue.options[type + 's'] = Object.create(null);
  });

  // this is used to identify the "base" constructor to extend all plain-object
  // components with in Weex's multi-instance scenarios.
  Vue.options._base = Vue;

  extend(Vue.options.components, builtInComponents);

  initUse(Vue);
  initMixin$1(Vue);
  initExtend(Vue);
  initAssetRegisters(Vue);
}

initGlobalAPI(Vue$3);

Object.defineProperty(Vue$3.prototype, '$isServer', {
  get: isServerRendering
});

Object.defineProperty(Vue$3.prototype, '$ssrContext', {
  get: function get () {
    /* istanbul ignore next */
    return this.$vnode && this.$vnode.ssrContext
  }
});

Vue$3.version = '2.4.1';
Vue$3.mpvueVersion = '2.0.6';

/* globals renderer */



var isReservedTag = makeMap(
  'template,script,style,element,content,slot,link,meta,svg,view,' +
  'a,div,img,image,text,span,richtext,input,switch,textarea,spinner,select,' +
  'slider,slider-neighbor,indicator,trisition,trisition-group,canvas,' +
  'list,cell,header,loading,loading-indicator,refresh,scrollable,scroller,' +
  'video,web,embed,tabbar,tabheader,datepicker,timepicker,marquee,countdown',
  true
);

// these are reserved for web because they are directly compiled away
// during template compilation
var isReservedAttr = makeMap('style,class');

// Elements that you can, intentionally, leave open (and which close themselves)
// more flexable than web
var canBeLeftOpenTag = makeMap(
  'web,spinner,switch,video,textarea,canvas,' +
  'indicator,marquee,countdown',
  true
);

var isUnaryTag = makeMap(
  'embed,img,image,input,link,meta',
  true
);

function mustUseProp () { /* console.log('mustUseProp') */ }
function getTagNamespace () { /* console.log('getTagNamespace') */ }
function isUnknownElement () { /* console.log('isUnknownElement') */ }



function getComKey (vm) {
  return vm && vm.$attrs ? vm.$attrs['mpcomid'] : '0'
}

// 用于小程序的 event type 到 web 的 event
var eventTypeMap = {
  tap: ['tap', 'click'],
  touchstart: ['touchstart'],
  touchmove: ['touchmove'],
  touchcancel: ['touchcancel'],
  touchend: ['touchend'],
  longtap: ['longtap'],
  input: ['input'],
  blur: ['change', 'blur'],
  submit: ['submit'],
  focus: ['focus'],
  scrolltoupper: ['scrolltoupper'],
  scrolltolower: ['scrolltolower'],
  scroll: ['scroll']
};

/*  */

// import { namespaceMap } from 'mp/util/index'

var obj = {};

function createElement$1 (tagName, vnode) {
  return obj
}

function createElementNS (namespace, tagName) {
  return obj
}

function createTextNode (text) {
  return obj
}

function createComment (text) {
  return obj
}

function insertBefore (parentNode, newNode, referenceNode) {}

function removeChild (node, child) {}

function appendChild (node, child) {}

function parentNode (node) {
  return obj
}

function nextSibling (node) {
  return obj
}

function tagName (node) {
  return 'div'
}

function setTextContent (node, text) {
  return obj
}

function setAttribute (node, key, val) {
  return obj
}


var nodeOps = Object.freeze({
	createElement: createElement$1,
	createElementNS: createElementNS,
	createTextNode: createTextNode,
	createComment: createComment,
	insertBefore: insertBefore,
	removeChild: removeChild,
	appendChild: appendChild,
	parentNode: parentNode,
	nextSibling: nextSibling,
	tagName: tagName,
	setTextContent: setTextContent,
	setAttribute: setAttribute
});

/*  */

var ref = {
  create: function create (_, vnode) {
    registerRef(vnode);
  },
  update: function update (oldVnode, vnode) {
    if (oldVnode.data.ref !== vnode.data.ref) {
      registerRef(oldVnode, true);
      registerRef(vnode);
    }
  },
  destroy: function destroy (vnode) {
    registerRef(vnode, true);
  }
};

function registerRef (vnode, isRemoval) {
  var key = vnode.data.ref;
  if (!key) { return }

  var vm = vnode.context;
  var ref = vnode.componentInstance || vnode.elm;
  var refs = vm.$refs;
  if (isRemoval) {
    if (Array.isArray(refs[key])) {
      remove(refs[key], ref);
    } else if (refs[key] === ref) {
      refs[key] = undefined;
    }
  } else {
    if (vnode.data.refInFor) {
      if (!Array.isArray(refs[key])) {
        refs[key] = [ref];
      } else if (refs[key].indexOf(ref) < 0) {
        // $flow-disable-line
        refs[key].push(ref);
      }
    } else {
      refs[key] = ref;
    }
  }
}

/**
 * Virtual DOM patching algorithm based on Snabbdom by
 * Simon Friis Vindum (@paldepind)
 * Licensed under the MIT License
 * https://github.com/paldepind/snabbdom/blob/master/LICENSE
 *
 * modified by Evan You (@yyx990803)
 *

/*
 * Not type-checking this because this file is perf-critical and the cost
 * of making flow understand it is not worth it.
 */

var emptyNode = new VNode('', {}, []);

var hooks = ['create', 'activate', 'update', 'remove', 'destroy'];

function sameVnode (a, b) {
  return (
    a.key === b.key && (
      (
        a.tag === b.tag &&
        a.isComment === b.isComment &&
        isDef(a.data) === isDef(b.data) &&
        sameInputType(a, b)
      ) || (
        isTrue(a.isAsyncPlaceholder) &&
        a.asyncFactory === b.asyncFactory &&
        isUndef(b.asyncFactory.error)
      )
    )
  )
}

// Some browsers do not support dynamically changing type for <input>
// so they need to be treated as different nodes
function sameInputType (a, b) {
  if (a.tag !== 'input') { return true }
  var i;
  var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;
  var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;
  return typeA === typeB
}

function createKeyToOldIdx (children, beginIdx, endIdx) {
  var i, key;
  var map = {};
  for (i = beginIdx; i <= endIdx; ++i) {
    key = children[i].key;
    if (isDef(key)) { map[key] = i; }
  }
  return map
}

function createPatchFunction (backend) {
  var i, j;
  var cbs = {};

  var modules = backend.modules;
  var nodeOps = backend.nodeOps;

  for (i = 0; i < hooks.length; ++i) {
    cbs[hooks[i]] = [];
    for (j = 0; j < modules.length; ++j) {
      if (isDef(modules[j][hooks[i]])) {
        cbs[hooks[i]].push(modules[j][hooks[i]]);
      }
    }
  }

  function emptyNodeAt (elm) {
    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm)
  }

  function createRmCb (childElm, listeners) {
    function remove$$1 () {
      if (--remove$$1.listeners === 0) {
        removeNode(childElm);
      }
    }
    remove$$1.listeners = listeners;
    return remove$$1
  }

  function removeNode (el) {
    var parent = nodeOps.parentNode(el);
    // element may have already been removed due to v-html / v-text
    if (isDef(parent)) {
      nodeOps.removeChild(parent, el);
    }
  }

  var inPre = 0;
  function createElm (vnode, insertedVnodeQueue, parentElm, refElm, nested) {
    vnode.isRootInsert = !nested; // for transition enter check
    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {
      return
    }

    var data = vnode.data;
    var children = vnode.children;
    var tag = vnode.tag;
    if (isDef(tag)) {
      vnode.elm = vnode.ns
        ? nodeOps.createElementNS(vnode.ns, tag)
        : nodeOps.createElement(tag, vnode);
      setScope(vnode);

      /* istanbul ignore if */
      {
        createChildren(vnode, children, insertedVnodeQueue);
        if (isDef(data)) {
          invokeCreateHooks(vnode, insertedVnodeQueue);
        }
        insert(parentElm, vnode.elm, refElm);
      }

      if (false) {
        inPre--;
      }
    } else if (isTrue(vnode.isComment)) {
      vnode.elm = nodeOps.createComment(vnode.text);
      insert(parentElm, vnode.elm, refElm);
    } else {
      vnode.elm = nodeOps.createTextNode(vnode.text);
      insert(parentElm, vnode.elm, refElm);
    }
  }

  function createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {
    var i = vnode.data;
    if (isDef(i)) {
      var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;
      if (isDef(i = i.hook) && isDef(i = i.init)) {
        i(vnode, false /* hydrating */, parentElm, refElm);
      }
      // after calling the init hook, if the vnode is a child component
      // it should've created a child instance and mounted it. the child
      // component also has set the placeholder vnode's elm.
      // in that case we can just return the element and be done.
      if (isDef(vnode.componentInstance)) {
        initComponent(vnode, insertedVnodeQueue);
        if (isTrue(isReactivated)) {
          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);
        }
        return true
      }
    }
  }

  function initComponent (vnode, insertedVnodeQueue) {
    if (isDef(vnode.data.pendingInsert)) {
      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);
      vnode.data.pendingInsert = null;
    }
    vnode.elm = vnode.componentInstance.$el;
    if (isPatchable(vnode)) {
      invokeCreateHooks(vnode, insertedVnodeQueue);
      setScope(vnode);
    } else {
      // empty component root.
      // skip all element-related modules except for ref (#3455)
      registerRef(vnode);
      // make sure to invoke the insert hook
      insertedVnodeQueue.push(vnode);
    }
  }

  function reactivateComponent (vnode, insertedVnodeQueue, parentElm, refElm) {
    var i;
    // hack for #4339: a reactivated component with inner transition
    // does not trigger because the inner node's created hooks are not called
    // again. It's not ideal to involve module-specific logic in here but
    // there doesn't seem to be a better way to do it.
    var innerNode = vnode;
    while (innerNode.componentInstance) {
      innerNode = innerNode.componentInstance._vnode;
      if (isDef(i = innerNode.data) && isDef(i = i.transition)) {
        for (i = 0; i < cbs.activate.length; ++i) {
          cbs.activate[i](emptyNode, innerNode);
        }
        insertedVnodeQueue.push(innerNode);
        break
      }
    }
    // unlike a newly created component,
    // a reactivated keep-alive component doesn't insert itself
    insert(parentElm, vnode.elm, refElm);
  }

  function insert (parent, elm, ref$$1) {
    if (isDef(parent)) {
      if (isDef(ref$$1)) {
        if (ref$$1.parentNode === parent) {
          nodeOps.insertBefore(parent, elm, ref$$1);
        }
      } else {
        nodeOps.appendChild(parent, elm);
      }
    }
  }

  function createChildren (vnode, children, insertedVnodeQueue) {
    if (Array.isArray(children)) {
      for (var i = 0; i < children.length; ++i) {
        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true);
      }
    } else if (isPrimitive(vnode.text)) {
      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(vnode.text));
    }
  }

  function isPatchable (vnode) {
    while (vnode.componentInstance) {
      vnode = vnode.componentInstance._vnode;
    }
    return isDef(vnode.tag)
  }

  function invokeCreateHooks (vnode, insertedVnodeQueue) {
    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
      cbs.create[i$1](emptyNode, vnode);
    }
    i = vnode.data.hook; // Reuse variable
    if (isDef(i)) {
      if (isDef(i.create)) { i.create(emptyNode, vnode); }
      if (isDef(i.insert)) { insertedVnodeQueue.push(vnode); }
    }
  }

  // set scope id attribute for scoped CSS.
  // this is implemented as a special case to avoid the overhead
  // of going through the normal attribute patching process.
  function setScope (vnode) {
    var i;
    var ancestor = vnode;
    while (ancestor) {
      if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {
        nodeOps.setAttribute(vnode.elm, i, '');
      }
      ancestor = ancestor.parent;
    }
    // for slot content they should also get the scopeId from the host instance.
    if (isDef(i = activeInstance) &&
      i !== vnode.context &&
      isDef(i = i.$options._scopeId)
    ) {
      nodeOps.setAttribute(vnode.elm, i, '');
    }
  }

  function addVnodes (parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {
    for (; startIdx <= endIdx; ++startIdx) {
      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm);
    }
  }

  function invokeDestroyHook (vnode) {
    var i, j;
    var data = vnode.data;
    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.destroy)) { i(vnode); }
      for (i = 0; i < cbs.destroy.length; ++i) { cbs.destroy[i](vnode); }
    }
    if (isDef(i = vnode.children)) {
      for (j = 0; j < vnode.children.length; ++j) {
        invokeDestroyHook(vnode.children[j]);
      }
    }
  }

  function removeVnodes (parentElm, vnodes, startIdx, endIdx) {
    for (; startIdx <= endIdx; ++startIdx) {
      var ch = vnodes[startIdx];
      if (isDef(ch)) {
        if (isDef(ch.tag)) {
          removeAndInvokeRemoveHook(ch);
          invokeDestroyHook(ch);
        } else { // Text node
          removeNode(ch.elm);
        }
      }
    }
  }

  function removeAndInvokeRemoveHook (vnode, rm) {
    if (isDef(rm) || isDef(vnode.data)) {
      var i;
      var listeners = cbs.remove.length + 1;
      if (isDef(rm)) {
        // we have a recursively passed down rm callback
        // increase the listeners count
        rm.listeners += listeners;
      } else {
        // directly removing
        rm = createRmCb(vnode.elm, listeners);
      }
      // recursively invoke hooks on child component root node
      if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {
        removeAndInvokeRemoveHook(i, rm);
      }
      for (i = 0; i < cbs.remove.length; ++i) {
        cbs.remove[i](vnode, rm);
      }
      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {
        i(vnode, rm);
      } else {
        rm();
      }
    } else {
      removeNode(vnode.elm);
    }
  }

  function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {
    var oldStartIdx = 0;
    var newStartIdx = 0;
    var oldEndIdx = oldCh.length - 1;
    var oldStartVnode = oldCh[0];
    var oldEndVnode = oldCh[oldEndIdx];
    var newEndIdx = newCh.length - 1;
    var newStartVnode = newCh[0];
    var newEndVnode = newCh[newEndIdx];
    var oldKeyToIdx, idxInOld, elmToMove, refElm;

    // removeOnly is a special flag used only by <transition-group>
    // to ensure removed elements stay in correct relative positions
    // during leaving transitions
    var canMove = !removeOnly;

    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
      if (isUndef(oldStartVnode)) {
        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left
      } else if (isUndef(oldEndVnode)) {
        oldEndVnode = oldCh[--oldEndIdx];
      } else if (sameVnode(oldStartVnode, newStartVnode)) {
        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);
        oldStartVnode = oldCh[++oldStartIdx];
        newStartVnode = newCh[++newStartIdx];
      } else if (sameVnode(oldEndVnode, newEndVnode)) {
        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);
        oldEndVnode = oldCh[--oldEndIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right
        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);
        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));
        oldStartVnode = oldCh[++oldStartIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left
        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);
        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
        oldEndVnode = oldCh[--oldEndIdx];
        newStartVnode = newCh[++newStartIdx];
      } else {
        if (isUndef(oldKeyToIdx)) { oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx); }
        idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : null;
        if (isUndef(idxInOld)) { // New element
          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);
          newStartVnode = newCh[++newStartIdx];
        } else {
          elmToMove = oldCh[idxInOld];
          /* istanbul ignore if */
          if (false) {
            warn(
              'It seems there are duplicate keys that is causing an update error. ' +
              'Make sure each v-for item has a unique key.'
            );
          }
          if (sameVnode(elmToMove, newStartVnode)) {
            patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);
            oldCh[idxInOld] = undefined;
            canMove && nodeOps.insertBefore(parentElm, elmToMove.elm, oldStartVnode.elm);
            newStartVnode = newCh[++newStartIdx];
          } else {
            // same key but different element. treat as new element
            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);
            newStartVnode = newCh[++newStartIdx];
          }
        }
      }
    }
    if (oldStartIdx > oldEndIdx) {
      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;
      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
    } else if (newStartIdx > newEndIdx) {
      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
    }
  }

  function patchVnode (oldVnode, vnode, insertedVnodeQueue, removeOnly) {
    if (oldVnode === vnode) {
      return
    }

    var elm = vnode.elm = oldVnode.elm;

    if (isTrue(oldVnode.isAsyncPlaceholder)) {
      if (isDef(vnode.asyncFactory.resolved)) {
        hydrate(oldVnode.elm, vnode, insertedVnodeQueue);
      } else {
        vnode.isAsyncPlaceholder = true;
      }
      return
    }

    // reuse element for static trees.
    // note we only do this if the vnode is cloned -
    // if the new node is not cloned it means the render functions have been
    // reset by the hot-reload-api and we need to do a proper re-render.
    if (isTrue(vnode.isStatic) &&
      isTrue(oldVnode.isStatic) &&
      vnode.key === oldVnode.key &&
      (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))
    ) {
      vnode.componentInstance = oldVnode.componentInstance;
      return
    }

    var i;
    var data = vnode.data;
    if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {
      i(oldVnode, vnode);
    }

    var oldCh = oldVnode.children;
    var ch = vnode.children;
    if (isDef(data) && isPatchable(vnode)) {
      for (i = 0; i < cbs.update.length; ++i) { cbs.update[i](oldVnode, vnode); }
      if (isDef(i = data.hook) && isDef(i = i.update)) { i(oldVnode, vnode); }
    }
    if (isUndef(vnode.text)) {
      if (isDef(oldCh) && isDef(ch)) {
        if (oldCh !== ch) { updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly); }
      } else if (isDef(ch)) {
        if (isDef(oldVnode.text)) { nodeOps.setTextContent(elm, ''); }
        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
      } else if (isDef(oldCh)) {
        removeVnodes(elm, oldCh, 0, oldCh.length - 1);
      } else if (isDef(oldVnode.text)) {
        nodeOps.setTextContent(elm, '');
      }
    } else if (oldVnode.text !== vnode.text) {
      nodeOps.setTextContent(elm, vnode.text);
    }
    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.postpatch)) { i(oldVnode, vnode); }
    }
  }

  function invokeInsertHook (vnode, queue, initial) {
    // delay insert hooks for component root nodes, invoke them after the
    // element is really inserted
    if (isTrue(initial) && isDef(vnode.parent)) {
      vnode.parent.data.pendingInsert = queue;
    } else {
      for (var i = 0; i < queue.length; ++i) {
        queue[i].data.hook.insert(queue[i]);
      }
    }
  }

  var bailed = false;
  // list of modules that can skip create hook during hydration because they
  // are already rendered on the client or has no need for initialization
  var isRenderedModule = makeMap('attrs,style,class,staticClass,staticStyle,key');

  // Note: this is a browser-only function so we can assume elms are DOM nodes.
  function hydrate (elm, vnode, insertedVnodeQueue) {
    if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {
      vnode.elm = elm;
      vnode.isAsyncPlaceholder = true;
      return true
    }
    vnode.elm = elm;
    var tag = vnode.tag;
    var data = vnode.data;
    var children = vnode.children;
    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.init)) { i(vnode, true /* hydrating */); }
      if (isDef(i = vnode.componentInstance)) {
        // child component. it should have hydrated its own tree.
        initComponent(vnode, insertedVnodeQueue);
        return true
      }
    }
    if (isDef(tag)) {
      if (isDef(children)) {
        // empty element, allow client to pick up and populate children
        if (!elm.hasChildNodes()) {
          createChildren(vnode, children, insertedVnodeQueue);
        } else {
          var childrenMatch = true;
          var childNode = elm.firstChild;
          for (var i$1 = 0; i$1 < children.length; i$1++) {
            if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue)) {
              childrenMatch = false;
              break
            }
            childNode = childNode.nextSibling;
          }
          // if childNode is not null, it means the actual childNodes list is
          // longer than the virtual children list.
          if (!childrenMatch || childNode) {
            if (false
            ) {
              bailed = true;
              console.warn('Parent: ', elm);
              console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);
            }
            return false
          }
        }
      }
      if (isDef(data)) {
        for (var key in data) {
          if (!isRenderedModule(key)) {
            invokeCreateHooks(vnode, insertedVnodeQueue);
            break
          }
        }
      }
    } else if (elm.data !== vnode.text) {
      elm.data = vnode.text;
    }
    return true
  }

  return function patch (oldVnode, vnode, hydrating, removeOnly, parentElm, refElm) {
    if (isUndef(vnode)) {
      if (isDef(oldVnode)) { invokeDestroyHook(oldVnode); }
      return
    }

    var isInitialPatch = false;
    var insertedVnodeQueue = [];

    if (isUndef(oldVnode)) {
      // empty mount (likely as component), create new root element
      isInitialPatch = true;
      createElm(vnode, insertedVnodeQueue, parentElm, refElm);
    } else {
      var isRealElement = isDef(oldVnode.nodeType);
      if (!isRealElement && sameVnode(oldVnode, vnode)) {
        // patch existing root node
        patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly);
      } else {
        if (isRealElement) {
          // mounting to a real element
          // check if this is server-rendered content and if we can perform
          // a successful hydration.
          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {
            oldVnode.removeAttribute(SSR_ATTR);
            hydrating = true;
          }
          if (isTrue(hydrating)) {
            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {
              invokeInsertHook(vnode, insertedVnodeQueue, true);
              return oldVnode
            } else {}
          }
          // either not server-rendered, or hydration failed.
          // create an empty node and replace it
          oldVnode = emptyNodeAt(oldVnode);
        }
        // replacing existing element
        var oldElm = oldVnode.elm;
        var parentElm$1 = nodeOps.parentNode(oldElm);
        createElm(
          vnode,
          insertedVnodeQueue,
          // extremely rare edge case: do not insert if old element is in a
          // leaving transition. Only happens when combining transition +
          // keep-alive + HOCs. (#4590)
          oldElm._leaveCb ? null : parentElm$1,
          nodeOps.nextSibling(oldElm)
        );

        if (isDef(vnode.parent)) {
          // component root element replaced.
          // update parent placeholder node element, recursively
          var ancestor = vnode.parent;
          while (ancestor) {
            ancestor.elm = vnode.elm;
            ancestor = ancestor.parent;
          }
          if (isPatchable(vnode)) {
            for (var i = 0; i < cbs.create.length; ++i) {
              cbs.create[i](emptyNode, vnode.parent);
            }
          }
        }

        if (isDef(parentElm$1)) {
          removeVnodes(parentElm$1, [oldVnode], 0, 0);
        } else if (isDef(oldVnode.tag)) {
          invokeDestroyHook(oldVnode);
        }
      }
    }

    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);
    return vnode.elm
  }
}

/*  */

// import baseModules from 'core/vdom/modules/index'
// const platformModules = []
// import platformModules from 'web/runtime/modules/index'

// the directive module should be applied last, after all
// built-in modules have been applied.
// const modules = platformModules.concat(baseModules)
var modules = [ref];

var corePatch = createPatchFunction({ nodeOps: nodeOps, modules: modules });

function patch () {
  corePatch.apply(this, arguments);
  this.$updateDataToMP();
}

function callHook$1 (vm, hook, params) {
  var handlers = vm.$options[hook];
  if (hook === 'onError' && handlers) {
    handlers = [handlers];
  } else if (hook === 'onPageNotFound' && handlers) {
    handlers = [handlers];
  }

  var ret;
  if (handlers) {
    for (var i = 0, j = handlers.length; i < j; i++) {
      try {
        ret = handlers[i].call(vm, params);
      } catch (e) {
        handleError(e, vm, (hook + " hook"));
      }
    }
  }
  if (vm._hasHookEvent) {
    vm.$emit('hook:' + hook);
  }

  // for child
  if (vm.$children.length) {
    vm.$children.forEach(function (v) { return callHook$1(v, hook, params); });
  }

  return ret
}

// mpType 小程序实例的类型，可能的值是 'app', 'page'
// rootVueVM 是 vue 的根组件实例，子组件中访问 this.$root 可得
function getGlobalData (app, rootVueVM) {
  var mp = rootVueVM.$mp;
  if (app && app.globalData) {
    mp.appOptions = app.globalData.appOptions;
  }
}

// 格式化 properties 属性，并给每个属性加上 observer 方法

// properties 的 一些类型 https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/component.html
// properties: {
//   paramA: Number,
//   myProperty: { // 属性名
//     type: String, // 类型（必填），目前接受的类型包括：String, Number, Boolean, Object, Array, null（表示任意类型）
//     value: '', // 属性初始值（可选），如果未指定则会根据类型选择一个
//     observer: function(newVal, oldVal, changedPath) {
//        // 属性被改变时执行的函数（可选），也可以写成在methods段中定义的方法名字符串, 如：'_propertyChange'
//        // 通常 newVal 就是新设置的数据， oldVal 是旧数据
//     }
//   },
// }

// props 的一些类型 https://cn.vuejs.org/v2/guide/components-props.html#ad
// props: {
//   // 基础的类型检查 (`null` 匹配任何类型)
//   propA: Number,
//   // 多个可能的类型
//   propB: [String, Number],
//   // 必填的字符串
//   propC: {
//     type: String,
//     required: true
//   },
//   // 带有默认值的数字
//   propD: {
//     type: Number,
//     default: 100
//   },
//   // 带有默认值的对象
//   propE: {
//     type: Object,
//     // 对象或数组且一定会从一个工厂函数返回默认值
//     default: function () {
//       return { message: 'hello' }
//     }
//   },
//   // 自定义验证函数
//   propF: {
//     validator: function (value) {
//       // 这个值必须匹配下列字符串中的一个
//       return ['success', 'warning', 'danger'].indexOf(value) !== -1
//     }
//   }
// }

// core/util/options
function normalizeProps$1 (props, res, vm) {
  if (!props) { return }
  var i, val, name;
  if (Array.isArray(props)) {
    i = props.length;
    while (i--) {
      val = props[i];
      if (typeof val === 'string') {
        name = camelize(val);
        res[name] = { type: null };
      } else {}
    }
  } else if (isPlainObject(props)) {
    for (var key in props) {
      val = props[key];
      name = camelize(key);
      res[name] = isPlainObject(val)
        ? val
        : { type: val };
    }
  }

  // fix vueProps to properties
  for (var key$1 in res) {
    if (res.hasOwnProperty(key$1)) {
      var item = res[key$1];
      if (item.default) {
        item.value = item.default;
      }
      var oldObserver = item.observer;
      item.observer = function (newVal, oldVal) {
        vm[name] = newVal;
        // 先修改值再触发原始的 observer，跟 watch 行为保持一致
        if (typeof oldObserver === 'function') {
          oldObserver.call(vm, newVal, oldVal);
        }
      };
    }
  }

  return res
}

function normalizeProperties (vm) {
  var properties = vm.$options.properties;
  var vueProps = vm.$options.props;
  var res = {};

  normalizeProps$1(properties, res, vm);
  normalizeProps$1(vueProps, res, vm);

  return res
}

/**
 * 把 properties 中的属性 proxy 到 vm 上
 */
function initMpProps (vm) {
  var mpProps = vm._mpProps = {};
  var keys = Object.keys(vm.$options.properties || {});
  keys.forEach(function (key) {
    if (!(key in vm)) {
      proxy(vm, '_mpProps', key);
      mpProps[key] = undefined; // for observe
    }
  });
  observe(mpProps, true);
}

function initMP (mpType, next) {
  var rootVueVM = this.$root;
  if (!rootVueVM.$mp) {
    rootVueVM.$mp = {};
  }

  var mp = rootVueVM.$mp;

  // Please do not register multiple Pages
  // if (mp.registered) {
  if (mp.status) {
    // 处理子组件的小程序生命周期
    if (mpType === 'app') {
      callHook$1(this, 'onLaunch', mp.appOptions);
    } else {
      callHook$1(this, 'onLoad', mp.query);
      callHook$1(this, 'onReady');
    }
    return next()
  }
  // mp.registered = true

  mp.mpType = mpType;
  mp.status = 'register';

  if (mpType === 'app') {
    global.App({
      // 页面的初始数据
      globalData: {
        appOptions: {}
      },

      handleProxy: function handleProxy (e) {
        return rootVueVM.$handleProxyWithVue(e)
      },

      // Do something initial when launch.
      onLaunch: function onLaunch (options) {
        if ( options === void 0 ) options = {};

        mp.app = this;
        mp.status = 'launch';
        this.globalData.appOptions = mp.appOptions = options;
        callHook$1(rootVueVM, 'onLaunch', options);
        next();
      },

      // Do something when app show.
      onShow: function onShow (options) {
        if ( options === void 0 ) options = {};

        mp.status = 'show';
        this.globalData.appOptions = mp.appOptions = options;
        callHook$1(rootVueVM, 'onShow', options);
      },

      // Do something when app hide.
      onHide: function onHide () {
        mp.status = 'hide';
        callHook$1(rootVueVM, 'onHide');
      },

      onError: function onError (err) {
        callHook$1(rootVueVM, 'onError', err);
      },

      onPageNotFound: function onPageNotFound (err) {
        callHook$1(rootVueVM, 'onPageNotFound', err);
      }
    });
  } else if (mpType === 'component') {
    initMpProps(rootVueVM);

    global.Component({
      // 小程序原生的组件属性
      properties: normalizeProperties(rootVueVM),
      // 页面的初始数据
      data: {
        $root: {}
      },
      methods: {
        handleProxy: function handleProxy (e) {
          return rootVueVM.$handleProxyWithVue(e)
        }
      },
      // mp lifecycle for vue
      // 组件生命周期函数，在组件实例进入页面节点树时执行，注意此时不能调用 setData
      created: function created () {
        mp.status = 'created';
        mp.page = this;
      },
      // 组件生命周期函数，在组件实例进入页面节点树时执行
      attached: function attached () {
        mp.status = 'attached';
        callHook$1(rootVueVM, 'attached');
      },
      // 组件生命周期函数，在组件布局完成后执行，此时可以获取节点信息（使用 SelectorQuery ）
      ready: function ready () {
        mp.status = 'ready';

        callHook$1(rootVueVM, 'ready');
        next();

        // 只有页面需要 setData
        rootVueVM.$nextTick(function () {
          rootVueVM._initDataToMP();
        });
      },
      // 组件生命周期函数，在组件实例被移动到节点树另一个位置时执行
      moved: function moved () {
        callHook$1(rootVueVM, 'moved');
      },
      // 组件生命周期函数，在组件实例被从页面节点树移除时执行
      detached: function detached () {
        mp.status = 'detached';
        callHook$1(rootVueVM, 'detached');
      }
    });
  } else {
    var app = global.getApp();
    global.Page({
      // 页面的初始数据
      data: {
        $root: {}
      },

      handleProxy: function handleProxy (e) {
        return rootVueVM.$handleProxyWithVue(e)
      },

      // mp lifecycle for vue
      // 生命周期函数--监听页面加载
      onLoad: function onLoad (query) {
        mp.page = this;
        mp.query = query;
        mp.status = 'load';
        getGlobalData(app, rootVueVM);
        callHook$1(rootVueVM, 'onLoad', query);
      },

      // 生命周期函数--监听页面显示
      onShow: function onShow () {
        mp.page = this;
        mp.status = 'show';
        callHook$1(rootVueVM, 'onShow');

        // 只有页面需要 setData
        rootVueVM.$nextTick(function () {
          rootVueVM._initDataToMP();
        });
      },

      // 生命周期函数--监听页面初次渲染完成
      onReady: function onReady () {
        mp.status = 'ready';

        callHook$1(rootVueVM, 'onReady');
        next();
      },

      // 生命周期函数--监听页面隐藏
      onHide: function onHide () {
        mp.status = 'hide';
        callHook$1(rootVueVM, 'onHide');
        mp.page = null;
      },

      // 生命周期函数--监听页面卸载
      onUnload: function onUnload () {
        mp.status = 'unload';
        callHook$1(rootVueVM, 'onUnload');
        mp.page = null;
      },

      // 页面相关事件处理函数--监听用户下拉动作
      onPullDownRefresh: function onPullDownRefresh () {
        callHook$1(rootVueVM, 'onPullDownRefresh');
      },

      // 页面上拉触底事件的处理函数
      onReachBottom: function onReachBottom () {
        callHook$1(rootVueVM, 'onReachBottom');
      },

      // 用户点击右上角分享
      onShareAppMessage: rootVueVM.$options.onShareAppMessage
        ? function (options) { return callHook$1(rootVueVM, 'onShareAppMessage', options); } : null,

      // Do something when page scroll
      onPageScroll: function onPageScroll (options) {
        callHook$1(rootVueVM, 'onPageScroll', options);
      },

      // 当前是 tab 页时，点击 tab 时触发
      onTabItemTap: function onTabItemTap (options) {
        callHook$1(rootVueVM, 'onTabItemTap', options);
      }
    });
  }
}

var updateDataTotal = 0; // 总共更新的数据量
function diffLog (updateData) {
  updateData = JSON.stringify(updateData);
  if (!Vue$3._mpvueTraceTimer) {
    Vue$3._mpvueTraceTimer = setTimeout(function () {
      clearTimeout(Vue$3._mpvueTraceTimer);
      updateDataTotal = (updateDataTotal / 1024).toFixed(1);
      console.log('这次操作引发500ms内数据更新量:' + updateDataTotal + 'kb');
      Vue$3._mpvueTraceTimer = 0;
      updateDataTotal = 0;
    }, 500);
  } else if (Vue$3._mpvueTraceTimer) {
    updateData = updateData.replace(/[^\u0000-\u00ff]/g, 'aa'); // 中文占2字节，中文替换成两个字母计算占用空间
    updateDataTotal += updateData.length;
  }
}

var KEY_SEP$1 = '_';

function getDeepData (keyList, viewData) {
  if (keyList.length > 1) {
    var _key = keyList.splice(0, 1);
    var _viewData = viewData[_key];
    if (_viewData) {
      return getDeepData(keyList, _viewData)
    } else {
      return null
    }
  } else {
    if (viewData[keyList[0]]) {
      return viewData[keyList[0]]
    } else {
      return null
    }
  }
}

function compareAndSetDeepData (key, newData, vm, data, forceUpdate) {
  // 比较引用类型数据
  try {
    var keyList = key.split('.');
    // page.__viewData__老版小程序不存在，使用mpvue里绑的data比对
    var oldData = getDeepData(keyList, vm.$root.$mp.page.data);
    if (oldData === null || JSON.stringify(oldData) !== JSON.stringify(newData) || forceUpdate) {
      data[key] = newData;
    } else {
      var keys = Object.keys(oldData);
      keys.forEach(function (_key) {
        var properties = Object.getOwnPropertyDescriptor(oldData, _key);
        if (!properties['get'] && !properties['set']) {
          data[key + '.' + _key] = newData[_key];
        }
      });
    }
  } catch (e) {
    console.log(e, key, newData, vm);
  }
}

function cleanKeyPath (vm) {
  if (vm.__mpKeyPath) {
    Object.keys(vm.__mpKeyPath).forEach(function (_key) {
      delete vm.__mpKeyPath[_key]['__keyPath'];
    });
  }
}

function minifyDeepData (rootKey, originKey, vmData, data, _mpValueSet, vm) {
  try {
    if (vmData instanceof Array) {
       // 数组
      compareAndSetDeepData(rootKey + '.' + originKey, vmData, vm, data, true);
    } else {
      // Object
      var _keyPathOnThis = {}; // 存储这层对象的keyPath
      if (vmData.__keyPath && !vmData.__newReference) {
        // 有更新列表 ，按照更新列表更新
        _keyPathOnThis = vmData.__keyPath;
        Object.keys(vmData).forEach(function (_key) {
          if (vmData[_key] instanceof Object) {
            // 引用类型 递归
            if (_key === '__keyPath') {
              return
            }
            minifyDeepData(rootKey + '.' + originKey, _key, vmData[_key], data, null, vm);
          } else {
            // 更新列表中的 加入data
            if (_keyPathOnThis[_key] === true) {
              if (originKey) {
                data[rootKey + '.' + originKey + '.' + _key] = vmData[_key];
              } else {
                data[rootKey + '.' + _key] = vmData[_key];
              }
            }
          }
        });
         // 根节点可能有父子引用同一个引用类型数据，依赖树都遍历完后清理
        vm['__mpKeyPath'] = vm['__mpKeyPath'] || {};
        vm['__mpKeyPath'][vmData.__ob__.dep.id] = vmData;
      } else {
        // 没有更新列表
        compareAndSetDeepData(rootKey + '.' + originKey, vmData, vm, data);
      }
      // 标记是否是通过this.Obj = {} 赋值印发的改动，解决少更新问题#1305
      def(vmData, '__newReference', false, false);
    }
  } catch (e) {
    console.log(e, rootKey, originKey, vmData, data);
  }
}

function getRootKey (vm, rootKey) {
  if (!vm.$parent.$attrs) {
    rootKey = '$root.0' + KEY_SEP$1 + rootKey;
    return rootKey
  } else {
    rootKey = vm.$parent.$attrs.mpcomid + KEY_SEP$1 + rootKey;
    return getRootKey(vm.$parent, rootKey)
  }
}

function diffData (vm, data) {
  var vmData = vm._data || {};
  var vmProps = vm._props || {};
  var rootKey = '';
  if (!vm.$attrs) {
    rootKey = '$root.0';
  } else {
    rootKey = getRootKey(vm, vm.$attrs.mpcomid);
  }
  Vue$3.nextTick(function () {
    cleanKeyPath(vm);
  });
  // console.log(rootKey)

  // 值类型变量不考虑优化，还是直接更新
  var __keyPathOnThis = vmData.__keyPath || vm.__keyPath || {};
  delete vm.__keyPath;
  delete vmData.__keyPath;
  delete vmProps.__keyPath;
  if (vm._mpValueSet === 'done') {
    // 第二次赋值才进行缩减操作
    Object.keys(vmData).forEach(function (vmDataItemKey) {
      if (vmData[vmDataItemKey] instanceof Object) {
        // 引用类型
        minifyDeepData(rootKey, vmDataItemKey, vmData[vmDataItemKey], data, vm._mpValueSet, vm);
      } else if (vmData[vmDataItemKey] !== undefined) {
        // _data上的值属性只有要更新的时候才赋值
        if (__keyPathOnThis[vmDataItemKey] === true) {
          data[rootKey + '.' + vmDataItemKey] = vmData[vmDataItemKey];
        }
      }
    });

    Object.keys(vmProps).forEach(function (vmPropsItemKey) {
      if (vmProps[vmPropsItemKey] instanceof Object) {
        // 引用类型
        minifyDeepData(rootKey, vmPropsItemKey, vmProps[vmPropsItemKey], data, vm._mpValueSet, vm);
      } else if (vmProps[vmPropsItemKey] !== undefined) {
        data[rootKey + '.' + vmPropsItemKey] = vmProps[vmPropsItemKey];
      }
      // _props上的值属性只有要更新的时候才赋值
    });

    // 检查完data和props,最后补上_mpProps & _computedWatchers
    var vmMpProps = vm._mpProps || {};
    var vmComputedWatchers = vm._computedWatchers || {};
    Object.keys(vmMpProps).forEach(function (mpItemKey) {
      data[rootKey + '.' + mpItemKey] = vm[mpItemKey];
    });
    Object.keys(vmComputedWatchers).forEach(function (computedItemKey) {
      data[rootKey + '.' + computedItemKey] = vm[computedItemKey];
    });
    // 更新的时候要删除$root.0:{},否则会覆盖原正确数据
    delete data[rootKey];
  }
  if (vm._mpValueSet === undefined) {
    // 第一次设置数据成功后，标记位置true,再更新到这个节点如果没有keyPath数组认为不需要更新
    vm._mpValueSet = 'done';
  }
  if (Vue$3.config._mpTrace) {
    // console.log('更新VM节点', vm)
    // console.log('实际传到Page.setData数据', data)
    diffLog(data);
  }
}

// 节流方法，性能优化
// 全局的命名约定，为了节省编译的包大小一律采取形象的缩写，说明如下。
// $c === $child
// $k === $comKey

// 新型的被拍平的数据结构
// {
//   $root: {
//     '1-1'{
//       // ... data
//     },
//     '1.2-1': {
//       // ... data1
//     },
//     '1.2-2': {
//       // ... data2
//     }
//   }
// }

var KEY_SEP = '_';

function getVmData (vm) {
  // 确保当前 vm 所有数据被同步
  var dataKeys = [].concat(
    Object.keys(vm._data || {}),
    Object.keys(vm._props || {}),
    Object.keys(vm._mpProps || {}),
    Object.keys(vm._computedWatchers || {})
  );
  return dataKeys.reduce(function (res, key) {
    res[key] = vm[key];
    return res
  }, {})
}

function getParentComKey (vm, res) {
  if ( res === void 0 ) res = [];

  var ref = vm || {};
  var $parent = ref.$parent;
  if (!$parent) { return res }
  res.unshift(getComKey($parent));
  if ($parent.$parent) {
    return getParentComKey($parent, res)
  }
  return res
}

function formatVmData (vm) {
  var $p = getParentComKey(vm).join(KEY_SEP);
  var $k = $p + ($p ? KEY_SEP : '') + getComKey(vm);

  // getVmData 这儿获取当前组件内的所有数据，包含 props、computed 的数据
  // 改动 vue.runtime 所获的的核心能力
  var data = Object.assign(getVmData(vm), { $k: $k, $kk: ("" + $k + KEY_SEP), $p: $p });
  var key = '$root.' + $k;
  var res = {};
  res[key] = data;
  return res
}

function collectVmData (vm, res) {
  if ( res === void 0 ) res = {};

  var vms = vm.$children;
  if (vms && vms.length) {
    vms.forEach(function (v) { return collectVmData(v, res); });
  }
  return Object.assign(res, formatVmData(vm))
}

/**
 * 频率控制 返回函数连续调用时，func 执行频率限定为 次 / wait
 * 自动合并 data
 *
 * @param  {function}   func      传入函数
 * @param  {number}     wait      表示时间窗口的间隔
 * @param  {object}     options   如果想忽略开始边界上的调用，传入{leading: false}。
 *                                如果想忽略结尾边界上的调用，传入{trailing: false}
 * @return {function}             返回客户调用函数
 */
function throttle (func, wait, options) {
  var context, args, result;
  var timeout = null;
  // 上次执行时间点
  var previous = 0;
  if (!options) { options = {}; }
  // 延迟执行函数
  function later () {
    // 若设定了开始边界不执行选项，上次执行时间始终为0
    previous = options.leading === false ? 0 : Date.now();
    timeout = null;
    result = func.apply(context, args);
    if (!timeout) { context = args = null; }
  }
  return function (handle, data) {
    var now = Date.now();
    // 首次执行时，如果设定了开始边界不执行选项，将上次执行时间设定为当前时间。
    if (!previous && options.leading === false) { previous = now; }
    // 延迟执行时间间隔
    var remaining = wait - (now - previous);
    context = this;
    args = args ? [handle, Object.assign(args[1], data)] : [handle, data];
    // 延迟时间间隔remaining小于等于0，表示上次执行至此所间隔时间已经超过一个时间窗口
    // remaining大于时间窗口wait，表示客户端系统时间被调整过
    if (remaining <= 0 || remaining > wait) {
      clearTimeout(timeout);
      timeout = null;
      previous = now;
      result = func.apply(context, args);
      if (!timeout) { context = args = null; }
    // 如果延迟执行不存在，且没有设定结尾边界不执行选项
    } else if (!timeout && options.trailing !== false) {
      timeout = setTimeout(later, remaining);
    }
    return result
  }
}

// 优化频繁的 setData: https://mp.weixin.qq.com/debug/wxadoc/dev/framework/performance/tips.html
var throttleSetData = throttle(function (handle, data) {
  handle(data);
}, 50);

function getPage (vm) {
  var rootVueVM = vm.$root;
  var ref = rootVueVM.$mp || {};
  var mpType = ref.mpType; if ( mpType === void 0 ) mpType = '';
  var page = ref.page;

  // 优化后台态页面进行 setData: https://mp.weixin.qq.com/debug/wxadoc/dev/framework/performance/tips.html
  if (mpType === 'app' || !page || typeof page.setData !== 'function') {
    return
  }
  return page
}

// 优化js变量动态变化时候引起全量更新
// 优化每次 setData 都传递大量新数据
function updateDataToMP () {
  var page = getPage(this);
  if (!page) {
    return
  }

  var data = formatVmData(this);
  diffData(this, data);
  throttleSetData(page.setData.bind(page), data);
}

function initDataToMP () {
  var page = getPage(this);
  if (!page) {
    return
  }

  var data = collectVmData(this.$root);
  page.setData(data);
}

// 虚拟dom的compid与真实dom的comkey匹配，多层嵌套的先补齐虚拟dom的compid直到完全匹配为止
function isVmKeyMatchedCompkey (k, comkey) {
  if (!k || !comkey) {
    return false
  }
  // 完全匹配 comkey = '1_0_1', k = '1_0_1'
  // 部分匹配 comkey = '1_0_10_1', k = '1_0_10'
  // k + KEY_SEP防止k = '1_0_1'误匹配comkey = '1_0_10_1'
  return comkey === k || comkey.indexOf(k + KEY_SEP$2) === 0
}

function getVM (vm, comkeys) {
  if ( comkeys === void 0 ) comkeys = [];

  var keys = comkeys.slice(1);
  if (!keys.length) { return vm }

  // bugfix #1375: 虚拟dom的compid和真实dom的comkey在组件嵌套时匹配出错，comid会丢失前缀，需要从父节点补充
  var comkey = keys.join(KEY_SEP$2);
  var comidPrefix = '';
  return keys.reduce(function (res, key) {
    var len = res.$children.length;
    for (var i = 0; i < len; i++) {
      var v = res.$children[i];
      var k = getComKey(v);
      if (comidPrefix) {
        k = comidPrefix + KEY_SEP$2 + k;
      }
      // 找到匹配的父节点
      if (isVmKeyMatchedCompkey(k, comkey)) {
        comidPrefix = k;
        res = v;
        return res
      }
    }
    return res
  }, vm)
}

function getHandle (vnode, eventid, eventTypes) {
  if ( eventTypes === void 0 ) eventTypes = [];

  var res = [];
  if (!vnode || !vnode.tag) {
    return res
  }

  var ref = vnode || {};
  var data = ref.data; if ( data === void 0 ) data = {};
  var children = ref.children; if ( children === void 0 ) children = [];
  var componentInstance = ref.componentInstance;
  if (componentInstance) {
    // 增加 slot 情况的处理
    // Object.values 会多增加几行编译后的代码
    Object.keys(componentInstance.$slots).forEach(function (slotKey) {
      var slot = componentInstance.$slots[slotKey];
      var slots = Array.isArray(slot) ? slot : [slot];
      slots.forEach(function (node) {
        res = res.concat(getHandle(node, eventid, eventTypes));
      });
    });
  } else {
    // 避免遍历超出当前组件的 vm
    children.forEach(function (node) {
      res = res.concat(getHandle(node, eventid, eventTypes));
    });
  }

  var attrs = data.attrs;
  var on = data.on;
  if (attrs && on && attrs['eventid'] === eventid) {
    eventTypes.forEach(function (et) {
      var h = on[et];
      if (typeof h === 'function') {
        res.push(h);
      } else if (Array.isArray(h)) {
        res = res.concat(h);
      }
    });
    return res
  }

  return res
}

function getWebEventByMP (e) {
  var type = e.type;
  var timeStamp = e.timeStamp;
  var touches = e.touches;
  var detail = e.detail; if ( detail === void 0 ) detail = {};
  var target = e.target; if ( target === void 0 ) target = {};
  var currentTarget = e.currentTarget; if ( currentTarget === void 0 ) currentTarget = {};
  var x = detail.x;
  var y = detail.y;
  var event = {
    mp: e,
    type: type,
    timeStamp: timeStamp,
    x: x,
    y: y,
    target: Object.assign({}, target, detail),
    currentTarget: currentTarget,
    stopPropagation: noop,
    preventDefault: noop
  };

  if (touches && touches.length) {
    Object.assign(event, touches[0]);
    event.touches = touches;
  }
  return event
}

var KEY_SEP$2 = '_';
function handleProxyWithVue (e) {
  var rootVueVM = this.$root;
  var type = e.type;
  var target = e.target; if ( target === void 0 ) target = {};
  var currentTarget = e.currentTarget;
  var ref = currentTarget || target;
  var dataset = ref.dataset; if ( dataset === void 0 ) dataset = {};
  var comkey = dataset.comkey; if ( comkey === void 0 ) comkey = '';
  var eventid = dataset.eventid;
  var vm = getVM(rootVueVM, comkey.split(KEY_SEP$2));

  if (!vm) {
    return
  }

  var webEventTypes = eventTypeMap[type] || [type];
  var handles = getHandle(vm._vnode, eventid, webEventTypes);

  // TODO, enevt 还需要处理更多
  // https://developer.mozilla.org/zh-CN/docs/Web/API/Event
  if (handles.length) {
    var event = getWebEventByMP(e);
    if (handles.length === 1) {
      var result = handles[0](event);
      return result
    }
    handles.forEach(function (h) { return h(event); });
  }
}

// for platforms
// import config from 'core/config'
// install platform specific utils
Vue$3.config.mustUseProp = mustUseProp;
Vue$3.config.isReservedTag = isReservedTag;
Vue$3.config.isReservedAttr = isReservedAttr;
Vue$3.config.getTagNamespace = getTagNamespace;
Vue$3.config.isUnknownElement = isUnknownElement;

// install platform patch function
Vue$3.prototype.__patch__ = patch;

// public mount method
Vue$3.prototype.$mount = function (el, hydrating) {
  var this$1 = this;

  // el = el && inBrowser ? query(el) : undefined
  // return mountComponent(this, el, hydrating)

  // 初始化小程序生命周期相关
  var options = this.$options;

  if (options && (options.render || options.mpType)) {
    var mpType = options.mpType; if ( mpType === void 0 ) mpType = 'page';
    return this._initMP(mpType, function () {
      return mountComponent(this$1, undefined, undefined)
    })
  } else {
    return mountComponent(this, undefined, undefined)
  }
};

// for mp
Vue$3.prototype._initMP = initMP;

Vue$3.prototype.$updateDataToMP = updateDataToMP;
Vue$3.prototype._initDataToMP = initDataToMP;

Vue$3.prototype.$handleProxyWithVue = handleProxyWithVue;

/*  */

return Vue$3;

})));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__("DuR2")))

/***/ }),

/***/ "5zde":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("zQR9");
__webpack_require__("qyJz");
module.exports = __webpack_require__("FeBl").Array.from;


/***/ }),

/***/ "77Pl":
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__("EqjI");
module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};


/***/ }),

/***/ "7KvD":
/***/ (function(module, exports) {

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self
  // eslint-disable-next-line no-new-func
  : Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef


/***/ }),

/***/ "880/":
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__("hJx8");


/***/ }),

/***/ "94VQ":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var create = __webpack_require__("Yobk");
var descriptor = __webpack_require__("X8DO");
var setToStringTag = __webpack_require__("e6n0");
var IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
__webpack_require__("hJx8")(IteratorPrototype, __webpack_require__("dSzd")('iterator'), function () { return this; });

module.exports = function (Constructor, NAME, next) {
  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
  setToStringTag(Constructor, NAME + ' Iterator');
};


/***/ }),

/***/ "D2L2":
/***/ (function(module, exports) {

var hasOwnProperty = {}.hasOwnProperty;
module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};


/***/ }),

/***/ "Dd8w":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _assign = __webpack_require__("woOf");

var _assign2 = _interopRequireDefault(_assign);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _assign2.default || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

/***/ }),

/***/ "DuR2":
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() { return typeof global !== 'undefined' ? global : this; })();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "EqjI":
/***/ (function(module, exports) {

module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};


/***/ }),

/***/ "FeBl":
/***/ (function(module, exports) {

var core = module.exports = { version: '2.6.9' };
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef


/***/ }),

/***/ "Gu7T":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _from = __webpack_require__("c/Tr");

var _from2 = _interopRequireDefault(_from);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  } else {
    return (0, _from2.default)(arr);
  }
};

/***/ }),

/***/ "Ibhu":
/***/ (function(module, exports, __webpack_require__) {

var has = __webpack_require__("D2L2");
var toIObject = __webpack_require__("TcQ7");
var arrayIndexOf = __webpack_require__("vFc/")(false);
var IE_PROTO = __webpack_require__("ax3d")('IE_PROTO');

module.exports = function (object, names) {
  var O = toIObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};


/***/ }),

/***/ "MU5D":
/***/ (function(module, exports, __webpack_require__) {

// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = __webpack_require__("R9M2");
// eslint-disable-next-line no-prototype-builtins
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return cof(it) == 'String' ? it.split('') : Object(it);
};


/***/ }),

/***/ "Mhyx":
/***/ (function(module, exports, __webpack_require__) {

// check on default Array iterator
var Iterators = __webpack_require__("/bQp");
var ITERATOR = __webpack_require__("dSzd")('iterator');
var ArrayProto = Array.prototype;

module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
};


/***/ }),

/***/ "MmMw":
/***/ (function(module, exports, __webpack_require__) {

// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = __webpack_require__("EqjI");
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};


/***/ }),

/***/ "NYxO":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/* unused harmony export Store */
/* unused harmony export install */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return mapState; });
/* unused harmony export mapMutations */
/* unused harmony export mapGetters */
/* unused harmony export mapActions */
/* unused harmony export createNamespacedHelpers */
/**
 * vuex v3.1.1
 * (c) 2019 Evan You
 * @license MIT
 */
function applyMixin (Vue) {
  var version = Number(Vue.version.split('.')[0]);

  if (version >= 2) {
    Vue.mixin({ beforeCreate: vuexInit });
  } else {
    // override init and inject vuex init procedure
    // for 1.x backwards compatibility.
    var _init = Vue.prototype._init;
    Vue.prototype._init = function (options) {
      if ( options === void 0 ) options = {};

      options.init = options.init
        ? [vuexInit].concat(options.init)
        : vuexInit;
      _init.call(this, options);
    };
  }

  /**
   * Vuex init hook, injected into each instances init hooks list.
   */

  function vuexInit () {
    var options = this.$options;
    // store injection
    if (options.store) {
      this.$store = typeof options.store === 'function'
        ? options.store()
        : options.store;
    } else if (options.parent && options.parent.$store) {
      this.$store = options.parent.$store;
    }
  }
}

var target = typeof window !== 'undefined'
  ? window
  : typeof global !== 'undefined'
    ? global
    : {};
var devtoolHook = target.__VUE_DEVTOOLS_GLOBAL_HOOK__;

function devtoolPlugin (store) {
  if (!devtoolHook) { return }

  store._devtoolHook = devtoolHook;

  devtoolHook.emit('vuex:init', store);

  devtoolHook.on('vuex:travel-to-state', function (targetState) {
    store.replaceState(targetState);
  });

  store.subscribe(function (mutation, state) {
    devtoolHook.emit('vuex:mutation', mutation, state);
  });
}

/**
 * Get the first item that pass the test
 * by second argument function
 *
 * @param {Array} list
 * @param {Function} f
 * @return {*}
 */

/**
 * forEach for object
 */
function forEachValue (obj, fn) {
  Object.keys(obj).forEach(function (key) { return fn(obj[key], key); });
}

function isObject (obj) {
  return obj !== null && typeof obj === 'object'
}

function isPromise (val) {
  return val && typeof val.then === 'function'
}

function assert (condition, msg) {
  if (!condition) { throw new Error(("[vuex] " + msg)) }
}

function partial (fn, arg) {
  return function () {
    return fn(arg)
  }
}

// Base data struct for store's module, package with some attribute and method
var Module = function Module (rawModule, runtime) {
  this.runtime = runtime;
  // Store some children item
  this._children = Object.create(null);
  // Store the origin module object which passed by programmer
  this._rawModule = rawModule;
  var rawState = rawModule.state;

  // Store the origin module's state
  this.state = (typeof rawState === 'function' ? rawState() : rawState) || {};
};

var prototypeAccessors = { namespaced: { configurable: true } };

prototypeAccessors.namespaced.get = function () {
  return !!this._rawModule.namespaced
};

Module.prototype.addChild = function addChild (key, module) {
  this._children[key] = module;
};

Module.prototype.removeChild = function removeChild (key) {
  delete this._children[key];
};

Module.prototype.getChild = function getChild (key) {
  return this._children[key]
};

Module.prototype.update = function update (rawModule) {
  this._rawModule.namespaced = rawModule.namespaced;
  if (rawModule.actions) {
    this._rawModule.actions = rawModule.actions;
  }
  if (rawModule.mutations) {
    this._rawModule.mutations = rawModule.mutations;
  }
  if (rawModule.getters) {
    this._rawModule.getters = rawModule.getters;
  }
};

Module.prototype.forEachChild = function forEachChild (fn) {
  forEachValue(this._children, fn);
};

Module.prototype.forEachGetter = function forEachGetter (fn) {
  if (this._rawModule.getters) {
    forEachValue(this._rawModule.getters, fn);
  }
};

Module.prototype.forEachAction = function forEachAction (fn) {
  if (this._rawModule.actions) {
    forEachValue(this._rawModule.actions, fn);
  }
};

Module.prototype.forEachMutation = function forEachMutation (fn) {
  if (this._rawModule.mutations) {
    forEachValue(this._rawModule.mutations, fn);
  }
};

Object.defineProperties( Module.prototype, prototypeAccessors );

var ModuleCollection = function ModuleCollection (rawRootModule) {
  // register root module (Vuex.Store options)
  this.register([], rawRootModule, false);
};

ModuleCollection.prototype.get = function get (path) {
  return path.reduce(function (module, key) {
    return module.getChild(key)
  }, this.root)
};

ModuleCollection.prototype.getNamespace = function getNamespace (path) {
  var module = this.root;
  return path.reduce(function (namespace, key) {
    module = module.getChild(key);
    return namespace + (module.namespaced ? key + '/' : '')
  }, '')
};

ModuleCollection.prototype.update = function update$1 (rawRootModule) {
  update([], this.root, rawRootModule);
};

ModuleCollection.prototype.register = function register (path, rawModule, runtime) {
    var this$1 = this;
    if ( runtime === void 0 ) runtime = true;

  if (false) {
    assertRawModule(path, rawModule);
  }

  var newModule = new Module(rawModule, runtime);
  if (path.length === 0) {
    this.root = newModule;
  } else {
    var parent = this.get(path.slice(0, -1));
    parent.addChild(path[path.length - 1], newModule);
  }

  // register nested modules
  if (rawModule.modules) {
    forEachValue(rawModule.modules, function (rawChildModule, key) {
      this$1.register(path.concat(key), rawChildModule, runtime);
    });
  }
};

ModuleCollection.prototype.unregister = function unregister (path) {
  var parent = this.get(path.slice(0, -1));
  var key = path[path.length - 1];
  if (!parent.getChild(key).runtime) { return }

  parent.removeChild(key);
};

function update (path, targetModule, newModule) {
  if (false) {
    assertRawModule(path, newModule);
  }

  // update target module
  targetModule.update(newModule);

  // update nested modules
  if (newModule.modules) {
    for (var key in newModule.modules) {
      if (!targetModule.getChild(key)) {
        if (false) {
          console.warn(
            "[vuex] trying to add a new module '" + key + "' on hot reloading, " +
            'manual reload is needed'
          );
        }
        return
      }
      update(
        path.concat(key),
        targetModule.getChild(key),
        newModule.modules[key]
      );
    }
  }
}

var functionAssert = {
  assert: function (value) { return typeof value === 'function'; },
  expected: 'function'
};

var objectAssert = {
  assert: function (value) { return typeof value === 'function' ||
    (typeof value === 'object' && typeof value.handler === 'function'); },
  expected: 'function or object with "handler" function'
};

var assertTypes = {
  getters: functionAssert,
  mutations: functionAssert,
  actions: objectAssert
};

function assertRawModule (path, rawModule) {
  Object.keys(assertTypes).forEach(function (key) {
    if (!rawModule[key]) { return }

    var assertOptions = assertTypes[key];

    forEachValue(rawModule[key], function (value, type) {
      assert(
        assertOptions.assert(value),
        makeAssertionMessage(path, key, type, value, assertOptions.expected)
      );
    });
  });
}

function makeAssertionMessage (path, key, type, value, expected) {
  var buf = key + " should be " + expected + " but \"" + key + "." + type + "\"";
  if (path.length > 0) {
    buf += " in module \"" + (path.join('.')) + "\"";
  }
  buf += " is " + (JSON.stringify(value)) + ".";
  return buf
}

var Vue; // bind on install

var Store = function Store (options) {
  var this$1 = this;
  if ( options === void 0 ) options = {};

  // Auto install if it is not done yet and `window` has `Vue`.
  // To allow users to avoid auto-installation in some cases,
  // this code should be placed here. See #731
  if (!Vue && typeof window !== 'undefined' && window.Vue) {
    install(window.Vue);
  }

  if (false) {
    assert(Vue, "must call Vue.use(Vuex) before creating a store instance.");
    assert(typeof Promise !== 'undefined', "vuex requires a Promise polyfill in this browser.");
    assert(this instanceof Store, "store must be called with the new operator.");
  }

  var plugins = options.plugins; if ( plugins === void 0 ) plugins = [];
  var strict = options.strict; if ( strict === void 0 ) strict = false;

  // store internal state
  this._committing = false;
  this._actions = Object.create(null);
  this._actionSubscribers = [];
  this._mutations = Object.create(null);
  this._wrappedGetters = Object.create(null);
  this._modules = new ModuleCollection(options);
  this._modulesNamespaceMap = Object.create(null);
  this._subscribers = [];
  this._watcherVM = new Vue();

  // bind commit and dispatch to self
  var store = this;
  var ref = this;
  var dispatch = ref.dispatch;
  var commit = ref.commit;
  this.dispatch = function boundDispatch (type, payload) {
    return dispatch.call(store, type, payload)
  };
  this.commit = function boundCommit (type, payload, options) {
    return commit.call(store, type, payload, options)
  };

  // strict mode
  this.strict = strict;

  var state = this._modules.root.state;

  // init root module.
  // this also recursively registers all sub-modules
  // and collects all module getters inside this._wrappedGetters
  installModule(this, state, [], this._modules.root);

  // initialize the store vm, which is responsible for the reactivity
  // (also registers _wrappedGetters as computed properties)
  resetStoreVM(this, state);

  // apply plugins
  plugins.forEach(function (plugin) { return plugin(this$1); });

  var useDevtools = options.devtools !== undefined ? options.devtools : Vue.config.devtools;
  if (useDevtools) {
    devtoolPlugin(this);
  }
};

var prototypeAccessors$1 = { state: { configurable: true } };

prototypeAccessors$1.state.get = function () {
  return this._vm._data.$$state
};

prototypeAccessors$1.state.set = function (v) {
  if (false) {
    assert(false, "use store.replaceState() to explicit replace store state.");
  }
};

Store.prototype.commit = function commit (_type, _payload, _options) {
    var this$1 = this;

  // check object-style commit
  var ref = unifyObjectStyle(_type, _payload, _options);
    var type = ref.type;
    var payload = ref.payload;
    var options = ref.options;

  var mutation = { type: type, payload: payload };
  var entry = this._mutations[type];
  if (!entry) {
    if (false) {
      console.error(("[vuex] unknown mutation type: " + type));
    }
    return
  }
  this._withCommit(function () {
    entry.forEach(function commitIterator (handler) {
      handler(payload);
    });
  });
  this._subscribers.forEach(function (sub) { return sub(mutation, this$1.state); });

  if (
    false
  ) {
    console.warn(
      "[vuex] mutation type: " + type + ". Silent option has been removed. " +
      'Use the filter functionality in the vue-devtools'
    );
  }
};

Store.prototype.dispatch = function dispatch (_type, _payload) {
    var this$1 = this;

  // check object-style dispatch
  var ref = unifyObjectStyle(_type, _payload);
    var type = ref.type;
    var payload = ref.payload;

  var action = { type: type, payload: payload };
  var entry = this._actions[type];
  if (!entry) {
    if (false) {
      console.error(("[vuex] unknown action type: " + type));
    }
    return
  }

  try {
    this._actionSubscribers
      .filter(function (sub) { return sub.before; })
      .forEach(function (sub) { return sub.before(action, this$1.state); });
  } catch (e) {
    if (false) {
      console.warn("[vuex] error in before action subscribers: ");
      console.error(e);
    }
  }

  var result = entry.length > 1
    ? Promise.all(entry.map(function (handler) { return handler(payload); }))
    : entry[0](payload);

  return result.then(function (res) {
    try {
      this$1._actionSubscribers
        .filter(function (sub) { return sub.after; })
        .forEach(function (sub) { return sub.after(action, this$1.state); });
    } catch (e) {
      if (false) {
        console.warn("[vuex] error in after action subscribers: ");
        console.error(e);
      }
    }
    return res
  })
};

Store.prototype.subscribe = function subscribe (fn) {
  return genericSubscribe(fn, this._subscribers)
};

Store.prototype.subscribeAction = function subscribeAction (fn) {
  var subs = typeof fn === 'function' ? { before: fn } : fn;
  return genericSubscribe(subs, this._actionSubscribers)
};

Store.prototype.watch = function watch (getter, cb, options) {
    var this$1 = this;

  if (false) {
    assert(typeof getter === 'function', "store.watch only accepts a function.");
  }
  return this._watcherVM.$watch(function () { return getter(this$1.state, this$1.getters); }, cb, options)
};

Store.prototype.replaceState = function replaceState (state) {
    var this$1 = this;

  this._withCommit(function () {
    this$1._vm._data.$$state = state;
  });
};

Store.prototype.registerModule = function registerModule (path, rawModule, options) {
    if ( options === void 0 ) options = {};

  if (typeof path === 'string') { path = [path]; }

  if (false) {
    assert(Array.isArray(path), "module path must be a string or an Array.");
    assert(path.length > 0, 'cannot register the root module by using registerModule.');
  }

  this._modules.register(path, rawModule);
  installModule(this, this.state, path, this._modules.get(path), options.preserveState);
  // reset store to update getters...
  resetStoreVM(this, this.state);
};

Store.prototype.unregisterModule = function unregisterModule (path) {
    var this$1 = this;

  if (typeof path === 'string') { path = [path]; }

  if (false) {
    assert(Array.isArray(path), "module path must be a string or an Array.");
  }

  this._modules.unregister(path);
  this._withCommit(function () {
    var parentState = getNestedState(this$1.state, path.slice(0, -1));
    Vue.delete(parentState, path[path.length - 1]);
  });
  resetStore(this);
};

Store.prototype.hotUpdate = function hotUpdate (newOptions) {
  this._modules.update(newOptions);
  resetStore(this, true);
};

Store.prototype._withCommit = function _withCommit (fn) {
  var committing = this._committing;
  this._committing = true;
  fn();
  this._committing = committing;
};

Object.defineProperties( Store.prototype, prototypeAccessors$1 );

function genericSubscribe (fn, subs) {
  if (subs.indexOf(fn) < 0) {
    subs.push(fn);
  }
  return function () {
    var i = subs.indexOf(fn);
    if (i > -1) {
      subs.splice(i, 1);
    }
  }
}

function resetStore (store, hot) {
  store._actions = Object.create(null);
  store._mutations = Object.create(null);
  store._wrappedGetters = Object.create(null);
  store._modulesNamespaceMap = Object.create(null);
  var state = store.state;
  // init all modules
  installModule(store, state, [], store._modules.root, true);
  // reset vm
  resetStoreVM(store, state, hot);
}

function resetStoreVM (store, state, hot) {
  var oldVm = store._vm;

  // bind store public getters
  store.getters = {};
  var wrappedGetters = store._wrappedGetters;
  var computed = {};
  forEachValue(wrappedGetters, function (fn, key) {
    // use computed to leverage its lazy-caching mechanism
    // direct inline function use will lead to closure preserving oldVm.
    // using partial to return function with only arguments preserved in closure enviroment.
    computed[key] = partial(fn, store);
    Object.defineProperty(store.getters, key, {
      get: function () { return store._vm[key]; },
      enumerable: true // for local getters
    });
  });

  // use a Vue instance to store the state tree
  // suppress warnings just in case the user has added
  // some funky global mixins
  var silent = Vue.config.silent;
  Vue.config.silent = true;
  store._vm = new Vue({
    data: {
      $$state: state
    },
    computed: computed
  });
  Vue.config.silent = silent;

  // enable strict mode for new vm
  if (store.strict) {
    enableStrictMode(store);
  }

  if (oldVm) {
    if (hot) {
      // dispatch changes in all subscribed watchers
      // to force getter re-evaluation for hot reloading.
      store._withCommit(function () {
        oldVm._data.$$state = null;
      });
    }
    Vue.nextTick(function () { return oldVm.$destroy(); });
  }
}

function installModule (store, rootState, path, module, hot) {
  var isRoot = !path.length;
  var namespace = store._modules.getNamespace(path);

  // register in namespace map
  if (module.namespaced) {
    store._modulesNamespaceMap[namespace] = module;
  }

  // set state
  if (!isRoot && !hot) {
    var parentState = getNestedState(rootState, path.slice(0, -1));
    var moduleName = path[path.length - 1];
    store._withCommit(function () {
      Vue.set(parentState, moduleName, module.state);
    });
  }

  var local = module.context = makeLocalContext(store, namespace, path);

  module.forEachMutation(function (mutation, key) {
    var namespacedType = namespace + key;
    registerMutation(store, namespacedType, mutation, local);
  });

  module.forEachAction(function (action, key) {
    var type = action.root ? key : namespace + key;
    var handler = action.handler || action;
    registerAction(store, type, handler, local);
  });

  module.forEachGetter(function (getter, key) {
    var namespacedType = namespace + key;
    registerGetter(store, namespacedType, getter, local);
  });

  module.forEachChild(function (child, key) {
    installModule(store, rootState, path.concat(key), child, hot);
  });
}

/**
 * make localized dispatch, commit, getters and state
 * if there is no namespace, just use root ones
 */
function makeLocalContext (store, namespace, path) {
  var noNamespace = namespace === '';

  var local = {
    dispatch: noNamespace ? store.dispatch : function (_type, _payload, _options) {
      var args = unifyObjectStyle(_type, _payload, _options);
      var payload = args.payload;
      var options = args.options;
      var type = args.type;

      if (!options || !options.root) {
        type = namespace + type;
        if (false) {
          console.error(("[vuex] unknown local action type: " + (args.type) + ", global type: " + type));
          return
        }
      }

      return store.dispatch(type, payload)
    },

    commit: noNamespace ? store.commit : function (_type, _payload, _options) {
      var args = unifyObjectStyle(_type, _payload, _options);
      var payload = args.payload;
      var options = args.options;
      var type = args.type;

      if (!options || !options.root) {
        type = namespace + type;
        if (false) {
          console.error(("[vuex] unknown local mutation type: " + (args.type) + ", global type: " + type));
          return
        }
      }

      store.commit(type, payload, options);
    }
  };

  // getters and state object must be gotten lazily
  // because they will be changed by vm update
  Object.defineProperties(local, {
    getters: {
      get: noNamespace
        ? function () { return store.getters; }
        : function () { return makeLocalGetters(store, namespace); }
    },
    state: {
      get: function () { return getNestedState(store.state, path); }
    }
  });

  return local
}

function makeLocalGetters (store, namespace) {
  var gettersProxy = {};

  var splitPos = namespace.length;
  Object.keys(store.getters).forEach(function (type) {
    // skip if the target getter is not match this namespace
    if (type.slice(0, splitPos) !== namespace) { return }

    // extract local getter type
    var localType = type.slice(splitPos);

    // Add a port to the getters proxy.
    // Define as getter property because
    // we do not want to evaluate the getters in this time.
    Object.defineProperty(gettersProxy, localType, {
      get: function () { return store.getters[type]; },
      enumerable: true
    });
  });

  return gettersProxy
}

function registerMutation (store, type, handler, local) {
  var entry = store._mutations[type] || (store._mutations[type] = []);
  entry.push(function wrappedMutationHandler (payload) {
    handler.call(store, local.state, payload);
  });
}

function registerAction (store, type, handler, local) {
  var entry = store._actions[type] || (store._actions[type] = []);
  entry.push(function wrappedActionHandler (payload, cb) {
    var res = handler.call(store, {
      dispatch: local.dispatch,
      commit: local.commit,
      getters: local.getters,
      state: local.state,
      rootGetters: store.getters,
      rootState: store.state
    }, payload, cb);
    if (!isPromise(res)) {
      res = Promise.resolve(res);
    }
    if (store._devtoolHook) {
      return res.catch(function (err) {
        store._devtoolHook.emit('vuex:error', err);
        throw err
      })
    } else {
      return res
    }
  });
}

function registerGetter (store, type, rawGetter, local) {
  if (store._wrappedGetters[type]) {
    if (false) {
      console.error(("[vuex] duplicate getter key: " + type));
    }
    return
  }
  store._wrappedGetters[type] = function wrappedGetter (store) {
    return rawGetter(
      local.state, // local state
      local.getters, // local getters
      store.state, // root state
      store.getters // root getters
    )
  };
}

function enableStrictMode (store) {
  store._vm.$watch(function () { return this._data.$$state }, function () {
    if (false) {
      assert(store._committing, "do not mutate vuex store state outside mutation handlers.");
    }
  }, { deep: true, sync: true });
}

function getNestedState (state, path) {
  return path.length
    ? path.reduce(function (state, key) { return state[key]; }, state)
    : state
}

function unifyObjectStyle (type, payload, options) {
  if (isObject(type) && type.type) {
    options = payload;
    payload = type;
    type = type.type;
  }

  if (false) {
    assert(typeof type === 'string', ("expects string as the type, but found " + (typeof type) + "."));
  }

  return { type: type, payload: payload, options: options }
}

function install (_Vue) {
  if (Vue && _Vue === Vue) {
    if (false) {
      console.error(
        '[vuex] already installed. Vue.use(Vuex) should be called only once.'
      );
    }
    return
  }
  Vue = _Vue;
  applyMixin(Vue);
}

/**
 * Reduce the code which written in Vue.js for getting the state.
 * @param {String} [namespace] - Module's namespace
 * @param {Object|Array} states # Object's item can be a function which accept state and getters for param, you can do something for state and getters in it.
 * @param {Object}
 */
var mapState = normalizeNamespace(function (namespace, states) {
  var res = {};
  normalizeMap(states).forEach(function (ref) {
    var key = ref.key;
    var val = ref.val;

    res[key] = function mappedState () {
      var state = this.$store.state;
      var getters = this.$store.getters;
      if (namespace) {
        var module = getModuleByNamespace(this.$store, 'mapState', namespace);
        if (!module) {
          return
        }
        state = module.context.state;
        getters = module.context.getters;
      }
      return typeof val === 'function'
        ? val.call(this, state, getters)
        : state[val]
    };
    // mark vuex getter for devtools
    res[key].vuex = true;
  });
  return res
});

/**
 * Reduce the code which written in Vue.js for committing the mutation
 * @param {String} [namespace] - Module's namespace
 * @param {Object|Array} mutations # Object's item can be a function which accept `commit` function as the first param, it can accept anthor params. You can commit mutation and do any other things in this function. specially, You need to pass anthor params from the mapped function.
 * @return {Object}
 */
var mapMutations = normalizeNamespace(function (namespace, mutations) {
  var res = {};
  normalizeMap(mutations).forEach(function (ref) {
    var key = ref.key;
    var val = ref.val;

    res[key] = function mappedMutation () {
      var args = [], len = arguments.length;
      while ( len-- ) args[ len ] = arguments[ len ];

      // Get the commit method from store
      var commit = this.$store.commit;
      if (namespace) {
        var module = getModuleByNamespace(this.$store, 'mapMutations', namespace);
        if (!module) {
          return
        }
        commit = module.context.commit;
      }
      return typeof val === 'function'
        ? val.apply(this, [commit].concat(args))
        : commit.apply(this.$store, [val].concat(args))
    };
  });
  return res
});

/**
 * Reduce the code which written in Vue.js for getting the getters
 * @param {String} [namespace] - Module's namespace
 * @param {Object|Array} getters
 * @return {Object}
 */
var mapGetters = normalizeNamespace(function (namespace, getters) {
  var res = {};
  normalizeMap(getters).forEach(function (ref) {
    var key = ref.key;
    var val = ref.val;

    // The namespace has been mutated by normalizeNamespace
    val = namespace + val;
    res[key] = function mappedGetter () {
      if (namespace && !getModuleByNamespace(this.$store, 'mapGetters', namespace)) {
        return
      }
      if (false) {
        console.error(("[vuex] unknown getter: " + val));
        return
      }
      return this.$store.getters[val]
    };
    // mark vuex getter for devtools
    res[key].vuex = true;
  });
  return res
});

/**
 * Reduce the code which written in Vue.js for dispatch the action
 * @param {String} [namespace] - Module's namespace
 * @param {Object|Array} actions # Object's item can be a function which accept `dispatch` function as the first param, it can accept anthor params. You can dispatch action and do any other things in this function. specially, You need to pass anthor params from the mapped function.
 * @return {Object}
 */
var mapActions = normalizeNamespace(function (namespace, actions) {
  var res = {};
  normalizeMap(actions).forEach(function (ref) {
    var key = ref.key;
    var val = ref.val;

    res[key] = function mappedAction () {
      var args = [], len = arguments.length;
      while ( len-- ) args[ len ] = arguments[ len ];

      // get dispatch function from store
      var dispatch = this.$store.dispatch;
      if (namespace) {
        var module = getModuleByNamespace(this.$store, 'mapActions', namespace);
        if (!module) {
          return
        }
        dispatch = module.context.dispatch;
      }
      return typeof val === 'function'
        ? val.apply(this, [dispatch].concat(args))
        : dispatch.apply(this.$store, [val].concat(args))
    };
  });
  return res
});

/**
 * Rebinding namespace param for mapXXX function in special scoped, and return them by simple object
 * @param {String} namespace
 * @return {Object}
 */
var createNamespacedHelpers = function (namespace) { return ({
  mapState: mapState.bind(null, namespace),
  mapGetters: mapGetters.bind(null, namespace),
  mapMutations: mapMutations.bind(null, namespace),
  mapActions: mapActions.bind(null, namespace)
}); };

/**
 * Normalize the map
 * normalizeMap([1, 2, 3]) => [ { key: 1, val: 1 }, { key: 2, val: 2 }, { key: 3, val: 3 } ]
 * normalizeMap({a: 1, b: 2, c: 3}) => [ { key: 'a', val: 1 }, { key: 'b', val: 2 }, { key: 'c', val: 3 } ]
 * @param {Array|Object} map
 * @return {Object}
 */
function normalizeMap (map) {
  return Array.isArray(map)
    ? map.map(function (key) { return ({ key: key, val: key }); })
    : Object.keys(map).map(function (key) { return ({ key: key, val: map[key] }); })
}

/**
 * Return a function expect two param contains namespace and map. it will normalize the namespace and then the param's function will handle the new namespace and the map.
 * @param {Function} fn
 * @return {Function}
 */
function normalizeNamespace (fn) {
  return function (namespace, map) {
    if (typeof namespace !== 'string') {
      map = namespace;
      namespace = '';
    } else if (namespace.charAt(namespace.length - 1) !== '/') {
      namespace += '/';
    }
    return fn(namespace, map)
  }
}

/**
 * Search a special module from store by namespace. if module not exist, print error message.
 * @param {Object} store
 * @param {String} helper
 * @param {String} namespace
 * @return {Object}
 */
function getModuleByNamespace (store, helper, namespace) {
  var module = store._modulesNamespaceMap[namespace];
  if (false) {
    console.error(("[vuex] module namespace not found in " + helper + "(): " + namespace));
  }
  return module
}

var index_esm = {
  Store: Store,
  install: install,
  version: '3.1.1',
  mapState: mapState,
  mapMutations: mapMutations,
  mapGetters: mapGetters,
  mapActions: mapActions,
  createNamespacedHelpers: createNamespacedHelpers
};

/* harmony default export */ __webpack_exports__["a"] = (index_esm);


/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__("DuR2")))

/***/ }),

/***/ "NpIQ":
/***/ (function(module, exports) {

exports.f = {}.propertyIsEnumerable;


/***/ }),

/***/ "O4g8":
/***/ (function(module, exports) {

module.exports = true;


/***/ }),

/***/ "ON07":
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__("EqjI");
var document = __webpack_require__("7KvD").document;
// typeof document.createElement is 'object' in old IE
var is = isObject(document) && isObject(document.createElement);
module.exports = function (it) {
  return is ? document.createElement(it) : {};
};


/***/ }),

/***/ "PDEy":
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {(function (global, factory) {
   true ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global = global || self, global.TIM = factory());
}(this, function () { 'use strict';

  var version = "2.0.8";

  /**
   * 接入侧需要监听处理的事件列表，详细如下：
   * @memberof SDK
   * @exports EVENT
   * @module EVENT
   */
  var TIM_OUTER_EVENT = {
    /**
     * @description SDK 进入 ready 状态时触发，接入侧监听此事件，然后可调用 SDK 发送消息等api，使用 SDK 的各项功能
     * @memberOf module:EVENT
     * @example
     * let onSdkReady = function(event) {
     *   let message = tim.createTextMessage({ to: 'user1', conversationType: 'C2C', payload: { text: 'Hello world!' }});
     *   tim.sendMessage(message);
     * };
     * tim.on(TIM.EVENT.SDK_READY, onSdkReady);
     */
    SDK_READY: 'sdkStateReady',

    /**
     * @description SDK 进入 not ready 状态时触发，此时接入侧将无法使用 SDK 发送消息等功能。<br/>
     * 如果想恢复使用，接入侧需调用 login 接口，驱动 SDK 进入 ready 状态
     * @memberOf module:EVENT
     * @example
     * let onSdkNotReady = function(event) {
     *   // 如果想使用发送消息等功能，接入侧需驱动 SDK 进入 ready 状态，重新调用 login 接口即可，如下所示：
     *   // tim.login({userID: 'your userID', userSig: 'your userSig'});
     * };
     * tim.on(TIM.EVENT.SDK_NOT_READY, onSdkNotReady);
     */
    SDK_NOT_READY: 'sdkStateNotReady',

    /**
     * @description 销毁时触发，TIM SDK实例工厂将删除SDKAppID对应的sdk实例。接入侧不需要侦听处理此事件
     * @memberOf module:EVENT
     * @private
     */
    SDK_DESTROY: 'sdkDestroy',
    // 消息相关事件

    /**
     * @description 消息已发送，但sdk尚未取得发送响应结果（即成功或失败未知），event.data是Message对象
     * @memberof module:EVENT
     * @example
     * let onMessageSending = function (event) {
     *     console.log(event.data); // Message对象
     * };
     * tim.on(TIM.EVENT.MESSAGE_SENDING, onMessageSending);
     * @private
     */
    MESSAGE_SENDING: 'onMessageSending',

    /**
     * @description 消息发送成功，event.data是Message对象
     * @memberof module:EVENT
     * @example
     * let onMessageSendSuccess = function (event) {
     *     console.log(event.data); // Message对象
     * };
     * tim.on(TIM.EVENT.MESSAGE_SEND_SUCCESS, onMessageSendSuccess);
     * @private
     */
    MESSAGE_SEND_SUCCESS: 'onMessageSendSuccess',

    /**
     * @description 消息发送失败，event.data是Message对象
     * @memberof module:EVENT
     * @example
     * let onMessageSendFail = function (event) {
     *     console.log(event.data); // Message对象
     * };
     * tim.on(TIM.EVENT.MESSAGE_SEND_FAIL, onMessageSendFail);
     * @private
     */
    MESSAGE_SEND_FAIL: 'onMessageSendFail',

    /**
     * @description SDK 收到新消息时触发，包括 C2C 消息、Group 消息、GroupTips(群提示)，可通过遍历 event.data 获取消息列表数据并渲染到页面
     * @memberof module:EVENT
     * @example
     * let onMessageReceived = function(event) {
     *   // event.data - 存储 Message 对象的数组 - [Message]
     * };
     * tim.on(TIM.EVENT.MESSAGE_RECEIVED, onMessageReceived);
     */
    MESSAGE_RECEIVED: 'onMessageReceived',
    // 申请相关

    /**
     * @memberof module:EVENT
     * @private
     */
    APPLY_ADD_FRIEND_SUCCESS: 'addFriendApplySendSuccess',

    /**
     * @memberof module:EVENT
     * @private
     */
    APPLY_ADD_FRIEND_FAIL: 'addFriendApplySendFail',

    /**
     * @memberof module:EVENT
     * @private
     */
    GET_PENDENCY_SUCCESS: 'getPendencySuccess',

    /**
     * @memberof module:EVENT
     * @private
     */
    GET_PENDENCY_FAIL: 'getPendencyFail',

    /**
     * @memberof module:EVENT
     * @private
     */
    DELETE_PENDENCY_SUCCESS: 'deletePendencySuccess',

    /**
     * @memberof module:EVENT
     * @private
     */
    DELETE_PENDENCY_FAIL: 'deletePendencyFail',

    /**
     * @memberof module:EVENT
     * @private
     */
    REPLY_PENDENCY_SUCCESS: 'replyPendencySuccess',

    /**
     * @memberof module:EVENT
     * @private
     */
    REPLY_PENDENCY_FAIL: 'replyPendencyFail',
    // 会话相关

    /**
     * @description 会话列表更新，event.data 是包含 Conversation 对象的数组
     * @memberof module:EVENT
     * @example
     * let onConversationListUpdated = function(event) {
     *   console.log(event.data); // 包含 {@link Conversation} 实例的数组
     * };
     * tim.on(TIM.EVENT.CONVERSATION_LIST_UPDATED, onConversationListUpdated);
     */
    CONVERSATION_LIST_UPDATED: 'onConversationListUpdated',
    // 群组相关

    /**
     * @description SDK 群组列表更新时触发，可通过遍历 event.data 获取群组列表数据并渲染到页面
     * @memberof module:EVENT
     * @example
     * let onGroupListUpdated = function(event) {
     *    console.log(event.data);// 包含 {@link Group} 实例的数组
     * };
     * tim.on(TIM.EVENT.GROUP_LIST_UPDATED, onGroupListUpdated);
     */
    GROUP_LIST_UPDATED: 'onGroupListUpdated',

    /**
     * @description SDK 收到新的群系统通知时触发
     * @see {@link module:TYPES.GROUP_SYSTEM_NOTICE_TYPES 群系统通知类型常量及含义} 
     * @see {@link Message.GroupSystemNoticePayload 群系统通知 payload 结构描述} 
     * @memberof module:EVENT
     * @example
     * let onGroupSystemNoticeReceived = function(event) {
     *   const type = event.data.type; // 群系统通知的类型，详见 {@link module:TYEPS.GROUP_SYSTEM_NOTICE_TYPES 群系统通知类型常量及含义} 
     *   const message = event.data.message; // 群系统通知的消息实例，详见 {@link Message}
     *   console.log(message.payload); // 消息内容. {@link Message.GroupSystemNoticePayload 群系统通知 payload 结构描述}
     * };
     * tim.on(TIM.EVENT.GROUP_SYSTEM_NOTICE_RECERIVED, onGroupSystemNoticeReceived);
     */
    GROUP_SYSTEM_NOTICE_RECERIVED: 'receiveGroupSystemNotice',
    //登入、登出事件

    /**
     * @description 登录状态变更 未使用
     * @memberof module:EVENT
     * @private
     */
    LOGIN_CHANGE: 'loginStatusChange',

    /**
     * @description 登出时触发，sdk进入not ready状态
     * @memberof module:EVENT
     * @example
     * let onLogoutSuccess = function (event) {
     *     // 登出成功。接入侧如需驱动sdk进入ready状态，重新调用login接口即可，如下所示：
     *     // tim.login({userID: "userID", userSig: "xxx"})
     * };
     * tim.on(TIM.EVENT.LOGOUT_SUCCESS, onLogoutSuccess);
     * @private
     */
    LOGOUT_SUCCESS: 'logoutSuccess',

    /**
     * @description 拉取个人或其他人资料成功时触发，event.data是包含Profile对象的数组
     * @memberof module:EVENT
     * @example
     * let onProfileGetSuccess = function (event) {
     *     console.log(event.data); // 包含 Profile 对象的数组
     * };
     * tim.on(TIM.EVENT.PROFILE_GET_SUCCESS, onProfileGetSuccess);
     * @private
     */
    PROFILE_GET_SUCCESS: 'getProfileSuccess',

    /**
     * @description 拉取个人或其他人资料失败时触发，event.data是失败的相关信息
     * @memberof module:EVENT
     * @example
     * let onProfileGetFail = function (event) {
     *     console.log(event.data); // 失败的相关信息
     * };
     * tim.on(TIM.EVENT.PROFILE_GET_FAIL, onProfileGetFail);
     * @private
     */
    PROFILE_GET_FAIL: 'getProfileFail',

    /**
     * @description 自己或好友的资料发生变更时触发，event.data 是包含 Profile 对象的数组
     * @memberof module:EVENT
     * @example
     * let onProfileUpdated = function(event) {
     *   console.log(event.data); // 包含 Profile 对象的数组
     * };
     * tim.on(TIM.EVENT.PROFILE_UPDATED, onProfileUpdated);
     */
    PROFILE_UPDATED: 'onProfileUpdated',

    /**
     * @description 更新个人资料失败时触发，event.data是失败的相关信息
     * @memberof module:EVENT
     * @example
     * let onUpdateMyProfileFail = function (event) {
     *     console.log(event.data); // 失败的相关信息
     * };
     * tim.on(TIM.EVENT.PROFILE_UPDATE_MY_PROFILE_FAIL, onUpdateMyProfileFail);
     * @private
     */
    PROFILE_UPDATE_MY_PROFILE_FAIL: 'updateMyProfileFail',
    // 好友相关

    /**
     * @description 拉取好友列表成功，event.data是我的好友列表：包含Friend对象的数组
     * @memberof module:EVENT
     * @example
     * let onGetFriendListSuccess = function (event) {
     *     console.log(event.data); // 我的好友列表：包含Friend对象的数组
     * };
     * tim.on(TIM.EVENT.FRIENDLIST_GET_SUCCESS, onGetFriendListSuccess);
     * @private
     */
    FRIENDLIST_GET_SUCCESS: 'getFriendListSuccess',

    /**
     * @description 拉取好友列表失败，event.data是失败的相关信息
     * @memberof module:EVENT
     * @example
     * let onGetFriendListFail = function (event) {
     *     console.log(event.data); // 失败的相关信息
     * };
     * tim.on(TIM.EVENT.FRIENDLIST_GET_FAIL, onGetFriendListFail);
     * @private
     */
    FRIENDLIST_GET_FAIL: 'getFriendsFail',

    /**
     * @description 会话列表更新
     * @memberof module:EVENT
     * @private
     */
    FRIEND_DELETE_SUCCESS: 'deleteFriendSuccess',

    /**
     * @description 会话列表更新
     * @memberof module:EVENT
     * @private
     */
    FRIEND_DELETE_FAIL: 'deleteFriendFail',

    /**
     * @description 添加黑名单成功
     * @memberof module:EVENT
     * @example
     * let onAddBlacklistSuccess = function (event) {
     *     console.log(event.data); // 成功添加到黑名单的账号信息，结构为包含用户 userID 的数组
     * };
     * tim.on(TIM.EVENT.BLACKLIST_ADD_SUCCESS, onAddBlacklistSuccess);
     * @private
     */
    BLACKLIST_ADD_SUCCESS: 'addBlacklistSuccess',

    /**
     * @description 添加黑名单失败
     * @memberof module:EVENT
     * @example
     * let onAddBlacklistFail = funciton (event) {
     *     console.log(event.data); // 添加黑名单失败的相关信息
     * };
     * tim.on(TIM.EVENT.BLACKLIST_ADD_FAIL, onAddBlacklistFail);
     * @private
     */
    BLACKLIST_ADD_FAIL: 'addBlacklistFail',

    /**
     * @description 拉取我的黑名单列表成功
     * @memberof module:EVENT
     * @example
     * let onGetBlacklistSuccess = funciton (event) {
     *     console.log(event.data); // 我的黑名单列表，结构为包含用户 userID 的数组
     * };
     * tim.on(TIM.EVENT.BLACKLIST_GET_SUCCESS, onGetBlacklistSuccess);
     * @private
     */
    BLACKLIST_GET_SUCCESS: 'getBlacklistSuccess',

    /**
     * @description 拉取我的黑名单列表失败
     * @memberof module:EVENT
     * @example
     * let onGetBlacklistFail = funciton (event) {
     *     console.log(event.data); // 拉取黑名单失败的相关信息
     * };
     * tim.on(TIM.EVENT.BLACKLIST_GET_FAIL, onGetBlacklistFail);
     * @private
     */
    BLACKLIST_GET_FAIL: 'getBlacklistFail',

    /**
     * @description SDK 黑名单列表更新时触发
     * @memberof module:EVENT
     * @example
     * let onBlacklistUpdated = funciton(event) {
     *   console.log(event.data); // 我的黑名单列表，结构为包含用户 userID 的数组
     * };
     * tim.on(TIM.EVENT.BLACKLIST_UPDATED, onBlacklistUpdated);
     */
    BLACKLIST_UPDATED: 'blacklistUpdated',

    /**
     * @description 删除黑名单失败
     * @memberof module:EVENT
     * @example
     * let onDeleteBlacklistFail = funciton (event) {
     *   console.log(event.data); // 删除黑名单失败的相关信息
     * };
     * tim.on(TIM.EVENT.BLACKLIST_DELETE_FAIL, onDeleteBlacklistFail);
     * @private
     */
    BLACKLIST_DELETE_FAIL: 'deleteBlacklistFail',

    /**
     * @description 用户被踢下线时触发
     * @memberof module:EVENT
     * @example
     * let onKickedOut = funciton(event) {
     *   console.log(event.data.type);
     *   // 1.TIM.TYPES.KICKED_OUT_MULT_ACCOUNT(Web端，同一账号，多页面登录被踢)
     *   // 2.TIM.TYPES.KICKED_OUT_MULT_DEVICE(同一账号，多端登录被踢)
     * };
     * tim.on(TIM.EVENT.KICKED_OUT, onKickedOut);
     */
    KICKED_OUT: 'kickedOut',

    /**
     * @description SDK 遇到错误时触发
     * @memberof module:EVENT
     * @example
     * let onError = function(event) {
     *   // event.data.code - 错误码
     *   // event.data.message - 错误信息
     * };
     * tim.on(TIM.EVENT.ERROR, onError);
     */
    ERROR: 'error' // 给 SDK 外部处理的error事件

  };

  /**
   * 类型常量， 消息类型、会话类型...
   *
   */
  // 消息的相关状态
  var MESSAGE = {
    // 使用JSON格式, 时使用的状态配置
    JSON: {
      // 主类型
      TYPE: {
        C2C: {
          NOTICE: 1,
          // 新的c2c消息通知
          COMMON: 9,
          // 新的c2c消息
          EVENT: 10 // TODO:未知

        },
        GROUP: {
          COMMON: 3,
          // 新的群消息
          TIP: 4,
          // 新的群提示消息
          SYSTEM: 5,
          // 新的群系统消息
          TIP2: 6 // 新的群提示消息2

        },
        FRIEND: {
          NOTICE: 7 // 好友系统通知

        },
        PROFILE: {
          NOTICE: 8 // 资料系统通知

        }
      },
      // 子类型
      SUBTYPE: {
        C2C: {
          COMMON: 0,
          // 普通消息
          READED: 92,
          // 已读消息同步
          KICKEDOUT: 96 // TODO: 未知, 看相关老代码，是被踢下线的事件 webim.js 5327行

        },
        GROUP: {
          COMMON: 0,
          // 普通消息
          LOVEMESSAGE: 1,
          // 点赞消息
          TIP: 2,
          // 提示消息
          REDPACKET: 3 // 红包消息

        }
      },
      // 操作提示类型
      OPTIONS: {
        GROUP: {
          JOIN: 1,
          // 加入群组
          QUIT: 2,
          // 退出群组
          KICK: 3,
          // 被踢出群组
          SET_ADMIN: 4,
          // 被设置为管理员
          CANCEL_ADMIN: 5,
          // 被取消管理员
          MODIFY_GROUP_INFO: 6,
          // 修改群资料
          MODIFY_MEMBER_INFO: 7 // 修改群成员信息

        }
      }
    },
    // 使用PROTOBUF协议时，使用的状态配置
    PROTOBUF: {},
    // 消息元素的类型
    ELEMENT_TYPES: {
      TEXT: 'TIMTextElem',
      FACE: 'TIMFaceElem',
      SOUND: 'TIMSoundElem',
      FILE: 'TIMFileElem',
      VIDEO: 'TIMVideoFileElem',
      // 视频类消息的类型为TIMVideoFileElem ， 已经与dramon确认， 此类型待联调
      IMAGE: 'TIMImageElem',
      GEO: 'TIMLocationElem',
      GROUP_TIP: 'TIMGroupTipElem',
      GROUP_SYSTEM_NOTICE: 'TIMGroupSystemNoticeElem',
      CUSTOM: 'TIMCustomElem'
    },
    IMAGE_TYPES: {
      ORIGIN: 1,
      // 原图
      LARGE: 2,
      // 缩略大图
      SMALL: 3 // 缩略小图

    },
    IMAGE_FORMAT: {
      // JPG: 0x1,
      // JPEG: 0x1,
      // GIF: 0x2,
      // PNG: 0x3,
      // BMP: 0x4,
      // UNKNOWN: 0xff
      JPG: 1,
      JPEG: 1,
      GIF: 2,
      PNG: 3,
      BMP: 4,
      UNKNOWN: 255
    }
  }; // 会话类型
  // TODO: 为了上线前少改动代码，先保留不删，sdk上线后再处理

  var CONVERSATION_TYPES = {
    C2C: 'C2C',
    GROUP: 'GROUP',
    SYSTEM: '@TIM#SYSTEM'
  };
  var SYSTEM_CONVERSATION_ID = '@TIM#SYSTEM'; // export const CONVERSATION_SUBTYPES_PRIVATE = 'Private';
  // export const CONVERSATION_SUBTYPES_PUBLIC = 'Public';
  // export const CONVERSATION_SUBTYPES_CHATROOM = 'ChatRoom';
  // export const CONVERSATION_SUBTYPES_AVCHATROOM = 'AVChatRoom';
  // TODO: 为了上线前少改动代码，先保留不删，sdk上线后再处理

  var GROUP_TYPES = {
    PRIVATE: 'Private',
    PUBLIC: 'Public',
    CHATROOM: 'ChatRoom',
    AVCHATROOM: 'AVChatRoom'
  }; // 群组相关
  // 群成员身份
  // TODO: 为了上线前少改动代码，先保留不删，sdk上线后再处理

  var GROUP_MEMBER_ROLE_TYPES = {
    OWNER: 'Owner',
    ADMIN: 'Admin',
    MEMBER: 'Member'
  }; // // 群提示消息的含义 (GroupTip 中的operationType)
  // export const GROUP_TIP_TYPES = {
  //   MEMBER_JOIN: 1,
  //   MEMBER_QUIT: 2,
  //   MEMBER_KICKED_OUT: 3,
  //   MEMBER_SET_ADMIN: 4, //被设置为管理员
  //   MEMBER_CANCELED_ADMIN: 5, //被取消管理员
  //   GROUP_INFO_MODIFIED: 6, //修改群资料，转让群组为该类型，msgBody.msgGroupNewInfo.ownerAccount表示新群主的ID
  //   MEMBER_INFO_MODIFIED: 7 //修改群成员信息
  // };
  // // 群系统通知的含义 (GroupSystemNotice中的operationType)
  // TODO: 为了上线前少改动代码，先保留不删，sdk上线后再处理

  var GROUP_SYSTEM_NOTICE_TYPES = {
    JOIN_GROUP_REQUEST: 1,
    // 申请加群请求（只有管理员会收到）
    JOIN_GROUP_ACCEPT: 2,
    // 申请加群被同意（只有申请人能够收到）
    JOIN_GROUP_REFUSE: 3,
    // 申请加群被拒绝（只有申请人能够收到）
    KICKED_OUT: 4,
    // 被管理员踢出群(只有被踢者接收到)
    GROUP_DISMISSED: 5,
    // 群被解散(全员接收)
    GROUP_CREATED: 6,
    // 创建群(创建者接收, 不展示)
    INVITED_JOIN_GROUP_REQUEST: 7,
    // 邀请加群(被邀请者接收)。
    QUIT: 8,
    // 主动退群(主动退出者接收, 不展示)
    SET_ADMIN: 9,
    // 设置管理员(被设置者接收)
    CANCELED_ADMIN: 10,
    // 取消管理员(被取消者接收)
    REVOKE: 11,
    // 群已被回收(全员接收, 不展示)
    INVITED_JOIN_GROUP_REQUEST_AGREE: 12,
    // 邀请加群(被邀请者需同意)
    READED: 15,
    // 群消息已读同步
    CUSTOM: 255 // 用户自定义通知(默认全员接收)

  }; // export const MESSAGE_REMIND_TYPES = {
  //   ACCEPT_AND_NOTIFY: 'AcceptAndNotify',
  //   ACCEPT_NOT_NOTIFY: 'AcceptNotNotify',
  //   DISCARD: 'Discard'
  // };
  // TODO: 为了上线前少改动代码，先保留不删，sdk上线后再处理

  var KICKED_OUT_TYPES = {
    MUTIPLE_ACCOUNT: 'mutipleAccount',
    MUTIPLE_DEVICE: 'mutipleDevice'
  };
  var RUNLOOP_TYPES = {
    AUTO: 0,
    SOCKET: 1,
    XHR: 2
  };
  var LOGOUT_TYPES = {
    ALL: 0,
    LONG_POLL: 1
  }; // 以下profile相关
  // TODO: 为了上线前少改动代码，先保留不删，sdk上线后再处理

  var GENDER_TYPES = {
    UNKNOWN: 'Gender_Type_Unknown',
    // 没设置性别
    FEMALE: 'Gender_Type_Female',
    // 女性
    MALE: 'Gender_Type_Male' // 男性

  };
  var ALLOW_TYPES = {
    NEED_CONFIRM: 'AllowType_Type_NeedConfirm',
    // 需要经过自己确认才能添加自己为好友
    ALLOW_ANY: 'AllowType_Type_AllowAny',
    // 允许任何人添加自己为好友
    DENY_ANY: 'AllowType_Type_DenyAny' // 不允许任何人添加自己为好友

  };
  var FORBID_TYPES = {
    NONE: 'AdminForbid_Type_None',
    // 默认值，允许加好友
    SEND_OUT: 'AdminForbid_Type_SendOut' // 禁止该用户发起加好友请求

  };
  var STANDARD_IM_PROFILE = {
    NICK: 'Tag_Profile_IM_Nick',
    GENDER: 'Tag_Profile_IM_Gender',
    BIRTHDAY: 'Tag_Profile_IM_BirthDay',
    LOCATION: 'Tag_Profile_IM_Location',
    SELFSIGNATURE: 'Tag_Profile_IM_SelfSignature',
    ALLOWTYPE: 'Tag_Profile_IM_AllowType',
    LANGUAGE: 'Tag_Profile_IM_Language',
    AVATAR: 'Tag_Profile_IM_Image',
    MESSAGESETTINGS: 'Tag_Profile_IM_MsgSettings',
    ADMINFORBIDTYPE: 'Tag_Profile_IM_AdminForbidType',
    LEVEL: 'Tag_Profile_IM_Level',
    ROLE: 'Tag_Profile_IM_Role'
  };
  /**
   * SDK 中的类型常量。为了代码简洁、方便阅读，部分常量使用常见的英文单词缩写描述，具体如下：<br/>
   * | 缩写 | 全称 |
   * | :--- | :---- |
   * | CONV | CONVERSATION（会话）|
   * | GRP | GROUP（群组）|
   * | MSG | MESSAGE（消息）|
   * | SYS | SYSTEM（系统）|
   * | MBR | MEMBER（成员）|
   * | ACPT | ACCEPT（接受）|
   * | NOTE | NOTIFY（通知）|
   * | MULT | MULTIPLE（多重的）|
   * @memberof SDK
   * @exports TYPES
   * @module TYPES
   * @example
   * // 判断消息类型
   * const isTextMessage = message.type === TIM.TYPES.MSG_TEXT // 是否是文本消息类型
   * // 判断会话类型
   * const isGroupConversation = conversation.type === TIM.TYPES.CONV_GROUP // 是否是群组会话
   */

  var TYPES = {
    // /**
    //  * 消息类型
    //  * @property {String} TEXT 文本
    //  * @property {String} IMAGE 图片
    //  * @property {String} SOUND 音频
    //  * @property {String} FILE 文件
    //  * @property {String} CUSTOM 自定义消息
    //  * @property {String} GROUP_TIP 群提示消息
    //  * @property {String} GROUP_SYSTEM_NOTICE 群系统消息
    //  * @memberOf module:TYPES
    //  */
    // MESSAGE_TYPES: MESSAGE.ELEMENT_TYPES,

    /**
     * @description 消息类型：文本消息
     * @memberof module:TYPES
     */
    MSG_TEXT: 'TIMTextElem',

    /**
     * @description 消息类型：图片消息
     * @memberof module:TYPES
     */
    MSG_IMAGE: 'TIMImageElem',

    /**
     * @description 消息类型：音频消息
     * @memberof module:TYPES
     */
    MSG_SOUND: 'TIMSoundElem',

    /**
     * @description 消息类型：文件消息
     * @memberof module:TYPES
     */
    MSG_FILE: 'TIMFileElem',

    /**
     * @private
     * @description 消息类型：表情消息
     * @memberof module:TYPES
     */
    MSG_FACE: 'TIMFaceElem',

    /**
     * @private
     * @description 消息类型：视频消息
     * @memberof module:TYPES
     */
    MSG_VIDEO: 'TIMVideoElem',

    /**
     * @private
     * @description 消息类型：位置消息
     * @memberof module:TYPES
     */
    MSG_GEO: 'TIMLocationElem',

    /**
     * @description 消息类型：群提示消息
     * @memberof module:TYPES
     */
    MSG_GRP_TIP: 'TIMGroupTipElem',

    /**
     * @description 消息类型：群系统通知消息
     * @memberof module:TYPES
     */
    MSG_GRP_SYS_NOTICE: 'TIMGroupSystemNoticeElem',

    /**
     * @description 消息类型：自定义消息
     * @memberof module:TYPES
     */
    MSG_CUSTOM: 'TIMCustomElem',
    // /**
    //  * 会话类型
    //  * @property {String} C2C C2C 会话类型
    //  * @property {String} GROUP 群组会话类型
    //  * @property {String} SYSTEM 系统会话类型
    //  * @memberOf module:TYPES
    //  */
    // // CONVERSATION_TYPES,

    /**
     * @description 会话类型：C2C(Client to Client, 端到端) 会话
     * @memberof module:TYPES
     */
    CONV_C2C: 'C2C',

    /**
     * @description 会话类型：GROUP(群组) 会话
     * @memberof module:TYPES
     */
    CONV_GROUP: 'GROUP',

    /**
     * @description 会话类型：SYSTEM(系统) 会话
     * @memberof module:TYPES
     */
    CONV_SYSTEM: '@TIM#SYSTEM',

    /**
     * 群组类型
     * @property {String} PRIVATE 私有群
     * @property {String} PUBLIC 公开群
     * @property {String} CHATROOM 聊天室
     * @property {String} AVCHATROOM 音视频聊天室
     * @memberOf module:TYPES
     */
    // GROUP_TYPES,

    /**
     * @description 群组类型：私有群
     * @memberof module:TYPES
     */
    GRP_PRIVATE: 'Private',

    /**
     * @description 群组类型：公开群
     * @memberof module:TYPES
     */
    GRP_PUBLIC: 'Public',

    /**
     * @description 群组类型：聊天室
     * @memberof module:TYPES
     */
    GRP_CHATROOM: 'ChatRoom',

    /**
     * @description 群组类型：音视频聊天室
     * @memberof module:TYPES
     */
    GRP_AVCHATROOM: 'AVChatRoom',

    /**
     * 群成员身份类型常量及含义
     * @property {String} OWNER 群主
     * @property {String} ADMIN 管理员
     * @property {String} MEMBER 普通群成员
     * @memberOf module:TYPES
     */
    // GROUP_MEMBER_ROLE_TYPES,

    /**
     * @description 群成员角色：群主
     * @memberof module:TYPES
     */
    GRP_MBR_ROLE_OWNER: 'Owner',

    /**
     * @description 群成员角色：管理员
     * @memberof module:TYPES
     */
    GRP_MBR_ROLE_ADMIN: 'Admin',

    /**
     * @description 群成员角色：普通群成员
     * @memberof module:TYPES
     */
    GRP_MBR_ROLE_MEMBER: 'Member',

    /**
     * 群提示消息类型常量含义
     * @property {Number} MEMBER_JOIN 有群成员加群
     * @property {Number} MEMBER_QUIT 有群成员退群
     * @property {Number} MEMBER_KICKED_OUT 有群成员被踢出群
     * @property {Number} MEMBER_SET_ADMIN 有群成员被设为管理员
     * @property {Number} MEMBER_CANCELED_ADMIN 有群成员被撤销管理员
     * @property {Number} GROUP_INFO_MODIFIED 群组资料变更
     * @property {Number} MEMBER_INFO_MODIFIED 群成员资料变更
     * @memberOf module:TYPES
     */
    // GROUP_TIP_TYPES,

    /**
     * @description 群提示：有成员加群
     * @memberof module:TYPES
     */
    GRP_TIP_MBR_JOIN: 1,

    /**
     * @description 群提示：有群成员退群
     * @memberof module:TYPES
     */
    GRP_TIP_MBR_QUIT: 2,

    /**
     * @description 群提示：有群成员被踢出群
     * @memberof module:TYPES
     */
    GRP_TIP_MBR_KICKED_OUT: 3,

    /**
     * @description 群提示：有群成员被设为管理员
     * @memberof module:TYPES
     */
    GRP_TIP_MBR_SET_ADMIN: 4,
    // 被设置为管理员

    /**
     * @description 群提示：有群成员被撤销管理员
     * @memberof module:TYPES
     */
    GRP_TIP_MBR_CANCELED_ADMIN: 5,
    // 被取消管理员

    /**
     * @description 群提示：群组资料变更
     * @memberof module:TYPES
     */
    GRP_TIP_GRP_PROFILE_UPDATED: 6,
    // 修改群资料，转让群组为该类型，msgBody.msgGroupNewInfo.ownerAccount表示新群主的ID

    /**
     * @description 群提示：群成员资料变更
     * @memberof module:TYPES
     */
    GRP_TIP_MBR_PROFILE_UPDATED: 7,
    // 修改群成员信息

    /**
     * 群系统通知类型常量及含义
     * @property {Number} JOIN_GROUP_REQUEST 有用户申请加群。群管理员/群主接收
     * @property {Number} JOIN_GROUP_ACCEPT 申请加群被同意。申请加群的用户接收
     * @property {Number} JOIN_GROUP_REFUSE 申请加群被拒绝。申请加群的用户接收
     * @property {Number} KICKED_OUT 被踢出群组。被踢出的用户接收
     * @property {Number} GROUP_DISMISSED 群组被解散。全体群成员接收
     * @property {Number} GROUP_CREATED 创建群组。创建者接收
     * @property {Number} QUIT 退群。退群者接收
     * @property {Number} SET_ADMIN 设置管理员。被设置方接收
     * @property {Number} CANCELED_ADMIN 取消管理员。被取消方接收
     * @property {Number} CUSTOM 自定义系统通知。全员接收
     * @memberOf module:TYPES
     */
    // GROUP_SYSTEM_NOTICE_TYPES,

    /**
     * @private
     * @description 有用户申请加群。群管理员/群主接收
     * @memberof module:TYPES
     */
    // GROUP_SYSTEM_NOTICE_JOIN_GROUP_REQUEST: 1, //申请加群请求（只有管理员会收到）

    /**
     * @private
     * @description 申请加群被同意。申请加群的用户接收
     * @memberof module:TYPES
     */
    // GROUP_SYSTEM_NOTICE_JOIN_GROUP_ACCEPT: 2, //申请加群被同意（只有申请人能够收到）

    /**
     * @private
     * @description 申请加群被拒绝。申请加群的用户接收
     * @memberof module:TYPES
     */
    // GROUP_SYSTEM_NOTICE_JOIN_GROUP_REFUSE: 3, //申请加群被拒绝（只有申请人能够收到）

    /**
     * @private
     * @description 被踢出群组。被踢出的用户接收
     * @memberof module:TYPES
     */
    // GROUP_SYSTEM_NOTICE_KICKED_OUT: 4, //被管理员踢出群(只有被踢者接收到)

    /**
     * @private
     * @description 群组被解散。全体群成员接收
     * @memberof module:TYPES
     */
    // GROUP_SYSTEM_NOTICE_GROUP_DISMISSED: 5, //群被解散(全员接收)

    /**
     * @private
     * @description 创建群组。创建者接收
     * @memberof module:TYPES
     */
    // GROUP_SYSTEM_NOTICE_GROUP_CREATED: 6, //创建群(创建者接收, 不展示)

    /**
     * @private
     * @description 邀请加群(被邀请者接收)
     * @memberof module:TYPES
     */
    // GROUP_SYSTEM_NOTICE_INVITED_JOIN_GROUP_REQUEST: 7, //邀请加群(被邀请者接收)。

    /**
     * @private
     * @description 退群。退群者接收
     * @memberof module:TYPES
     */
    // GROUP_SYSTEM_NOTICE_QUIT: 8, //主动退群(主动退出者接收, 不展示)

    /**
     * @private
     * @description 设置管理员。被设置方接收
     * @memberof module:TYPES
     */
    // GROUP_SYSTEM_NOTICE_SET_ADMIN: 9, //设置管理员(被设置者接收)

    /**
     * @private
     * @description 取消管理员。被取消方接收
     * @memberof module:TYPES
     */
    // GROUP_SYSTEM_NOTICE_CANCELED_ADMIN: 10, //取消管理员(被取消者接收)

    /**
     * @private
     * @description 群已被回收(全员接收, 不展示)
     * @memberof module:TYPES
     */
    // GROUP_SYSTEM_NOTICE_REVOKE: 11, //群已被回收(全员接收, 不展示)

    /**
     * @private
     * @description 邀请加群(被邀请者需同意)
     * @memberof module:TYPES
     */
    // GROUP_SYSTEM_NOTICE_INVITED_JOIN_GROUP_REQUEST_AGREE: 12, //邀请加群(被邀请者需同意)

    /**
     * @private
     * @description 群消息已读同步
     * @memberof module:TYPES
     */
    // GROUP_SYSTEM_NOTICE_READED: 15, //群消息已读同步

    /**
     * @private
     * @description 用户自定义通知(默认全员接收)
     * @memberof module:TYPES
     */
    // GROUP_SYSTEM_NOTICE_CUSTOM: 255, //用户自定义通知(默认全员接收)

    /**
     * 群消息提示类型常量及含义
     * @property {String} ACCEPT_AND_NOTIFY 通知并提示
     * @property {String} ACCEPT_NOT_NOTIFY 通知但不提示
     * @property {String} DISCARD 拒收消息
     * @memberOf module:TYPES
     */
    // MESSAGE_REMIND_TYPES,

    /**
     * @description 群消息提示类型：SDK 接收消息并通知接入侧，接入侧做提示
     * @memberof module:TYPES
     */
    MSG_REMIND_ACPT_AND_NOTE: 'AcceptAndNotify',

    /**
     * @description 群消息提示类型：SDK 接收消息并通知接入侧，接入侧不做提示
     * @memberof module:TYPES
     */
    MSG_REMIND_ACPT_NOT_NOTE: 'AcceptNotNotify',

    /**
     * @description 群消息提示类型：SDK 拒收消息
     * @memberof module:TYPES
     */
    MSG_REMIND_DISCARD: 'Discard',

    /**
     * 性别类型常量及含义
     * @property {String} MALE 男
     * @property {String} FEMALE 女
     * @property {String} UNKNOWN 未设置性别
     * @memberOf module:TYPES
     */
    // GENDER_TYPES,

    /**
     * @description 性别：未设置性别
     * @memberOf module:TYPES
     */
    GENDER_UNKNOWN: 'Gender_Type_Unknown',

    /**
     * @description 性别：女性
     * @memberOf module:TYPES
     */
    GENDER_FEMALE: 'Gender_Type_Female',

    /**
     * @description 性别：男性
     * @memberOf module:TYPES
     */
    GENDER_MALE: 'Gender_Type_Male',

    /**
     * 被踢类型常量及含义
     * @property {String} MUTIPLE_ACCOUNT 多账号登录被踢
     * @memberOf module:TYPES
     */
    // KICKED_OUT_TYPES,

    /**
     * @description 被踢类型：多账号登录被踢
     * @memberOf module:TYPES
     */
    KICKED_OUT_MULT_ACCOUNT: 'mutipleAccount',

    /**
     * @private
     */
    KICKED_OUT_MULT_DEVICE: 'mutipleDevice',

    /**
     * @description 当被人加好友时：允许任何人添加自己为好友
     * @memberOf module:TYPES
     */
    ALLOW_TYPE_ALLOW_ANY: 'AllowType_Type_AllowAny',

    /**
     * @description 当被人加好友时：需要经过自己确认才能添加自己为好友
     * @memberOf module:TYPES
     */
    ALLOW_TYPE_NEED_CONFIRM: 'AllowType_Type_NeedConfirm',

    /**
     * @description 当被人加好友时：不允许任何人添加自己为好友
     * @memberOf module:TYPES
     */
    ALLOW_TYPE_DENY_ANY: 'AllowType_Type_DenyAny',

    /**
     * @description 管理员禁止加好友标识：默认值，允许加好友
     * @memberOf module:TYPES
     */
    FORBID_TYPE_NONE: 'AdminForbid_Type_None',

    /**
     * @description 管理员禁止加好友标识：禁止该用户发起加好友请求
     * @memberOf module:TYPES
     */
    FORBID_TYPE_SEND_OUT: 'AdminForbid_Type_SendOut',

    /**
     * @description 加群选项：自由加入
     * @memberOf module:TYPES
     */
    JOIN_OPTIONS_FREE_ACCESS: 'FreeAccess',

    /**
     * @description 加群选项：需要管理员同意
     * @memberOf module:TYPES
     */
    JOIN_OPTIONS_NEED_PERMISSION: 'NeedPermission',

    /**
     * @description 加群选项：不允许加群
     * @memberOf module:TYPES
     */
    JOIN_OPTIONS_DISABLE_APPLY: 'DisableApply',

    /**
     * @description 加群申请状态：加群成功
     * @memberOf module:TYPES
     */
    JOIN_STATUS_SUCCESS: 'JoinedSuccess',

    /**
     * @description 加群申请状态：等待管理员同意
     * @memberOf module:TYPES
     */
    JOIN_STATUS_WAIT_APPROVAL: 'WaitAdminApproval'
  };

  function _typeof(obj) {
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function (obj) {
        return typeof obj;
      };
    } else {
      _typeof = function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof(obj);
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);

    if (Object.getOwnPropertySymbols) {
      keys.push.apply(keys, Object.getOwnPropertySymbols(object));
    }

    if (enumerableOnly) keys = keys.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    return keys;
  }

  function _objectSpread2(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};

      if (i % 2) {
        ownKeys(source, true).forEach(function (key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys(source).forEach(function (key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }

    return target;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }

  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  function isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _construct(Parent, args, Class) {
    if (isNativeReflectConstruct()) {
      _construct = Reflect.construct;
    } else {
      _construct = function _construct(Parent, args, Class) {
        var a = [null];
        a.push.apply(a, args);
        var Constructor = Function.bind.apply(Parent, a);
        var instance = new Constructor();
        if (Class) _setPrototypeOf(instance, Class.prototype);
        return instance;
      };
    }

    return _construct.apply(null, arguments);
  }

  function _isNativeFunction(fn) {
    return Function.toString.call(fn).indexOf("[native code]") !== -1;
  }

  function _wrapNativeSuper(Class) {
    var _cache = typeof Map === "function" ? new Map() : undefined;

    _wrapNativeSuper = function _wrapNativeSuper(Class) {
      if (Class === null || !_isNativeFunction(Class)) return Class;

      if (typeof Class !== "function") {
        throw new TypeError("Super expression must either be null or a function");
      }

      if (typeof _cache !== "undefined") {
        if (_cache.has(Class)) return _cache.get(Class);

        _cache.set(Class, Wrapper);
      }

      function Wrapper() {
        return _construct(Class, arguments, _getPrototypeOf(this).constructor);
      }

      Wrapper.prototype = Object.create(Class.prototype, {
        constructor: {
          value: Wrapper,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      return _setPrototypeOf(Wrapper, Class);
    };

    return _wrapNativeSuper(Class);
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized(self);
  }

  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
  }

  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
  }

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

      return arr2;
    }
  }

  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  function _iterableToArray(iter) {
    if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
  }

  function _iterableToArrayLimit(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance");
  }

  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance");
  }

  var Middleware =
  /*#__PURE__*/
  function () {
    function Middleware() {
      _classCallCheck(this, Middleware);

      this.cache = [];
      this.options = null; //缓存options
    }

    _createClass(Middleware, [{
      key: "use",
      value: function use(fn) {
        if (typeof fn !== 'function') {
          throw 'middleware must be a function';
        }

        this.cache.push(fn);
        return this;
      }
    }, {
      key: "next",
      value: function next(fn) {
        if (this.middlewares && this.middlewares.length > 0) {
          var ware = this.middlewares.shift();
          return ware.call(this, this.options, this.next.bind(this)); // 需要返回中间件函数运行多结果
        }
      }
      /**
       * @param options 数据的入口
       * @param next
       */

    }, {
      key: "run",
      value: function run(options) {
        this.middlewares = this.cache.map(function (fn) {
          return fn;
        });
        this.options = options; // 缓存数据

        return this.next();
      }
    }]);

    return Middleware;
  }();

  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  function createCommonjsModule(fn, module) {
  	return module = { exports: {} }, fn(module, module.exports), module.exports;
  }

  var typeDetect = createCommonjsModule(function (module, exports) {
  (function (global, factory) {
  	 module.exports = factory() ;
  }(commonjsGlobal, (function () {
  /* !
   * type-detect
   * Copyright(c) 2013 jake luer <jake@alogicalparadox.com>
   * MIT Licensed
   */
  var promiseExists = typeof Promise === 'function';

  /* eslint-disable no-undef */
  var globalObject = typeof self === 'object' ? self : commonjsGlobal; // eslint-disable-line id-blacklist

  var symbolExists = typeof Symbol !== 'undefined';
  var mapExists = typeof Map !== 'undefined';
  var setExists = typeof Set !== 'undefined';
  var weakMapExists = typeof WeakMap !== 'undefined';
  var weakSetExists = typeof WeakSet !== 'undefined';
  var dataViewExists = typeof DataView !== 'undefined';
  var symbolIteratorExists = symbolExists && typeof Symbol.iterator !== 'undefined';
  var symbolToStringTagExists = symbolExists && typeof Symbol.toStringTag !== 'undefined';
  var setEntriesExists = setExists && typeof Set.prototype.entries === 'function';
  var mapEntriesExists = mapExists && typeof Map.prototype.entries === 'function';
  var setIteratorPrototype = setEntriesExists && Object.getPrototypeOf(new Set().entries());
  var mapIteratorPrototype = mapEntriesExists && Object.getPrototypeOf(new Map().entries());
  var arrayIteratorExists = symbolIteratorExists && typeof Array.prototype[Symbol.iterator] === 'function';
  var arrayIteratorPrototype = arrayIteratorExists && Object.getPrototypeOf([][Symbol.iterator]());
  var stringIteratorExists = symbolIteratorExists && typeof String.prototype[Symbol.iterator] === 'function';
  var stringIteratorPrototype = stringIteratorExists && Object.getPrototypeOf(''[Symbol.iterator]());
  var toStringLeftSliceLength = 8;
  var toStringRightSliceLength = -1;
  /**
   * ### typeOf (obj)
   *
   * Uses `Object.prototype.toString` to determine the type of an object,
   * normalising behaviour across engine versions & well optimised.
   *
   * @param {Mixed} object
   * @return {String} object type
   * @api public
   */
  function typeDetect(obj) {
    /* ! Speed optimisation
     * Pre:
     *   string literal     x 3,039,035 ops/sec ±1.62% (78 runs sampled)
     *   boolean literal    x 1,424,138 ops/sec ±4.54% (75 runs sampled)
     *   number literal     x 1,653,153 ops/sec ±1.91% (82 runs sampled)
     *   undefined          x 9,978,660 ops/sec ±1.92% (75 runs sampled)
     *   function           x 2,556,769 ops/sec ±1.73% (77 runs sampled)
     * Post:
     *   string literal     x 38,564,796 ops/sec ±1.15% (79 runs sampled)
     *   boolean literal    x 31,148,940 ops/sec ±1.10% (79 runs sampled)
     *   number literal     x 32,679,330 ops/sec ±1.90% (78 runs sampled)
     *   undefined          x 32,363,368 ops/sec ±1.07% (82 runs sampled)
     *   function           x 31,296,870 ops/sec ±0.96% (83 runs sampled)
     */
    var typeofObj = typeof obj;
    if (typeofObj !== 'object') {
      return typeofObj;
    }

    /* ! Speed optimisation
     * Pre:
     *   null               x 28,645,765 ops/sec ±1.17% (82 runs sampled)
     * Post:
     *   null               x 36,428,962 ops/sec ±1.37% (84 runs sampled)
     */
    if (obj === null) {
      return 'null';
    }

    /* ! Spec Conformance
     * Test: `Object.prototype.toString.call(window)``
     *  - Node === "[object global]"
     *  - Chrome === "[object global]"
     *  - Firefox === "[object Window]"
     *  - PhantomJS === "[object Window]"
     *  - Safari === "[object Window]"
     *  - IE 11 === "[object Window]"
     *  - IE Edge === "[object Window]"
     * Test: `Object.prototype.toString.call(this)``
     *  - Chrome Worker === "[object global]"
     *  - Firefox Worker === "[object DedicatedWorkerGlobalScope]"
     *  - Safari Worker === "[object DedicatedWorkerGlobalScope]"
     *  - IE 11 Worker === "[object WorkerGlobalScope]"
     *  - IE Edge Worker === "[object WorkerGlobalScope]"
     */
    if (obj === globalObject) {
      return 'global';
    }

    /* ! Speed optimisation
     * Pre:
     *   array literal      x 2,888,352 ops/sec ±0.67% (82 runs sampled)
     * Post:
     *   array literal      x 22,479,650 ops/sec ±0.96% (81 runs sampled)
     */
    if (
      Array.isArray(obj) &&
      (symbolToStringTagExists === false || !(Symbol.toStringTag in obj))
    ) {
      return 'Array';
    }

    // Not caching existence of `window` and related properties due to potential
    // for `window` to be unset before tests in quasi-browser environments.
    if (typeof window === 'object' && window !== null) {
      /* ! Spec Conformance
       * (https://html.spec.whatwg.org/multipage/browsers.html#location)
       * WhatWG HTML$7.7.3 - The `Location` interface
       * Test: `Object.prototype.toString.call(window.location)``
       *  - IE <=11 === "[object Object]"
       *  - IE Edge <=13 === "[object Object]"
       */
      if (typeof window.location === 'object' && obj === window.location) {
        return 'Location';
      }

      /* ! Spec Conformance
       * (https://html.spec.whatwg.org/#document)
       * WhatWG HTML$3.1.1 - The `Document` object
       * Note: Most browsers currently adher to the W3C DOM Level 2 spec
       *       (https://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-26809268)
       *       which suggests that browsers should use HTMLTableCellElement for
       *       both TD and TH elements. WhatWG separates these.
       *       WhatWG HTML states:
       *         > For historical reasons, Window objects must also have a
       *         > writable, configurable, non-enumerable property named
       *         > HTMLDocument whose value is the Document interface object.
       * Test: `Object.prototype.toString.call(document)``
       *  - Chrome === "[object HTMLDocument]"
       *  - Firefox === "[object HTMLDocument]"
       *  - Safari === "[object HTMLDocument]"
       *  - IE <=10 === "[object Document]"
       *  - IE 11 === "[object HTMLDocument]"
       *  - IE Edge <=13 === "[object HTMLDocument]"
       */
      if (typeof window.document === 'object' && obj === window.document) {
        return 'Document';
      }

      if (typeof window.navigator === 'object') {
        /* ! Spec Conformance
         * (https://html.spec.whatwg.org/multipage/webappapis.html#mimetypearray)
         * WhatWG HTML$8.6.1.5 - Plugins - Interface MimeTypeArray
         * Test: `Object.prototype.toString.call(navigator.mimeTypes)``
         *  - IE <=10 === "[object MSMimeTypesCollection]"
         */
        if (typeof window.navigator.mimeTypes === 'object' &&
            obj === window.navigator.mimeTypes) {
          return 'MimeTypeArray';
        }

        /* ! Spec Conformance
         * (https://html.spec.whatwg.org/multipage/webappapis.html#pluginarray)
         * WhatWG HTML$8.6.1.5 - Plugins - Interface PluginArray
         * Test: `Object.prototype.toString.call(navigator.plugins)``
         *  - IE <=10 === "[object MSPluginsCollection]"
         */
        if (typeof window.navigator.plugins === 'object' &&
            obj === window.navigator.plugins) {
          return 'PluginArray';
        }
      }

      if ((typeof window.HTMLElement === 'function' ||
          typeof window.HTMLElement === 'object') &&
          obj instanceof window.HTMLElement) {
        /* ! Spec Conformance
        * (https://html.spec.whatwg.org/multipage/webappapis.html#pluginarray)
        * WhatWG HTML$4.4.4 - The `blockquote` element - Interface `HTMLQuoteElement`
        * Test: `Object.prototype.toString.call(document.createElement('blockquote'))``
        *  - IE <=10 === "[object HTMLBlockElement]"
        */
        if (obj.tagName === 'BLOCKQUOTE') {
          return 'HTMLQuoteElement';
        }

        /* ! Spec Conformance
         * (https://html.spec.whatwg.org/#htmltabledatacellelement)
         * WhatWG HTML$4.9.9 - The `td` element - Interface `HTMLTableDataCellElement`
         * Note: Most browsers currently adher to the W3C DOM Level 2 spec
         *       (https://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-82915075)
         *       which suggests that browsers should use HTMLTableCellElement for
         *       both TD and TH elements. WhatWG separates these.
         * Test: Object.prototype.toString.call(document.createElement('td'))
         *  - Chrome === "[object HTMLTableCellElement]"
         *  - Firefox === "[object HTMLTableCellElement]"
         *  - Safari === "[object HTMLTableCellElement]"
         */
        if (obj.tagName === 'TD') {
          return 'HTMLTableDataCellElement';
        }

        /* ! Spec Conformance
         * (https://html.spec.whatwg.org/#htmltableheadercellelement)
         * WhatWG HTML$4.9.9 - The `td` element - Interface `HTMLTableHeaderCellElement`
         * Note: Most browsers currently adher to the W3C DOM Level 2 spec
         *       (https://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-82915075)
         *       which suggests that browsers should use HTMLTableCellElement for
         *       both TD and TH elements. WhatWG separates these.
         * Test: Object.prototype.toString.call(document.createElement('th'))
         *  - Chrome === "[object HTMLTableCellElement]"
         *  - Firefox === "[object HTMLTableCellElement]"
         *  - Safari === "[object HTMLTableCellElement]"
         */
        if (obj.tagName === 'TH') {
          return 'HTMLTableHeaderCellElement';
        }
      }
    }

    /* ! Speed optimisation
    * Pre:
    *   Float64Array       x 625,644 ops/sec ±1.58% (80 runs sampled)
    *   Float32Array       x 1,279,852 ops/sec ±2.91% (77 runs sampled)
    *   Uint32Array        x 1,178,185 ops/sec ±1.95% (83 runs sampled)
    *   Uint16Array        x 1,008,380 ops/sec ±2.25% (80 runs sampled)
    *   Uint8Array         x 1,128,040 ops/sec ±2.11% (81 runs sampled)
    *   Int32Array         x 1,170,119 ops/sec ±2.88% (80 runs sampled)
    *   Int16Array         x 1,176,348 ops/sec ±5.79% (86 runs sampled)
    *   Int8Array          x 1,058,707 ops/sec ±4.94% (77 runs sampled)
    *   Uint8ClampedArray  x 1,110,633 ops/sec ±4.20% (80 runs sampled)
    * Post:
    *   Float64Array       x 7,105,671 ops/sec ±13.47% (64 runs sampled)
    *   Float32Array       x 5,887,912 ops/sec ±1.46% (82 runs sampled)
    *   Uint32Array        x 6,491,661 ops/sec ±1.76% (79 runs sampled)
    *   Uint16Array        x 6,559,795 ops/sec ±1.67% (82 runs sampled)
    *   Uint8Array         x 6,463,966 ops/sec ±1.43% (85 runs sampled)
    *   Int32Array         x 5,641,841 ops/sec ±3.49% (81 runs sampled)
    *   Int16Array         x 6,583,511 ops/sec ±1.98% (80 runs sampled)
    *   Int8Array          x 6,606,078 ops/sec ±1.74% (81 runs sampled)
    *   Uint8ClampedArray  x 6,602,224 ops/sec ±1.77% (83 runs sampled)
    */
    var stringTag = (symbolToStringTagExists && obj[Symbol.toStringTag]);
    if (typeof stringTag === 'string') {
      return stringTag;
    }

    var objPrototype = Object.getPrototypeOf(obj);
    /* ! Speed optimisation
    * Pre:
    *   regex literal      x 1,772,385 ops/sec ±1.85% (77 runs sampled)
    *   regex constructor  x 2,143,634 ops/sec ±2.46% (78 runs sampled)
    * Post:
    *   regex literal      x 3,928,009 ops/sec ±0.65% (78 runs sampled)
    *   regex constructor  x 3,931,108 ops/sec ±0.58% (84 runs sampled)
    */
    if (objPrototype === RegExp.prototype) {
      return 'RegExp';
    }

    /* ! Speed optimisation
    * Pre:
    *   date               x 2,130,074 ops/sec ±4.42% (68 runs sampled)
    * Post:
    *   date               x 3,953,779 ops/sec ±1.35% (77 runs sampled)
    */
    if (objPrototype === Date.prototype) {
      return 'Date';
    }

    /* ! Spec Conformance
     * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-promise.prototype-@@tostringtag)
     * ES6$25.4.5.4 - Promise.prototype[@@toStringTag] should be "Promise":
     * Test: `Object.prototype.toString.call(Promise.resolve())``
     *  - Chrome <=47 === "[object Object]"
     *  - Edge <=20 === "[object Object]"
     *  - Firefox 29-Latest === "[object Promise]"
     *  - Safari 7.1-Latest === "[object Promise]"
     */
    if (promiseExists && objPrototype === Promise.prototype) {
      return 'Promise';
    }

    /* ! Speed optimisation
    * Pre:
    *   set                x 2,222,186 ops/sec ±1.31% (82 runs sampled)
    * Post:
    *   set                x 4,545,879 ops/sec ±1.13% (83 runs sampled)
    */
    if (setExists && objPrototype === Set.prototype) {
      return 'Set';
    }

    /* ! Speed optimisation
    * Pre:
    *   map                x 2,396,842 ops/sec ±1.59% (81 runs sampled)
    * Post:
    *   map                x 4,183,945 ops/sec ±6.59% (82 runs sampled)
    */
    if (mapExists && objPrototype === Map.prototype) {
      return 'Map';
    }

    /* ! Speed optimisation
    * Pre:
    *   weakset            x 1,323,220 ops/sec ±2.17% (76 runs sampled)
    * Post:
    *   weakset            x 4,237,510 ops/sec ±2.01% (77 runs sampled)
    */
    if (weakSetExists && objPrototype === WeakSet.prototype) {
      return 'WeakSet';
    }

    /* ! Speed optimisation
    * Pre:
    *   weakmap            x 1,500,260 ops/sec ±2.02% (78 runs sampled)
    * Post:
    *   weakmap            x 3,881,384 ops/sec ±1.45% (82 runs sampled)
    */
    if (weakMapExists && objPrototype === WeakMap.prototype) {
      return 'WeakMap';
    }

    /* ! Spec Conformance
     * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-dataview.prototype-@@tostringtag)
     * ES6$24.2.4.21 - DataView.prototype[@@toStringTag] should be "DataView":
     * Test: `Object.prototype.toString.call(new DataView(new ArrayBuffer(1)))``
     *  - Edge <=13 === "[object Object]"
     */
    if (dataViewExists && objPrototype === DataView.prototype) {
      return 'DataView';
    }

    /* ! Spec Conformance
     * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%mapiteratorprototype%-@@tostringtag)
     * ES6$23.1.5.2.2 - %MapIteratorPrototype%[@@toStringTag] should be "Map Iterator":
     * Test: `Object.prototype.toString.call(new Map().entries())``
     *  - Edge <=13 === "[object Object]"
     */
    if (mapExists && objPrototype === mapIteratorPrototype) {
      return 'Map Iterator';
    }

    /* ! Spec Conformance
     * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%setiteratorprototype%-@@tostringtag)
     * ES6$23.2.5.2.2 - %SetIteratorPrototype%[@@toStringTag] should be "Set Iterator":
     * Test: `Object.prototype.toString.call(new Set().entries())``
     *  - Edge <=13 === "[object Object]"
     */
    if (setExists && objPrototype === setIteratorPrototype) {
      return 'Set Iterator';
    }

    /* ! Spec Conformance
     * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%arrayiteratorprototype%-@@tostringtag)
     * ES6$22.1.5.2.2 - %ArrayIteratorPrototype%[@@toStringTag] should be "Array Iterator":
     * Test: `Object.prototype.toString.call([][Symbol.iterator]())``
     *  - Edge <=13 === "[object Object]"
     */
    if (arrayIteratorExists && objPrototype === arrayIteratorPrototype) {
      return 'Array Iterator';
    }

    /* ! Spec Conformance
     * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%stringiteratorprototype%-@@tostringtag)
     * ES6$21.1.5.2.2 - %StringIteratorPrototype%[@@toStringTag] should be "String Iterator":
     * Test: `Object.prototype.toString.call(''[Symbol.iterator]())``
     *  - Edge <=13 === "[object Object]"
     */
    if (stringIteratorExists && objPrototype === stringIteratorPrototype) {
      return 'String Iterator';
    }

    /* ! Speed optimisation
    * Pre:
    *   object from null   x 2,424,320 ops/sec ±1.67% (76 runs sampled)
    * Post:
    *   object from null   x 5,838,000 ops/sec ±0.99% (84 runs sampled)
    */
    if (objPrototype === null) {
      return 'Object';
    }

    return Object
      .prototype
      .toString
      .call(obj)
      .slice(toStringLeftSliceLength, toStringRightSliceLength);
  }

  return typeDetect;

  })));
  });

  /**
   * Has own property.
   *
   * @type {Function}
   */
  var has = Object.prototype.hasOwnProperty;
  /**
   * To string.
   *
   * @type {Function}
   */

  var toString = Object.prototype.toString;
  /**
   * Test whether a value is "empty".
   *
   * @param {Mixed} val
   * @return {Boolean}
   */

  function isEmpty(val) {
    // Null and Undefined...
    if (val == null) return true; // Booleans...

    if ('boolean' == typeof val) return false; // Numbers...

    if ('number' == typeof val) return val === 0; // Strings...

    if ('string' == typeof val) return val.length === 0; // Functions...

    if ('function' == typeof val) return val.length === 0; // Arrays...

    if (Array.isArray(val)) return val.length === 0; // Errors...

    if (val instanceof Error) return val.message === ''; // Objects...

    if (val.toString == toString) {
      switch (val.toString()) {
        // Maps, Sets, Files and Errors...
        case '[object File]':
        case '[object Map]':
        case '[object Set]':
          {
            return val.size === 0;
          }
        // Plain objects...

        case '[object Object]':
          {
            for (var key in val) {
              if (has.call(val, key)) return false;
            }

            return true;
          }
      }
    } // Anything else...


    return false;
  }

  var global$1 = (typeof global !== "undefined" ? global :
              typeof self !== "undefined" ? self :
              typeof window !== "undefined" ? window : {});

  var _console, method;

  if (typeof console != 'undefined') {
    _console = console;
  } else if (typeof global$1 !== 'undefined' && global$1.console) {
    _console = global$1.console;
  } else if (typeof window !== 'undefined' && window.console) {
    _console = window.console;
  } else {
    _console = {};
  }

  var noop = function noop() {};

  var methods = ['assert', 'clear', 'count', 'debug', 'dir', 'dirxml', 'error', 'exception', 'group', 'groupCollapsed', 'groupEnd', 'info', 'log', 'markTimeline', 'profile', 'profileEnd', 'table', 'time', 'timeEnd', 'timeStamp', 'trace', 'warn'];
  var length = methods.length;

  while (length--) {
    method = methods[length];

    if (!console[method]) {
      _console[method] = noop;
    }
  }

  _console.methods = methods;
  var console$1 = _console;

  /**
   *
   * @param {*} obj
   */
  // function getType(obj) {
  //   return Reflect.apply(Object.prototype.toString, obj, [])
  //     .replace(/^\[object\s(\w+)\]$/, '$1')
  //     .toLowerCase();
  // }

  /**
   *
   * @param {*} options
   * @param {*} validateConfig
   */

  function validateParams(args, validateConfig, functionName) {
    // console.log('TIM validateParams', functionName, args, validateConfig); //  typeof options, validateConfig,
    // 没有传入对应的参数校验配置
    if (validateConfig === undefined) {
      return true;
    } // args 为 arguments 转数组


    var valid = true; // 需要以 validateConfig 为基准进行遍历判断

    if (typeDetect(validateConfig).toLowerCase() === 'object') {
      // 检查单个对象参数的情况
      Object.keys(validateConfig).forEach(function (key) {
        var params = args.length == 1 ? args[0][key] : undefined; // 只要返回一次false，结果就是false

        valid = _validateParams(params, validateConfig[key], functionName, key) ? valid : false;
      });
    } else if (typeDetect(validateConfig).toLowerCase() === 'array') {
      // 检查多个参数的情况
      for (var i = 0; i < validateConfig.length; i++) {
        valid = _validateParams(args[i], validateConfig[i], functionName, validateConfig[i].name) ? valid : false;
      }
    }

    if (valid) {
      return valid; // 通过验证
    } else {
      throw new Error('Params validate failed.'); // 验证不通过，中断同步函数执行
    }
  }
  /**
   *
   * @param {*} param
   * @param {*} validateConfig
   */

  function _validateParams(param, validateConfig, functionName, paramName) {
    if (validateConfig === undefined) {
      return true;
    }

    var valid = true;

    if (validateConfig.required && isEmpty(param)) {
      console$1.error("TIM [".concat(functionName, "] Missing required params: \"").concat(paramName, "\"."));
      valid = false;
    } // 检查基本数据类型


    if (!isEmpty(param) && typeDetect(param).toLowerCase() !== validateConfig.type.toLowerCase()) {
      console$1.error("TIM [".concat(functionName, "] Invalid params: type check failed for \"").concat(paramName, "\".Expected ").concat(validateConfig.type, "."));
      valid = false;
    } // 自定义检测逻辑


    if (validateConfig.validator && !validateConfig.validator(param)) {
      console$1.error("TIM [".concat(functionName, "] Invalid params: custom validator check failed for params."));
      valid = false;
    }

    return valid;
  }

  /**
   * API 接口参数校验的配置
   * {
   *   // 多个参数传参，例如 func(args1, args2, ...)
   *   'API名称': [
   *     {
   *       name: '', // 参数名称
   *       type: 'Number',  // 支持 String Number Array Object Boolean Map 等基本类型
   *       required: true // 是否必选
   *     }
   *     ...
   *   ],
   *   // 对象类型的参数配置，有且只有一个参数，例如 func(options)
   *   API名称: {
   *     参数名称: {
   *       type: 'String',
   *       required: true
   *     },
   *     ...
   *     参数名称1: {
   *       type: 'Array',
   *       required: false
   *     }
   *   }
   * }
   */
  var APIValidateConfig = {
    login: {
      userID: {
        type: 'String',
        required: true
      },
      userSig: {
        type: 'String',
        required: true
      }
    },
    addToBlacklist: {
      userIDList: {
        type: 'Array',
        required: true
      }
    },
    mutilParam: [{
      name: 'paramName',
      type: 'Number',
      required: true
    }, {
      name: 'paramName',
      type: 'String',
      required: true
    }],
    on: [{
      name: 'eventName',
      type: 'String',
      required: true
    }, {
      name: 'listener',
      type: 'Function',
      required: false
    }],
    sendMessage: [{
      name: 'message',
      // TODO: 仅支持判断基本类型，目前支持通过自定义校验方法处理
      type: 'Object',
      required: true
    }],
    // Conversation
    getConversationProfile: [{
      name: 'conversationID',
      type: 'String',
      required: true
    }],
    deleteConversation: [{
      name: 'conversationID',
      type: 'String',
      required: true
    }],
    // GROUP
    getGroupProfile: {
      groupID: {
        type: 'String',
        required: true
      },
      groupCustomFieldFilter: {
        type: 'Array'
      },
      memberCustomFieldFilter: {
        type: 'Array'
      }
    },
    getGroupProfileAdvance: {
      groupIDList: {
        type: 'Array',
        required: true
      }
    },
    createGroup: {
      name: {
        type: 'String',
        required: true
      }
    },
    joinGroup: {
      groupID: {
        type: 'String',
        required: true
      },
      type: {
        type: 'String'
      },
      applyMessage: {
        type: 'String'
      }
    },
    quitGroup: [{
      name: 'groupID',
      type: 'String',
      required: true
    }],
    handleApplication: {
      message: {
        type: 'Object',
        required: true
      },
      handleAction: {
        type: 'String',
        required: true
      },
      handleMessage: {
        type: 'String'
      }
    },
    changeGroupOwner: {
      groupID: {
        type: 'String',
        required: true
      },
      newOwnerID: {
        type: 'String',
        required: true
      }
    },
    updateGroupProfile: {
      groupID: {
        type: 'String',
        required: true
      }
    },
    dismissGroup: [{
      name: 'groupID',
      type: 'String',
      required: true
    }],
    searchGroupByID: [{
      name: 'groupID',
      type: 'String',
      required: true
    }],
    // Group Member
    getGroupMemberList: {
      groupID: {
        type: 'String',
        required: true
      },
      offset: {
        type: 'Number'
      },
      count: {
        type: 'Number'
      }
    },
    addGroupMemeber: {
      groupID: {
        type: 'String',
        required: true
      },
      userIDList: {
        type: 'Array',
        required: true
      }
    },
    setGroupMemberRole: {
      groupID: {
        type: 'String',
        required: true
      },
      userID: {
        type: 'String',
        required: true
      },
      role: {
        type: 'String',
        required: true
      }
    },
    setGroupMemberMuteTime: {
      groupID: {
        type: 'String',
        required: true
      },
      userID: {
        type: 'String'
      },
      muteTime: {
        type: 'Number',
        validator: function validator(param) {
          return param >= 0;
        }
      }
    },
    setGroupMemberNameCard: {
      groupID: {
        type: 'String',
        required: true
      },
      userID: {
        type: 'String'
      },
      nameCard: {
        type: 'String',
        required: true,
        validator: function validator(param) {
          if (/^\s+$/.test(param) === true) {
            return false;
          }

          return true;
        }
      }
    },
    setMessageRemindType: {
      groupID: {
        type: 'String',
        required: true
      },
      messageRemindType: {
        type: 'String',
        required: true
      }
    },
    setMemberCustomField: {
      groupID: {
        type: 'String',
        required: true
      },
      userID: {
        type: 'String'
      },
      memberCustomField: {
        type: 'Array',
        required: true
      }
    },
    deleteGroupMember: {
      groupID: {
        type: 'String',
        required: true
      }
    },
    createTextMessage: {
      to: {
        type: 'String',
        required: true
      },
      conversationType: {
        type: 'String',
        required: true
      },
      payload: {
        type: 'Object',
        required: true
      }
    },
    createCustomMessage: {
      to: {
        type: 'String',
        required: true
      },
      conversationType: {
        type: 'String',
        required: true
      },
      payload: {
        type: 'Object',
        required: true
      }
    },
    createImageMessage: {
      to: {
        type: 'String',
        required: true
      },
      conversationType: {
        type: 'String',
        required: true
      },
      payload: {
        type: 'Object',
        required: true
      }
    },
    createFileMessage: {
      to: {
        type: 'String',
        required: true
      },
      conversationType: {
        type: 'String',
        required: true
      },
      payload: {
        type: 'Object',
        required: true
      }
    }
  };

  /**
   * API 映射表
   * 示例：{
   *  sdk.js的方法名 : 暴露的API名
   * }
   */
  var APIList = {
    // Global
    login: 'login',
    logout: 'logout',
    on: 'on',
    once: 'once',
    off: 'off',
    setLogLevel: 'setLogLevel',
    downloadLog: 'downloadLog',
    registerPlugin: 'registerPlugin',
    ready: 'ready',
    destroy: 'destroy',
    // Message
    createTextMessage: 'createTextMessage',
    createFileMessage: 'createFileMessage',
    createSoundMessage: 'createSoundMessage',
    createImageMessage: 'createImageMessage',
    createCustomMessage: 'createCustomMessage',
    sendMessage: 'sendMessage',
    sendTextMessage: 'sendTextMessage',
    sendImageMessage: 'sendImageMessage',
    sendCustomMessage: 'sendCustomMessage',
    sendFileMessage: 'sendFileMessage',
    resendMessage: 'resendMessage',
    getMessageList: 'getMessageList',
    setMessageRead: 'setMessageRead',
    // Conversation
    getConversationList: 'getConversationList',
    getConversationProfile: 'getConversationProfile',
    deleteConversation: 'deleteConversation',
    // Group
    getGroupList: 'getGroupList',
    getGroupProfile: 'getGroupProfile',
    getGroupProfileAdvance: 'getGroupProfileAdvance',
    createGroup: 'createGroup',
    joinGroup: 'joinGroup',
    updateGroupProfile: 'updateGroupProfile',
    quitGroup: 'quitGroup',
    dismissGroup: 'dismissGroup',
    changeGroupOwner: 'changeGroupOwner',
    searchGroupByID: 'searchGroupByID',
    setMessageRemindType: 'setMessageRemindType',
    handleGroupApplication: 'handleGroupApplication',
    // Group Member
    getGroupMemberList: 'getGroupMemberList',
    addGroupMember: 'addGroupMember',
    deleteGroupMember: 'deleteGroupMember',
    setGroupMemberNameCard: 'setGroupMemberNameCard',
    setGroupMemberMuteTime: 'setGroupMemberMuteTime',
    setGroupMemberRole: 'setGroupMemberRole',
    setGroupMemberCustomField: 'setGroupMemberCustomField',
    // Profile
    getMyProfile: 'getMyProfile',
    getUserProfile: 'getUserProfile',
    updateMyProfile: 'updateMyProfile',
    // Contacts
    addToBlacklist: 'addToBlacklist',
    applyAddFriend: 'applyAddFriend',
    removeFromBlacklist: 'removeFromBlacklist',
    deleteFriend: 'deleteFriend',
    deletePendency: 'deletePendency',
    getBlacklist: 'getBlacklist',
    getFriendList: 'getFriendList',
    getPendency: 'getPendency',
    getPendencyReport: 'getPendencyReport',
    replyPendency: 'replyPendency' // 'sdk.js的方法名': '暴露的API名'

  };

  /**
   * @typedef 错误码对照表
   * @description SDK 错误码对照表
   * | 错误码 | 说明 |
   * | :--- | :---- |
   * | 2000 | 无 SDKAppID  |
   * | 2001 | 无 accountType |
   * | 2002 | 无 userID |
   * | 2003 | 无 usersig |
   * | 2004 | 无 SDK 实例 |
   * | 2020 | 获取沙箱请求失败  |
   * | 2021 | 登录请求失败  |
   * | 2022 | 无 tinyid  |
   * | 2023 | 无 a2key  |
   * | 2100 | 消息发送失败 |
   * | 2101 | 未知的漫游消息结束字段 |
   * | 2102 | 消息元素未创建，因为方法未定义 |
   * | 2103 | MessageController.constructor() 需要参数 options |
   * | 2104 | 需要 toAccount 参数 |
   * | 2105 | 需要 Message 的实例 |
   * | 2106 | Message.conversationType 只能为 "C2C"或"GROUP" |
   * | 2107 | 文件类消息不能使用 SDK.resendMessage() 函数重发 |
   * | 2250 | 图片上传失败 |
   * | 2251 | 请先选择一个图片 |
   * | 2252 | 图片类型受限 |
   * | 2253 | 图片大小受限 |
   * | 2401 | 请先选择一个文件 |
   * | 2402 | 文件大小受限 |
   * | 2403 | 缺少必要的参数文件 URL |
   * | 2404 | 微信小程序暂时不支持文件选择功能 |
   * | 2500 | 没有找到相应的会话，请检查传入参数 |
   * | 2501 | 没有找到相应的用户或群主，请检查传入参数 |
   * | 2502 | 未记录的会话类型 |
   * | 2600 | 非法的群类型，请检查传入参数 |
   * | 2601 | 不能加入 Private 类型的群组 |
   * | 2620 | AVChatRoom 类型的群组不能转让群主 |
   * | 2621 | 不能把群主转让给自己 |
   * | 2622 | 不能解散 Private 类型的群组 |
   * | 2660 | 加群失败，请检查传入参数或重试 |
   * | 2661 | AVChatRoom 类型的群不支持邀请群成员 |
   * | 2680 | 不能在 AVChatRoom 类型的群组踢人 |
   * | 2681 | 你不是群主，只有群主才有权限操作 |
   * | 2682 | 不能在 Private / AVChatRoom 类型的群中设置群成员身份 |
   * | 2683 | 不合法的群成员身份，请检查传入参数 |
   * | 2684 | 不能设置自己的群成员身份，请检查传入参数 |
   * | 2700 | 传入 deleteFriend 接口的参数无效 |
   * | 2720 | 传入 getUserProfile 接口的参数无效 |
   * | 2721 | 传入 updateMyProfile 接口的参数无效 |
   * | 2740 | 传入 addToBlacklist 接口的参数无效 |
   * | 2741 | 传入 removeFromBlacklist 接口的参数无效 |
   * | 2742 | 不能拉黑自己 |
   * | 2800 | 网络错误 |
   * | 2801 | 请求超时 |
   * | 2802 | 网络层初始化错误，缺少 URL 参数 |
   * | 2803 | 打包错误，未定义的 serverName |
   * | 2804 | 未定义的 packageConfig |
   * | 2850 | 当前浏览器不支持 WebSocket |
   * | 2900 | 不规范的参数名称 |
   * | 2901 | 意料外的通知条件 |
   * | 2902 | _syncOffset 丢失 |
   * | 2903 | 未经明确定义的错误 |
   * | 2999 | 接口调用时机不合理，等待 SDK 处于 ready 状态后再调用（监听 TIM.EVENT.SDK_READY 事件）|
   *
   * [服务端错误码](https://cloud.tencent.com/document/product/269/1671?!preview&!editLang=zh#.EF.BC.88.E4.BA.8C.EF.BC.89.E6.9C.8D.E5.8A.A1.E7.AB.AF.E7.9A.84.E9.94.99.E8.AF.AF.E7.A0.81)
   */
  var ERROR_CODE = {
    //REQ_XXX_FAILED 指的是response.data.errorCode != 0
    //--[2000-2099] 初始化、登录、插件注册使用、登录状态变更等
    //----[2000-2019] 初始化
    NO_SDKAPPID: 2000,
    NO_ACCOUNT_TYPE: 2001,
    NO_IDENTIFIER: 2002,
    NO_USERSIG: 2003,
    NO_SDK_INSTANCE: 2004,
    //----[2020-2039] 登录相关
    REQ_GET_ACCESS_LAYER_FAILED: 2020,
    REQ_LOGIN_FAILED: 2021,
    NO_TINYID: 2022,
    NO_A2KEY: 2023,
    //----[2040-2059] 插件注册使用相关
    //----[2060-2079] 登录态变更，如被踢下线，a2key 失效等
    //--[2100-2499] 消息收发相关
    MESSAGE_SEND_FAIL: 2100,
    MESSAGE_UNKNOW_ROMA_LIST_END_FLAG_FIELD: 2101,
    MESSAGE_ELEMENT_METHOD_UNDEFINED: 2102,
    MESSAGE_LIST_CONSTRUCTOR_NEED_OPTIONS: 2103,
    MESSAGE_PARAMETER_MISSING_TO_ACCOUNT: 2104,
    MESSAGE_SEND_NEED_MESSAGE_INSTANCE: 2105,
    MESSAGE_SEND_INVALID_CONVERSATION_TYPE: 2106,
    MESSAGE_RESEND_FILE_UNSUPPORTED: 2107,
    //----[2150-2199] 拉取、同步、重发消息相关
    //----[2200-2249] 文本消息收发相关
    //----[2250-2299] 图片消息收发相关
    MESSAGE_IMAGE_UPLOAD_FAIL: 2250,
    MESSAGE_IMAGE_SELECT_FILE_FIRST: 2251,
    MESSAGE_IMAGE_TYPES_LIMIT: 2252,
    MESSAGE_IMAGE_SIZE_LIMIT: 2253,
    //----[2300-2349] 语音消息收发相关
    MESSAGE_SOUND_UPLOAD_FAIL: 2300,
    //----[2350-2399] 视频消息收发相关
    //----[2400-2449] 文件消息收发相关
    MESSAGE_FILE_SELECT_FILE_FIRST: 2401,
    MESSAGE_FILE_SIZE_LIMIT: 2402,
    MESSAGE_FILE_URL_IS_EMPTY: 2403,
    MESSAGE_FILE_WECHAT_MINIAPP_NOT_SUPPORT: 2404,
    //----[2450-2499] 自定义消息收发相关
    //--[2500-2599] 会话相关
    //----[2500-2519] 拉取、同步会话列表，搜索会话列表相关
    CONVERSATION_NOT_FOUND: 2500,
    USER_OR_GROUP_NOT_FOUND: 2501,
    CONVERSATION_UN_RECORDED_TYPE: 2502,
    //----[2520-2539] 删除会话、获取会话信息相关
    //----[2530-2549] C2C 会话相关
    //----[2550-2569] 群组会话相关
    //--[2600-2699] 群组相关
    //----[2600-2619] 拉取、同步、搜索群组列表相关
    ILLEGAL_GROUP_TYPE: 2600,
    CANNOT_JOIN_PRIVATE: 2601,
    //----[2620-2639] 创建、解散、退出、转让群组相关
    CANNOT_CHANGE_OWNER_IN_AVCHATROOM: 2620,
    CANNOT_CHANGE_OWNER_TO_SELF: 2621,
    CANNOT_DISMISS_PRIVATE: 2622,
    // 不能解散 Private 类型群组
    //----[2640-2659] 查询、修改群组资料相关
    //----[2660-2679] 邀人入群、申请加群与处理申请相关
    JOIN_GROUP_FAIL: 2660,
    CANNOT_ADD_MEMBER_IN_AVCHATROOM: 2661,
    //----[2680-2699] 控群相关，如设置禁言时间，设置群成员名片，踢人等
    CANNOT_KICK_MEMBER_IN_AVCHATROOM: 2680,
    NOT_OWNER: 2681,
    CANNOT_SET_MEMBER_ROLE_IN_PRIVATE_AND_AVCHATROOM: 2682,
    INVALID_MEMBER_ROLE: 2683,
    CANNOT_SET_SELF_MEMBER_ROLE: 2684,
    //--[2700-2799] 关系链相关
    //----[2700-2719] 拉取、同步好友列表、删除好友相关
    DEL_FRIEND_INVALID_PARAM: 2700,
    //----[2720-2739] 资料相关
    GET_PROFILE_INVALID_PARAM: 2720,
    UPDATE_PROFILE_INVALID_PARAM: 2721,
    //----[2740-2759] 黑名单相关
    ADD_BLACKLIST_INVALID_PARAM: 2740,
    DEL_BLACKLIST_INVALID_PARAM: 2741,
    CANNOT_ADD_SELF_TO_BLACKLIST: 2742,
    //----[2760-2779] 申请加好友与处理申请相关
    //--[2800-2849] 网络相关
    NETWORK_ERROR: 2800,
    NETWORK_TIMEOUT: 2801,
    NETWORK_BASE_OPTIONS_NO_URL: 2802,
    NETWORK_UNDEFINED_SERVER_NAME: 2803,
    NETWORK_PACKAGE_UNDEFINED: 2804,
    //----[2850-2869] websocket相关，如连接断开、心跳超时等
    SOCKET_NOT_SUPPORTED: 2850,
    //--[2870-2899] 宿主环境相关
    //----[2870-2879] 小程序环境相关
    //----[2880-2889] PC/Mac 浏览器环境相关
    //----[2890-2899] 移动端浏览器环境相关
    //--[2900-2999] 其它
    CONVERTOR_IRREGULAR_PARAMS: 2900,
    //--runLoop 相关
    NOTICE_RUNLOOP_UNEXPECTED_CONDITION: 2901,
    NOTICE_RUNLOOP_OFFSET_LOST: 2902,
    //--未捕获的错误，需要引起注意
    UNCAUGHT_ERROR: 2903,
    SDK_IS_NOT_READY: 2999,
    //--服务端错误码
    LONG_POLL_KICK_OUT: 91101
  };
  var ERROR_MESSAGE = {
    //--初始化、登录、插件注册使用、登录状态变更等
    //----初始化
    NO_SDKAPPID: '无 SDKAppID',
    NO_ACCOUNT_TYPE: '无 accountType',
    NO_IDENTIFIER: '无 userID',
    NO_USERSIG: '无 usersig',
    NO_SDK_INSTANCE: '无 SDK 实例',
    //----登录
    REQ_GET_ACCESS_LAYER_FAILED: '获取沙箱请求失败',
    // 指的是 response.data.errorCode != 0
    REQ_LOGIN_FAILED: '登录请求失败',
    // 指的是 response.data.errorCode != 0
    NO_TINYID: '无tinyid',
    NO_A2KEY: '无a2key',
    //----插件注册使用相关
    //----登录态变更，如被踢下线，a2key 失效等
    //--消息收发
    MESSAGE_SEND_FAIL: '消息发送失败',
    MESSAGE_UNKNOW_ROMA_LIST_END_FLAG_FIELD: '未知的漫游消息结束字段',
    MESSAGE_ELEMENT_METHOD_UNDEFINED: '消息元素未创建，因为方法未定义',
    MESSAGE_LIST_CONSTRUCTOR_NEED_OPTIONS: 'MessageController.constructor() 需要参数 options',
    MESSAGE_PARAMETER_MISSING_TO_ACCOUNT: '需要 toAccount 参数',
    MESSAGE_SEND_NEED_MESSAGE_INSTANCE: '需要 Message 的实例',
    MESSAGE_SEND_INVALID_CONVERSATION_TYPE: 'Message.conversationType 只能为 "C2C"或"GROUP" ',
    MESSAGE_RESEND_FILE_UNSUPPORTED: '文件类消息不能使用 SDK.resendMessage() 函数重发',
    //----拉取、同步、重发消息相关
    //----文本消息收发相关
    //----图片消息收发相关
    MESSAGE_IMAGE_UPLOAD_FAIL: '图片上传失败',
    MESSAGE_IMAGE_SELECT_FILE_FIRST: '请先选择一个图片',
    MESSAGE_IMAGE_TYPES_LIMIT: '图片类型受限',
    MESSAGE_IMAGE_SIZE_LIMIT: '图片大小受限',
    //----语音消息收发相关
    MESSAGE_SOUND_UPLOAD_FAIL: '语音上传失败',
    //----视频消息收发相关
    //----文件消息收发相关
    MESSAGE_FILE_SELECT_FILE_FIRST: '请先选择一个文件',
    MESSAGE_FILE_SIZE_LIMIT: '文件大小受限 ',
    MESSAGE_FILE_URL_IS_EMPTY: '缺少必要的参数文件 URL',
    MESSAGE_FILE_WECHAT_MINIAPP_NOT_SUPPORT: '微信小程序暂时不支持文件选择功能',
    //----自定义消息收发相关
    //--会话相关
    //----拉取、同步会话列表，搜索会话列表相关
    CONVERSATION_NOT_FOUND: '没有找到相应的会话，请检查传入参数',
    USER_OR_GROUP_NOT_FOUND: '没有找到相应的用户或群主，请检查传入参数',
    CONVERSATION_UN_RECORDED_TYPE: '未记录的会话类型',
    //----删除会话、获取会话信息相关
    //----C2C会话相关
    //----群组会话相关
    //--群组相关
    ILLEGAL_GROUP_TYPE: '非法的群类型，请检查传入参数',
    CANNOT_JOIN_PRIVATE: '不能加入 Private 类型的群组',
    //----拉取、同步、搜索群组列表相关
    //----创建群组相关
    //----解散、退出、转让群组相关
    CANNOT_CHANGE_OWNER_IN_AVCHATROOM: 'AVChatRoom 类型的群组不能转让群主',
    CANNOT_CHANGE_OWNER_TO_SELF: '不能把群主转让给自己',
    CANNOT_DISMISS_PRIVATE: '不能解散 Private 类型的群组',
    //----查询、修改群组资料相关
    //----邀人入群、申请加群与处理申请相关
    JOIN_GROUP_FAIL: '加群失败，请检查传入参数或重试',
    CANNOT_ADD_MEMBER_IN_AVCHATROOM: 'AVChatRoom 类型的群不支持邀请群成员',
    //----控群相关，如设置禁言时间，设置群成员名片，踢人等
    CANNOT_KICK_MEMBER_IN_AVCHATROOM: '不能在 AVChatRoom 类型的群组踢人',
    NOT_OWNER: '你不是群主，只有群主才有权限操作',
    CANNOT_SET_MEMBER_ROLE_IN_PRIVATE_AND_AVCHATROOM: '不能在 Private / AVChatRoom 类型的群中设置群成员身份',
    INVALID_MEMBER_ROLE: '不合法的群成员身份，请检查传入参数',
    CANNOT_SET_SELF_MEMBER_ROLE: '不能设置自己的群成员身份，请检查传入参数',
    //--关系链相关
    //----拉取、同步好友列表、删除好友相关
    DEL_FRIEND_INVALID_PARAM: '传入 deleteFriend 接口的参数无效',
    //----资料相关
    GET_PROFILE_INVALID_PARAM: '传入 getUserProfile 接口的参数无效',
    UPDATE_PROFILE_INVALID_PARAM: '传入 updateMyProfile 接口的参数无效',
    //----黑名单相关
    ADD_BLACKLIST_INVALID_PARAM: '传入 addToBlacklist 接口的参数无效',
    DEL_BLACKLIST_INVALID_PARAM: '传入 removeFromBlacklist 接口的参数无效',
    CANNOT_ADD_SELF_TO_BLACKLIST: '不能拉黑自己',
    //----申请加好友与处理申请相关
    //--网络相关
    NETWORK_ERROR: '网络错误',
    NETWORK_TIMEOUT: '请求超时',
    NETWORK_BASE_OPTIONS_NO_URL: '网络层初始化错误，缺少 URL 参数',
    NETWORK_UNDEFINED_SERVER_NAME: '打包错误，未定义的 serverName',
    NETWORK_PACKAGE_UNDEFINED: '未定义的 packageConfig',
    //----websocket相关，如连接断开、心跳超时等
    SOCKET_NOT_SUPPORTED: '当前浏览器不支持 WebSocket',
    CONVERTOR_IRREGULAR_PARAMS: '不规范的参数名称',
    //----runLoop相关
    NOTICE_RUNLOOP_UNEXPECTED_CONDITION: '意料外的通知条件',
    NOTICE_RUNLOOP_OFFSET_LOST: '_syncOffset 丢失',
    //--宿主环境相关
    //----小程序环境相关
    //----PC/Mac浏览器环境相关
    //----移动端浏览器环境相关
    //--其它
    // SDK_ERROR:
    UNCAUGHT_ERROR: '未经明确定义的错误',
    SDK_IS_NOT_READY: '接口调用时机不合理，等待 SDK 处于 ready 状态后再调用（监听 TIM.EVENT.SDK_READY 事件）' // 服务端错误
    // LONG_POLL_KICK_OUT: '检测到多个 web 实例登录，消息通道下线',

  };

  /**
   * IMError类， 用于描述TIMSDK中的错误类型
   * @param {Object} options
   * @param {Number} options.code - 错误代码
   * @param {Number} options.message - 错误信息
   * @param {Object} options.data - 需要通过IMError传递的数据
   * @example
   * new IMError({
   *  code: ERROR_CODE.NO_SDKAPPID
   *  message: ERROR_MESSAGE.NO_SDKAPPID
   * })
   */
  var IMError =
  /*#__PURE__*/
  function (_Error) {
    _inherits(IMError, _Error);

    function IMError(options) {
      var _this;

      _classCallCheck(this, IMError);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(IMError).call(this));
      _this.code = options.code;
      _this.message = options.message;
      _this.data = options.data || {};
      return _this;
    }

    return IMError;
  }(_wrapNativeSuper(Error));

  /**
   * 其他配置常量
   */
  //sdk版本
  var SDK = {
    VERSION: '1.7.3',
    //sdk版本号，暂定，此参数影响到后端接口返回的数据
    APPID: '537048168',
    //web im sdk 版本 APPID
    PLATFORM: '10' //发送请求时判断其是来自web端的请求

  }; //环境配置

  var PROTOCOL_TYPE = {
    PROTOBUF: 'protobuf',
    JSON: 'json'
  }; //接口地址配置

  var SERVER = {
    HOST: {
      /**
       * @description 当前使用的接口类型，取值范围：SANDBOX: 1, TEST: 2，PRODUCTION: 3，详情请看`ACCESS_LAYER_TYPES`
       */
      TYPE: 3,

      /**
       * @description 接口类型配置,与ENV的配置相似，但这里使用了整型数据
       */
      ACCESS_LAYER_TYPES: {
        SANDBOX: 1,
        //使用沙箱服务器,判断该值时，为服务端返回，只能取1
        TEST: 2,
        //使用测试服务器
        PRODUCTION: 3 //使用正式环境

      },

      /**
       * @description 当前生效的接口地址的配置,推荐从这里取得服务器配置
       **/
      CURRENT: {
        COMMON: 'https://webim.tim.qq.com',
        PIC: 'https://pic.tim.qq.com',
        COS: 'https://yun.tim.qq.com'
      },

      /**
       * @description 正式环境
       *  */
      PRODUCTION: {
        COMMON: 'https://webim.tim.qq.com',
        PIC: 'https://pic.tim.qq.com',
        COS: 'https://yun.tim.qq.com'
      },

      /**
       * @description 沙箱环境
       *  */
      SANDBOX: {
        COMMON: 'https://events.tim.qq.com',
        PIC: 'https://pic.tim.qq.com',
        COS: 'https://yun.tim.qq.com'
      },

      /**
       * @description 测试环境
       *  */
      TEST: {
        COMMON: 'https://test.tim.qq.com',
        PIC: 'https://pic.tim.qq.com',
        COS: 'https://yun.tim.qq.com'
      },

      /**
       * @uses 用来设置当前接口的环境
       * @param {Number} sccessLayerType-此参数决定了使用的服务器类型，可以查阅`SERVER.HOST.ACCESS_LAYER_TYPES`
       ```
        1: 沙箱环境
        2: 测试环境
        3: 正式环境
       ```
       * @caution 此函数也会同时改变`ENV.CURRENT`的取值
       */
      setCurrent: function setCurrent() {
        var accessLayerType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 3;

        switch (accessLayerType) {
          case this.ACCESS_LAYER_TYPES.SANDBOX:
            this.CURRENT = this.SANDBOX;
            this.TYPE = this.ACCESS_LAYER_TYPES.SANDBOX;
            break;

          case this.ACCESS_LAYER_TYPES.TEST:
            this.CURRENT = this.TEST;
            this.TYPE = this.ACCESS_LAYER_TYPES.TEST;
            break;

          default:
            this.CURRENT = this.PRODUCTION;
            this.TYPE = this.ACCESS_LAYER_TYPES.PRODUCTION;
            break;
        }
      }
    },
    //服务名称
    NAME: {
      OPEN_IM: 'openim',
      //私聊（拉取未读c2c消息，长轮询，c2c消息已读上报等）服务名
      GROUP: 'group_open_http_svc',
      //群组管理（拉取群消息，创建群，群成员管理，群消息已读上报等）服务名
      FRIEND: 'sns',
      //关系链管理（好友管理，黑名单管理等）服务名
      PROFILE: 'profile',
      //资料管理（查询，设置个人资料等）服务名
      RECENT_CONTACT: 'recentcontact',
      //最近联系人服务名
      PIC: 'openpic',
      //图片（或文件）服务名
      BIG_GROUP_NO_AUTH: 'group_open_http_noauth_svc',
      //直播大群 群组管理（申请加大群）服务名
      BIG_GROUP_LONG_POLLING_NO_AUTH: 'group_open_long_polling_http_noauth_svc',
      //直播大群 长轮询（拉取消息等）服务名
      IM_OPEN_STAT: 'imopenstat',
      //质量上报，统计接口错误率
      WEB_IM: 'webim',
      IM_COS_SIGN: 'im_cos_sign_svr'
    },

    /**
     * @uses 命令字，待补全
     **/
    CMD: {
      ACCESS_LAYER: 'accesslayer',
      //获取沙箱
      LOGIN: 'login',
      //登录
      LOGOUT_LONG_POLL: 'longpollinglogout',
      // 登出
      LOGOUT_ALL: 'logout',
      //
      PORTRAIT_GET: 'portrait_get',
      //获取个人信息
      PORTRAIT_SET: 'portrait_set',
      //获取个人信息
      GET_LONG_POLL_ID: 'getlongpollingid',
      LONG_POLL: 'longpolling',
      // 轮询
      AVCHATROOM_LONG_POLL: 'get_msg',
      // AVChatRoom 长轮询拉消息
      FRIEND_ADD: 'friend_add',
      //加好友
      FRIEND_GET_ALL: 'friend_get_all',
      //获取所有好友
      FRIEND_DELETE: 'friend_delete',
      //删除好友
      RESPONSE_PENDENCY: 'friend_response',
      //响应好友申请
      GET_PENDENCY: 'pendency_get',
      //获取未决的好友申请列表
      DELETE_PENDENCY: 'pendency_delete',
      //删除好友申请列表
      GET_BLACKLIST: 'black_list_get',
      //获取黑名单列表
      ADD_BLACKLIST: 'black_list_add',
      //添加好友进黑名单
      DELETE_BLACKLIST: 'black_list_delete',
      //将好友移出黑名单
      CREATE_GROUP: 'create_group',
      //创建群组
      GET_JOINED_GROUPS: 'get_joined_group_list',
      //获取用户加入的群组
      SEND_MESSAGE: 'sendmsg',
      // 发送私聊消息
      SEND_GROUP_MESSAGE: 'send_group_msg',
      // 发送群消息
      GET_GROUP_INFO: 'get_group_info',
      //获取群组详细信息
      GET_GROUP_MEMBER_INFO: 'get_group_member_info',
      //获取群组成员信息列表
      QUIT_GROUP: 'quit_group',
      //退出群组
      CHANGE_GROUP_OWNER: 'change_group_owner',
      //转让群组
      DESTROY_GROUP: 'destroy_group',
      //解散群组
      ADD_GROUP_MEMBER: 'add_group_member',
      //添加群成员
      DELETE_GROUP_MEMBER: 'delete_group_member',
      //删除群成员
      SEARCH_GROUP_BY_ID: 'get_group_public_info',
      //搜索群组（ID）
      APPLY_JOIN_GROUP: 'apply_join_group',
      //申请加群
      HANDLE_APPLY_JOIN_GROUP: 'handle_apply_join_group',
      //处理加群申请
      MODIFY_GROUP_INFO: 'modify_group_base_info',
      //修改群资料
      MODIFY_GROUP_MEMBER_INFO: 'modify_group_member_info',
      //修改群成员资料
      DELETE_GROUP_SYSTEM_MESSAGE: 'deletemsg',
      //修改群成员资料
      GET_CONVERSATION_LIST: 'get',
      //获取会话列表
      DELETE_CONVERSATION: 'delete',
      //删除会话
      GET_MESSAGES: 'getmsg',
      // 获取未读消息
      GET_C2C_ROAM_MESSAGES: 'getroammsg',
      // 获取C2C漫游消息
      GET_GROUP_ROAM_MESSAGES: 'group_msg_get',
      // 获取C2C漫游消息
      SET_C2C_MESSAGE_READ: 'msgreaded',
      SET_GROUP_MESSAGE_READ: 'msg_read_report',
      FILE_READ_AND_WRITE_AUTHKEY: 'authkey',
      FILE_UPLOAD: 'pic_up',
      COS_SIGN: 'cos'
    },
    CHANNEL: {
      SOCKET: 1,
      // - 使用socket请求
      XHR: 2,
      // - 使用XHR请求
      AUTO: 0 // - 由ConnectionController决定用什么方式完成请求

    },
    //不同服务对应的版本号
    NAME_VERSION: {
      openim: 'v4',
      group_open_http_svc: 'v4',
      sns: 'v4',
      profile: 'v4',
      recentcontact: 'v4',
      openpic: 'v4',
      group_open_http_noauth_svc: 'v1',
      group_open_long_polling_http_noauth_svc: 'v1',
      imopenstat: 'v4',
      im_cos_sign_svr: 'v4',
      webim: 'v3'
    }
  }; //默认使用正式环境

  SERVER.HOST.setCurrent(SERVER.HOST.ACCESS_LAYER_TYPES.PRODUCTION); // SERVER.HOST.setCurrent(SERVER.HOST.ACCESS_LAYER_TYPES.TEST);

  /**
   * 场景：后端CGI参数命名大多数为大驼峰形式，但也有部分是To_Account这种形式，或许也有其他形式。
   * 用途：该对象用于/utils/convertor中的converRequestParam方法。该方法默认将小驼峰参数转成大驼峰，需要自定义的在该对象中定义。
   * 说明：在map中的key为需要自定义的参数key值，value为自定义转换的value值
   * 注意：该对象为全局公用的keyMaps，若出现接口与该keyMaps冲突，请在对应接口配置文件加上配置。参考：const/packageConfig/friend.js 下的query配置
   * @example
   * keyMaps:{
   *  request: {
   *    toAccount: 'to_Account' //该配置会覆盖keyMaps中的配置
   *  }
   * }
   */
  var keyMaps = {
    request: {
      toAccount: 'To_Account',
      fromAccount: 'From_Account',
      to: 'To_Account',
      from: 'From_Account',
      groupID: 'GroupId',
      avatar: 'FaceUrl'
    },
    response: {
      GroupId: 'groupID',
      Member_Account: 'userID',
      MsgList: 'messageList',
      SyncFlag: 'syncFlag',
      To_Account: 'to',
      From_Account: 'from',
      MsgSeq: 'sequence',
      MsgRandom: 'random',
      MsgTimeStamp: 'time',
      MsgContent: 'content',
      MsgBody: 'elements',
      MsgType: 'type',
      MsgShow: 'messageShow',
      NextMsgSeq: 'nextMessageSeq',
      FaceUrl: 'avatar',
      ProfileDataMod: 'profileModify',
      Profile_Account: 'userID',
      ValueBytes: 'value',
      ValueNum: 'value',
      NoticeSeq: 'noticeSequence',
      NotifySeq: 'notifySequence',
      // event4 & event5
      Operator_Account: 'operatorID',
      OpType: 'operationType',
      ReportType: 'operationType',
      UserId: 'userID',
      User_Account: 'userID',
      List_Account: 'userIDList',
      MsgOperatorMemberExtraInfo: 'operatorInfo',
      MsgMemberExtraInfo: 'memberInfoList',
      ImageUrl: 'avatar',
      NickName: 'nick',
      MsgGroupNewInfo: 'newGroupProfile',
      Owner_Account: 'ownerID',
      GroupName: 'name',
      GroupFaceUrl: 'avatar',
      GroupIntroduction: 'introduction',
      GroupNotification: 'notification',
      GroupApplyJoinOption: 'joinOption',
      MsgKey: 'messageKey',
      GroupInfo: 'groupProfile',
      // CUSTOM
      Desc: 'description',
      Ext: 'extension'
    },
    ignoreKeyWord: ['C2C', 'ID', 'USP'] //这些关键字是要在 请求参数转换器的 非法参数检测中忽略的。例如：不会检查 groupID，userID 的合法性

  };

  // 内部事件
  var TIM_INNER_EVENT = {
    // context
    CONTEXT_UPDATED: '_contextWasUpdated',
    CONTEXT_RESET: '_contextWasReset',
    CONTEXT_A2KEY_AND_TINYID_UPDATED: '_a2KeyAndTinyIDUpdated',
    // running_state
    RUNNING_STATE_CHANGE: '_runningStateChange',
    // 消息同步
    SYNC_MESSAGE_C2C_START: '_noticeSynchronizationStart',
    SYNC_MESSAGE_C2C_PROCESSING: '_noticeIsSynchronizing',
    SYNC_MESSAGE_C2C_FINISHED: '_noticeIsSynchronized',
    SYNC_MESSAGE_GROUP_SYSTEM_NOTICE_FINISHED: '_groupSystemNoticeSyncFinished',
    // 消息相关事件
    MESSAGE_SENDING: '_sendingMessage',
    MESSAGE_C2C_SEND_SUCCESS: '_sendC2CMessageSuccess',
    MESSAGE_C2C_SEND_FAIL: '_sendC2CMessageFail',
    MESSAGE_C2C_INSTANT_RECEIVED: '_receiveInstantMessage',
    // 收到新的C2C即时消息
    MESSAGE_C2C_RECEIVE_ROAMING_SUCCESS: '_receiveC2CRoamingMessageSuccess',
    MESSAGE_C2C_RECEIVE_ROAMING_FAIL: '_receiveC2CRoamingMessageFail',
    MESSAGE_GROUP_SEND_SUCCESS: '_sendGroupMessageSuccess',
    MESSAGE_GROUP_SEND_FAIL: '_sendGroupMessageFail',
    MESSAGE_GROUP_RECEIVE_ROAMING_SUCCESS: '_receiveGroupRoamingMessageSuccess',
    MESSAGE_GROUP_RECEIVE_ROAMING_FAIL: '_receiveGroupRoamingMessageFail',
    MESSAGE_GROUP_INSTANT_RECEIVED: '_receiveGroupInstantMessage',
    // 收到新的群即时消息
    MESSAGE_GROUP_SYSTEM_NOTICE_RECEIVED: '_receveGroupSystemNotice',
    // 收到新的群系统通知
    // 通知相关
    NOTICE_LONGPOLL_GETID_SUCCESS: '_getLongPollIDSuccess',
    NOTICE_LONGPOLL_GETID_FAIL: '_getLongPollIDFail',
    NOTICE_LONGPOLL_START: '_longPollStart',
    NOTICE_LONGPOLL_IN_POLLING: '_longPollInPolling',
    NOTICE_LONGPOLL_REQUEST_ARRIVED: '_longPollInArrived',
    // 表示 longpoll 的 request 已经到达，并收到了服务端的 response
    NOTICE_LONGPOLL_REQUEST_NOT_ARRIVED: '_longPollInNotArrived',
    // 表示 longpoll 的 request 未到达
    NOTICE_LONGPOLL_JITTER: '_longPollJitter',
    // longpoll 出现波动，小于消息超时时间（2分钟）的掉线
    NOTICE_LONGPOLL_SOON_RECONNECT: '_longPollSoonReconnect',
    // longpoll 已重连，大于实时消息超时时间（2分钟）并小于最大超时时间（目录是5分钟）时触发
    NOTICE_LONGPOLL_LONG_RECONNECT: '_longPollLongReconnect',
    NOTICE_LONGPOLL_DISCONNECT: '_longpollChannelDisconnect',
    NOTICE_LONGPOLL_STOPPED: '_longPollStopped',
    NOTICE_LONGPOLL_KICKED_OUT: '_longPollKickedOut',
    NOTICE_LONGPOLL_MUTIPLE_DEVICE_KICKED_OUT: '_longPollMitipuleDeviceKickedOut',
    // mutiple
    NOTICE_LONGPOLL_NEW_C2C_NOTICE: '_longPollGetNewC2CNotice',
    NOTICE_LONGPOLL_NEW_C2C_MESSAGES: '_longPollGetNewC2CMessages',
    NOTICE_LONGPOLL_NEW_GROUP_MESSAGES: '_longPollGetNewGroupMessages',
    NOTICE_LONGPOLL_NEW_GROUP_TIPS: '_longPollGetNewGroupTips',
    NOTICE_LONGPOLL_NEW_GROUP_NOTICE: '_longPollGetNewGroupNotice',
    NOTICE_LONGPOLL_NEW_FRIEND_MESSAGES: '_longPollGetNewFriendMessages',
    NOTICE_LONGPOLL_SEQUENCE_UPDATE: '_longPollNoticeSequenceUpdate',
    NOTICE_LONGPOLL_PROFILE_MODIFIED: '_longPollProfileModified',
    // 申请相关
    APPLY_ADD_FRIEND_SUCCESS: '_addFriendApplySendSucess',
    APPLY_ADD_FRIEND_FAIL: '_addFriendApplySendFail',
    APPLY_GET_PENDENCY_SUCCESS: '_applyGetPendenciesSucess',
    APPLY_GET_PENDENCY_FAIL: '_applyGetPendenciesFail',
    APPLY_DELETE_SUCCESS: '_applyDeletedSucess',
    APPLY_DELETE_FAIL: '_applyDeletedFail',
    // group操作相关
    GROUP_CREATE_SUCCESS: '_createGroupSuccess',
    GROUP_CREATE_FAIL: '_createGroupFail',
    GROUP_LIST_UPDATED: '_onGroupListUpdated',
    // 登入、登出事件
    SIGN_LOGIN_CHANGE: '_loginStatusChange',
    SIGN_LOGIN: '_login',
    // 登录
    SIGN_LOGIN_SUCCESS: '_loginSuccess',
    // 登录成功
    SIGN_LOGIN_FAIL: '_loginFail',
    // 登录失败
    SIGN_LOGININFO_UPDATED: '_signLoginInfoUpdated',
    SIGN_LOGOUT_EXECUTING: '_signLogoutExcuting',
    // 登出正在执行，还未取得响应 executing
    SIGN_LOGOUT_SUCCESS: '_logoutSuccess',
    SIGN_GET_ACCESS_LAYER_CHANGE: '_getAccessLayerStatusChange',
    SIGN_GET_ACCESS_LAYER_SUCCESS: '_getAccessLayerSuccess',
    SIGN_GET_ACCESS_LAYER_FAIL: '_getAccessLayerFail',
    // 发现异常
    ERROR_DETECTED: '_errorHasBeenDetected',
    // 会话相关
    CONVERSATION_LIST_UPDATED: '_onConversationListUpdated',
    CONVERSATION_LIST_PROFILE_UPDATED: '_onConversationListProfileUpdated',
    CONVERSATION_DELETED: '_conversationDeleted',
    // 资料相关
    PROFILE_UPDATED: 'onProfileUpdated',
    // 好友相关
    FRIEND_GET_SUCCESS: '_getFriendsSuccess',
    FRIEND_GET_FAIL: '_getFriendsFail',
    FRIEND_DELETE_SUCCESS: '_deleteFriendSuccess',
    FRIEND_DELETE_FAIL: '_deleteFriendFail',
    // 黑名单相关
    BLACKLIST_ADD_SUCCESS: '_addBlacklistSuccess',
    BLACKLIST_ADD_FAIL: '_addBlacklistFail',
    BLACKLIST_GET_SUCCESS: '_getBlacklistSuccess',
    BLACKLIST_GET_FAIL: '_getBlacklistFail',
    // AVChatRoom相关
    AVCHATROOM_OPTIONS_UPDATED: '_AVChatRoomOptionsUpdated',
    AVCHATROOM_JOIN_SUCCESS: 'joinAVChatRoomSuccess',
    // SDK内部系统相关
    SDK_MEMORY_STATUS_UPDATE: '_sdkMemoryStatusUpdate',
    SDK_READY: '_sdkStateReady'
  };

  /**
   * @file env.js
   * @module env
   */
  var IN_BROWSER = typeof window !== 'undefined'; // 请勿在这里引用common-utlils的isFunction，避免模块循环引用

  var IN_WX_MINI_APP = typeof wx !== 'undefined' && typeof wx.getSystemInfoSync === 'function' && typeof wx.canIUse === 'function';
  var USER_AGENT = IN_BROWSER && window.navigator && window.navigator.userAgent || '';
  var webkitVersionMap = /AppleWebKit\/([\d.]+)/i.exec(USER_AGENT);
  var appleWebkitVersion = webkitVersionMap ? parseFloat(webkitVersionMap.pop()) : null;
  /*
   * Device is an iPhone
   *
   * @type {Boolean}
   * @constant
   * @private
   */

  var IS_IPAD = /iPad/i.test(USER_AGENT); // The Facebook app's UIWebView identifies as both an iPhone and iPad, so
  // to identify iPhones, we need to exclude iPads.
  // http://artsy.github.io/blog/2012/10/18/the-perils-of-ios-user-agent-sniffing/

  var IS_IPHONE = /iPhone/i.test(USER_AGENT) && !IS_IPAD;
  var IS_IPOD = /iPod/i.test(USER_AGENT);
  var IOS_VERSION = function () {
    var match = USER_AGENT.match(/OS (\d+)_/i);

    if (match && match[1]) {
      return match[1];
    }

    return null;
  }();
  var IS_ANDROID = /Android/i.test(USER_AGENT);
  var ANDROID_VERSION = function () {
    // This matches Android Major.Minor.Patch versions
    // ANDROID_VERSION is Major.Minor as a Number, if Minor isn't available, then only Major is returned
    var match = USER_AGENT.match(/Android (\d+)(?:\.(\d+))?(?:\.(\d+))*/i);

    if (!match) {
      return null;
    }

    var major = match[1] && parseFloat(match[1]);
    var minor = match[2] && parseFloat(match[2]);

    if (major && minor) {
      return parseFloat(match[1] + '.' + match[2]);
    } else if (major) {
      return major;
    }

    return null;
  }(); // Old Android is defined as Version older than 2.3, and requiring a webkit version of the android browser

  var IS_OLD_ANDROID = IS_ANDROID && /webkit/i.test(USER_AGENT) && ANDROID_VERSION < 2.3;
  var IS_FIREFOX = /Firefox/i.test(USER_AGENT);
  var IS_EDGE = /Edge/i.test(USER_AGENT);
  var IS_CHROME = !IS_EDGE && /Chrome/i.test(USER_AGENT);
  var CHROME_VERSION = function () {
    var match = USER_AGENT.match(/Chrome\/(\d+)/);

    if (match && match[1]) {
      return parseFloat(match[1]);
    }

    return null;
  }(); // IE

  var IS_IE = /MSIE/.test(USER_AGENT); // 是否为IE浏览器

  var IS_IE8 = /MSIE\s8\.0/.test(USER_AGENT);
  var IE_VERSION = function () {
    var result = /MSIE\s(\d+)\.\d/.exec(USER_AGENT);
    var version = result && parseFloat(result[1]);

    if (!version && /Trident\/7.0/i.test(USER_AGENT) && /rv:11.0/.test(USER_AGENT)) {
      // IE 11 has a different user agent string than other IE versions
      version = 11.0;
    }

    return version;
  }(); // Safari

  var IS_SAFARI = /Safari/i.test(USER_AGENT) && !IS_CHROME && !IS_ANDROID && !IS_EDGE;
  var IS_TBS = /TBS\/\d+/i.test(USER_AGENT); // 仅X5内核，QQ浏览器默认x5内核，但是agent没有TBS

  var TBS_VERSION = function () {
    var match = USER_AGENT.match(/TBS\/(\d+)/i);

    if (match && match[1]) {
      return match[1];
    }
  }(); // X5内核版本

  var IS_MQQB = !IS_TBS && /MQQBrowser\/\d+/i.test(USER_AGENT); // 移动端QQ浏览器

  var IS_QQB = !IS_TBS && / QQBrowser\/\d+/i.test(USER_AGENT); // pc端QQ浏览器

  var IS_WECHAT = /(micromessenger|webbrowser)/i.test(USER_AGENT);
  var IS_WIN = /Windows/i.test(USER_AGENT); // window系统

  var IS_MAC = /MAC OS X/i.test(USER_AGENT); // MAC系统，先检查IOS

  var IS_WX = /MicroMessenger/i.test(USER_AGENT); //是否为微信环境

  var LOGLEVEL_DEBUG = -1;
  var LOGLEVEL_LOG = 0;
  var LOGLEVEL_INFO = 1;
  var LOGLEVEL_WARN = 2;
  var LOGLEVEL_ERROR = 3;
  var LOGLEVEL_NON_LOGGING = 4; // 无日志记录级别，sdk将不打印任何日志

  var MAX_LOG_LENGTH = 1000;
  var globalLevel = LOGLEVEL_DEBUG;
  var bCanIUseWxLog = canIUseWxLog(); // wx的LogManager是否可用，存储一份避免频繁获取

  var timerMap = new Map();
  /**
   * 对齐毫秒字符串
   * @param {*} ms 毫秒
   * @returns {String} 对齐后的毫秒时间字符串
   */

  function padMs(ms) {
    var len = ms.toString().length;
    var ret;

    switch (len) {
      case 1:
        ret = '00' + ms;
        break;

      case 2:
        ret = '0' + ms;
        break;

      default:
        ret = ms;
        break;
    }

    return ret;
  }
  /**
   * log前缀
   * @returns {String} 日志前缀
   */


  function getPrefix() {
    var date = new Date();
    return 'TIM ' + date.toLocaleTimeString('en-US', {
      hour12: false
    }) + '.' + padMs(date.getMilliseconds()) + ':';
  }
  /**
   * wx LogManager是否可用
   * @returns {Boolean} true->I can use LogManager
   */


  function canIUseWxLog() {
    if (IN_WX_MINI_APP) {
      // 必须是微信小程序环境，百度小程序目前还只能用console
      var version = wx.getSystemInfoSync().SDKVersion; // HBuilder等工具会在window对象下挂自己模拟的wx对象，但是又没抄好，做个防御

      if (typeof version === 'undefined' || typeof wx.getLogManager === 'undefined') {
        return false;
      }

      if (compareVersion(version, '2.1.0') >= 0) {
        wx.getLogManager().log('I can use wx log. SDKVersion=' + version);
        return true;
      }
    }

    return false;
  }
  /**
   * 比较wx SDKVersion
   * @param {String} v1 版本字符串
   * @param {String} v2 版本字符串
   * @returns {Number} v1>v2，返回1；v1<v2，返回-1；v1==v2，返回0
   */


  function compareVersion(v1, v2) {
    v1 = v1.split('.');
    v2 = v2.split('.');
    var len = Math.max(v1.length, v2.length);

    while (v1.length < len) {
      v1.push('0');
    }

    while (v2.length < len) {
      v2.push('0');
    }

    for (var i = 0; i < len; i++) {
      var num1 = parseInt(v1[i]);
      var num2 = parseInt(v2[i]);

      if (num1 > num2) {
        return 1;
      }

      if (num1 < num2) {
        return -1;
      }
    }

    return 0;
  }

  var logger = {
    _data: [],
    _length: 0,
    _visible: false,
    // 将函数参数拼成字符串
    arguments2String: function arguments2String(args) {
      var s;

      if (args.length === 1) {
        s = getPrefix() + args[0];
      } else {
        s = getPrefix();

        for (var i = 0, length = args.length; i < length; i++) {
          if (isArrayOrObject(args[i])) {
            s += JSON.stringify(args[i]) + ' ';
          } else {
            s += args[i] + ' ';
          }
        }
      }

      return s;
    },

    /**
     * 打印调试日志
     */
    debug: function debug() {
      if (globalLevel <= LOGLEVEL_DEBUG) {
        // 对参数使用slice会阻止某些JavaScript引擎中的优化 (比如 V8 - 更多信息)
        // see:https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#3-managing-arguments
        var s = this.arguments2String(arguments);
        logger.record(s, 'debug');
        console$1.debug(s);

        if (bCanIUseWxLog) {
          wx.getLogManager().debug(s);
        }
      }
    },

    /**
     * 打印普通日志
     */
    log: function log() {
      if (globalLevel <= LOGLEVEL_LOG) {
        var s = this.arguments2String(arguments);
        logger.record(s, 'log');
        console$1.log(s);

        if (bCanIUseWxLog) {
          wx.getLogManager().log(s);
        }
      }
    },

    /**
     * 打印release日志
     */
    info: function info() {
      if (globalLevel <= LOGLEVEL_INFO) {
        var s = this.arguments2String(arguments);
        logger.record(s, 'info');
        console$1.info(s);

        if (bCanIUseWxLog) {
          wx.getLogManager().info(s);
        }
      }
    },

    /**
     * 打印告警日志
     */
    warn: function warn() {
      if (globalLevel <= LOGLEVEL_WARN) {
        var s = this.arguments2String(arguments);
        logger.record(s, 'warn');
        console$1.warn(s);

        if (bCanIUseWxLog) {
          wx.getLogManager().warn(s);
        }
      }
    },

    /**
     * 打印错误日志
     */
    error: function error() {
      if (globalLevel <= LOGLEVEL_ERROR) {
        var s = this.arguments2String(arguments);
        logger.record(s, 'error');
        console$1.error(s); // 微信写不了error日志，就用warn代替了

        if (bCanIUseWxLog) {
          wx.getLogManager().warn(s);
        }
      }
    },
    time: function time(label) {
      timerMap.set(label, TimeUtil.now());
    },
    timeEnd: function timeEnd(label) {
      if (timerMap.has(label)) {
        var cost = TimeUtil.now() - timerMap.get(label);
        timerMap["delete"](label);
        return cost;
      }

      console$1.warn("\u672A\u627E\u5230\u5BF9\u5E94label: ".concat(label, ", \u8BF7\u5728\u8C03\u7528 logger.timeEnd \u524D\uFF0C\u8C03\u7528 logger.time"));
      return 0;
    },
    setLevel: function setLevel(newLevel) {
      if (newLevel < LOGLEVEL_NON_LOGGING) {
        console$1.log(getPrefix() + 'set level from ' + globalLevel + ' to ' + newLevel);
      }

      globalLevel = newLevel;
    },
    record: function record(s, type) {
      if (bCanIUseWxLog) {
        // 小程序环境不在内存缓存日志
        return;
      }

      if (logger._length === MAX_LOG_LENGTH + 100) {
        logger._data.splice(0, 100);

        logger._length = MAX_LOG_LENGTH;
      }

      logger._length++;

      logger._data.push("".concat(s, " [").concat(type, "] \n"));
    },
    getLog: function getLog() {
      return logger._data;
    }
  };

  /**
   * 检测input类型是否为number
   * @param {*} input 任意类型的输入
   * @returns {Boolean} true->number / false->not a number
   */

  var isNumber = function isNumber(input) {
    return input !== null && (typeof input === 'number' && !isNaN(input - 0) || _typeof(input) === 'object' && input.constructor === Number);
  };
  /**
   * 检测input类型是否为string
   * @param {*} input 任意类型的输入
   * @returns {Boolean} true->string / false->not a string
   */

  var isString = function isString(input) {
    return typeof input === 'string';
  };
  var isObject = function isObject(input) {
    // null is object, hence the extra check
    return input !== null && _typeof(input) === 'object';
  };
  /**
   * 检测input类型是否为数组
   * @param {*} input 任意类型的输入
   * @returns {Boolean} true->array / false->not an array
   */

  var isArray = function isArray(input) {
    if (typeof Array.isArray === 'function') {
      return Array.isArray(input);
    } // eslint-disable-next-line no-invalid-this


    return this.getType(input) === 'array';
  };
  /**
   * Checks to see if a value is undefined
   * @param {*} input 任意类型的输入
   * @returns {Boolean} true->input value is undefined
   */

  var isUndefined = function isUndefined(input) {
    return typeof input === 'undefined';
  };
  /**
   * 检测input类型是否为数组或者object
   * @param {*} input 任意类型的输入
   * @returns {Boolean} true->input is an array or an object
   */

  var isArrayOrObject = function isArrayOrObject(input) {
    return isArray(input) || isObject(input);
  };

  var baseTime = 0;

  if (!Date.now) {
    Date.now = function now() {
      return new Date().getTime();
    };
  }

  var TimeUtil = {
    now: function now() {
      if (baseTime === 0) {
        baseTime = Date.now() - 1;
      }

      var diff = Date.now() - baseTime;

      if (diff > 0xffffffff) {
        baseTime += 0xffffffff;
        return Date.now() - baseTime;
      }

      return diff;
    },
    utc: function utc() {
      return Math.round(Date.now() / 1000);
    }
  }; // -----------------深度合并工具函数-----------------

  /**
   * 深度 merge 两个对象。merge source to target.
   * @param {Object|Object[]} target 目标对象
   * @param {Object|Object[]} source 来源对象
   * @param {String[]} [keysIgnore] 要忽略的 keys。命中的 key 会在merge时被忽略
   * @param {*[]} [valuesIgnore] 要忽略的 values。命中的 value 会在merge时被忽略
   * @returns {Number} merge的次数（只有key相同value不同的时候才会merge），如果target和source既不是数组也不是object，则返回0
   */

  var deepMerge = function deepMerge(target, source, keysIgnore, valuesIgnore) {
    // 1. 非 Array 或 Object 类型则直接 return
    if (!(isArrayOrObject(target) && isArrayOrObject(source))) {
      return 0;
    }

    var mergedCount = 0;
    var keys = Object.keys(source);
    var tmpKey;

    for (var i = 0, len = keys.length; i < len; i++) {
      tmpKey = keys[i];

      if (isUndefined(source[tmpKey]) || keysIgnore && keysIgnore.includes(tmpKey)) {
        continue;
      }

      if (isArrayOrObject(target[tmpKey]) && isArrayOrObject(source[tmpKey])) {
        // 递归merge
        mergedCount += deepMerge(target[tmpKey], source[tmpKey], keysIgnore, valuesIgnore);
      } else {
        if (valuesIgnore && valuesIgnore.includes(source[tmpKey])) {
          continue;
        }

        if (target[tmpKey] !== source[tmpKey]) {
          target[tmpKey] = source[tmpKey];
          mergedCount += 1;
        }
      }
    }

    return mergedCount;
  }; // 简单的深拷贝实现
  /**
   * 获取字符串占用的字节数
   * @param {String} string - 字符串
   * @returns {Number} 字符串的长度
   */

  var stringSize = function stringSize(string) {
    if (string.length === 0) {
      return 0;
    }

    var i = 0;
    var _char = '';
    var len = 0;
    var sizeStep = 1;

    var charSet = function () {
      if (typeof document !== 'undefined' && typeof document.characterSet !== 'undefined') {
        return document.characterSet;
      }

      return 'UTF-8';
    }();

    while (typeof string[i] !== 'undefined') {
      _char = string[i++];

      if (_char.charCodeAt[i] <= 255) {
        sizeStep = 1;
      } else {
        sizeStep = charSet === 'UTF-8' >= 0 ? 3 : 2;
      }

      len += sizeStep;
    }

    return len;
  };
  /**
   *  用于生成随机整数
   * @param {Number} level - 整数的级别 例如： 99, 999 , 9999 等
   * @returns {Number} 随机数字
   */

  var randomInt = function randomInt(level) {
    var lv = level || 99999999;
    return Math.round(Math.random() * lv);
  }; // 判断传入的枚举值是否有效

  var isValidType = function isValidType(obj, type) {
    for (var k in obj) {
      if (obj[k] === type) {
        return true;
      }
    }

    return false;
  };
  var AIIList = {};
  var autoincrementIndex = function autoincrementIndex(key) {
    if (!key) {
      logger.error("autoincrementIndex(string: key) need key parameter");
      return false;
    }

    if (typeof AIIList[key] === 'undefined') {
      var dateInstance = new Date();
      var hoursString = "3".concat(dateInstance.getHours()).slice(-2); // 小时数，用3占位，因为一天中不会出现30小时

      var minuteString = "0".concat(dateInstance.getMinutes()).slice(-2);
      var secondString = "0".concat(dateInstance.getSeconds()).slice(-2);
      AIIList[key] = parseInt([hoursString, minuteString, secondString, '0001'].join(''));
      hoursString = null;
      minuteString = null;
      secondString = null;
      logger.warn("utils.autoincrementIndex() create new sequence : ".concat(key, " = ").concat(AIIList[key]));
    }

    return AIIList[key]++;
  };
  var getPageProtocol = function getPageProtocol() {
    if (IN_WX_MINI_APP) {
      return 'https:';
    }

    var preFix = window.location.protocol;

    if (['http:', 'https:'].indexOf(preFix) < 0) {
      preFix = 'http:';
    }

    return preFix;
  };
  /**
   * 深度克隆
   * @param {Object} data 要克隆的对象
   * @returns {Object} 克隆后的对象
   */

  var clone = function clone(data) {
    if (Object.getOwnPropertyNames(data).length === 0) {
      return Object.create(null);
    }

    var newObject = Array.isArray(data) ? [] : Object.create(null);
    var type = ''; // eslint-disable-next-line guard-for-in

    for (var key in data) {
      // null 是一个特殊的对象，优先处理掉
      if (data[key] === null) {
        newObject[key] = null;
        continue;
      } // undefined 也优先处理掉


      if (data[key] === undefined) {
        newObject[key] = undefined;
        continue;
      }

      type = _typeof(data[key]);

      if (['string', 'number', 'function', 'boolean'].indexOf(type) >= 0) {
        newObject[key] = data[key];
        continue;
      } // 只剩对象，递归


      newObject[key] = clone(data[key]);
    }

    return newObject;
  }; // -----------------群组类型判断工具函数-----------------
  var isPublic = function isPublic(type) {
    return type === TYPES.GRP_PUBLIC;
  };
  var isAVChatRoom = function isAVChatRoom(type) {
    return type === TYPES.GRP_AVCHATROOM;
  }; // -----------------类lodash.mapKeys函数-----------------

  function mapKeys(obj, iteratee) {
    var newObj = {};
    Object.keys(obj).forEach(function (key) {
      newObj[iteratee(obj[key], key)] = obj[key];
    });
    return newObj;
  } // -----------------类lodash.mapValues函数-----------------

  function mapValues(obj, iteratee) {
    var newObj = {};
    Object.keys(obj).forEach(function (key) {
      newObj[key] = iteratee(obj[key]);
    });
    return newObj;
  }

  function camelCase(input, options) {
    if (!(typeof input === 'string' || Array.isArray(input))) {
      throw new TypeError('Expected the input to be `string | string[]`');
    }

    options = Object.assign({
      pascalCase: false
    }, options);

    var postProcess = function postProcess(x) {
      return options.pascalCase ? x.charAt(0).toUpperCase() + x.slice(1) : x;
    };

    if (Array.isArray(input)) {
      input = input.map(function (x) {
        return x.trim();
      }).filter(function (x) {
        return x.length;
      }).join('-');
    } else {
      input = input.trim();
    }

    if (input.length === 0) {
      return '';
    }

    if (input.length === 1) {
      return options.pascalCase ? input.toUpperCase() : input.toLowerCase();
    }

    var hasUpperCase = input !== input.toLowerCase();

    if (hasUpperCase) {
      input = preserveCamelCase(input);
    }

    input = input.replace(/^[_.\- ]+/, '').toLowerCase().replace(/[_.\- ]+(\w|$)/g, function (_, p1) {
      return p1.toUpperCase();
    }).replace(/\d+(\w|$)/g, function (m) {
      return m.toUpperCase();
    });
    return postProcess(input);
  }

  var preserveCamelCase = function preserveCamelCase(string) {
    var isLastCharLower = false;
    var isLastCharUpper = false;
    var isLastLastCharUpper = false;

    for (var i = 0; i < string.length; i++) {
      var character = string[i];

      if (isLastCharLower && /[a-zA-Z]/.test(character) && character.toUpperCase() === character) {
        string = string.slice(0, i) + '-' + string.slice(i);
        isLastCharLower = false;
        isLastLastCharUpper = isLastCharUpper;
        isLastCharUpper = true;
        i++;
      } else if (isLastCharUpper && isLastLastCharUpper && /[a-zA-Z]/.test(character) && character.toLowerCase() === character) {
        string = string.slice(0, i - 1) + '-' + string.slice(i - 1);
        isLastLastCharUpper = isLastCharUpper;
        isLastCharUpper = false;
        isLastCharLower = true;
      } else {
        isLastCharLower = character.toLowerCase() === character && character.toUpperCase() !== character;
        isLastLastCharUpper = isLastCharUpper;
        isLastCharUpper = character.toUpperCase() === character && character.toLowerCase() !== character;
      }
    }

    return string;
  };

  /**
   * 背景：后端CGI接口响应参数命名风格不统一，比如有大驼峰形式，也有下划线形式。
   * 用途：将小驼峰形式的参数转成大驼峰（默认），也可传入map参数自定义转换参数字段。
   * 注意：该转换器只转换key，不会改变value值。
   * @param {Object|Array} params - 待转换的参数
   * @param {Object} [map=keyMaps] - 参数的map表，默认值为定义在src/const/keyMaps/index.js中的keyMaps对象。
   * @example
   * const params = { "fromAccount":"id", "addFriendItem":[{ "toAccount":"id1", "addSourse":"AddSource_Type_XXXXXXXX" }]}
   * const map = {"fromAccount":"From_Account", "toAccount":"To_Account"}
   * // 传入map自定义参数转换格式
   * convertRequestParam(params, map)
   *
   * //返回
   * {
   *    "From_Account":"id",
   *    "AddFriendItem":[{"To_Account":"id1", "AddSource":"AddSource_Type_XXXXXXXX"}]
   * }
   */

  function convertRequestParam(params, map, tim) {
    var unStandardParams = [];
    map = _objectSpread2({}, keyMaps.request, {}, map);

    var result = function convert(params, map) {
      /**
       * 参数值是数组
       * 若数组由Object组成，则递归每个value。否则不做处理。
       */
      if (isArray(params)) {
        return params.map(function (param) {
          var needRecursive = isObject(param); //是否需要递归

          return needRecursive ? convert(param, map) : param;
        });
      } // 参数值是对象


      if (isObject(params)) {
        // 先转换key。在转换key时，判断map中是否有key，如有则用对应的值，否则转成大驼峰形式。
        var _result = mapKeys(params, function (value, key) {
          if (key[0] === '_') {
            return key;
          }

          if (!isCamelCase(key)) {
            var isInvalidKey = true;

            for (var i = 0; i < keyMaps.ignoreKeyWord.length; i++) {
              if (key.includes(keyMaps.ignoreKeyWord[i])) {
                isInvalidKey = false;
                break;
              }
            }

            if (isInvalidKey) unStandardParams.push(key);
          }

          return isUndefined(map[key]) ? toUpperCamelCase(key) : map[key];
        }); // 遍历value，遇到数组或者对象则递归，否则返回原value。


        _result = mapValues(_result, function (value) {
          var needRecursive = isArray(value) || isObject(value); //是否需要递归

          return needRecursive ? convert(value, map) : value;
        });
        return _result;
      }
    }(params, map);

    if (unStandardParams.length > 0) {
      tim.innerEmitter.emit(TIM_INNER_EVENT.ERROR_DETECTED, {
        code: ERROR_CODE.CONVERTOR_IRREGULAR_PARAMS,
        message: ERROR_CODE.CONVERTOR_IRREGULAR_PARAMS
      });
    }

    return result;
  }
  /**
   * 场景：后端CGI接口响应参数命名风格不统一，比如有大驼峰形式，也有下划线形式。
   * 用途：将响应参数转换成小驼峰形式。
   * 注意：该转换器只转换key，不会改变value值。
   * @param {Object|Array} params - 待转换的参数
   * @param {Object} map - 响应参数keyMaps表
   * @returns {Object|Array} 转换后的参数
   * @example
   * const params = { To_Account: 'User1', ErrorCode: 0, }
   * convertResponseBody(params)
   * //返回
   * { 'toAccount': 'User1', 'errorCode': 0}
   *
   */

  function convertResponseBody(params, map) {
    map = _objectSpread2({}, keyMaps.response, {}, map);
    /**
     * 参数值是数组
     * 若数组由Object组成，则递归每个value。否则不做处理。
     */

    if (isArray(params)) {
      return params.map(function (param) {
        var needRecursive = isObject(param); //是否需要递归

        return needRecursive ? convertResponseBody(param, map) : param;
      });
    }
    /**
     * 参数值是对象
     * 先遍历keys，把对象的key值转成小驼峰。
     * 然后遍历对象的value，若遇到数组或者对象的value，则递归，否则返回原value
     */


    if (isObject(params)) {
      var result = mapKeys(params, function (value, key) {
        return isUndefined(map[key]) ? camelCase(key) : map[key];
      });
      result = mapValues(result, function (value) {
        var needRecursive = isArray(value) || isObject(value); //是否需要递归

        return needRecursive ? convertResponseBody(value, map) : value;
      });
      return result;
    }
  }
  /**
   * 字符串转大驼峰
   * @param {String} str
   * @returns
   */

  function toUpperCamelCase(str) {
    return str[0].toUpperCase() + camelCase(str).slice(1);
  }
  /**
   * 判断字符串是否是小驼峰
   *
   * @param {*} str
   * @returns
   */

  function isCamelCase(str) {
    return str === camelCase(str);
  }

  /**
   * 此类用于生成网络层传输用的“胶囊” capsule ，为什么要用”胶囊“一词， 因为 package 用了会报错，(T-T)
   */

  var TransportCapsule =
  /*#__PURE__*/
  function () {
    function TransportCapsule(packageOptions, tim) {
      var _this = this;

      _classCallCheck(this, TransportCapsule);

      if (typeof tim === 'undefined') {
        throw new IMError({
          code: ERROR_CODE.NO_SDK_INSTANCE,
          message: ERROR_MESSAGE.NO_SDK_INSTANCE
        });
      }

      this.tim = tim;
      this.method = packageOptions.method || 'POST';

      this._initializeServerMap();

      this._initializeURL(packageOptions); // 打包request数据，会主调用包的encoder方法


      this._initializeRequestData(packageOptions); // this.requestData= packageOptions.requestData;


      this.callback = function (response) {
        response = packageOptions.decode(response); // 把decode方法设置到回调中

        var result = convertResponseBody(response, _this._getResponseMap(packageOptions));
        return result;
      };
    }

    _createClass(TransportCapsule, [{
      key: "_initializeServerMap",
      value: function _initializeServerMap() {
        this._serverMap = Object.create(null);
        var name = '';

        for (var p in SERVER.NAME) {
          name = SERVER.NAME[p];

          switch (name) {
            case SERVER.NAME.PIC:
              this._serverMap[name] = SERVER.HOST.CURRENT.PIC;
              break;

            case SERVER.NAME.IM_COS_SIGN:
              this._serverMap[name] = SERVER.HOST.CURRENT.COS;
              break;

            default:
              this._serverMap[name] = SERVER.HOST.CURRENT.COMMON;
          }
        }
      }
    }, {
      key: "_getHost",
      value: function _getHost(serverName) {
        if (typeof this._serverMap[serverName] != 'undefined') {
          return this._serverMap[serverName];
        }

        throw new IMError({
          code: ERROR_CODE.NETWORK_UNDEFINED_SERVER_NAME,
          message: ERROR_MESSAGE.NETWORK_UNDEFINED_SERVER_NAME
        });
      }
      /**
       * 初始化URL，同时会配置好URL参数
       * @param {Object} packageOptions - packageConfig下对应接口的配置
       */

    }, {
      key: "_initializeURL",
      value: function _initializeURL(packageOptions) {
        var srvName = packageOptions.serverName;
        var cmd = packageOptions.cmd;

        var srvHost = this._getHost(srvName);

        var url = "".concat(srvHost, "/").concat(SERVER.NAME_VERSION[srvName], "/").concat(srvName, "/").concat(cmd);
        url += "?".concat(this._getQueryString(packageOptions.queryString));
        this.url = url;
      }
      /**
       * getUrl 目前用于轮询时，修改reqtime参数
       */

    }, {
      key: "getUrl",
      value: function getUrl() {
        return this.url.replace(/&reqtime=(\d+)/, "&reqtime=".concat(Math.ceil(+new Date() / 1000)));
      }
      /**
       * 打包 requestData 这里会调用encode对requestData 进行编码。
       * @param {*} packageOptions
       */

    }, {
      key: "_initializeRequestData",
      value: function _initializeRequestData(packageOptions) {
        var data = {};
        var requestData = packageOptions.requestData; // 清除掉带有'_'前缀的参数 

        data = this._requestDataCleaner(requestData); // data = requestData;

        this.requestData = packageOptions.encode(data);
      } // 清除掉带有'_'前缀的参数 

    }, {
      key: "_requestDataCleaner",
      value: function _requestDataCleaner(data) {
        var result = Array.isArray(data) ? [] : Object.create(null);

        for (var key in data) {
          // 清除掉带有'_'前缀、值为null的
          if (key[0] === '_') {
            continue;
          }

          if (data[key] === null) {
            // result[key] = null;
            continue;
          } // 清除掉带有 getter 方法的属性


          if (this._isGetterProperty(data, key) === true) {
            continue;
          } // 如果是数组
          // if (Array.isArray(data[key])) {
          //   result[key] = data[key];
          //   continue;
          // }


          if (_typeof(data[key]) === 'object') {
            result[key] = this._requestDataCleaner.bind(this)(data[key]);
            continue;
          }

          result[key] = data[key];
        }

        return result;
      }
      /**
       * 判断一个属性是否有 getter和 setter
       */

    }, {
      key: "_isGetterProperty",
      value: function _isGetterProperty(father, key) {
        var propertyInfo = Object.getOwnPropertyDescriptor(father, key);

        if (typeof propertyInfo.get === 'function') {
          return true;
        }

        return false;
      }
      /**
       * 拼装URL参数
       * @param {Object} queryStringObject
       * @returns {String}
       */

    }, {
      key: "_getQueryString",
      value: function _getQueryString(queryStringObject) {
        var tmp = [];

        for (var p in queryStringObject) {
          if (typeof queryStringObject[p] === 'function') {
            tmp.push("".concat(p, "=").concat(queryStringObject[p]()));
            continue;
          }

          tmp.push("".concat(p, "=").concat(queryStringObject[p]));
        }

        return tmp.join('&');
      }
    }, {
      key: "_getResponseMap",
      value: function _getResponseMap(packageOptions) {
        if (packageOptions.keyMaps) {
          if (packageOptions.keyMaps.response) {
            if (Object.keys(packageOptions.keyMaps.response).length > 0) {
              return packageOptions.keyMaps.response;
            }
          }
        }
      }
    }]);

    return TransportCapsule;
  }();

  /**
   * 为对象或实例添加ready状态管理机制
   * @author anderlu
   * @param {*} target
   * @example
   * import ReadyStatus from './base/mixin/ready-status.js';
   * // use in constructor
   * ReadyStatus(this);
   * // or
   * ReadyStatus.mixin(this);
   */
  function ReadyStatus(target) {
    this.mixin(target);
  }

  ReadyStatus.mixin = function (constructor) {
    var prototype = constructor.prototype || constructor;
    prototype._isReady = false;

    prototype.ready = function (fn) {
      var sync = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      if (!fn) {
        return;
      }

      if (!this._isReady) {
        this._readyQueue = this._readyQueue || [];

        this._readyQueue.push(fn);

        return;
      }

      if (sync) {
        fn.call(this);
      } else {
        // Call the function asynchronously by default for consistency
        setTimeout(fn, 1);
      }
    };

    prototype.triggerReady = function () {
      var _this = this;

      this._isReady = true; // Ensure ready is triggerd asynchronously

      setTimeout(function () {
        var readyQueue = _this._readyQueue; // Reset Ready Queue

        _this._readyQueue = [];

        if (readyQueue && readyQueue.length > 0) {
          readyQueue.forEach(function (fn) {
            // console.log(this);
            fn.call(this);
          }, _this);
        } // Allow for using event listeners also
        // emitter('ready');

      }, 1);
    };

    prototype.resetReady = function () {
      this._isReady = false;
      this._readyQueue = [];
    };

    prototype.isReady = function () {
      return this._isReady;
    };
  };

  var IMController =
  /*#__PURE__*/
  function () {
    function IMController(tim) {
      _classCallCheck(this, IMController);

      if (!!tim == false) {
        throw new IMError({
          code: ERROR_CODE.NO_SDK_INSTANCE,
          message: ERROR_MESSAGE.NO_SDK_INSTANCE
        });
      }

      ReadyStatus.mixin(this);
      this.tim = tim;
      this.innerEmitter = tim.innerEmitter;
      this.connectionController = tim.connectionController;
      this.packageConfig = tim.packageConfig;
      this.packageConfig.update(tim);
    }
    /**
     * 生成网络包配置，此包可以由 `ConnectionController.request()` 方法发送
     * @param {Object} options
     * @param {String} options.name - packageConfig 的名称
     * @param {String} options.action - packageConfig 的操作， 一个 packageConfig 有四个操作：create/query/update/delete
     * @param {Object} [options.param] - 接口的 POST 参数
     * @returns {object}
     */


    _createClass(IMController, [{
      key: "createPackage",
      value: function createPackage(options) {
        var packOptions = this.packageConfig.get(options);

        if (!packOptions) {
          return false;
        }

        var capsule = new TransportCapsule(packOptions, this.tim);
        return capsule;
      }
      /**
       * 子类需要实现reset方法，否则一调用就会有警告
       */

    }, {
      key: "reset",
      value: function reset() {
        logger.warn(['method: IMController.reset() method must be implemented'].join());
      }
      /**
       * 销毁实例
       */

    }, {
      key: "destroy",
      value: function destroy() {
        logger.warn('destory');
      }
    }]);

    return IMController;
  }();

  /**
   * @uses 用于登录上下文件数据的存储
   */

  var Context =
  /*#__PURE__*/
  function () {
    function Context(data, tim) {
      _classCallCheck(this, Context);

      this.data = data;
      this.tim = tim; //记录下原始值， 重置的时候比较方便

      this.defaultData = {};
      Object.assign(this.defaultData, data); //深拷贝

      this.initGetterAndSetter();
    }
    /**
     * 配置 Context 的 setter 和 getter，目的是当 Context 的成员属性变更的时候，能发布更新事件。
     */


    _createClass(Context, [{
      key: "initGetterAndSetter",
      value: function initGetterAndSetter() {
        var self = this;
        var tim = this.tim;

        var setValProxy = function setValProxy(key, val) {
          Object.defineProperty(self, key, {
            enumerable: true,
            configurable: true,
            get: function get() {
              // logger.log(`Contex.${key} getted`);
              return self.data[key];
            },
            set: function set(newValue) {
              // let oldLen = JSON.stringify(self.data[key]).length;
              // let newLen = JSON.stringify(newValue).length;
              self.data[key] = newValue;
              self.onChange.bind(self)(tim.context, key, newValue);
            }
          });
        };

        for (var key in self.data) {
          setValProxy(key, self.data[key]);
        }
      }
      /**
       * ctx成员属性已更新，发布`TIM_INNER_EVENT.CONTEXT_UPDATED`事件。
       * @param {Object} context  - 整个ctx实例
       * @param {String} key - 变更的key
       * @param {string | number} value - 新的值
       * @fires TIM_INNER_EVENT.CONTEXT_UPDATED - Context属性值变更事件。
       */

    }, {
      key: "onChange",
      value: function onChange(context, key, value) {
        this.tim.innerEmitter.emit(TIM_INNER_EVENT.CONTEXT_UPDATED, {
          data: {
            context: context,
            key: key,
            value: value
          }
        });
      }
      /**
       * 重置
       */

    }, {
      key: "reset",
      value: function reset() {
        var tim = this.tim;

        for (var p in this.data) {
          // this[p] = this.defaultData.hasOwnProperty(p) ? this.defaultData[p] : null;
          this.data[p] = this.defaultData.hasOwnProperty(p) ? this.defaultData[p] : null;
        }

        this.tim.innerEmitter.emit(TIM_INNER_EVENT.CONTEXT_RESET, {
          data: tim.context
        });
      }
    }]);

    return Context;
  }();

  /**
   * 状态码，
   */

  /**
   * 一些常用的状态
   */
  var COMMON_STATUS = {
    SUCCESS: 'OK',
    FAIL: 'FAIL'
  };
  /**
   * 网络请求状态
   */

  var REQUEST_STATUS = {
    SUCCESS: 0
  };
  /**
   * 沙盒状态
   */

  var ACCESS_LAYER = {
    PRODUCTION: 0,
    TEST: 1
  };
  var LOGIN = {
    IS_LOGIN: 1,
    IS_NOT_LOGIN: 0
  };
  /**
   * 消息同步状态
   */

  var SYNC_MESSAGE = {
    SYNCHRONIZATION_START: 0,
    // 开始同步
    SYNCHRONIZING: 1,
    // 同步中
    SYNCHRONIZED: 2 // 同步完成

  };
  var MESSAGE_STATUS = {
    UNSEND: 'unSend',
    SUCCESS: 'success',
    FAIL: 'fail'
  };
  /**
   * 获取大量历史消息时需要继拉，用来表示续拉的状态
   */

  var GET_HISTORY_MESSAGE_STATUS = {
    C2C_IS_FINISHED: 1,
    C2C_IS_NOT_FINISHED: 0,
    GROUP_IS_FINISHED: 1,
    GROUP_IS_NOT_FINISHED: 0
  };
  /**
   * 账号在线状态
   */

  var ACCOUNT_STATUS = {
    SIGN_IN: true,
    SIGN_OUT: false
  };
  /**
   * 消息通道在线状态
   */

  var CHANNEL_STATUS = {
    ONLINE: true,
    OFFLINE: false
  };
  var JOIN_GROUP_STATUS = {
    SUCCESS: 'JoinedSuccess',
    WAIT_APPROVAL: 'WaitAdminApproval'
  };
  var UPLOAD_STATUS = {
    FINISHED: 1,
    // 上传完成
    UPLOADING: 0 // 上传中

  };
  var TIM_STATUS = {
    COMMON: COMMON_STATUS,
    REQUEST: REQUEST_STATUS,
    ACCESS_LAYER: ACCESS_LAYER,
    LOGIN: LOGIN,
    SYNC_MESSAGE: SYNC_MESSAGE,
    MESSAGE_STATUS: MESSAGE_STATUS,
    GET_HISTORY_MESSAGE_STATUS: GET_HISTORY_MESSAGE_STATUS,
    ACCOUNT_STATUS: ACCOUNT_STATUS,
    CHANNEL_STATUS: CHANNEL_STATUS,
    JOIN_GROUP_STATUS: JOIN_GROUP_STATUS,
    UPLOAD: UPLOAD_STATUS
  };

  var ContextController =
  /*#__PURE__*/
  function (_IMController) {
    _inherits(ContextController, _IMController);

    function ContextController(tim) {
      var _this;

      _classCallCheck(this, ContextController);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(ContextController).call(this, tim));

      _this._initContext();

      _this._initListener();

      return _this;
    }

    _createClass(ContextController, [{
      key: "reset",
      value: function reset() {
        this.tim.context.reset();
      }
      /**
       * 控制器准备就绪时，调用此方法
       */

    }, {
      key: "_IAmReady",
      value: function _IAmReady() {
        this.triggerReady();
      }
    }, {
      key: "_initListener",
      value: function _initListener() {
        this.tim.innerEmitter.on(TIM_INNER_EVENT.SIGN_LOGIN_SUCCESS, this._updateA2KeyAndTinyID, this);
      }
    }, {
      key: "_updateA2KeyAndTinyID",
      value: function _updateA2KeyAndTinyID(_ref) {
        var _ref$data = _ref.data,
            a2Key = _ref$data.a2Key,
            tinyID = _ref$data.tinyID;
        this.set('a2Key', a2Key);
        this.set('tinyID', tinyID);
        this.tim.innerEmitter.emit(TIM_INNER_EVENT.CONTEXT_A2KEY_AND_TINYID_UPDATED, {
          data: {
            context: this.tim.context
          }
        });

        this._IAmReady();
      }
    }, {
      key: "get",
      value: function get(key) {
        return this.tim.context[key];
      }
    }, {
      key: "set",
      value: function set(key, value) {
        this.tim.context[key] = value;
      }
      /**
       * 生成ctx对象
       * @ignore
       */

    }, {
      key: "_initContext",
      value: function _initContext() {
        var loginInfo = this.tim.loginInfo;
        this.tim.context = new Context({
          login: TIM_STATUS.LOGIN.IS_NOT_LOGIN,
          SDKAppID: loginInfo.SDKAppID,
          appIDAt3rd: null,
          accountType: loginInfo.accountType,
          identifier: loginInfo.identifier,
          tinyID: null,
          identifierNick: loginInfo.identifierNick,
          userSig: loginInfo.userSig,
          a2Key: null,
          contentType: 'json',
          apn: 1
        }, this.tim); // this.tim.innerEmitter.on(TIM_INNER_EVENT.SIGN._LOGININFO_UPDATED, this._onContextMemberChange.bind(this));

        this.tim.innerEmitter.on(TIM_INNER_EVENT.CONTEXT_UPDATED, this._onContextMemberChange.bind(this));
      }
      /**
       * 当ctx变量内容发生变化时，会调用此方法
       * @ignore
       */

    }, {
      key: "_onContextMemberChange",
      value: function _onContextMemberChange(event) {
        var _event$data = event.data,
            key = _event$data.key,
            value = _event$data.value;

        switch (key) {
          case 'tinyID':
            //如果 tinyID 为空了， 说明不在登录状态
            if (value.length <= 0) {
              this.tim.context.login = TIM_STATUS.LOGIN.IS_NOT_LOGIN;
            } else {
              this.tim.context.login = this.tim.context.a2Key != null ? TIM_STATUS.LOGIN.IS_LOGIN : TIM_STATUS.LOGIN.IS_NOT_LOGIN;
            }

            break;

          case 'a2Key':
            //如果a2Key为空了， 说明不在登录状态
            if (value.length <= 0) {
              this.tim.context.login = TIM_STATUS.LOGIN.IS_NOT_LOGIN;
            } else {
              this.tim.context.login = this.tim.context.tinyID != null ? TIM_STATUS.LOGIN.IS_LOGIN : TIM_STATUS.LOGIN.IS_NOT_LOGIN;
            }

            break;
        }
      }
    }]);

    return ContextController;
  }(IMController);

  /**
   * 标准 Response 类 <br/>
   * @class IMResponse
   * @param {Object} options
   * @param {Number} options.code 
   * @param {*} options.data 
   */
  var IMResponse = function IMResponse(options) {
    _classCallCheck(this, IMResponse);

    this.code = 0;
    this.data = options || {};
  };

  /**
   * sdk对接入侧的统一的Promise入口
   */

  var _emitter = null;
  var IMPromise = {
    hookEmitter: function hookEmitter(emitter) {
      _emitter = emitter;
    },
    resolve: function resolve(options) {
      if (options instanceof IMResponse) {
        logger.warn('IMPromise.resolve 此函数会自动用options创建IMResponse实例，调用侧不需创建，建议修改！');
        return Promise.resolve(options);
      }

      return Promise.resolve(new IMResponse(options));
    },

    /**
     * 返回一个带有拒绝原因(错误信息)的 Promise 对象
     * @param {Object} options - 创建 IMError 实例的配置，包含 code 和 message
     * @param {Number} options.code - 错误码
     * @param {String} options.message - 错误信息
     * @param {*} bEmitErrorEvent 是否派发错误事件的标识，默认 false。设置为 true 将派发 TIM_OUTER_EVENT.ERROR 事件
     */
    reject: function reject(options) {
      var bEmitErrorEvent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      if (options instanceof IMError) {
        bEmitErrorEvent && _emitter != null && _emitter.emit(TIM_OUTER_EVENT.ERROR, options);
        return Promise.reject(options);
      }

      if (options instanceof Error) {
        logger.warn('IMPromise.reject options not instanceof IMError! details:', options);

        var _imError = new IMError({
          code: ERROR_CODE.UNCAUGHT_ERROR,
          message: options.message
        });

        bEmitErrorEvent && _emitter != null && _emitter.emit(TIM_OUTER_EVENT.ERROR, _imError);
        return Promise.reject(_imError);
      } // 这两种错误应该在开发阶段解决掉，不对外提供错误码 


      if (isUndefined(options) || isUndefined(options.code) || isUndefined(options.message)) {
        logger.error('IMPromise.reject 必须指定code(错误码)和message(错误信息)!!!');
        return;
      } else if (!isNumber(options.code) || !isString(options.message)) {
        logger.error('IMPromise.reject code(错误码)必须为数字，message(错误信息)必须为字符串!!!');
        return;
      }

      var imError = new IMError(options);
      bEmitErrorEvent && _emitter != null && _emitter.emit(TIM_OUTER_EVENT.ERROR, imError);
      return Promise.reject(imError);
    }
  };

  // logger.time 函数的 label 常量。 用于统计耗时。
  var label = {
    SDK_READY: 'sdkReady',
    LOGIN: 'login',
    SEND_MESSAGE: 'sendMessage',
    INIT_CONVERSATION_LIST: 'initConversationList',
    INIT_GROUP_LIST: 'initGroupList',
    UPLOAD: 'upload'
  };

  /**
   * 用于处理登录、登出等逻辑
   * @class
   * @author SaxonGao
   */

  var SignController =
  /*#__PURE__*/
  function (_IMController) {
    _inherits(SignController, _IMController);

    /**
     * @param {TIM} tim - TIM 实例
     */
    function SignController(tim) {
      var _this;

      _classCallCheck(this, SignController);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(SignController).call(this, tim));
      /**
       * 如果开发输错了参数，这条消息抛出。期望能提示到开发者
       */

      _this.devLoginTips = "new TIM({\n      SDKAppID: \"\u5FC5\u586B\",\n      accountType: \"\u5FC5\u586B\",\n      identifier: \"\u5FC5\u586B\",\n      userSig: \"\u5FC5\u586B\",\n      identifierNick: \"\u53EF\u9009\"\n    })\n    ";

      _this._initListener();

      return _this;
    }
    /**
     * @uses 处理用户登录
     * @param {object} options - 登录参数
     * @param {string} options.SDKAppID - 用户标识接入SDK的应用ID，必填
     * @param {string} options.accountType - 用户标识接入SDK的应用ID，选填
     * @param {string} options.identifier - 用户帐号,必须是字符串类型，必填
     * @param {string} options.userSig - 鉴权Token，必须是字符串类型，必填
     * @description 登录流程为 ：
     * 1. 请求沙箱类型
     * 2. 设置API地址
     * 3. 正式登录
     * 4. 抛出登录成功事件或登录失败事件
     * @returns {IMPromise}
     */


    _createClass(SignController, [{
      key: "login",
      value: function login(options) {
        logger.log('SignController.login userID=', options.identifier);
        logger.time(label.LOGIN);

        var ret = this._checkLoginInfo(options);

        if (!isEmpty(ret)) {
          return IMPromise.reject(ret);
        }

        this.tim.context.identifier = options.identifier;
        this.tim.context.userSig = options.userSig;
        this.tim.context.SDKAppID = options.SDKAppID;
        this.tim.context.accountType = options.accountType;

        if (this.tim.context.identifier && this.tim.context.userSig) {
          // 带状态登录
          // TODO: 此逻辑应该存在优化空间，`_accessLayer`是请求沙箱类型
          this.tim.innerEmitter.emit(TIM_INNER_EVENT.SIGN_LOGIN);
          return this._accessLayer();
        } // TODO: 待完善,不带状态登录，进入直播场景sdk

      }
      /**
       * 绑定事件
       */

    }, {
      key: "_initListener",
      value: function _initListener() {
        // TODO: 此controller无需监听这些事件
        // this.innerEmitter.on(TIM_INNER_EVENT.SIGN_GET_ACCESS_LAYER_SUCCESS, this._onGetAccessLayerSuccess, this);
        // this.innerEmitter.on(TIM_INNER_EVENT.SIGN_GET_ACCESS_LAYER_FAIL, this._onGetAccessLayerFail, this);
        // this.innerEmitter.on(TIM_INNER_EVENT.SIGN_LOGIN_FAIL, this._onLoginFail, this);
        // 多实例被踢
        this.innerEmitter.on(TIM_INNER_EVENT.NOTICE_LONGPOLL_KICKED_OUT, this._onKickedOut, this); // 多终端被踢

        this.innerEmitter.on(TIM_INNER_EVENT.NOTICE_LONGPOLL_MUTIPLE_DEVICE_KICKED_OUT, this._onMultipleDeviceKickedOut, this);
      }
      /**
       * 请求沙箱类型
       * @returns {promise} result
       */

    }, {
      key: "_accessLayer",
      value: function _accessLayer() {
        var _this2 = this;

        logger.log('SignController._accessLayer.');
        var capsule = this.createPackage({
          name: 'accessLayer',
          action: 'query'
        });
        return this.tim.connectionController.request(capsule).then(function (response) {
          logger.log('SignController._accessLayer ok. webImAccessLayer=', response.data.webImAccessLayer); // TIPS: 以下逻辑是选择不同的沙箱，events.tim.qq.com是活动沙箱

          if (response.data.webImAccessLayer === 1) {
            SERVER.HOST.setCurrent(response.data.webImAccessLayer);
          }

          return _this2._login();
        })["catch"](function (error) {
          logger.error('SignController._accessLayer error:', error); // 统计用（在这里派发登录失败更准确些，因为login操作如果失败，这里也能捕获到；而accessLayer操作失败，实际也会导致登录失败）

          return IMPromise.reject(error, true);
        });
      }
      /**
       * @returns {promise} result
       */

    }, {
      key: "_login",
      value: function _login() {
        var _this3 = this;

        var capsule = this.createPackage({
          name: 'login',
          action: 'query'
        });
        return this.connectionController.request(capsule).then(function (response) {
          if (!!response.data.tinyID === false) {
            throw new IMError({
              code: ERROR_CODE.NO_TINYID,
              message: ERROR_MESSAGE.NO_TINYID
            });
          }

          if (!!response.data.a2Key === false) {
            // 注： 回调中使用emitter发布异常事件时， 不需要使用 throw new IMError
            throw new IMError({
              code: ERROR_CODE.NO_A2KEY,
              message: ERROR_MESSAGE.NO_A2KEY
            });
          }

          logger.log("SignController.login ok. userID=".concat(_this3.tim.loginInfo.identifier, " loginCost=").concat(logger.timeEnd(label.LOGIN), "ms")); // 统计用

          _this3.tim.innerEmitter.emit(TIM_INNER_EVENT.SIGN_LOGIN_SUCCESS, {
            data: {
              a2Key: response.data.a2Key,
              tinyID: response.data.tinyID
            }
          });

          _this3.tim.outerEmitter.emit(TIM_OUTER_EVENT.LOGIN_SUCCESS);

          return IMPromise.resolve(response.data);
        })["catch"](function (error) {
          logger.error('SignController.login error:', error);
          return IMPromise.reject(error); // 这里不需抛出事件，在accessLayer.catch中统一抛出即可。
        });
      }
      /**
       * @descriptionSDK 登出
       * 分为三个步骤
       * 1. 调用后端 longpolling logout 接口
       * 2. 调用后端 logout 接口
       * 3. 关闭长轮询通道且 reset SDK 的数据
       * @returns {IMPromise}
       */

    }, {
      key: "logout",
      value: function logout() {
        logger.info('SignController.logout');
        this.tim.innerEmitter.emit(TIM_INNER_EVENT.SIGN_LOGOUT_EXECUTING); // 无论then/catch 都是登出成功

        return Promise.all(this._logout(LOGOUT_TYPES.LONG_POLL), this._logout(LOGOUT_TYPES.ALL)).then(this._emitLogoutSuccess.bind(this))["catch"](this._emitLogoutSuccess.bind(this));
      }
      /**
       * 登出
       * @param {Number} type - 登出的类型
       * @description
       *  type为`LOGOUT_TYPES.ALL`时: webim 完全退出登录态
       *  type为`LOGOUT_TYPES.LONG_POLL`时: 仅注销掉longPollID
       * @returns {IMPromise}
       */

    }, {
      key: "_logout",
      value: function _logout(type) {
        var notificationController = this.tim.notificationController;
        var name = type === LOGOUT_TYPES.ALL ? 'logout' : 'longPollLogout';
        var packOptions = type === LOGOUT_TYPES.ALL ? {
          name: name,
          action: 'query'
        } : {
          name: name,
          action: 'query',
          param: {
            longPollID: notificationController.getLongPollID()
          }
        };
        var pack = this.createPackage(packOptions);
        return this.connectionController.request(pack)["catch"](function (error) {
          logger.error('SignController._logout error:', error);
          return IMPromise.reject(error); // logger.error(error);
          // this.innerEmitter.emit(TIM_INNER_EVENT.ERROR_DETECTED, error);
        });
      }
      /**
       * @uses 当获取沙箱类型成功
       */
      // _onGetAccessLayerSuccess(event) {
      //   logger.log('_onGetAccessLayerSuccess', event);
      //   if (event.data.errorCode === TIM_STATUS.REQUEST.SUCCESS) {
      //     this._login();
      //   }
      // }

      /**
       * @uses 当获取沙箱类型失败
       */
      // _onGetAccessLayerFail(event) {
      //   logger.log('_onGetAccessLayerFail', event);
      // }

      /**
       * @uses 当登录失败
       */
      // _onLoginFail(event) {
      //   let { innerEmitter } = this.tim;
      //   logger.log('onLoginFail:', event);
      //   innerEmitter.emit(TIM_INNER_EVENT.ERROR_DETECTED, {
      //     code: event.data.errorCode,
      //     message: event.data.errorInfo || event.data.message,
      //     level: TIM_ERROR.LEVEL.FATAL_ERROR,
      //     tips: event.data.errorInfo || event.data.message
      //   });
      // }

      /**
       * @description 检测loginInfo是否规范
       * @param {object} loginInfo - 登录参数
       * @returns {object} - loginInfo相关参数都ok，返回一个空的{}，如果有不规范的参数，则返回一个包含code和message的{}
       */

    }, {
      key: "_checkLoginInfo",
      value: function _checkLoginInfo(loginInfo) {
        var code = 0;
        var message = '';

        if (loginInfo.SDKAppID === null) {
          code = ERROR_CODE.NO_SDKAPPID;
          message = ERROR_MESSAGE.NO_SDKAPPID;
        } else if (loginInfo.accountType === null) {
          code = ERROR_CODE.NO_ACCOUNT_TYPE;
          message = ERROR_MESSAGE.NO_ACCOUNT_TYPE;
        } else if (loginInfo.identifier === null) {
          code = ERROR_CODE.NO_IDENTIFIER;
          message = ERROR_MESSAGE.NO_IDENTIFIER;
        } else if (loginInfo.userSig === null) {
          code = ERROR_CODE.NO_USERSIG;
          message = ERROR_MESSAGE.NO_USERSIG;
        } // identifierNick  暂时不做检测


        if (!isEmpty(code) && !isEmpty(message)) {
          return {
            code: code,
            message: message
          };
        }

        return {};
      }
      /**
       * 抛出登出成功事件
       * @private
       * @memberof SignController
       * @returns {IMPromise}
       */

    }, {
      key: "_emitLogoutSuccess",
      value: function _emitLogoutSuccess() {
        this.tim.innerEmitter.emit(TIM_INNER_EVENT.SIGN_LOGOUT_SUCCESS);
        return IMPromise.resolve({});
      }
      /**
       * 多实例被踢出
       * @memberof SignController
       */

    }, {
      key: "_onKickedOut",
      value: function _onKickedOut() {
        var _this4 = this;

        this.tim.logout().then(function () {
          logger.warn("SignController._onKickedOut kicked out.       userID=".concat(_this4.tim.loginInfo.identifier));

          _this4.tim.outerEmitter.emit(TIM_OUTER_EVENT.KICKED_OUT, {
            type: KICKED_OUT_TYPES.MUTIPLE_ACCOUNT
          });
        });
      }
      /**
       * 多终端被踢出
       * @memberof SignController
       */

    }, {
      key: "_onMultipleDeviceKickedOut",
      value: function _onMultipleDeviceKickedOut() {
        var _this5 = this;

        this.tim.logout().then(function () {
          logger.warn("SignController._onKickedOut kicked out.       userID=".concat(_this5.tim.loginInfo.identifier));

          _this5.tim.outerEmitter.emit(TIM_OUTER_EVENT.KICKED_OUT, {
            type: KICKED_OUT_TYPES.MUTIPLE_DEVICE
          });
        });
      }
    }, {
      key: "reset",
      value: function reset() {}
    }]);

    return SignController;
  }(IMController);

  var bind = function bind(fn, thisArg) {
    return function wrap() {
      var args = new Array(arguments.length);
      for (var i = 0; i < args.length; i++) {
        args[i] = arguments[i];
      }
      return fn.apply(thisArg, args);
    };
  };

  /*!
   * Determine if an object is a Buffer
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   */

  var isBuffer = function isBuffer (obj) {
    return obj != null && obj.constructor != null &&
      typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
  };

  /*global toString:true*/

  // utils is a library of generic helper functions non-specific to axios

  var toString$1 = Object.prototype.toString;

  /**
   * Determine if a value is an Array
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is an Array, otherwise false
   */
  function isArray$1(val) {
    return toString$1.call(val) === '[object Array]';
  }

  /**
   * Determine if a value is an ArrayBuffer
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is an ArrayBuffer, otherwise false
   */
  function isArrayBuffer(val) {
    return toString$1.call(val) === '[object ArrayBuffer]';
  }

  /**
   * Determine if a value is a FormData
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is an FormData, otherwise false
   */
  function isFormData(val) {
    return (typeof FormData !== 'undefined') && (val instanceof FormData);
  }

  /**
   * Determine if a value is a view on an ArrayBuffer
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
   */
  function isArrayBufferView(val) {
    var result;
    if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
      result = ArrayBuffer.isView(val);
    } else {
      result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);
    }
    return result;
  }

  /**
   * Determine if a value is a String
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is a String, otherwise false
   */
  function isString$1(val) {
    return typeof val === 'string';
  }

  /**
   * Determine if a value is a Number
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is a Number, otherwise false
   */
  function isNumber$1(val) {
    return typeof val === 'number';
  }

  /**
   * Determine if a value is undefined
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if the value is undefined, otherwise false
   */
  function isUndefined$1(val) {
    return typeof val === 'undefined';
  }

  /**
   * Determine if a value is an Object
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is an Object, otherwise false
   */
  function isObject$1(val) {
    return val !== null && typeof val === 'object';
  }

  /**
   * Determine if a value is a Date
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is a Date, otherwise false
   */
  function isDate(val) {
    return toString$1.call(val) === '[object Date]';
  }

  /**
   * Determine if a value is a File
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is a File, otherwise false
   */
  function isFile(val) {
    return toString$1.call(val) === '[object File]';
  }

  /**
   * Determine if a value is a Blob
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is a Blob, otherwise false
   */
  function isBlob(val) {
    return toString$1.call(val) === '[object Blob]';
  }

  /**
   * Determine if a value is a Function
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is a Function, otherwise false
   */
  function isFunction(val) {
    return toString$1.call(val) === '[object Function]';
  }

  /**
   * Determine if a value is a Stream
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is a Stream, otherwise false
   */
  function isStream(val) {
    return isObject$1(val) && isFunction(val.pipe);
  }

  /**
   * Determine if a value is a URLSearchParams object
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is a URLSearchParams object, otherwise false
   */
  function isURLSearchParams(val) {
    return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
  }

  /**
   * Trim excess whitespace off the beginning and end of a string
   *
   * @param {String} str The String to trim
   * @returns {String} The String freed of excess whitespace
   */
  function trim(str) {
    return str.replace(/^\s*/, '').replace(/\s*$/, '');
  }

  /**
   * Determine if we're running in a standard browser environment
   *
   * This allows axios to run in a web worker, and react-native.
   * Both environments support XMLHttpRequest, but not fully standard globals.
   *
   * web workers:
   *  typeof window -> undefined
   *  typeof document -> undefined
   *
   * react-native:
   *  navigator.product -> 'ReactNative'
   * nativescript
   *  navigator.product -> 'NativeScript' or 'NS'
   */
  function isStandardBrowserEnv() {
    if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' ||
                                             navigator.product === 'NativeScript' ||
                                             navigator.product === 'NS')) {
      return false;
    }
    return (
      typeof window !== 'undefined' &&
      typeof document !== 'undefined'
    );
  }

  /**
   * Iterate over an Array or an Object invoking a function for each item.
   *
   * If `obj` is an Array callback will be called passing
   * the value, index, and complete array for each item.
   *
   * If 'obj' is an Object callback will be called passing
   * the value, key, and complete object for each property.
   *
   * @param {Object|Array} obj The object to iterate
   * @param {Function} fn The callback to invoke for each item
   */
  function forEach(obj, fn) {
    // Don't bother if no value provided
    if (obj === null || typeof obj === 'undefined') {
      return;
    }

    // Force an array if not already something iterable
    if (typeof obj !== 'object') {
      /*eslint no-param-reassign:0*/
      obj = [obj];
    }

    if (isArray$1(obj)) {
      // Iterate over array values
      for (var i = 0, l = obj.length; i < l; i++) {
        fn.call(null, obj[i], i, obj);
      }
    } else {
      // Iterate over object keys
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          fn.call(null, obj[key], key, obj);
        }
      }
    }
  }

  /**
   * Accepts varargs expecting each argument to be an object, then
   * immutably merges the properties of each object and returns result.
   *
   * When multiple objects contain the same key the later object in
   * the arguments list will take precedence.
   *
   * Example:
   *
   * ```js
   * var result = merge({foo: 123}, {foo: 456});
   * console.log(result.foo); // outputs 456
   * ```
   *
   * @param {Object} obj1 Object to merge
   * @returns {Object} Result of all merge properties
   */
  function merge(/* obj1, obj2, obj3, ... */) {
    var result = {};
    function assignValue(val, key) {
      if (typeof result[key] === 'object' && typeof val === 'object') {
        result[key] = merge(result[key], val);
      } else {
        result[key] = val;
      }
    }

    for (var i = 0, l = arguments.length; i < l; i++) {
      forEach(arguments[i], assignValue);
    }
    return result;
  }

  /**
   * Function equal to merge with the difference being that no reference
   * to original objects is kept.
   *
   * @see merge
   * @param {Object} obj1 Object to merge
   * @returns {Object} Result of all merge properties
   */
  function deepMerge$1(/* obj1, obj2, obj3, ... */) {
    var result = {};
    function assignValue(val, key) {
      if (typeof result[key] === 'object' && typeof val === 'object') {
        result[key] = deepMerge$1(result[key], val);
      } else if (typeof val === 'object') {
        result[key] = deepMerge$1({}, val);
      } else {
        result[key] = val;
      }
    }

    for (var i = 0, l = arguments.length; i < l; i++) {
      forEach(arguments[i], assignValue);
    }
    return result;
  }

  /**
   * Extends object a by mutably adding to it the properties of object b.
   *
   * @param {Object} a The object to be extended
   * @param {Object} b The object to copy properties from
   * @param {Object} thisArg The object to bind function to
   * @return {Object} The resulting value of object a
   */
  function extend(a, b, thisArg) {
    forEach(b, function assignValue(val, key) {
      if (thisArg && typeof val === 'function') {
        a[key] = bind(val, thisArg);
      } else {
        a[key] = val;
      }
    });
    return a;
  }

  var utils = {
    isArray: isArray$1,
    isArrayBuffer: isArrayBuffer,
    isBuffer: isBuffer,
    isFormData: isFormData,
    isArrayBufferView: isArrayBufferView,
    isString: isString$1,
    isNumber: isNumber$1,
    isObject: isObject$1,
    isUndefined: isUndefined$1,
    isDate: isDate,
    isFile: isFile,
    isBlob: isBlob,
    isFunction: isFunction,
    isStream: isStream,
    isURLSearchParams: isURLSearchParams,
    isStandardBrowserEnv: isStandardBrowserEnv,
    forEach: forEach,
    merge: merge,
    deepMerge: deepMerge$1,
    extend: extend,
    trim: trim
  };

  function encode(val) {
    return encodeURIComponent(val).
      replace(/%40/gi, '@').
      replace(/%3A/gi, ':').
      replace(/%24/g, '$').
      replace(/%2C/gi, ',').
      replace(/%20/g, '+').
      replace(/%5B/gi, '[').
      replace(/%5D/gi, ']');
  }

  /**
   * Build a URL by appending params to the end
   *
   * @param {string} url The base of the url (e.g., http://www.google.com)
   * @param {object} [params] The params to be appended
   * @returns {string} The formatted url
   */
  var buildURL = function buildURL(url, params, paramsSerializer) {
    /*eslint no-param-reassign:0*/
    if (!params) {
      return url;
    }

    var serializedParams;
    if (paramsSerializer) {
      serializedParams = paramsSerializer(params);
    } else if (utils.isURLSearchParams(params)) {
      serializedParams = params.toString();
    } else {
      var parts = [];

      utils.forEach(params, function serialize(val, key) {
        if (val === null || typeof val === 'undefined') {
          return;
        }

        if (utils.isArray(val)) {
          key = key + '[]';
        } else {
          val = [val];
        }

        utils.forEach(val, function parseValue(v) {
          if (utils.isDate(v)) {
            v = v.toISOString();
          } else if (utils.isObject(v)) {
            v = JSON.stringify(v);
          }
          parts.push(encode(key) + '=' + encode(v));
        });
      });

      serializedParams = parts.join('&');
    }

    if (serializedParams) {
      var hashmarkIndex = url.indexOf('#');
      if (hashmarkIndex !== -1) {
        url = url.slice(0, hashmarkIndex);
      }

      url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
    }

    return url;
  };

  function InterceptorManager() {
    this.handlers = [];
  }

  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  InterceptorManager.prototype.use = function use(fulfilled, rejected) {
    this.handlers.push({
      fulfilled: fulfilled,
      rejected: rejected
    });
    return this.handlers.length - 1;
  };

  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   */
  InterceptorManager.prototype.eject = function eject(id) {
    if (this.handlers[id]) {
      this.handlers[id] = null;
    }
  };

  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   */
  InterceptorManager.prototype.forEach = function forEach(fn) {
    utils.forEach(this.handlers, function forEachHandler(h) {
      if (h !== null) {
        fn(h);
      }
    });
  };

  var InterceptorManager_1 = InterceptorManager;

  /**
   * Transform the data for a request or a response
   *
   * @param {Object|String} data The data to be transformed
   * @param {Array} headers The headers for the request or response
   * @param {Array|Function} fns A single function or Array of functions
   * @returns {*} The resulting transformed data
   */
  var transformData = function transformData(data, headers, fns) {
    /*eslint no-param-reassign:0*/
    utils.forEach(fns, function transform(fn) {
      data = fn(data, headers);
    });

    return data;
  };

  var isCancel = function isCancel(value) {
    return !!(value && value.__CANCEL__);
  };

  // shim for using process in browser
  // based off https://github.com/defunctzombie/node-process/blob/master/browser.js

  function defaultSetTimout() {
      throw new Error('setTimeout has not been defined');
  }
  function defaultClearTimeout () {
      throw new Error('clearTimeout has not been defined');
  }
  var cachedSetTimeout = defaultSetTimout;
  var cachedClearTimeout = defaultClearTimeout;
  if (typeof global$1.setTimeout === 'function') {
      cachedSetTimeout = setTimeout;
  }
  if (typeof global$1.clearTimeout === 'function') {
      cachedClearTimeout = clearTimeout;
  }

  function runTimeout(fun) {
      if (cachedSetTimeout === setTimeout) {
          //normal enviroments in sane situations
          return setTimeout(fun, 0);
      }
      // if setTimeout wasn't available but was latter defined
      if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
          cachedSetTimeout = setTimeout;
          return setTimeout(fun, 0);
      }
      try {
          // when when somebody has screwed with setTimeout but no I.E. maddness
          return cachedSetTimeout(fun, 0);
      } catch(e){
          try {
              // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
              return cachedSetTimeout.call(null, fun, 0);
          } catch(e){
              // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
              return cachedSetTimeout.call(this, fun, 0);
          }
      }


  }
  function runClearTimeout(marker) {
      if (cachedClearTimeout === clearTimeout) {
          //normal enviroments in sane situations
          return clearTimeout(marker);
      }
      // if clearTimeout wasn't available but was latter defined
      if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
          cachedClearTimeout = clearTimeout;
          return clearTimeout(marker);
      }
      try {
          // when when somebody has screwed with setTimeout but no I.E. maddness
          return cachedClearTimeout(marker);
      } catch (e){
          try {
              // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
              return cachedClearTimeout.call(null, marker);
          } catch (e){
              // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
              // Some versions of I.E. have different rules for clearTimeout vs setTimeout
              return cachedClearTimeout.call(this, marker);
          }
      }



  }
  var queue = [];
  var draining = false;
  var currentQueue;
  var queueIndex = -1;

  function cleanUpNextTick() {
      if (!draining || !currentQueue) {
          return;
      }
      draining = false;
      if (currentQueue.length) {
          queue = currentQueue.concat(queue);
      } else {
          queueIndex = -1;
      }
      if (queue.length) {
          drainQueue();
      }
  }

  function drainQueue() {
      if (draining) {
          return;
      }
      var timeout = runTimeout(cleanUpNextTick);
      draining = true;

      var len = queue.length;
      while(len) {
          currentQueue = queue;
          queue = [];
          while (++queueIndex < len) {
              if (currentQueue) {
                  currentQueue[queueIndex].run();
              }
          }
          queueIndex = -1;
          len = queue.length;
      }
      currentQueue = null;
      draining = false;
      runClearTimeout(timeout);
  }
  function nextTick(fun) {
      var args = new Array(arguments.length - 1);
      if (arguments.length > 1) {
          for (var i = 1; i < arguments.length; i++) {
              args[i - 1] = arguments[i];
          }
      }
      queue.push(new Item(fun, args));
      if (queue.length === 1 && !draining) {
          runTimeout(drainQueue);
      }
  }
  // v8 likes predictible objects
  function Item(fun, array) {
      this.fun = fun;
      this.array = array;
  }
  Item.prototype.run = function () {
      this.fun.apply(null, this.array);
  };
  var title = 'browser';
  var platform = 'browser';
  var browser = true;
  var env = {};
  var argv = [];
  var version$1 = ''; // empty string to avoid regexp issues
  var versions = {};
  var release = {};
  var config = {};

  function noop$1() {}

  var on = noop$1;
  var addListener = noop$1;
  var once = noop$1;
  var off = noop$1;
  var removeListener = noop$1;
  var removeAllListeners = noop$1;
  var emit = noop$1;

  function binding(name) {
      throw new Error('process.binding is not supported');
  }

  function cwd () { return '/' }
  function chdir (dir) {
      throw new Error('process.chdir is not supported');
  }function umask() { return 0; }

  // from https://github.com/kumavis/browser-process-hrtime/blob/master/index.js
  var performance = global$1.performance || {};
  var performanceNow =
    performance.now        ||
    performance.mozNow     ||
    performance.msNow      ||
    performance.oNow       ||
    performance.webkitNow  ||
    function(){ return (new Date()).getTime() };

  // generate timestamp or delta
  // see http://nodejs.org/api/process.html#process_process_hrtime
  function hrtime(previousTimestamp){
    var clocktime = performanceNow.call(performance)*1e-3;
    var seconds = Math.floor(clocktime);
    var nanoseconds = Math.floor((clocktime%1)*1e9);
    if (previousTimestamp) {
      seconds = seconds - previousTimestamp[0];
      nanoseconds = nanoseconds - previousTimestamp[1];
      if (nanoseconds<0) {
        seconds--;
        nanoseconds += 1e9;
      }
    }
    return [seconds,nanoseconds]
  }

  var startTime = new Date();
  function uptime() {
    var currentTime = new Date();
    var dif = currentTime - startTime;
    return dif / 1000;
  }

  var process = {
    nextTick: nextTick,
    title: title,
    browser: browser,
    env: env,
    argv: argv,
    version: version$1,
    versions: versions,
    on: on,
    addListener: addListener,
    once: once,
    off: off,
    removeListener: removeListener,
    removeAllListeners: removeAllListeners,
    emit: emit,
    binding: binding,
    cwd: cwd,
    chdir: chdir,
    umask: umask,
    hrtime: hrtime,
    platform: platform,
    release: release,
    config: config,
    uptime: uptime
  };

  var normalizeHeaderName = function normalizeHeaderName(headers, normalizedName) {
    utils.forEach(headers, function processHeader(value, name) {
      if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
        headers[normalizedName] = value;
        delete headers[name];
      }
    });
  };

  /**
   * Update an Error with the specified config, error code, and response.
   *
   * @param {Error} error The error to update.
   * @param {Object} config The config.
   * @param {string} [code] The error code (for example, 'ECONNABORTED').
   * @param {Object} [request] The request.
   * @param {Object} [response] The response.
   * @returns {Error} The error.
   */
  var enhanceError = function enhanceError(error, config, code, request, response) {
    error.config = config;
    if (code) {
      error.code = code;
    }

    error.request = request;
    error.response = response;
    error.isAxiosError = true;

    error.toJSON = function() {
      return {
        // Standard
        message: this.message,
        name: this.name,
        // Microsoft
        description: this.description,
        number: this.number,
        // Mozilla
        fileName: this.fileName,
        lineNumber: this.lineNumber,
        columnNumber: this.columnNumber,
        stack: this.stack,
        // Axios
        config: this.config,
        code: this.code
      };
    };
    return error;
  };

  /**
   * Create an Error with the specified message, config, error code, request and response.
   *
   * @param {string} message The error message.
   * @param {Object} config The config.
   * @param {string} [code] The error code (for example, 'ECONNABORTED').
   * @param {Object} [request] The request.
   * @param {Object} [response] The response.
   * @returns {Error} The created error.
   */
  var createError = function createError(message, config, code, request, response) {
    var error = new Error(message);
    return enhanceError(error, config, code, request, response);
  };

  /**
   * Resolve or reject a Promise based on response status.
   *
   * @param {Function} resolve A function that resolves the promise.
   * @param {Function} reject A function that rejects the promise.
   * @param {object} response The response.
   */
  var settle = function settle(resolve, reject, response) {
    var validateStatus = response.config.validateStatus;
    if (!validateStatus || validateStatus(response.status)) {
      resolve(response);
    } else {
      reject(createError(
        'Request failed with status code ' + response.status,
        response.config,
        null,
        response.request,
        response
      ));
    }
  };

  // Headers whose duplicates are ignored by node
  // c.f. https://nodejs.org/api/http.html#http_message_headers
  var ignoreDuplicateOf = [
    'age', 'authorization', 'content-length', 'content-type', 'etag',
    'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
    'last-modified', 'location', 'max-forwards', 'proxy-authorization',
    'referer', 'retry-after', 'user-agent'
  ];

  /**
   * Parse headers into an object
   *
   * ```
   * Date: Wed, 27 Aug 2014 08:58:49 GMT
   * Content-Type: application/json
   * Connection: keep-alive
   * Transfer-Encoding: chunked
   * ```
   *
   * @param {String} headers Headers needing to be parsed
   * @returns {Object} Headers parsed into an object
   */
  var parseHeaders = function parseHeaders(headers) {
    var parsed = {};
    var key;
    var val;
    var i;

    if (!headers) { return parsed; }

    utils.forEach(headers.split('\n'), function parser(line) {
      i = line.indexOf(':');
      key = utils.trim(line.substr(0, i)).toLowerCase();
      val = utils.trim(line.substr(i + 1));

      if (key) {
        if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
          return;
        }
        if (key === 'set-cookie') {
          parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
        } else {
          parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
        }
      }
    });

    return parsed;
  };

  var isURLSameOrigin = (
    utils.isStandardBrowserEnv() ?

    // Standard browser envs have full support of the APIs needed to test
    // whether the request URL is of the same origin as current location.
      (function standardBrowserEnv() {
        var msie = /(msie|trident)/i.test(navigator.userAgent);
        var urlParsingNode = document.createElement('a');
        var originURL;

        /**
      * Parse a URL to discover it's components
      *
      * @param {String} url The URL to be parsed
      * @returns {Object}
      */
        function resolveURL(url) {
          var href = url;

          if (msie) {
          // IE needs attribute set twice to normalize properties
            urlParsingNode.setAttribute('href', href);
            href = urlParsingNode.href;
          }

          urlParsingNode.setAttribute('href', href);

          // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
          return {
            href: urlParsingNode.href,
            protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
            host: urlParsingNode.host,
            search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
            hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
            hostname: urlParsingNode.hostname,
            port: urlParsingNode.port,
            pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
              urlParsingNode.pathname :
              '/' + urlParsingNode.pathname
          };
        }

        originURL = resolveURL(window.location.href);

        /**
      * Determine if a URL shares the same origin as the current location
      *
      * @param {String} requestURL The URL to test
      * @returns {boolean} True if URL shares the same origin, otherwise false
      */
        return function isURLSameOrigin(requestURL) {
          var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
          return (parsed.protocol === originURL.protocol &&
              parsed.host === originURL.host);
        };
      })() :

    // Non standard browser envs (web workers, react-native) lack needed support.
      (function nonStandardBrowserEnv() {
        return function isURLSameOrigin() {
          return true;
        };
      })()
  );

  var cookies = (
    utils.isStandardBrowserEnv() ?

    // Standard browser envs support document.cookie
      (function standardBrowserEnv() {
        return {
          write: function write(name, value, expires, path, domain, secure) {
            var cookie = [];
            cookie.push(name + '=' + encodeURIComponent(value));

            if (utils.isNumber(expires)) {
              cookie.push('expires=' + new Date(expires).toGMTString());
            }

            if (utils.isString(path)) {
              cookie.push('path=' + path);
            }

            if (utils.isString(domain)) {
              cookie.push('domain=' + domain);
            }

            if (secure === true) {
              cookie.push('secure');
            }

            document.cookie = cookie.join('; ');
          },

          read: function read(name) {
            var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
            return (match ? decodeURIComponent(match[3]) : null);
          },

          remove: function remove(name) {
            this.write(name, '', Date.now() - 86400000);
          }
        };
      })() :

    // Non standard browser env (web workers, react-native) lack needed support.
      (function nonStandardBrowserEnv() {
        return {
          write: function write() {},
          read: function read() { return null; },
          remove: function remove() {}
        };
      })()
  );

  var xhr = function xhrAdapter(config) {
    return new Promise(function dispatchXhrRequest(resolve, reject) {
      var requestData = config.data;
      var requestHeaders = config.headers;

      if (utils.isFormData(requestData)) {
        delete requestHeaders['Content-Type']; // Let the browser set it
      }

      var request = new XMLHttpRequest();

      // HTTP basic authentication
      if (config.auth) {
        var username = config.auth.username || '';
        var password = config.auth.password || '';
        requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
      }

      request.open(config.method.toUpperCase(), buildURL(config.url, config.params, config.paramsSerializer), true);

      // Set the request timeout in MS
      request.timeout = config.timeout;

      // Listen for ready state
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }

        // The request errored out and we didn't get a response, this will be
        // handled by onerror instead
        // With one exception: request that using file: protocol, most browsers
        // will return status as 0 even though it's a successful request
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
          return;
        }

        // Prepare the response
        var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
        var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;
        var response = {
          data: responseData,
          status: request.status,
          statusText: request.statusText,
          headers: responseHeaders,
          config: config,
          request: request
        };

        settle(resolve, reject, response);

        // Clean up request
        request = null;
      };

      // Handle browser request cancellation (as opposed to a manual cancellation)
      request.onabort = function handleAbort() {
        if (!request) {
          return;
        }

        reject(createError('Request aborted', config, 'ECONNABORTED', request));

        // Clean up request
        request = null;
      };

      // Handle low level network errors
      request.onerror = function handleError() {
        // Real errors are hidden from us by the browser
        // onerror should only fire if it's a network error
        reject(createError('Network Error', config, null, request));

        // Clean up request
        request = null;
      };

      // Handle timeout
      request.ontimeout = function handleTimeout() {
        reject(createError('timeout of ' + config.timeout + 'ms exceeded', config, 'ECONNABORTED',
          request));

        // Clean up request
        request = null;
      };

      // Add xsrf header
      // This is only done if running in a standard browser environment.
      // Specifically not if we're in a web worker, or react-native.
      if (utils.isStandardBrowserEnv()) {
        var cookies$1 = cookies;

        // Add xsrf header
        var xsrfValue = (config.withCredentials || isURLSameOrigin(config.url)) && config.xsrfCookieName ?
          cookies$1.read(config.xsrfCookieName) :
          undefined;

        if (xsrfValue) {
          requestHeaders[config.xsrfHeaderName] = xsrfValue;
        }
      }

      // Add headers to the request
      if ('setRequestHeader' in request) {
        utils.forEach(requestHeaders, function setRequestHeader(val, key) {
          if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
            // Remove Content-Type if data is undefined
            delete requestHeaders[key];
          } else {
            // Otherwise add header to the request
            request.setRequestHeader(key, val);
          }
        });
      }

      // Add withCredentials to request if needed
      if (config.withCredentials) {
        request.withCredentials = true;
      }

      // Add responseType to request if needed
      if (config.responseType) {
        try {
          request.responseType = config.responseType;
        } catch (e) {
          // Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2.
          // But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function.
          if (config.responseType !== 'json') {
            throw e;
          }
        }
      }

      // Handle progress if needed
      if (typeof config.onDownloadProgress === 'function') {
        request.addEventListener('progress', config.onDownloadProgress);
      }

      // Not all browsers support upload events
      if (typeof config.onUploadProgress === 'function' && request.upload) {
        request.upload.addEventListener('progress', config.onUploadProgress);
      }

      if (config.cancelToken) {
        // Handle cancellation
        config.cancelToken.promise.then(function onCanceled(cancel) {
          if (!request) {
            return;
          }

          request.abort();
          reject(cancel);
          // Clean up request
          request = null;
        });
      }

      if (requestData === undefined) {
        requestData = null;
      }

      // Send the request
      request.send(requestData);
    });
  };

  var DEFAULT_CONTENT_TYPE = {
    'Content-Type': 'application/x-www-form-urlencoded'
  };

  function setContentTypeIfUnset(headers, value) {
    if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
      headers['Content-Type'] = value;
    }
  }

  function getDefaultAdapter() {
    var adapter;
    // Only Node.JS has a process variable that is of [[Class]] process
    if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {
      // For node use HTTP adapter
      adapter = xhr;
    } else if (typeof XMLHttpRequest !== 'undefined') {
      // For browsers use XHR adapter
      adapter = xhr;
    }
    return adapter;
  }

  var defaults = {
    adapter: getDefaultAdapter(),

    transformRequest: [function transformRequest(data, headers) {
      normalizeHeaderName(headers, 'Accept');
      normalizeHeaderName(headers, 'Content-Type');
      if (utils.isFormData(data) ||
        utils.isArrayBuffer(data) ||
        utils.isBuffer(data) ||
        utils.isStream(data) ||
        utils.isFile(data) ||
        utils.isBlob(data)
      ) {
        return data;
      }
      if (utils.isArrayBufferView(data)) {
        return data.buffer;
      }
      if (utils.isURLSearchParams(data)) {
        setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
        return data.toString();
      }
      if (utils.isObject(data)) {
        setContentTypeIfUnset(headers, 'application/json;charset=utf-8');
        return JSON.stringify(data);
      }
      return data;
    }],

    transformResponse: [function transformResponse(data) {
      /*eslint no-param-reassign:0*/
      if (typeof data === 'string') {
        try {
          data = JSON.parse(data);
        } catch (e) { /* Ignore */ }
      }
      return data;
    }],

    /**
     * A timeout in milliseconds to abort a request. If set to 0 (default) a
     * timeout is not created.
     */
    timeout: 0,

    xsrfCookieName: 'XSRF-TOKEN',
    xsrfHeaderName: 'X-XSRF-TOKEN',

    maxContentLength: -1,

    validateStatus: function validateStatus(status) {
      return status >= 200 && status < 300;
    }
  };

  defaults.headers = {
    common: {
      'Accept': 'application/json, text/plain, */*'
    }
  };

  utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
    defaults.headers[method] = {};
  });

  utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
    defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
  });

  var defaults_1 = defaults;

  /**
   * Determines whether the specified URL is absolute
   *
   * @param {string} url The URL to test
   * @returns {boolean} True if the specified URL is absolute, otherwise false
   */
  var isAbsoluteURL = function isAbsoluteURL(url) {
    // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
    // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
    // by any combination of letters, digits, plus, period, or hyphen.
    return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
  };

  /**
   * Creates a new URL by combining the specified URLs
   *
   * @param {string} baseURL The base URL
   * @param {string} relativeURL The relative URL
   * @returns {string} The combined URL
   */
  var combineURLs = function combineURLs(baseURL, relativeURL) {
    return relativeURL
      ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '')
      : baseURL;
  };

  /**
   * Throws a `Cancel` if cancellation has been requested.
   */
  function throwIfCancellationRequested(config) {
    if (config.cancelToken) {
      config.cancelToken.throwIfRequested();
    }
  }

  /**
   * Dispatch a request to the server using the configured adapter.
   *
   * @param {object} config The config that is to be used for the request
   * @returns {Promise} The Promise to be fulfilled
   */
  var dispatchRequest = function dispatchRequest(config) {
    throwIfCancellationRequested(config);

    // Support baseURL config
    if (config.baseURL && !isAbsoluteURL(config.url)) {
      config.url = combineURLs(config.baseURL, config.url);
    }

    // Ensure headers exist
    config.headers = config.headers || {};

    // Transform request data
    config.data = transformData(
      config.data,
      config.headers,
      config.transformRequest
    );

    // Flatten headers
    config.headers = utils.merge(
      config.headers.common || {},
      config.headers[config.method] || {},
      config.headers || {}
    );

    utils.forEach(
      ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
      function cleanHeaderConfig(method) {
        delete config.headers[method];
      }
    );

    var adapter = config.adapter || defaults_1.adapter;

    return adapter(config).then(function onAdapterResolution(response) {
      throwIfCancellationRequested(config);

      // Transform response data
      response.data = transformData(
        response.data,
        response.headers,
        config.transformResponse
      );

      return response;
    }, function onAdapterRejection(reason) {
      if (!isCancel(reason)) {
        throwIfCancellationRequested(config);

        // Transform response data
        if (reason && reason.response) {
          reason.response.data = transformData(
            reason.response.data,
            reason.response.headers,
            config.transformResponse
          );
        }
      }

      return Promise.reject(reason);
    });
  };

  /**
   * Config-specific merge-function which creates a new config-object
   * by merging two configuration objects together.
   *
   * @param {Object} config1
   * @param {Object} config2
   * @returns {Object} New object resulting from merging config2 to config1
   */
  var mergeConfig = function mergeConfig(config1, config2) {
    // eslint-disable-next-line no-param-reassign
    config2 = config2 || {};
    var config = {};

    utils.forEach(['url', 'method', 'params', 'data'], function valueFromConfig2(prop) {
      if (typeof config2[prop] !== 'undefined') {
        config[prop] = config2[prop];
      }
    });

    utils.forEach(['headers', 'auth', 'proxy'], function mergeDeepProperties(prop) {
      if (utils.isObject(config2[prop])) {
        config[prop] = utils.deepMerge(config1[prop], config2[prop]);
      } else if (typeof config2[prop] !== 'undefined') {
        config[prop] = config2[prop];
      } else if (utils.isObject(config1[prop])) {
        config[prop] = utils.deepMerge(config1[prop]);
      } else if (typeof config1[prop] !== 'undefined') {
        config[prop] = config1[prop];
      }
    });

    utils.forEach([
      'baseURL', 'transformRequest', 'transformResponse', 'paramsSerializer',
      'timeout', 'withCredentials', 'adapter', 'responseType', 'xsrfCookieName',
      'xsrfHeaderName', 'onUploadProgress', 'onDownloadProgress', 'maxContentLength',
      'validateStatus', 'maxRedirects', 'httpAgent', 'httpsAgent', 'cancelToken',
      'socketPath'
    ], function defaultToConfig2(prop) {
      if (typeof config2[prop] !== 'undefined') {
        config[prop] = config2[prop];
      } else if (typeof config1[prop] !== 'undefined') {
        config[prop] = config1[prop];
      }
    });

    return config;
  };

  /**
   * Create a new instance of Axios
   *
   * @param {Object} instanceConfig The default config for the instance
   */
  function Axios(instanceConfig) {
    this.defaults = instanceConfig;
    this.interceptors = {
      request: new InterceptorManager_1(),
      response: new InterceptorManager_1()
    };
  }

  /**
   * Dispatch a request
   *
   * @param {Object} config The config specific for this request (merged with this.defaults)
   */
  Axios.prototype.request = function request(config) {
    /*eslint no-param-reassign:0*/
    // Allow for axios('example/url'[, config]) a la fetch API
    if (typeof config === 'string') {
      config = arguments[1] || {};
      config.url = arguments[0];
    } else {
      config = config || {};
    }

    config = mergeConfig(this.defaults, config);
    config.method = config.method ? config.method.toLowerCase() : 'get';

    // Hook up interceptors middleware
    var chain = [dispatchRequest, undefined];
    var promise = Promise.resolve(config);

    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      chain.unshift(interceptor.fulfilled, interceptor.rejected);
    });

    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      chain.push(interceptor.fulfilled, interceptor.rejected);
    });

    while (chain.length) {
      promise = promise.then(chain.shift(), chain.shift());
    }

    return promise;
  };

  Axios.prototype.getUri = function getUri(config) {
    config = mergeConfig(this.defaults, config);
    return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, '');
  };

  // Provide aliases for supported request methods
  utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
    /*eslint func-names:0*/
    Axios.prototype[method] = function(url, config) {
      return this.request(utils.merge(config || {}, {
        method: method,
        url: url
      }));
    };
  });

  utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
    /*eslint func-names:0*/
    Axios.prototype[method] = function(url, data, config) {
      return this.request(utils.merge(config || {}, {
        method: method,
        url: url,
        data: data
      }));
    };
  });

  var Axios_1 = Axios;

  /**
   * A `Cancel` is an object that is thrown when an operation is canceled.
   *
   * @class
   * @param {string=} message The message.
   */
  function Cancel(message) {
    this.message = message;
  }

  Cancel.prototype.toString = function toString() {
    return 'Cancel' + (this.message ? ': ' + this.message : '');
  };

  Cancel.prototype.__CANCEL__ = true;

  var Cancel_1 = Cancel;

  /**
   * A `CancelToken` is an object that can be used to request cancellation of an operation.
   *
   * @class
   * @param {Function} executor The executor function.
   */
  function CancelToken(executor) {
    if (typeof executor !== 'function') {
      throw new TypeError('executor must be a function.');
    }

    var resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve) {
      resolvePromise = resolve;
    });

    var token = this;
    executor(function cancel(message) {
      if (token.reason) {
        // Cancellation has already been requested
        return;
      }

      token.reason = new Cancel_1(message);
      resolvePromise(token.reason);
    });
  }

  /**
   * Throws a `Cancel` if cancellation has been requested.
   */
  CancelToken.prototype.throwIfRequested = function throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  };

  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  CancelToken.source = function source() {
    var cancel;
    var token = new CancelToken(function executor(c) {
      cancel = c;
    });
    return {
      token: token,
      cancel: cancel
    };
  };

  var CancelToken_1 = CancelToken;

  /**
   * Syntactic sugar for invoking a function and expanding an array for arguments.
   *
   * Common use case would be to use `Function.prototype.apply`.
   *
   *  ```js
   *  function f(x, y, z) {}
   *  var args = [1, 2, 3];
   *  f.apply(null, args);
   *  ```
   *
   * With `spread` this example can be re-written.
   *
   *  ```js
   *  spread(function(x, y, z) {})([1, 2, 3]);
   *  ```
   *
   * @param {Function} callback
   * @returns {Function}
   */
  var spread = function spread(callback) {
    return function wrap(arr) {
      return callback.apply(null, arr);
    };
  };

  /**
   * Create an instance of Axios
   *
   * @param {Object} defaultConfig The default config for the instance
   * @return {Axios} A new instance of Axios
   */
  function createInstance(defaultConfig) {
    var context = new Axios_1(defaultConfig);
    var instance = bind(Axios_1.prototype.request, context);

    // Copy axios.prototype to instance
    utils.extend(instance, Axios_1.prototype, context);

    // Copy context to instance
    utils.extend(instance, context);

    return instance;
  }

  // Create the default instance to be exported
  var axios = createInstance(defaults_1);

  // Expose Axios class to allow class inheritance
  axios.Axios = Axios_1;

  // Factory for creating new instances
  axios.create = function create(instanceConfig) {
    return createInstance(mergeConfig(axios.defaults, instanceConfig));
  };

  // Expose Cancel & CancelToken
  axios.Cancel = Cancel_1;
  axios.CancelToken = CancelToken_1;
  axios.isCancel = isCancel;

  // Expose all/spread
  axios.all = function all(promises) {
    return Promise.all(promises);
  };
  axios.spread = spread;

  var axios_1 = axios;

  // Allow use of default import syntax in TypeScript
  var default_1 = axios;
  axios_1.default = default_1;

  var axios$1 = axios_1;

  var IMAxios = axios$1.create({
    timeout: 6000,
    headers: {
      'Content-Type': 'application/x-www-form-urlencoded;charset=UTF-8'
    }
  }); //IMAxios.defaults.withCredentials = true; // - 暂时不打开 ， 服务端还不支持 `Access-Controller-Allow-Credentials`

  IMAxios.interceptors.response.use(function (response) {
    var _response$data = response.data,
        error_code = _response$data.error_code,
        ErrorCode = _response$data.ErrorCode; // 气人，有两种errorCode 名称…… fuck x 2

    var errorCode = ErrorCode;

    if (isNumber(error_code)) {
      errorCode = error_code;
    }

    if (errorCode != TIM_STATUS.REQUEST.SUCCESS) {
      response.data.ErrorCode = Number(errorCode); // 维持服务端错误码不变 qiaoyang
    }

    return response;
  }, function (error) {
    if (error.message === 'Network Error') {
      if (IMAxios.defaults.withCredentials === true) {
        logger.warn('Network Error, try to close `IMAxios.defaults.withCredentials` to false. (IMAxios.js)');
      }

      IMAxios.defaults.withCredentials = false;
    }

    return Promise.reject(error);
  });

  var ConnectionBase =
  /*#__PURE__*/
  function () {
    function ConnectionBase() {
      _classCallCheck(this, ConnectionBase);
    }

    _createClass(ConnectionBase, [{
      key: "request",

      /**
       * 提交异步请求
       * @param {String}options.url	string		是	开发者服务器接口地址
       * @param {Any}options.data	- string/object/ArrayBuffer		否	请求的参数
       * @param {Object}options.header	Object		否	设置请求的 header，
       * @param {String}options.method	string	GET	否	HTTP 请求方法
       * @param {String}options.dataType	string	json	否	返回的数据格式
       * @param {String}options.responseType	string	text	否	响应的数据类型
       * @param {Boolean}isRetry	string	text	false	是否为重试的请求
       */
      value: function request(options) {
        console.warn('请注意： ConnectionBase.request() 方法必须被派生类重写:');
        console.log("\u53C2\u6570\u5982\u4E0B\uFF1A\n    * @param {String}options.url\tstring\t\t\u662F\t\u5F00\u53D1\u8005\u670D\u52A1\u5668\u63A5\u53E3\u5730\u5740\t\n    * @param {Any}options.data\t- string/object/ArrayBuffer\t\t\u5426\t\u8BF7\u6C42\u7684\u53C2\u6570\t\n    * @param {Object}options.header\tObject\t\t\u5426\t\u8BBE\u7F6E\u8BF7\u6C42\u7684 header\uFF0C\n    * @param {String}options.method\tstring\tGET\t\u5426\tHTTP \u8BF7\u6C42\u65B9\u6CD5\t\n    * @param {String}options.dataType\tstring\tjson\t\u5426\t\u8FD4\u56DE\u7684\u6570\u636E\u683C\u5F0F\t\n    * @param {String}options.responseType\tstring\ttext\t\u5426\t\u54CD\u5E94\u7684\u6570\u636E\u7C7B\u578B\t\n    * @param {Boolean}isRetry\tstring\ttext\tfalse\t\u662F\u5426\u4E3A\u91CD\u8BD5\u7684\u8BF7\u6C42\t\n   ");
      }
    }, {
      key: "_checkOptions",
      value: function _checkOptions(options) {
        if (!!options.url === false) throw new IMError({
          code: ERROR_CODE.NETWORK_BASE_OPTIONS_NO_URL,
          message: ERROR_MESSAGE.NETWORK_BASE_OPTIONS_NO_URL
        });
      }
    }, {
      key: "_initOptions",
      value: function _initOptions(options) {
        options.method = ['POST', 'GET', 'PUT', 'DELETE', 'OPTION'].indexOf(options.method) >= 0 ? options.method : 'POST';
        options.dataType = options.dataType || 'json';
        options.responseType = options.responseType || 'json'; // options.header= {
        //   "Content-Type": "x-www-form-urlencoded"
        // };
      }
    }]);

    return ConnectionBase;
  }();

  /**
   * @uses 使用xhr发送网络请求
   * @name xhr
   */
  //@TODO 换成axios

  var XHR =
  /*#__PURE__*/
  function (_ConnectionBase) {
    _inherits(XHR, _ConnectionBase);

    function XHR() {
      var _this;

      _classCallCheck(this, XHR);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(XHR).call(this));
      _this.retry = 1;
      return _this;
    }
    /**
     * 提交异步请求
     * @param {object.<url:string,data:object,header:object,method:string,dataType:string,responseType:string,isRetry:boolean>} options - 请求参数
     * @property {String} url - 开发者服务器接口地址
     * @property {Any} data	- string/object/ArrayBuffer		否	请求的参数
     * @property {Object} header	Object		否	设置请求的 header，header 中不能设置 Referer。
     * @property {String} method	string	GET	否	HTTP 请求方法
     * @property {String} dataType	string	json	否	返回的数据格式
     * @property {String} responseType	string	text	否	响应的数据类型	1.7.0
     */


    _createClass(XHR, [{
      key: "request",
      value: function request(options) {
        this._checkOptions(options);

        this._initOptions(options);

        return this._requestWithRetry({
          url: options.url,
          data: options.data,
          method: options.method
        });
      }
    }, {
      key: "_requestWithRetry",
      value: function _requestWithRetry(options) {
        var _this2 = this;

        var retryCount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        return IMAxios(options)["catch"](function (error) {
          if (_this2.retry && retryCount < _this2.retry) {
            return _this2._requestWithRetry(options, ++retryCount);
          }

          return IMPromise.reject(error);
        });
      }
    }]);

    return XHR;
  }(ConnectionBase);

  var lookup = [];
  var revLookup = [];
  var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
  var inited = false;
  function init () {
    inited = true;
    var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
    for (var i = 0, len = code.length; i < len; ++i) {
      lookup[i] = code[i];
      revLookup[code.charCodeAt(i)] = i;
    }

    revLookup['-'.charCodeAt(0)] = 62;
    revLookup['_'.charCodeAt(0)] = 63;
  }

  function toByteArray (b64) {
    if (!inited) {
      init();
    }
    var i, j, l, tmp, placeHolders, arr;
    var len = b64.length;

    if (len % 4 > 0) {
      throw new Error('Invalid string. Length must be a multiple of 4')
    }

    // the number of equal signs (place holders)
    // if there are two placeholders, than the two characters before it
    // represent one byte
    // if there is only one, then the three characters before it represent 2 bytes
    // this is just a cheap hack to not do indexOf twice
    placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;

    // base64 is 4/3 + up to two characters of the original data
    arr = new Arr(len * 3 / 4 - placeHolders);

    // if there are placeholders, only get up to the last complete 4 chars
    l = placeHolders > 0 ? len - 4 : len;

    var L = 0;

    for (i = 0, j = 0; i < l; i += 4, j += 3) {
      tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)];
      arr[L++] = (tmp >> 16) & 0xFF;
      arr[L++] = (tmp >> 8) & 0xFF;
      arr[L++] = tmp & 0xFF;
    }

    if (placeHolders === 2) {
      tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4);
      arr[L++] = tmp & 0xFF;
    } else if (placeHolders === 1) {
      tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2);
      arr[L++] = (tmp >> 8) & 0xFF;
      arr[L++] = tmp & 0xFF;
    }

    return arr
  }

  function tripletToBase64 (num) {
    return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
  }

  function encodeChunk (uint8, start, end) {
    var tmp;
    var output = [];
    for (var i = start; i < end; i += 3) {
      tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);
      output.push(tripletToBase64(tmp));
    }
    return output.join('')
  }

  function fromByteArray (uint8) {
    if (!inited) {
      init();
    }
    var tmp;
    var len = uint8.length;
    var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
    var output = '';
    var parts = [];
    var maxChunkLength = 16383; // must be multiple of 3

    // go through the array every three bytes, we'll deal with trailing stuff later
    for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
      parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)));
    }

    // pad the end with zeros, but make sure to not forget the extra bytes
    if (extraBytes === 1) {
      tmp = uint8[len - 1];
      output += lookup[tmp >> 2];
      output += lookup[(tmp << 4) & 0x3F];
      output += '==';
    } else if (extraBytes === 2) {
      tmp = (uint8[len - 2] << 8) + (uint8[len - 1]);
      output += lookup[tmp >> 10];
      output += lookup[(tmp >> 4) & 0x3F];
      output += lookup[(tmp << 2) & 0x3F];
      output += '=';
    }

    parts.push(output);

    return parts.join('')
  }

  function read (buffer, offset, isLE, mLen, nBytes) {
    var e, m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? (nBytes - 1) : 0;
    var d = isLE ? -1 : 1;
    var s = buffer[offset + i];

    i += d;

    e = s & ((1 << (-nBits)) - 1);
    s >>= (-nBits);
    nBits += eLen;
    for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

    m = e & ((1 << (-nBits)) - 1);
    e >>= (-nBits);
    nBits += mLen;
    for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

    if (e === 0) {
      e = 1 - eBias;
    } else if (e === eMax) {
      return m ? NaN : ((s ? -1 : 1) * Infinity)
    } else {
      m = m + Math.pow(2, mLen);
      e = e - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
  }

  function write (buffer, value, offset, isLE, mLen, nBytes) {
    var e, m, c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);
    var i = isLE ? 0 : (nBytes - 1);
    var d = isLE ? 1 : -1;
    var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

    value = Math.abs(value);

    if (isNaN(value) || value === Infinity) {
      m = isNaN(value) ? 1 : 0;
      e = eMax;
    } else {
      e = Math.floor(Math.log(value) / Math.LN2);
      if (value * (c = Math.pow(2, -e)) < 1) {
        e--;
        c *= 2;
      }
      if (e + eBias >= 1) {
        value += rt / c;
      } else {
        value += rt * Math.pow(2, 1 - eBias);
      }
      if (value * c >= 2) {
        e++;
        c /= 2;
      }

      if (e + eBias >= eMax) {
        m = 0;
        e = eMax;
      } else if (e + eBias >= 1) {
        m = (value * c - 1) * Math.pow(2, mLen);
        e = e + eBias;
      } else {
        m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
        e = 0;
      }
    }

    for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

    e = (e << mLen) | m;
    eLen += mLen;
    for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

    buffer[offset + i - d] |= s * 128;
  }

  var toString$2 = {}.toString;

  var isArray$2 = Array.isArray || function (arr) {
    return toString$2.call(arr) == '[object Array]';
  };

  var INSPECT_MAX_BYTES = 50;

  /**
   * If `Buffer.TYPED_ARRAY_SUPPORT`:
   *   === true    Use Uint8Array implementation (fastest)
   *   === false   Use Object implementation (most compatible, even IE6)
   *
   * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
   * Opera 11.6+, iOS 4.2+.
   *
   * Due to various browser bugs, sometimes the Object implementation will be used even
   * when the browser supports typed arrays.
   *
   * Note:
   *
   *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
   *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
   *
   *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
   *
   *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
   *     incorrect length in some situations.

   * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
   * get the Object implementation, which is slower but behaves correctly.
   */
  Buffer.TYPED_ARRAY_SUPPORT = global$1.TYPED_ARRAY_SUPPORT !== undefined
    ? global$1.TYPED_ARRAY_SUPPORT
    : true;

  function kMaxLength () {
    return Buffer.TYPED_ARRAY_SUPPORT
      ? 0x7fffffff
      : 0x3fffffff
  }

  function createBuffer (that, length) {
    if (kMaxLength() < length) {
      throw new RangeError('Invalid typed array length')
    }
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      // Return an augmented `Uint8Array` instance, for best performance
      that = new Uint8Array(length);
      that.__proto__ = Buffer.prototype;
    } else {
      // Fallback: Return an object instance of the Buffer class
      if (that === null) {
        that = new Buffer(length);
      }
      that.length = length;
    }

    return that
  }

  /**
   * The Buffer constructor returns instances of `Uint8Array` that have their
   * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
   * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
   * and the `Uint8Array` methods. Square bracket notation works as expected -- it
   * returns a single octet.
   *
   * The `Uint8Array` prototype remains unmodified.
   */

  function Buffer (arg, encodingOrOffset, length) {
    if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
      return new Buffer(arg, encodingOrOffset, length)
    }

    // Common case.
    if (typeof arg === 'number') {
      if (typeof encodingOrOffset === 'string') {
        throw new Error(
          'If encoding is specified then the first argument must be a string'
        )
      }
      return allocUnsafe(this, arg)
    }
    return from(this, arg, encodingOrOffset, length)
  }

  Buffer.poolSize = 8192; // not used by this implementation

  // TODO: Legacy, not needed anymore. Remove in next major version.
  Buffer._augment = function (arr) {
    arr.__proto__ = Buffer.prototype;
    return arr
  };

  function from (that, value, encodingOrOffset, length) {
    if (typeof value === 'number') {
      throw new TypeError('"value" argument must not be a number')
    }

    if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
      return fromArrayBuffer(that, value, encodingOrOffset, length)
    }

    if (typeof value === 'string') {
      return fromString(that, value, encodingOrOffset)
    }

    return fromObject(that, value)
  }

  /**
   * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
   * if value is a number.
   * Buffer.from(str[, encoding])
   * Buffer.from(array)
   * Buffer.from(buffer)
   * Buffer.from(arrayBuffer[, byteOffset[, length]])
   **/
  Buffer.from = function (value, encodingOrOffset, length) {
    return from(null, value, encodingOrOffset, length)
  };

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    Buffer.prototype.__proto__ = Uint8Array.prototype;
    Buffer.__proto__ = Uint8Array;
  }

  function assertSize (size) {
    if (typeof size !== 'number') {
      throw new TypeError('"size" argument must be a number')
    } else if (size < 0) {
      throw new RangeError('"size" argument must not be negative')
    }
  }

  function alloc (that, size, fill, encoding) {
    assertSize(size);
    if (size <= 0) {
      return createBuffer(that, size)
    }
    if (fill !== undefined) {
      // Only pay attention to encoding if it's a string. This
      // prevents accidentally sending in a number that would
      // be interpretted as a start offset.
      return typeof encoding === 'string'
        ? createBuffer(that, size).fill(fill, encoding)
        : createBuffer(that, size).fill(fill)
    }
    return createBuffer(that, size)
  }

  /**
   * Creates a new filled Buffer instance.
   * alloc(size[, fill[, encoding]])
   **/
  Buffer.alloc = function (size, fill, encoding) {
    return alloc(null, size, fill, encoding)
  };

  function allocUnsafe (that, size) {
    assertSize(size);
    that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
    if (!Buffer.TYPED_ARRAY_SUPPORT) {
      for (var i = 0; i < size; ++i) {
        that[i] = 0;
      }
    }
    return that
  }

  /**
   * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
   * */
  Buffer.allocUnsafe = function (size) {
    return allocUnsafe(null, size)
  };
  /**
   * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
   */
  Buffer.allocUnsafeSlow = function (size) {
    return allocUnsafe(null, size)
  };

  function fromString (that, string, encoding) {
    if (typeof encoding !== 'string' || encoding === '') {
      encoding = 'utf8';
    }

    if (!Buffer.isEncoding(encoding)) {
      throw new TypeError('"encoding" must be a valid string encoding')
    }

    var length = byteLength(string, encoding) | 0;
    that = createBuffer(that, length);

    var actual = that.write(string, encoding);

    if (actual !== length) {
      // Writing a hex string, for example, that contains invalid characters will
      // cause everything after the first invalid character to be ignored. (e.g.
      // 'abxxcd' will be treated as 'ab')
      that = that.slice(0, actual);
    }

    return that
  }

  function fromArrayLike (that, array) {
    var length = array.length < 0 ? 0 : checked(array.length) | 0;
    that = createBuffer(that, length);
    for (var i = 0; i < length; i += 1) {
      that[i] = array[i] & 255;
    }
    return that
  }

  function fromArrayBuffer (that, array, byteOffset, length) {
    array.byteLength; // this throws if `array` is not a valid ArrayBuffer

    if (byteOffset < 0 || array.byteLength < byteOffset) {
      throw new RangeError('\'offset\' is out of bounds')
    }

    if (array.byteLength < byteOffset + (length || 0)) {
      throw new RangeError('\'length\' is out of bounds')
    }

    if (byteOffset === undefined && length === undefined) {
      array = new Uint8Array(array);
    } else if (length === undefined) {
      array = new Uint8Array(array, byteOffset);
    } else {
      array = new Uint8Array(array, byteOffset, length);
    }

    if (Buffer.TYPED_ARRAY_SUPPORT) {
      // Return an augmented `Uint8Array` instance, for best performance
      that = array;
      that.__proto__ = Buffer.prototype;
    } else {
      // Fallback: Return an object instance of the Buffer class
      that = fromArrayLike(that, array);
    }
    return that
  }

  function fromObject (that, obj) {
    if (internalIsBuffer(obj)) {
      var len = checked(obj.length) | 0;
      that = createBuffer(that, len);

      if (that.length === 0) {
        return that
      }

      obj.copy(that, 0, 0, len);
      return that
    }

    if (obj) {
      if ((typeof ArrayBuffer !== 'undefined' &&
          obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
        if (typeof obj.length !== 'number' || isnan(obj.length)) {
          return createBuffer(that, 0)
        }
        return fromArrayLike(that, obj)
      }

      if (obj.type === 'Buffer' && isArray$2(obj.data)) {
        return fromArrayLike(that, obj.data)
      }
    }

    throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
  }

  function checked (length) {
    // Note: cannot use `length < kMaxLength()` here because that fails when
    // length is NaN (which is otherwise coerced to zero.)
    if (length >= kMaxLength()) {
      throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                           'size: 0x' + kMaxLength().toString(16) + ' bytes')
    }
    return length | 0
  }
  Buffer.isBuffer = isBuffer$1;
  function internalIsBuffer (b) {
    return !!(b != null && b._isBuffer)
  }

  Buffer.compare = function compare (a, b) {
    if (!internalIsBuffer(a) || !internalIsBuffer(b)) {
      throw new TypeError('Arguments must be Buffers')
    }

    if (a === b) return 0

    var x = a.length;
    var y = b.length;

    for (var i = 0, len = Math.min(x, y); i < len; ++i) {
      if (a[i] !== b[i]) {
        x = a[i];
        y = b[i];
        break
      }
    }

    if (x < y) return -1
    if (y < x) return 1
    return 0
  };

  Buffer.isEncoding = function isEncoding (encoding) {
    switch (String(encoding).toLowerCase()) {
      case 'hex':
      case 'utf8':
      case 'utf-8':
      case 'ascii':
      case 'latin1':
      case 'binary':
      case 'base64':
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return true
      default:
        return false
    }
  };

  Buffer.concat = function concat (list, length) {
    if (!isArray$2(list)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }

    if (list.length === 0) {
      return Buffer.alloc(0)
    }

    var i;
    if (length === undefined) {
      length = 0;
      for (i = 0; i < list.length; ++i) {
        length += list[i].length;
      }
    }

    var buffer = Buffer.allocUnsafe(length);
    var pos = 0;
    for (i = 0; i < list.length; ++i) {
      var buf = list[i];
      if (!internalIsBuffer(buf)) {
        throw new TypeError('"list" argument must be an Array of Buffers')
      }
      buf.copy(buffer, pos);
      pos += buf.length;
    }
    return buffer
  };

  function byteLength (string, encoding) {
    if (internalIsBuffer(string)) {
      return string.length
    }
    if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
        (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
      return string.byteLength
    }
    if (typeof string !== 'string') {
      string = '' + string;
    }

    var len = string.length;
    if (len === 0) return 0

    // Use a for loop to avoid recursion
    var loweredCase = false;
    for (;;) {
      switch (encoding) {
        case 'ascii':
        case 'latin1':
        case 'binary':
          return len
        case 'utf8':
        case 'utf-8':
        case undefined:
          return utf8ToBytes(string).length
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return len * 2
        case 'hex':
          return len >>> 1
        case 'base64':
          return base64ToBytes(string).length
        default:
          if (loweredCase) return utf8ToBytes(string).length // assume utf8
          encoding = ('' + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer.byteLength = byteLength;

  function slowToString (encoding, start, end) {
    var loweredCase = false;

    // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
    // property of a typed array.

    // This behaves neither like String nor Uint8Array in that we set start/end
    // to their upper/lower bounds if the value passed is out of range.
    // undefined is handled specially as per ECMA-262 6th Edition,
    // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
    if (start === undefined || start < 0) {
      start = 0;
    }
    // Return early if start > this.length. Done here to prevent potential uint32
    // coercion fail below.
    if (start > this.length) {
      return ''
    }

    if (end === undefined || end > this.length) {
      end = this.length;
    }

    if (end <= 0) {
      return ''
    }

    // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
    end >>>= 0;
    start >>>= 0;

    if (end <= start) {
      return ''
    }

    if (!encoding) encoding = 'utf8';

    while (true) {
      switch (encoding) {
        case 'hex':
          return hexSlice(this, start, end)

        case 'utf8':
        case 'utf-8':
          return utf8Slice(this, start, end)

        case 'ascii':
          return asciiSlice(this, start, end)

        case 'latin1':
        case 'binary':
          return latin1Slice(this, start, end)

        case 'base64':
          return base64Slice(this, start, end)

        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return utf16leSlice(this, start, end)

        default:
          if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
          encoding = (encoding + '').toLowerCase();
          loweredCase = true;
      }
    }
  }

  // The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
  // Buffer instances.
  Buffer.prototype._isBuffer = true;

  function swap (b, n, m) {
    var i = b[n];
    b[n] = b[m];
    b[m] = i;
  }

  Buffer.prototype.swap16 = function swap16 () {
    var len = this.length;
    if (len % 2 !== 0) {
      throw new RangeError('Buffer size must be a multiple of 16-bits')
    }
    for (var i = 0; i < len; i += 2) {
      swap(this, i, i + 1);
    }
    return this
  };

  Buffer.prototype.swap32 = function swap32 () {
    var len = this.length;
    if (len % 4 !== 0) {
      throw new RangeError('Buffer size must be a multiple of 32-bits')
    }
    for (var i = 0; i < len; i += 4) {
      swap(this, i, i + 3);
      swap(this, i + 1, i + 2);
    }
    return this
  };

  Buffer.prototype.swap64 = function swap64 () {
    var len = this.length;
    if (len % 8 !== 0) {
      throw new RangeError('Buffer size must be a multiple of 64-bits')
    }
    for (var i = 0; i < len; i += 8) {
      swap(this, i, i + 7);
      swap(this, i + 1, i + 6);
      swap(this, i + 2, i + 5);
      swap(this, i + 3, i + 4);
    }
    return this
  };

  Buffer.prototype.toString = function toString () {
    var length = this.length | 0;
    if (length === 0) return ''
    if (arguments.length === 0) return utf8Slice(this, 0, length)
    return slowToString.apply(this, arguments)
  };

  Buffer.prototype.equals = function equals (b) {
    if (!internalIsBuffer(b)) throw new TypeError('Argument must be a Buffer')
    if (this === b) return true
    return Buffer.compare(this, b) === 0
  };

  Buffer.prototype.inspect = function inspect () {
    var str = '';
    var max = INSPECT_MAX_BYTES;
    if (this.length > 0) {
      str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
      if (this.length > max) str += ' ... ';
    }
    return '<Buffer ' + str + '>'
  };

  Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
    if (!internalIsBuffer(target)) {
      throw new TypeError('Argument must be a Buffer')
    }

    if (start === undefined) {
      start = 0;
    }
    if (end === undefined) {
      end = target ? target.length : 0;
    }
    if (thisStart === undefined) {
      thisStart = 0;
    }
    if (thisEnd === undefined) {
      thisEnd = this.length;
    }

    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
      throw new RangeError('out of range index')
    }

    if (thisStart >= thisEnd && start >= end) {
      return 0
    }
    if (thisStart >= thisEnd) {
      return -1
    }
    if (start >= end) {
      return 1
    }

    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;

    if (this === target) return 0

    var x = thisEnd - thisStart;
    var y = end - start;
    var len = Math.min(x, y);

    var thisCopy = this.slice(thisStart, thisEnd);
    var targetCopy = target.slice(start, end);

    for (var i = 0; i < len; ++i) {
      if (thisCopy[i] !== targetCopy[i]) {
        x = thisCopy[i];
        y = targetCopy[i];
        break
      }
    }

    if (x < y) return -1
    if (y < x) return 1
    return 0
  };

  // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
  // OR the last index of `val` in `buffer` at offset <= `byteOffset`.
  //
  // Arguments:
  // - buffer - a Buffer to search
  // - val - a string, Buffer, or number
  // - byteOffset - an index into `buffer`; will be clamped to an int32
  // - encoding - an optional encoding, relevant is val is a string
  // - dir - true for indexOf, false for lastIndexOf
  function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
    // Empty buffer means no match
    if (buffer.length === 0) return -1

    // Normalize byteOffset
    if (typeof byteOffset === 'string') {
      encoding = byteOffset;
      byteOffset = 0;
    } else if (byteOffset > 0x7fffffff) {
      byteOffset = 0x7fffffff;
    } else if (byteOffset < -0x80000000) {
      byteOffset = -0x80000000;
    }
    byteOffset = +byteOffset;  // Coerce to Number.
    if (isNaN(byteOffset)) {
      // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
      byteOffset = dir ? 0 : (buffer.length - 1);
    }

    // Normalize byteOffset: negative offsets start from the end of the buffer
    if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
    if (byteOffset >= buffer.length) {
      if (dir) return -1
      else byteOffset = buffer.length - 1;
    } else if (byteOffset < 0) {
      if (dir) byteOffset = 0;
      else return -1
    }

    // Normalize val
    if (typeof val === 'string') {
      val = Buffer.from(val, encoding);
    }

    // Finally, search either indexOf (if dir is true) or lastIndexOf
    if (internalIsBuffer(val)) {
      // Special case: looking for empty string/buffer always fails
      if (val.length === 0) {
        return -1
      }
      return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
    } else if (typeof val === 'number') {
      val = val & 0xFF; // Search for a byte value [0-255]
      if (Buffer.TYPED_ARRAY_SUPPORT &&
          typeof Uint8Array.prototype.indexOf === 'function') {
        if (dir) {
          return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
        } else {
          return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
        }
      }
      return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
    }

    throw new TypeError('val must be string, number or Buffer')
  }

  function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
    var indexSize = 1;
    var arrLength = arr.length;
    var valLength = val.length;

    if (encoding !== undefined) {
      encoding = String(encoding).toLowerCase();
      if (encoding === 'ucs2' || encoding === 'ucs-2' ||
          encoding === 'utf16le' || encoding === 'utf-16le') {
        if (arr.length < 2 || val.length < 2) {
          return -1
        }
        indexSize = 2;
        arrLength /= 2;
        valLength /= 2;
        byteOffset /= 2;
      }
    }

    function read (buf, i) {
      if (indexSize === 1) {
        return buf[i]
      } else {
        return buf.readUInt16BE(i * indexSize)
      }
    }

    var i;
    if (dir) {
      var foundIndex = -1;
      for (i = byteOffset; i < arrLength; i++) {
        if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
          if (foundIndex === -1) foundIndex = i;
          if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
        } else {
          if (foundIndex !== -1) i -= i - foundIndex;
          foundIndex = -1;
        }
      }
    } else {
      if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
      for (i = byteOffset; i >= 0; i--) {
        var found = true;
        for (var j = 0; j < valLength; j++) {
          if (read(arr, i + j) !== read(val, j)) {
            found = false;
            break
          }
        }
        if (found) return i
      }
    }

    return -1
  }

  Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1
  };

  Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
  };

  Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
  };

  function hexWrite (buf, string, offset, length) {
    offset = Number(offset) || 0;
    var remaining = buf.length - offset;
    if (!length) {
      length = remaining;
    } else {
      length = Number(length);
      if (length > remaining) {
        length = remaining;
      }
    }

    // must be an even number of digits
    var strLen = string.length;
    if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

    if (length > strLen / 2) {
      length = strLen / 2;
    }
    for (var i = 0; i < length; ++i) {
      var parsed = parseInt(string.substr(i * 2, 2), 16);
      if (isNaN(parsed)) return i
      buf[offset + i] = parsed;
    }
    return i
  }

  function utf8Write (buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
  }

  function asciiWrite (buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length)
  }

  function latin1Write (buf, string, offset, length) {
    return asciiWrite(buf, string, offset, length)
  }

  function base64Write (buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length)
  }

  function ucs2Write (buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
  }

  Buffer.prototype.write = function write (string, offset, length, encoding) {
    // Buffer#write(string)
    if (offset === undefined) {
      encoding = 'utf8';
      length = this.length;
      offset = 0;
    // Buffer#write(string, encoding)
    } else if (length === undefined && typeof offset === 'string') {
      encoding = offset;
      length = this.length;
      offset = 0;
    // Buffer#write(string, offset[, length][, encoding])
    } else if (isFinite(offset)) {
      offset = offset | 0;
      if (isFinite(length)) {
        length = length | 0;
        if (encoding === undefined) encoding = 'utf8';
      } else {
        encoding = length;
        length = undefined;
      }
    // legacy write(string, encoding, offset, length) - remove in v0.13
    } else {
      throw new Error(
        'Buffer.write(string, encoding, offset[, length]) is no longer supported'
      )
    }

    var remaining = this.length - offset;
    if (length === undefined || length > remaining) length = remaining;

    if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
      throw new RangeError('Attempt to write outside buffer bounds')
    }

    if (!encoding) encoding = 'utf8';

    var loweredCase = false;
    for (;;) {
      switch (encoding) {
        case 'hex':
          return hexWrite(this, string, offset, length)

        case 'utf8':
        case 'utf-8':
          return utf8Write(this, string, offset, length)

        case 'ascii':
          return asciiWrite(this, string, offset, length)

        case 'latin1':
        case 'binary':
          return latin1Write(this, string, offset, length)

        case 'base64':
          // Warning: maxLength not taken into account in base64Write
          return base64Write(this, string, offset, length)

        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return ucs2Write(this, string, offset, length)

        default:
          if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
          encoding = ('' + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  };

  Buffer.prototype.toJSON = function toJSON () {
    return {
      type: 'Buffer',
      data: Array.prototype.slice.call(this._arr || this, 0)
    }
  };

  function base64Slice (buf, start, end) {
    if (start === 0 && end === buf.length) {
      return fromByteArray(buf)
    } else {
      return fromByteArray(buf.slice(start, end))
    }
  }

  function utf8Slice (buf, start, end) {
    end = Math.min(buf.length, end);
    var res = [];

    var i = start;
    while (i < end) {
      var firstByte = buf[i];
      var codePoint = null;
      var bytesPerSequence = (firstByte > 0xEF) ? 4
        : (firstByte > 0xDF) ? 3
        : (firstByte > 0xBF) ? 2
        : 1;

      if (i + bytesPerSequence <= end) {
        var secondByte, thirdByte, fourthByte, tempCodePoint;

        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 0x80) {
              codePoint = firstByte;
            }
            break
          case 2:
            secondByte = buf[i + 1];
            if ((secondByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);
              if (tempCodePoint > 0x7F) {
                codePoint = tempCodePoint;
              }
            }
            break
          case 3:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);
              if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                codePoint = tempCodePoint;
              }
            }
            break
          case 4:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            fourthByte = buf[i + 3];
            if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);
              if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                codePoint = tempCodePoint;
              }
            }
        }
      }

      if (codePoint === null) {
        // we did not generate a valid codePoint so insert a
        // replacement char (U+FFFD) and advance only 1 byte
        codePoint = 0xFFFD;
        bytesPerSequence = 1;
      } else if (codePoint > 0xFFFF) {
        // encode to utf16 (surrogate pair dance)
        codePoint -= 0x10000;
        res.push(codePoint >>> 10 & 0x3FF | 0xD800);
        codePoint = 0xDC00 | codePoint & 0x3FF;
      }

      res.push(codePoint);
      i += bytesPerSequence;
    }

    return decodeCodePointsArray(res)
  }

  // Based on http://stackoverflow.com/a/22747272/680742, the browser with
  // the lowest limit is Chrome, with 0x10000 args.
  // We go 1 magnitude less, for safety
  var MAX_ARGUMENTS_LENGTH = 0x1000;

  function decodeCodePointsArray (codePoints) {
    var len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
    }

    // Decode in chunks to avoid "call stack size exceeded".
    var res = '';
    var i = 0;
    while (i < len) {
      res += String.fromCharCode.apply(
        String,
        codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
      );
    }
    return res
  }

  function asciiSlice (buf, start, end) {
    var ret = '';
    end = Math.min(buf.length, end);

    for (var i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i] & 0x7F);
    }
    return ret
  }

  function latin1Slice (buf, start, end) {
    var ret = '';
    end = Math.min(buf.length, end);

    for (var i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i]);
    }
    return ret
  }

  function hexSlice (buf, start, end) {
    var len = buf.length;

    if (!start || start < 0) start = 0;
    if (!end || end < 0 || end > len) end = len;

    var out = '';
    for (var i = start; i < end; ++i) {
      out += toHex(buf[i]);
    }
    return out
  }

  function utf16leSlice (buf, start, end) {
    var bytes = buf.slice(start, end);
    var res = '';
    for (var i = 0; i < bytes.length; i += 2) {
      res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    }
    return res
  }

  Buffer.prototype.slice = function slice (start, end) {
    var len = this.length;
    start = ~~start;
    end = end === undefined ? len : ~~end;

    if (start < 0) {
      start += len;
      if (start < 0) start = 0;
    } else if (start > len) {
      start = len;
    }

    if (end < 0) {
      end += len;
      if (end < 0) end = 0;
    } else if (end > len) {
      end = len;
    }

    if (end < start) end = start;

    var newBuf;
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      newBuf = this.subarray(start, end);
      newBuf.__proto__ = Buffer.prototype;
    } else {
      var sliceLen = end - start;
      newBuf = new Buffer(sliceLen, undefined);
      for (var i = 0; i < sliceLen; ++i) {
        newBuf[i] = this[i + start];
      }
    }

    return newBuf
  };

  /*
   * Need to make sure that buffer isn't trying to write out of bounds.
   */
  function checkOffset (offset, ext, length) {
    if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
    if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
  }

  Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);

    var val = this[offset];
    var mul = 1;
    var i = 0;
    while (++i < byteLength && (mul *= 0x100)) {
      val += this[offset + i] * mul;
    }

    return val
  };

  Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) {
      checkOffset(offset, byteLength, this.length);
    }

    var val = this[offset + --byteLength];
    var mul = 1;
    while (byteLength > 0 && (mul *= 0x100)) {
      val += this[offset + --byteLength] * mul;
    }

    return val
  };

  Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 1, this.length);
    return this[offset]
  };

  Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] | (this[offset + 1] << 8)
  };

  Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 2, this.length);
    return (this[offset] << 8) | this[offset + 1]
  };

  Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);

    return ((this[offset]) |
        (this[offset + 1] << 8) |
        (this[offset + 2] << 16)) +
        (this[offset + 3] * 0x1000000)
  };

  Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);

    return (this[offset] * 0x1000000) +
      ((this[offset + 1] << 16) |
      (this[offset + 2] << 8) |
      this[offset + 3])
  };

  Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);

    var val = this[offset];
    var mul = 1;
    var i = 0;
    while (++i < byteLength && (mul *= 0x100)) {
      val += this[offset + i] * mul;
    }
    mul *= 0x80;

    if (val >= mul) val -= Math.pow(2, 8 * byteLength);

    return val
  };

  Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);

    var i = byteLength;
    var mul = 1;
    var val = this[offset + --i];
    while (i > 0 && (mul *= 0x100)) {
      val += this[offset + --i] * mul;
    }
    mul *= 0x80;

    if (val >= mul) val -= Math.pow(2, 8 * byteLength);

    return val
  };

  Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 1, this.length);
    if (!(this[offset] & 0x80)) return (this[offset])
    return ((0xff - this[offset] + 1) * -1)
  };

  Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 2, this.length);
    var val = this[offset] | (this[offset + 1] << 8);
    return (val & 0x8000) ? val | 0xFFFF0000 : val
  };

  Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 2, this.length);
    var val = this[offset + 1] | (this[offset] << 8);
    return (val & 0x8000) ? val | 0xFFFF0000 : val
  };

  Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);

    return (this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16) |
      (this[offset + 3] << 24)
  };

  Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);

    return (this[offset] << 24) |
      (this[offset + 1] << 16) |
      (this[offset + 2] << 8) |
      (this[offset + 3])
  };

  Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);
    return read(this, offset, true, 23, 4)
  };

  Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);
    return read(this, offset, false, 23, 4)
  };

  Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 8, this.length);
    return read(this, offset, true, 52, 8)
  };

  Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 8, this.length);
    return read(this, offset, false, 52, 8)
  };

  function checkInt (buf, value, offset, ext, max, min) {
    if (!internalIsBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
    if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
    if (offset + ext > buf.length) throw new RangeError('Index out of range')
  }

  Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) {
      var maxBytes = Math.pow(2, 8 * byteLength) - 1;
      checkInt(this, value, offset, byteLength, maxBytes, 0);
    }

    var mul = 1;
    var i = 0;
    this[offset] = value & 0xFF;
    while (++i < byteLength && (mul *= 0x100)) {
      this[offset + i] = (value / mul) & 0xFF;
    }

    return offset + byteLength
  };

  Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) {
      var maxBytes = Math.pow(2, 8 * byteLength) - 1;
      checkInt(this, value, offset, byteLength, maxBytes, 0);
    }

    var i = byteLength - 1;
    var mul = 1;
    this[offset + i] = value & 0xFF;
    while (--i >= 0 && (mul *= 0x100)) {
      this[offset + i] = (value / mul) & 0xFF;
    }

    return offset + byteLength
  };

  Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
    if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
    this[offset] = (value & 0xff);
    return offset + 1
  };

  function objectWriteUInt16 (buf, value, offset, littleEndian) {
    if (value < 0) value = 0xffff + value + 1;
    for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
      buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
        (littleEndian ? i : 1 - i) * 8;
    }
  }

  Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value & 0xff);
      this[offset + 1] = (value >>> 8);
    } else {
      objectWriteUInt16(this, value, offset, true);
    }
    return offset + 2
  };

  Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value >>> 8);
      this[offset + 1] = (value & 0xff);
    } else {
      objectWriteUInt16(this, value, offset, false);
    }
    return offset + 2
  };

  function objectWriteUInt32 (buf, value, offset, littleEndian) {
    if (value < 0) value = 0xffffffff + value + 1;
    for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
      buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff;
    }
  }

  Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset + 3] = (value >>> 24);
      this[offset + 2] = (value >>> 16);
      this[offset + 1] = (value >>> 8);
      this[offset] = (value & 0xff);
    } else {
      objectWriteUInt32(this, value, offset, true);
    }
    return offset + 4
  };

  Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value >>> 24);
      this[offset + 1] = (value >>> 16);
      this[offset + 2] = (value >>> 8);
      this[offset + 3] = (value & 0xff);
    } else {
      objectWriteUInt32(this, value, offset, false);
    }
    return offset + 4
  };

  Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength - 1);

      checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }

    var i = 0;
    var mul = 1;
    var sub = 0;
    this[offset] = value & 0xFF;
    while (++i < byteLength && (mul *= 0x100)) {
      if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
        sub = 1;
      }
      this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
    }

    return offset + byteLength
  };

  Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength - 1);

      checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }

    var i = byteLength - 1;
    var mul = 1;
    var sub = 0;
    this[offset + i] = value & 0xFF;
    while (--i >= 0 && (mul *= 0x100)) {
      if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
        sub = 1;
      }
      this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
    }

    return offset + byteLength
  };

  Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
    if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
    if (value < 0) value = 0xff + value + 1;
    this[offset] = (value & 0xff);
    return offset + 1
  };

  Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value & 0xff);
      this[offset + 1] = (value >>> 8);
    } else {
      objectWriteUInt16(this, value, offset, true);
    }
    return offset + 2
  };

  Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value >>> 8);
      this[offset + 1] = (value & 0xff);
    } else {
      objectWriteUInt16(this, value, offset, false);
    }
    return offset + 2
  };

  Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value & 0xff);
      this[offset + 1] = (value >>> 8);
      this[offset + 2] = (value >>> 16);
      this[offset + 3] = (value >>> 24);
    } else {
      objectWriteUInt32(this, value, offset, true);
    }
    return offset + 4
  };

  Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
    if (value < 0) value = 0xffffffff + value + 1;
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value >>> 24);
      this[offset + 1] = (value >>> 16);
      this[offset + 2] = (value >>> 8);
      this[offset + 3] = (value & 0xff);
    } else {
      objectWriteUInt32(this, value, offset, false);
    }
    return offset + 4
  };

  function checkIEEE754 (buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length) throw new RangeError('Index out of range')
    if (offset < 0) throw new RangeError('Index out of range')
  }

  function writeFloat (buf, value, offset, littleEndian, noAssert) {
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 4);
    }
    write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4
  }

  Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert)
  };

  Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert)
  };

  function writeDouble (buf, value, offset, littleEndian, noAssert) {
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 8);
    }
    write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8
  }

  Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert)
  };

  Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert)
  };

  // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
  Buffer.prototype.copy = function copy (target, targetStart, start, end) {
    if (!start) start = 0;
    if (!end && end !== 0) end = this.length;
    if (targetStart >= target.length) targetStart = target.length;
    if (!targetStart) targetStart = 0;
    if (end > 0 && end < start) end = start;

    // Copy 0 bytes; we're done
    if (end === start) return 0
    if (target.length === 0 || this.length === 0) return 0

    // Fatal error conditions
    if (targetStart < 0) {
      throw new RangeError('targetStart out of bounds')
    }
    if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
    if (end < 0) throw new RangeError('sourceEnd out of bounds')

    // Are we oob?
    if (end > this.length) end = this.length;
    if (target.length - targetStart < end - start) {
      end = target.length - targetStart + start;
    }

    var len = end - start;
    var i;

    if (this === target && start < targetStart && targetStart < end) {
      // descending copy from end
      for (i = len - 1; i >= 0; --i) {
        target[i + targetStart] = this[i + start];
      }
    } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
      // ascending copy from start
      for (i = 0; i < len; ++i) {
        target[i + targetStart] = this[i + start];
      }
    } else {
      Uint8Array.prototype.set.call(
        target,
        this.subarray(start, start + len),
        targetStart
      );
    }

    return len
  };

  // Usage:
  //    buffer.fill(number[, offset[, end]])
  //    buffer.fill(buffer[, offset[, end]])
  //    buffer.fill(string[, offset[, end]][, encoding])
  Buffer.prototype.fill = function fill (val, start, end, encoding) {
    // Handle string cases:
    if (typeof val === 'string') {
      if (typeof start === 'string') {
        encoding = start;
        start = 0;
        end = this.length;
      } else if (typeof end === 'string') {
        encoding = end;
        end = this.length;
      }
      if (val.length === 1) {
        var code = val.charCodeAt(0);
        if (code < 256) {
          val = code;
        }
      }
      if (encoding !== undefined && typeof encoding !== 'string') {
        throw new TypeError('encoding must be a string')
      }
      if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
        throw new TypeError('Unknown encoding: ' + encoding)
      }
    } else if (typeof val === 'number') {
      val = val & 255;
    }

    // Invalid ranges are not set to a default, so can range check early.
    if (start < 0 || this.length < start || this.length < end) {
      throw new RangeError('Out of range index')
    }

    if (end <= start) {
      return this
    }

    start = start >>> 0;
    end = end === undefined ? this.length : end >>> 0;

    if (!val) val = 0;

    var i;
    if (typeof val === 'number') {
      for (i = start; i < end; ++i) {
        this[i] = val;
      }
    } else {
      var bytes = internalIsBuffer(val)
        ? val
        : utf8ToBytes(new Buffer(val, encoding).toString());
      var len = bytes.length;
      for (i = 0; i < end - start; ++i) {
        this[i + start] = bytes[i % len];
      }
    }

    return this
  };

  // HELPER FUNCTIONS
  // ================

  var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

  function base64clean (str) {
    // Node strips out invalid characters like \n and \t from the string, base64-js does not
    str = stringtrim(str).replace(INVALID_BASE64_RE, '');
    // Node converts strings with length < 2 to ''
    if (str.length < 2) return ''
    // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
    while (str.length % 4 !== 0) {
      str = str + '=';
    }
    return str
  }

  function stringtrim (str) {
    if (str.trim) return str.trim()
    return str.replace(/^\s+|\s+$/g, '')
  }

  function toHex (n) {
    if (n < 16) return '0' + n.toString(16)
    return n.toString(16)
  }

  function utf8ToBytes (string, units) {
    units = units || Infinity;
    var codePoint;
    var length = string.length;
    var leadSurrogate = null;
    var bytes = [];

    for (var i = 0; i < length; ++i) {
      codePoint = string.charCodeAt(i);

      // is surrogate component
      if (codePoint > 0xD7FF && codePoint < 0xE000) {
        // last char was a lead
        if (!leadSurrogate) {
          // no lead yet
          if (codePoint > 0xDBFF) {
            // unexpected trail
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
            continue
          } else if (i + 1 === length) {
            // unpaired lead
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
            continue
          }

          // valid lead
          leadSurrogate = codePoint;

          continue
        }

        // 2 leads in a row
        if (codePoint < 0xDC00) {
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          leadSurrogate = codePoint;
          continue
        }

        // valid surrogate pair
        codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
      } else if (leadSurrogate) {
        // valid bmp char, but last char was a lead
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
      }

      leadSurrogate = null;

      // encode utf8
      if (codePoint < 0x80) {
        if ((units -= 1) < 0) break
        bytes.push(codePoint);
      } else if (codePoint < 0x800) {
        if ((units -= 2) < 0) break
        bytes.push(
          codePoint >> 0x6 | 0xC0,
          codePoint & 0x3F | 0x80
        );
      } else if (codePoint < 0x10000) {
        if ((units -= 3) < 0) break
        bytes.push(
          codePoint >> 0xC | 0xE0,
          codePoint >> 0x6 & 0x3F | 0x80,
          codePoint & 0x3F | 0x80
        );
      } else if (codePoint < 0x110000) {
        if ((units -= 4) < 0) break
        bytes.push(
          codePoint >> 0x12 | 0xF0,
          codePoint >> 0xC & 0x3F | 0x80,
          codePoint >> 0x6 & 0x3F | 0x80,
          codePoint & 0x3F | 0x80
        );
      } else {
        throw new Error('Invalid code point')
      }
    }

    return bytes
  }

  function asciiToBytes (str) {
    var byteArray = [];
    for (var i = 0; i < str.length; ++i) {
      // Node's code seems to be doing this and not & 0x7F..
      byteArray.push(str.charCodeAt(i) & 0xFF);
    }
    return byteArray
  }

  function utf16leToBytes (str, units) {
    var c, hi, lo;
    var byteArray = [];
    for (var i = 0; i < str.length; ++i) {
      if ((units -= 2) < 0) break

      c = str.charCodeAt(i);
      hi = c >> 8;
      lo = c % 256;
      byteArray.push(lo);
      byteArray.push(hi);
    }

    return byteArray
  }


  function base64ToBytes (str) {
    return toByteArray(base64clean(str))
  }

  function blitBuffer (src, dst, offset, length) {
    for (var i = 0; i < length; ++i) {
      if ((i + offset >= dst.length) || (i >= src.length)) break
      dst[i + offset] = src[i];
    }
    return i
  }

  function isnan (val) {
    return val !== val // eslint-disable-line no-self-compare
  }


  // the following is from is-buffer, also by Feross Aboukhadijeh and with same lisence
  // The _isBuffer check is for Safari 5-7 support, because it's missing
  // Object.prototype.constructor. Remove this eventually
  function isBuffer$1(obj) {
    return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj))
  }

  function isFastBuffer (obj) {
    return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
  }

  // For Node v0.10 support. Remove this eventually.
  function isSlowBuffer (obj) {
    return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isFastBuffer(obj.slice(0, 0))
  }

  function isNumber$2(arg) {
    return typeof arg === 'number';
  }

  var WXRequest =
  /*#__PURE__*/
  function (_ConnectionBase) {
    _inherits(WXRequest, _ConnectionBase);

    function WXRequest() {
      var _this;

      _classCallCheck(this, WXRequest);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(WXRequest).call(this));
      _this._request = _this.promisify(wx.request);
      return _this;
    }
    /**
     * 提交异步请求
     * @param {String}options.url	string		是	开发者服务器接口地址
     * @param {Any}options.data	- string/object/ArrayBuffer		否	请求的参数
     * @param {Object}options.header	Object		否	设置请求的 header，header 中不能设置 Referer。
     * @param {String}options.method	string	GET	否	HTTP 请求方法
     * @param {String}options.dataType	string	json	否	返回的数据格式
     * @param {String}options.responseType	string	text	否	响应的数据类型	1.7.0
     */


    _createClass(WXRequest, [{
      key: "request",
      value: function request(options) {

        this._checkOptions(options);

        this._initOptions(options);

        options = _objectSpread2({}, options, {
          responseType: 'text'
        });
        return this._request(options).then(this._handleResolve)["catch"](this._handleReject);
      }
    }, {
      key: "_handleResolve",
      value: function _handleResolve(response) {
        var _response$data = response.data,
            error_code = _response$data.error_code,
            ErrorCode = _response$data.ErrorCode; // 气人，有两种errorCode 名称…… fuck x 2

        var errorCode = ErrorCode;

        if (isNumber$2(error_code)) {
          errorCode = error_code;
        }

        if (errorCode !== TIM_STATUS.REQUEST.SUCCESS) {
          response.data.ErrorCode = Number("".concat(errorCode));
        }

        return response;
      }
    }, {
      key: "_handleReject",
      value: function _handleReject(error) {
        if (isString(error.errMsg)) {
          if (error.errMsg.includes('abort')) {
            return IMPromise.resolve({});
          }

          if (error.errMsg.includes('timeout')) {
            return IMPromise.reject(new IMError({
              code: ERROR_CODE.NETWORK_TIMEOUT,
              message: error.errMsg
            }));
          }

          if (error.errMsg.includes('fail')) {
            return IMPromise.reject(new IMError({
              code: ERROR_CODE.NETWORK_ERROR,
              message: error.errMsg
            }));
          }
        }

        return IMPromise.reject(new IMError(_objectSpread2({
          code: ERROR_CODE.UNCAUGHT_ERROR,
          message: error.message
        }, error)));
      }
    }, {
      key: "promisify",
      value: function promisify(api) {
        return function (options) {
          return new Promise(function (resolve, reject) {
            var task = api(Object.assign({}, options, {
              success: resolve,
              fail: reject
            }));

            if (options.updateAbort) {
              options.updateAbort(function () {
                return task.abort();
              });
            }
          });
        };
      }
    }]);

    return WXRequest;
  }(ConnectionBase);

  var RunLoopStats =
  /*#__PURE__*/
  function () {
    function RunLoopStats() {
      _classCallCheck(this, RunLoopStats);

      this.request = 0; // 请求次数

      this.success = 0; // 成功次数

      this.fail = 0; // 失败次数

      this.reportRate = 10; // 10次轮询报告一次

      this.requestTimeCost = []; // 每次请求花费的时间
    }

    _createClass(RunLoopStats, [{
      key: "report",
      value: function report() {
        if (this.request === 1) {
          return;
        }

        if (this.request % this.reportRate != 0) {
          return null;
        }

        var avgTime = this.avgRequestTime();
        var string = "runLoop reports: success=".concat(this.success, ",fail=").concat(this.fail, ",total=").concat(this.request, ",avg=").concat(avgTime, ",cur=").concat(this.requestTimeCost[this.requestTimeCost.length - 1], ",max=").concat(Math.max.apply(null, this.requestTimeCost), ",min=").concat(Math.min.apply(null, this.requestTimeCost)); // this.reset();

        logger.log(string);
      }
    }, {
      key: "setRequestTime",
      value: function setRequestTime(t1, t2) {
        var diff = Math.abs(t2 - t1);

        if (this.requestTimeCost.length === 100) {
          this.requestTimeCost.shift();
        }

        this.requestTimeCost.push(diff);
      }
    }, {
      key: "avgRequestTime",
      value: function avgRequestTime() {
        var len = this.requestTimeCost.length;
        var sum = 0;
        var avg = 0;

        for (var i = 0; i < len; i++) {
          sum += this.requestTimeCost[i];
        }

        avg = sum / len;
        return Math.round(avg * 100) / 100;
      }
    }]);

    return RunLoopStats;
  }();

  var CancelToken$1 = axios$1.CancelToken;

  var XHRRunLoop =
  /*#__PURE__*/
  function () {
    /**
     * 
     * @param {*} options 
     * @param {Function} options.before - 回调函数，此函数会在每次请求发出前执行
     * @param {Function} options.success - 成功回调函数，此函数会在请求成功后执行
     * @param {Function} options.fail - 失败回调函数，此函数会在网络请求失败后执行
     */
    function XHRRunLoop(options) {
      _classCallCheck(this, XHRRunLoop);

      this._initializeOptions(options);

      this._initializeMembers();

      this.status = new RunLoopStats();
    }
    /**
     * 自我销毁，并反回索引
     * @returns {Number} index
     */


    _createClass(XHRRunLoop, [{
      key: "destructor",
      value: function destructor() {
        clearTimeout(this._seedID);

        var index = this._index();

        for (var p in this) {
          this[p] = null;
        }

        return index;
      }
      /**
       * 记录一下自己实例的索引
       * @param {*} value 
       */

    }, {
      key: "setIndex",
      value: function setIndex(value) {
        this._index = value;
      }
      /**
       * 获取实例的索引
       */

    }, {
      key: "getIndex",
      value: function getIndex() {
        return this._index;
      }
    }, {
      key: "isRunning",
      value: function isRunning() {
        return !this._stoped;
      }
    }, {
      key: "_initializeOptions",
      value: function _initializeOptions(options) {
        this.options = options;
      }
    }, {
      key: "_initializeMembers",
      value: function _initializeMembers() {
        this._index = -1;
        this._seedID = 0;
        this._requestStatus = false;
        this._stoped = false;
        this._intervalTime = 0; // 本次拿到 reponse 后，到下一次请求发起的时间间隔，默认为0，但在服务器快速返回的情况下，会马上进行下一次请求，因此需要做控制，毫秒

        this._intervalIncreaseStep = 1000; // _intervalTime 每次步进的幅度，毫秒

        this._intervalDecreaseStep = 1000; // _intervalTime 每次步减的幅度，毫秒

        this._intervalTimeMax = 5000; // setTimeout的最大时间间隔，毫秒

        this._protectTimeout = 3000; // 设置一个保护值，防止服务器下发错误的值导致请求过于频繁，毫秒

        this._getNoticeSeq = this.options.getNoticeSeq;
        this._retryCount = 0;
        this._responseTime = Date.now();
        this._responseTimeThreshold = 2000; // 两次连续的 response 时差的阀值，大于这个阀值，当做正常请求，小于这个阀值，可能会引起爆炸式请求，会提高 _intervalTime 。毫秒

        this.requestor = IMAxios;
        this.abort = null; // 取消当前请求
      }
    }, {
      key: "start",
      value: function start() {
        if (this._seedID != 0) {
          logger.log('XHRRunLoop.start(), XHRRunLoop is running now, if you want to restart runLoop , please run "stop()" first.');
          return;
        }

        this._stoped = false;

        this._send();
      }
    }, {
      key: "_reset",
      value: function _reset() {
        logger.log('XHRRunLoop._reset(), reset long poll _intervalTime', this._intervalTime);
        this.stop();
        this.start();
      }
      /**
       * 加大请求间隔
       */

    }, {
      key: "_intervalTimeIncrease",
      value: function _intervalTimeIncrease() {
        if (this._intervalTime === this._responseTimeThreshold) {
          return;
        }

        if (this._intervalTime < this._responseTimeThreshold) {
          this._intervalTime += this._intervalIncreaseStep;
        }

        if (this._intervalTime > this._responseTimeThreshold) {
          this._intervalTime = this._responseTimeThreshold;
        }
      }
      /**
       * 减少请求间隔
       */

    }, {
      key: "_intervalTimeDecrease",
      value: function _intervalTimeDecrease() {
        if (this._intervalTime === 0) {
          return;
        }

        if (this._intervalTime > 0) {
          this._intervalTime -= this._intervalDecreaseStep;
        }

        if (this._intervalTime < 0) {
          this._intervalTime = 0;
        }
      }
      /**
       * 调整 _intervalTime 的大小， 频保
       */

    }, {
      key: "_intervalTimeAdjustment",
      value: function _intervalTimeAdjustment() {
        var timeNew = Date.now();
        var diffriece = Math.floor((timeNew - this._responseTime) / 100) * 100;

        if (diffriece <= this._responseTimeThreshold) {
          this._intervalTimeIncrease(); // logger.log(`WXRunLoop._intervalTimeAdjustment Increase:timeNew - _responseTime≈${diffriece}, IT/Threshold: ${this._intervalTime}/${this._responseTimeThreshold}`);

        } else {
          this._intervalTimeDecrease(); // logger.log(`WXRunLoop._intervalTimeAdjustment Decrease:timeNew - _responseTime≈${diffriece}, IT/Threshold: ${this._intervalTime}/${this._responseTimeThreshold}`);

        }

        this._responseTime = timeNew;
      }
      /**
       * 基于response.data 对频繁进行调整
       * @param {*} responseData 
       */

    }, {
      key: "_intervalTimeAdjustmentBaseOnResponseData",
      value: function _intervalTimeAdjustmentBaseOnResponseData(responseData) {
        // 如果收到错误码，提高间隔，降低频率，反之慢慢降到0
        if (responseData.ErrorCode === TIM_STATUS.REQUEST.SUCCESS) {
          this._intervalTimeDecrease(); // logger.log(`WXRunLoop._intervalTimeAdjustmentBaseOnResponseData Decrease - errorCode: ${responseData.ErrorCode} , IT/Threshold: ${this._intervalTime}/${this._responseTimeThreshold}`);

        } else {
          this._intervalTimeIncrease(); // logger.log(`WXRunLoop._intervalTimeAdjustmentBaseOnResponseData Increase - errorCode: ${responseData.ErrorCode} , IT/Threshold: ${this._intervalTime}/${this._responseTimeThreshold}`);

        }
      }
      /**
       * 提交请求
       * @description `_send`函数请求执行的时间为：每`_intervalTime`秒执行一次，当`_requestStatus`为false时，才会提交请求，这样防止重复提交，防止网络请求没必要的`abort`
       */

    }, {
      key: "_send",
      value: function _send() {
        var _this = this;

        // 如果之前的请求还没有结论，不进行本次请求
        if (this._requestStatus === true) {
          return;
        }

        this._requestStatus = true;
        this.status.request++;

        if (typeof this.options.before === 'function') {
          this.options.before(this.options.pack.requestData);
        }

        var timeStart = Date.now();
        var timeEnd = 0;
        this.requestor.request({
          url: this.options.pack.getUrl(),
          data: this.options.pack.requestData,
          method: this.options.pack.method,
          // 参考axios 文档：https://github.com/axios/axios#cancellation
          cancelToken: new CancelToken$1(function (abort) {
            _this.abort = abort;
          })
        }).then(function (response) {
          _this._intervalTimeAdjustmentBaseOnResponseData.bind(_this)(response.data); // 基于 responseData 的频保


          _this._retryCount > 0 ? _this._retryCount = 0 : null; // 请求成功时，把this._retryCount归零

          _this.status.success++;

          if (typeof _this.options.success === 'function') {
            // 防止回调出错，用try catch 包起来
            try {
              _this.options.success({
                pack: _this.options.pack,
                error: false,
                data: _this.options.pack.callback(response.data) //轮询返回体进行参数key转换

              });
            } catch (userError) {
              logger.warn('XHRRunLoop._send(), success callback error:');
              logger.error(userError);
            }
          }

          _this._requestStatus = false;

          if (_this._stoped === false) {
            _this._seedID = setTimeout(_this._send.bind(_this), _this._intervalTime);
          }

          timeEnd = Date.now();

          _this.status.setRequestTime(timeStart, timeEnd);

          _this.status.report();
        })["catch"](function (error) {
          _this.status.fail++;
          _this._retryCount++;

          _this._intervalTimeAdjustment.bind(_this)(); // 频保


          if (_this._stoped === false) {
            _this._seedID = setTimeout(_this._send.bind(_this), _this._intervalTime);
          }

          _this._requestStatus = false;

          if (typeof _this.options.fail === 'function' && typeof error.request != 'undefined') {
            // 防止回调出错，用try catch 包起来
            try {
              _this.options.fail({
                pack: _this.options.pack,
                error: error,
                data: false
              });
            } catch (userError) {
              logger.warn('XHRRunLoop._send(), fail callback error:');
              logger.error(userError);
            }
          }

          timeEnd = Date.now();

          _this.status.setRequestTime(timeStart, timeEnd);

          _this.status.report();
        });
      }
      /**
       * 停止轮询
       */

    }, {
      key: "stop",
      value: function stop() {
        this._clearAllTimeOut();

        this._stoped = true;
      }
    }, {
      key: "_clearAllTimeOut",
      value: function _clearAllTimeOut() {
        clearTimeout(this._seedID);
        this._seedID = 0;
      }
    }]);

    return XHRRunLoop;
  }();

  var WXRunLoop =
  /*#__PURE__*/
  function () {
    /**
     * 
     * @param {*} options 
     * @param {Function} options.before - 回调函数，此函数会在每次请求发出前执行
     * @param {Function} options.success - 成功回调函数，此函数会在请求成功后执行
     * @param {Function} options.fail - 失败回调函数，此函数会在网络请求失败后执行
     */
    function WXRunLoop(options) {
      _classCallCheck(this, WXRunLoop);

      this._initializeOptions(options);

      this._initializeMembers();

      this.status = new RunLoopStats();
    }
    /**
     * 自我销毁，并反回索引
     * @returns {Number} index
     */


    _createClass(WXRunLoop, [{
      key: "destructor",
      value: function destructor() {
        clearTimeout(this._seedID);

        var index = this._index();

        for (var p in this) {
          this[p] = null;
        }

        return index;
      }
      /**
       * 记录一下自己实例的索引
       * @param {*} value 
       */

    }, {
      key: "setIndex",
      value: function setIndex(value) {
        this._index = value;
      }
    }, {
      key: "isRunning",
      value: function isRunning() {
        return !this._stoped;
      }
      /**
       * 获取实例的索引
       */

    }, {
      key: "getIndex",
      value: function getIndex() {
        return this._index;
      }
    }, {
      key: "_initializeOptions",
      value: function _initializeOptions(options) {
        this.options = options;
      }
    }, {
      key: "_initializeMembers",
      value: function _initializeMembers() {
        this._index = -1;
        this._seedID = 0;
        this._requestStatus = false;
        this._stoped = false;
        this._intervalTime = 0; // 本次拿到 reponse 后，到下一次请求发起的时间间隔，默认为0，但在服务器快速返回的情况下，会马上进行下一次请求，因此需要做控制，毫秒

        this._intervalIncreaseStep = 1000; // _intervalTime 每次步进的幅度，毫秒

        this._intervalDecreaseStep = 1000; // _intervalTime 每次步减的幅度，毫秒

        this._intervalTimeMax = 5000; // setTimeout的最大时间间隔，毫秒

        this._protectTimeout = 3000; // 设置一个保护值，防止服务器下发错误的值导致请求过于频繁，毫秒

        this._getNoticeSeq = this.options.getNoticeSeq;
        this._retryCount = 0;
        this._responseTime = Date.now();
        this._responseTimeThreshold = 2000; // 两次连续的 response 时差的阀值，大于这个阀值，当做正常请求，小于这个阀值，可能会引起爆炸式请求，会提高 _intervalTime 。毫秒

        this.requestor = new WXRequest();
        this.abort = null; // 取消当前请求
      }
    }, {
      key: "start",
      value: function start() {
        if (this._seedID !== 0) {
          logger.log('WXRunLoop.start(): WXRunLoop is running now, if you want to restart runLoop , please run "stop()" first.');
          return;
        } // 这里暂时不使用递归，看看能不能减少一点函数调用栈


        this._stoped = false;

        this._send();
      }
    }, {
      key: "_reset",
      value: function _reset() {
        logger.log('WXRunLoop.reset(), long poll _intervalMaxRate', this._intervalMaxRate);
        this.stop();
        this.start();
      }
      /**
       * 加大请求间隔
       */

    }, {
      key: "_intervalTimeIncrease",
      value: function _intervalTimeIncrease() {
        if (this._intervalTime === this._responseTimeThreshold) {
          return;
        }

        if (this._intervalTime < this._responseTimeThreshold) {
          this._intervalTime += this._intervalIncreaseStep;
        }

        if (this._intervalTime > this._responseTimeThreshold) {
          this._intervalTime = this._responseTimeThreshold;
        }
      }
      /**
       * 减少请求间隔
       */

    }, {
      key: "_intervalTimeDecrease",
      value: function _intervalTimeDecrease() {
        if (this._intervalTime === 0) {
          return;
        }

        if (this._intervalTime > 0) {
          this._intervalTime -= this._intervalDecreaseStep;
        }

        if (this._intervalTime < 0) {
          this._intervalTime = 0;
        }
      }
      /**
       * 调整 _intervalTime 的大小， 频保
       */

    }, {
      key: "_intervalTimeAdjustment",
      value: function _intervalTimeAdjustment() {
        var timeNew = Date.now();
        var diffriece = Math.floor((timeNew - this._responseTime) / 100) * 100;

        if (diffriece <= this._responseTimeThreshold) {
          this._intervalTimeIncrease(); // logger.log(`WXRunLoop._intervalTimeAdjustment Increase timeNew - _responseTime≈${diffriece}, IT/Threshold: ${this._intervalTime}/${this._responseTimeThreshold}`);

        } else {
          this._intervalTimeDecrease(); // logger.log(`WXRunLoop._intervalTimeAdjustment Decrease timeNew - _responseTime≈${diffriece}, IT/Threshold: ${this._intervalTime}/${this._responseTimeThreshold}`);

        }

        this._responseTime = timeNew;
      }
      /**
       * 基于response.data 对频繁进行调整
       * @param {*} responseData 
       */

    }, {
      key: "_intervalTimeAdjustmentBaseOnResponseData",
      value: function _intervalTimeAdjustmentBaseOnResponseData(responseData) {
        // 如果收到错误码，提高间隔，降低频率，反之慢慢降到0
        if (responseData.ErrorCode === TIM_STATUS.REQUEST.SUCCESS) {
          this._intervalTimeDecrease(); // logger.log(`WXRunLoop._intervalTimeAdjustmentBaseOnResponseData Decrease errorCode: ${responseData.ErrorCode} , IT/Threshold: ${this._intervalTime}/${this._responseTimeThreshold}`);

        } else {
          this._intervalTimeIncrease(); // logger.log(`WXRunLoop._intervalTimeAdjustmentBaseOnResponseData Increase errorCode: ${responseData.ErrorCode} , IT/Threshold: ${this._intervalTime}/${this._responseTimeThreshold}`);

        }
      }
      /**
      * 提交请求
      * @description `_send`函数请求执行的时间为：每`_intervalMaxRate`秒执行一次，当`_requestStatus`为false时，才会提交请求，这样防止重复提交，防止网络请求没必要的`abort`
      */

    }, {
      key: "_send",
      value: function _send() {
        var _this = this;

        if (this._requestStatus === true) {
          return;
        }

        var self = this;
        this._requestStatus = true;
        this.status.request++;

        if (typeof this.options.before === 'function') {
          this.options.before(self.options.pack.requestData);
        }

        var timeStart = Date.now();
        var timeEnd = 0; // 参考小程序文档：https://developers.weixin.qq.com/miniprogram/dev/api/network/request/RequestTask.html

        this.requestor.request({
          url: self.options.pack.getUrl(),
          data: self.options.pack.requestData,
          method: self.options.pack.method,
          updateAbort: function updateAbort(abort) {
            _this.abort = abort;
          }
        }).then(function (response) {
          self._intervalTimeAdjustmentBaseOnResponseData.bind(_this)(response.data); // 基于 responseData 的频保


          self._retryCount > 0 ? self._retryCount = 0 : null; // 请求成功时，把self._retryCount归零

          _this.status.success++;

          if (typeof self.options.success === 'function') {
            // 防止回调出错，用try catch 包起来
            try {
              _this.options.success({
                pack: _this.options.pack,
                error: false,
                data: _this.options.pack.callback(response.data) //轮询返回体进行参数key转换

              });
            } catch (userError) {
              logger.warn('WXRunLoop._send(),success callback error:');
              logger.error(userError);
            }
          }

          self._requestStatus = false;

          if (self._stoped === false) {
            self._seedID = setTimeout(self._send.bind(self), self._intervalTime);
          }

          timeEnd = Date.now();

          _this.status.setRequestTime(timeStart, timeEnd);

          _this.status.report();
        })["catch"](function (error) {
          _this.status.fail++;
          self._retryCount++;

          self._intervalTimeAdjustment.bind(_this)(); // 频保


          if (self._stoped === false) {
            self._seedID = setTimeout(self._send.bind(self), self._intervalTime);
          }

          self._requestStatus = false;

          if (typeof self.options.fail === 'function') {
            // 防止回调出错，用try catch 包起来
            try {
              _this.options.fail({
                pack: _this.options.pack,
                error: error,
                data: false
              });
            } catch (userError) {
              logger.warn('WXRunLoop._send(), fail callback error:');
              logger.error(userError);
            }
          }

          timeEnd = Date.now();

          _this.status.setRequestTime(timeStart, timeEnd);

          _this.status.report();
        });
      }
      /**
      * 停止轮询
      */

    }, {
      key: "stop",
      value: function stop() {
        this._clearAllTimeOut();

        this._stoped = true;
      }
    }, {
      key: "_clearAllTimeOut",
      value: function _clearAllTimeOut() {
        clearTimeout(this._seedID);
        this._seedID = 0;
      }
    }]);

    return WXRunLoop;
  }();

  /**
   * 网络控制逻辑
   */

  var ConnectionController =
  /*#__PURE__*/
  function (_IMController) {
    _inherits(ConnectionController, _IMController);

    function ConnectionController(tim) {
      var _this;

      _classCallCheck(this, ConnectionController);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(ConnectionController).call(this, tim));
      _this.context = tim.context;
      _this.httpConnection = _this._getHttpconnection();
      _this.keepAliveConnections = [];
      return _this;
    }

    _createClass(ConnectionController, [{
      key: "initializeListener",
      value: function initializeListener() {
        var innerEmitter = this.tim.innerEmitter;
        innerEmitter.on(TIM_INNER_EVENT.SIGN_LOGOUT_EXECUTING, this._stopAllRunLoop, this);
      }
    }, {
      key: "request",
      value: function request(pack) {
        var requestOption = {
          url: pack.url,
          data: pack.requestData,
          method: pack.method,
          callback: pack.callback
        };
        return this.httpConnection.request(requestOption).then(function (response) {
          // decode 和 convertor Key转换
          response.data = pack.callback(response.data);

          if (response.data.errorCode !== TIM_STATUS.REQUEST.SUCCESS) {
            return IMPromise.reject(new IMError({
              code: response.data.errorCode,
              message: response.data.errorInfo
            }));
          }

          return response;
        });
      }
      /**
       * 返回一个runLoop实例
       * @param {*} options
       * @param {Function} options.before - 发送前回调
       * @param {Function} options.success - 成功后回调
       * @param {Function} options.fail - 失败后回调
       * @example
       * let runLoop = connectionController.createRunLoop({
       *    before: function(){},
       *    success: function(){},
       *    fail: function(){}
       * })
       * runLoop.start(); // 启动轮询
       * runLoop.stop(); // 停止轮询
       * connectionController.startRunLoopExclusive(runLoop); // 排它启动 - 停止别人，启动自己
       * connectionController.destroyRunLoop(runLoop); // 销毁一个轮询实例
       */

    }, {
      key: "createRunLoop",
      value: function createRunLoop(options) {
        var xhrRunLoop = this.createKeepAliveConnection(options);
        xhrRunLoop.setIndex(this.keepAliveConnections.push(xhrRunLoop) - 1);
        return xhrRunLoop;
      }
      /**
       * 停止某个runLoop实例，但不会销毁该实例
       * @param {*} xhrRunLoop
       */

    }, {
      key: "stopRunLoop",
      value: function stopRunLoop(xhrRunLoop) {
        xhrRunLoop.stop();
      }
      /**
       * 关闭掉所有的 runLoop
       */

    }, {
      key: "_stopAllRunLoop",
      value: function _stopAllRunLoop() {
        var length = this.keepAliveConnections.length;

        for (var i = 0; i < length; i++) {
          this.keepAliveConnections[i].stop();
        }
      }
      /**
       * 停止并销毁某个runLoop实例
       * @param {*} xhrRunLoop
       */

    }, {
      key: "destroyRunLoop",
      value: function destroyRunLoop(xhrRunLoop) {
        xhrRunLoop.stop();
        var index = xhrRunLoop.destructor();
        this.keepAliveConnections.slice(index, 1);
      }
      /**
       * 排它启用，关闭非其他的实例，启动自己
       * @param {*} xhrRunLoop
       */

    }, {
      key: "startRunLoopExclusive",
      value: function startRunLoopExclusive(xhrRunLoop) {
        var index = xhrRunLoop.getIndex();

        for (var i = 0; i < this.keepAliveConnections.length; i++) {
          i != index ? this.keepAliveConnections[i].stop() : null;
        }

        xhrRunLoop.start();
      }
      /**
       * 根据运行环境的不同，返回不同的httpConnection
       */

    }, {
      key: "_getHttpconnection",
      value: function _getHttpconnection() {
        if (IN_WX_MINI_APP) {
          return new WXRequest();
        }

        return new XHR();
      }
      /**
       * 获取`keepAliveConnection`
       */

    }, {
      key: "createKeepAliveConnection",
      value: function createKeepAliveConnection(options) {
        if (IN_WX_MINI_APP) {
          return new WXRunLoop(options);
        } // 先查看是否有强制配置使用 XHR 方式轮询


        if (this.tim.options.runLoopNetType === RUNLOOP_TYPES.XHR) {
          return new XHRRunLoop(options);
        } // 查看是否有强制配置使用 SOCKET 方式轮询


        if (this.tim.options.runLoopNetType === RUNLOOP_TYPES.SOCKET) ; // return new SocketRunLoop(options);
        // 自动获取


        if (typeof window.WebSocket === 'function' && typeof window.WebSocket.prototype.send === 'function') ;

        return new XHRRunLoop(options);
      }
    }, {
      key: "clearAll",
      value: function clearAll() {
        this.conn.cancelAll();
      }
    }, {
      key: "reset",
      value: function reset() {
        this.keepAliveConnections = [];
      }
    }]);

    return ConnectionController;
  }(IMController);

  var MANUAL_PAGES = {
    ERROR_CODES: 'https://cloud.tencent.com/document/product/269/1671'
  };

  if (typeof console.table == 'undefined') {
    console.table = console.log;
  }

  var LEVEL = {
    UNDEFINEDED: -1,
    // - 未定义 ， 未定义级别的错误，效果未知
    NOTE: 1,
    // - 提示 , 不影响程序执行
    WARN: 2,
    // - 警告 , 可能会影响执行结果
    ERROR: 3,
    // - 错误 , 导致函数无法继续运行
    FATAL_ERROR: 4 // - 致命错误 , 导致应用无法继续运行、很多功能无法使用的错误

  };
  var titlesSet = {};
  titlesSet[LEVEL.UNDEFINEDED] = 'Unknow error level';
  titlesSet[LEVEL.NOTE] = 'Note';
  titlesSet[LEVEL.WARN] = 'Warn';
  titlesSet[LEVEL.ERROR] = 'Error';
  titlesSet[LEVEL.FATAL_ERROR] = 'Fatal error';

  var echo = function echo(err, tips) {
    // let color = colorsSet[err.level];
    var title = titlesSet[err.level];
    logger.warn("".concat(title, " - Code: [").concat(err.code, "]; message: ").concat(err.message));
    logger.warn('Stack\n', err.stack);
    var tipsString = [err.tips || '', '\n', tips].join('');

    if (!!tipsString == false) {
      tipsString = false;
    }

    if (tipsString) {
      logger.log("About IMError ".concat(err.code, ": ").concat(tipsString));
    }
  };
  /**
   * errorMethods 负责给错误给出合理的提示信息，这些提示信息的要求是：
   * 1. 能指引开发者正确的调用
   * 2. 对于SDK内不能解决的问题，要给出指引性的提示
   * 3. API_ERROR默认用echo方法输出，如果有更好的描述信息，可以在errorMethods对象后填写对应方法进行覆盖
   */


  var errorMethods = {
    f9999998: function f9999998(err) {
      echo(err);
    },
    //新增error code 9999999的处理方法
    f9999999: function f9999999(err) {
      echo(err, '在errorCode.js文件中为此错误创建一个错误码');
    },
    f: function f(err) {
      echo(err), "\u672A\u5B9A\u4E49\u7684\u9519\u8BEF:".concat(err.code, " , ").concat(err.message);
    },
    f20000: function f20000(err) {
      echo(err);
    },
    f20001: function f20001(err) {
      echo(err);
    },
    f20002: function f20002(err) {
      echo(err);
    },
    f30000: function f30000(err) {
      echo(err);
    },
    f40004: function f40004(err) {
      echo(err, 'new Controller(TIMSDK instance)');
    },
    f40005: function f40005(err) {
      echo(err);
    },
    f40006: function f40006(err) {
      echo(err);
    },
    f40007: function f40007(err) {
      echo(err);
    },
    f40008: function f40008(err) {
      echo(err);
    },
    f50070003: function f50070003(err) {
      var apiErrorCode = err.code.replace('500', '');
      echo(err, "Information about error code [".concat(apiErrorCode, "] : ").concat(MANUAL_PAGES.ERROR_CODES));
    },
    f50030001: function f50030001(err) {
      echo(err);
    },
    f50070221: function f50070221(err) {
      echo(err);
    }
  };
  errorMethods.echo = echo;

  var ExceptionController =
  /*#__PURE__*/
  function () {
    function ExceptionController(tim) {
      _classCallCheck(this, ExceptionController);

      this.methods = errorMethods;
      this.tim = tim;

      this._initielizeListener();
    }

    _createClass(ExceptionController, [{
      key: "_initielizeListener",
      value: function _initielizeListener() {
        this.tim.innerEmitter.on(TIM_INNER_EVENT.ERROR_DETECTED, this._onErrorDetected, this);
      }
      /**
       * 受理IMError的入口
       * @param {IMError} imError
       * @return {Promise} 仅包含 catch 处理的 Promise
       */

    }, {
      key: "ask",
      value: function ask(imError) {
        var name = ['f', imError.code].join('');
        var echo = errorMethods.echo;

        if (this.methods.hasOwnProperty(name)) {
          this.methods[name](imError);
        } else {
          echo(imError); // console.log(
          //   `\n%c开发者建议：%c
          // error code:[${imError.code}] 没有对应的 errorMethods 处理。
          // 请到 "src/controller/ExceptionController/errorMethods.js" 文件中找到 "errorMethods" 对象，在其中添加 "f${imError.code}" 方法，如下所示:%c
          // let %c errorMethods= {%c
          //   %c//新增error code ${imError.code}的处理方法%c
          //   %c${name}%c : %cfunction%c(imError){
          //     %cecho%c(imError);
          //     %c/*错误处理代码*/%c
          //   }
          // }\n\n%c`,
          //   'background:#9A9;color:#eee',
          //   'background:default;color:#9a9',
          //   'color:#22E',
          //   'color:#aaf',
          //   'color:default',
          //   'color:#bbb',
          //   'color:default',
          //   'color:#bb0',
          //   'color:#aaf',
          //   'color:#22E',
          //   'color:#aaf',
          //   'color:#bb0',
          //   'color:#aaf',
          //   'color:#bbb',
          //   'color:#aaf',
          //   'color:default'
          // );
        }
      }
      /**
       * 捕获错误事件的入口
       * @param {IMError} errorEvent
       */

    }, {
      key: "_onErrorDetected",
      value: function _onErrorDetected(imError) {
        this.ask(imError);
        this.tim.outerEmitter.emit(TIM_OUTER_EVENT.ERROR, imError);
      }
    }]);

    return ExceptionController;
  }();

  var UPLOAD_FILE_SIZE_LIMIT = 20971520; // 上传的文件大小，限制为20M
  // export const UPLOAD_IMAGE_SIZE_LIMIT = 10485760; // 上传的图片大小，限制为10M
  // export const UPLOAD_IMAGE_SIZE_LIMIT = 20971520; // 上传的图片大小，限制为20M

  var UPLOAD_IMAGE_SIZE_LIMIT = 20971520; // 上传的图片大小，限制为20M

  var UPLOAD_IMAGE_TYPES_LIMIT = ['jpg', 'jpeg', 'gif', 'png']; // 上传文件的类型限制 

  /**
   * 用户昵称长度限制，单位为bytes ，注意：用String.length只能取得字符串中的字符个数，并不能取得字节数
   * @private
   */

  var NICK_NAME_LENGTH_LIMIT = 500;

  /**
   * 用户资料对象，用于描述用户具有的属性，如昵称、头像地址、个性签名、性别等。
   * @class Profile
   * @property {String} userID 用户账号
   * @property {String} nick 昵称，长度不得超过500个字节
   * @property {String} gender 性别<br/>
   * - TIM.TYPES.GENDER_UNKNOWN（未设置性别）
   * - TIM.TYPES.GENDER_FEMALE（女）
   * - TIM.TYPES.GENDER_MALE（男）
   * @property {Number} birthday 生日 uint32 推荐用法：20000101
   * @property {String} location 所在地 长度不得超过16个字节，推荐用法如下：App 本地定义一套数字到地名的映射关系 后台实际保存的是4个 uint32_t 类型的数字：
   * - 第一个 uint32_t 表示国家
   * - 第二个 uint32_t 用于表示省份
   * - 第三个 uint32_t 用于表示城市
   * - 第四个 uint32_t 用于表示区县 
   * @property {String} selfSignature 个性签名 长度不得超过500个字节
   * @property {String} allowType 加好友验证方式<br/>
   * - TIM.TYPES.ALLOW_TYPE_ALLOW_ANY（允许任何人添加自己为好友）
   * - TIM.TYPES.ALLOW_TYPE_NEED_CONFIRM（需要经过自己确认才能添加自己为好友）
   * - TIM.TYPES.ALLOW_TYPE_DENY_ANY（不允许任何人添加自己为好友）
   * @property {Number} language 语言 uint32
   * @property {String} avatar 头像URL，长度不得超过500个字节
   * @property {Number} messageSettings 消息设置 uint32 标志位：Bit0：置0表示接收消息，置1则不接收消息
   * @property {String} adminForbidType 管理员禁止加好友标识<br/>
   * - TIM.TYPES.FORBID_TYPE_NONE（默认值，允许加好友）
   * - TIM.TYPES.FORBID_TYPE_SEND_OUT（禁止该用户发起加好友请求）
   * @property {Number} level 等级 uint32 建议拆分以保存多种角色的等级信息
   * @property {Number} role 角色 uint32 建议拆分以保存多种角色信息
   * @property {Number} lastUpdatedTime 上次更新时间，用户本地时间
   */

  var Profile =
  /*#__PURE__*/
  function () {
    function Profile(options) {
      _classCallCheck(this, Profile);

      if (!isEmpty(options)) {
        this.userID = options.userID || '';
        this.nick = options.nick || '';
        this.gender = options.gender || '';
        this.birthday = options.birthday || 0;
        this.location = options.location || '';
        this.selfSignature = options.selfSignature || '';
        this.allowType = options.allowType || TYPES.ALLOW_TYPE_ALLOW_ANY;
        this.language = options.language || 0;
        this.avatar = options.avatar || '';
        this.messageSettings = options.messageSettings || 0;
        this.adminForbidType = options.adminForbidType || TYPES.FORBID_TYPE_NONE;
        this.level = options.level || 0;
        this.role = options.role || 0; // this.userCustomFiled = options.userCustomFiled || [];

        this.lastUpdatedTime = 0;
      }
    }
    /**
    * 验证配置是否有效
    * @param {*} options 
     * @private
    */


    _createClass(Profile, [{
      key: "validate",
      value: function validate(options) {
        var valid = true;
        var tips = '';

        if (isEmpty(options)) {
          valid = false;
          tips = 'empty options';
        }

        for (var key in options) {
          // key对应的value检测出是empty，并且既不是''，也不是0（如可能是undefined或者null）
          if (isEmpty(options[key]) && !isString(options[key]) && !isNumber(options[key])) {
            tips = 'key:' + key + ', invalid value:' + options[key];
            valid = false;
            continue;
          } // 检测每个key对应的value的类型是否正确


          switch (key) {
            case 'nick':
              if (!isString(options[key])) {
                tips = 'nick should be a string';
                valid = false;
              } // 昵称长度限制为`NICK_NAME_LENGTH_LIMIT`个字节


              if (stringSize(options[key]) > NICK_NAME_LENGTH_LIMIT) {
                tips = "nick name limited: must less than or equal to ".concat(NICK_NAME_LENGTH_LIMIT, " bytes, current size: ").concat(stringSize(options[key]), " bytes");
                valid = false;
              }

              break;

            case 'gender':
              if (!isValidType(GENDER_TYPES, options.gender)) {
                tips = 'key:gender, invalid value:' + options.gender;
                valid = false;
              }

              break;

            case 'birthday':
              if (!isNumber(options.birthday)) {
                tips = 'birthday should be a number';
                valid = false;
              }

              break;

            case 'location':
              if (!isString(options.location)) {
                tips = 'location should be a string';
                valid = false;
              }

              break;

            case 'selfSignature':
              if (!isString(options.selfSignature)) {
                tips = 'selfSignature should be a string';
                valid = false;
              }

              break;

            case 'allowType':
              if (!isValidType(ALLOW_TYPES, options.allowType)) {
                tips = 'key:allowType, invalid value:' + options.allowType;
                valid = false;
              }

              break;

            case 'language':
              if (!isNumber(options.language)) {
                tips = 'language should be a number';
                valid = false;
              }

              break;

            case 'avatar':
              if (!isString(options.avatar)) {
                tips = 'avatar should be a string';
                valid = false;
              }

              break;

            case 'messageSettings':
              if (options.messageSettings !== 0 && options.messageSettings !== 1) {
                tips = 'messageSettings should be 0 or 1';
                valid = false;
              }

              break;

            case 'adminForbidType':
              if (!isValidType(FORBID_TYPES, options.adminForbidType)) {
                tips = 'key:adminForbidType, invalid value:' + options.adminForbidType;
                valid = false;
              }

              break;

            case 'level':
              if (!isNumber(options.level)) {
                tips = 'level should be a number';
                valid = false;
              }

              break;

            case 'role':
              if (!isNumber(options.role)) {
                tips = 'role should be a number';
                valid = false;
              }

              break;
            //TODO: userCustomFiled 待处理

            default:
              tips = 'unknown key:' + key;
              valid = false;
              break;
          }
        }

        return {
          valid: valid,
          tips: tips
        };
      }
    }]);

    return Profile;
  }();

  /**
   * 处理profile相关
   * @author qiaoyang
   */

  var ProfileHandler =
  /*#__PURE__*/
  function () {
    function ProfileHandler(userController) {
      _classCallCheck(this, ProfileHandler);

      this.uc = userController;
      this.TAG = 'profile';
      this.Actions = {
        Q: 'query',
        U: 'update'
      };
      this.accountProfileMap = new Map(); // map->(account,profile)

      this.expirationTime = 86400000; // profile过期时间，默认1天，单位毫秒
    }
    /**
     * 设置缓存失效时间
     * @param {*} time 
     */


    _createClass(ProfileHandler, [{
      key: "setExpirationTime",
      value: function setExpirationTime(time) {
        this.expirationTime = time;
      } // 获取用户资料

    }, {
      key: "getUserProfile",
      value: function getUserProfile(options) {
        var _this = this;

        var _this$uc$tim = this.uc.tim,
            connectionController = _this$uc$tim.connectionController,
            outerEmitter = _this$uc$tim.outerEmitter;
        var toAccount = options.userIDList;

        if (!isArray(toAccount)) {
          logger.error('ProfileHandler.getUserProfile options.userIDList 必需是数组');
          return IMPromise.reject({
            code: ERROR_CODE.GET_PROFILE_INVALID_PARAM,
            message: ERROR_MESSAGE.GET_PROFILE_INVALID_PARAM
          });
        }

        options.fromAccount = this.uc.getMyAccount();

        if (toAccount.length > 100) {
          logger.warn('ProfileHandler.getUserProfile 获取用户资料人数不能超过100人');
          toAccount.length = 100;
        }

        var newToAccount = []; // 需要异步查询的账户列表

        var cachedProfileArray = [];
        var tempAccount;

        for (var i = 0, len = toAccount.length; i < len; i++) {
          tempAccount = toAccount[i]; // 非好友，或好友但无好友profile缓存，则需异步拉取

          if (!this.uc.isMyFriend(tempAccount) || !this._containsAccount(tempAccount)) {
            newToAccount.push(tempAccount);
          } else {
            cachedProfileArray.push(this._getProfileFromMap(tempAccount));
          }
        } // 刚好要查询的profile缓存里都有，直接返回


        if (newToAccount.length == 0) {
          outerEmitter.emit(TIM_OUTER_EVENT.PROFILE_GET_SUCCESS, cachedProfileArray); // 事件统一对应数组形式

          return IMPromise.resolve(cachedProfileArray);
        }

        options.toAccount = newToAccount;
        var bFromGetMyProfile = options.bFromGetMyProfile || false;
        var capsule = this.uc.makeCapsule(this.TAG, this.Actions.Q, options);
        var result = connectionController.request(capsule);
        return result.then(function (response) {
          logger.info('ProfileHandler.getUserProfile ok');

          var profileArray = _this._handleResponse(response).concat(cachedProfileArray);

          outerEmitter.emit(TIM_OUTER_EVENT.PROFILE_GET_SUCCESS, profileArray);

          if (bFromGetMyProfile) {
            _this.uc.onGotMyProfile();

            return new IMResponse(profileArray[0]); // getMyProfile 接口返回一个 promise 对象
          }

          return new IMResponse(profileArray); // getUserProfile 接口返回一个包含 promise 对象的数组
        })["catch"](function (error) {
          logger.error('ProfileHandler.getUserProfile error:', error);
          return IMPromise.reject(error, true);
        });
      } // 获取我的个人信息

    }, {
      key: "getMyProfile",
      value: function getMyProfile() {
        var myAccount = this.uc.getMyAccount();
        logger.log('ProfileHandler.getMyProfile myAccount=' + myAccount);

        this._fillMap(); // 先查缓存，有则返回，无则异步获取


        if (this._containsAccount(myAccount)) {
          var myProfile = this._getProfileFromMap(myAccount);

          logger.debug('ProfileHandler.getMyProfile from cache, myProfile:' + JSON.stringify(myProfile));
          var outerEmitter = this.uc.tim.outerEmitter;
          outerEmitter.emit(TIM_OUTER_EVENT.PROFILE_GET_SUCCESS, [myProfile]); // 事件统一对应数组形式

          this.uc.onGotMyProfile();
          return IMPromise.resolve(myProfile);
        }

        var result = this.getUserProfile({
          fromAccount: myAccount,
          userIDList: [myAccount],
          bFromGetMyProfile: true // 此标识为true，表明是 getMyProfile 接口发起的请求

        });
        return result;
      }
      /**
       * 返回包含这些profile对象的数组
       * @param {*} response 
       */

    }, {
      key: "_handleResponse",
      value: function _handleResponse(response) {
        var now = TimeUtil.now();
        var userProfileItem = response.data.userProfileItem;
        var profileArray = [];
        var userID;
        var latestProfile;

        for (var i = 0, len = userProfileItem.length; i < len; i++) {
          // TODO: 这里用resultCode处理可能会更好一些
          if (userProfileItem[i].to == '@TLS#NOT_FOUND' || userProfileItem[i].to == '') {
            // 防御后台的鬼才设计
            continue;
          }

          userID = userProfileItem[i].to; // 这个操作会填充默认值（全量更新）
          // latestProfile = new Profile(this._getLatestProfileFromResponse(userID, userProfileItem[i].profileItem));
          // this._updateMap(userID, latestProfile);

          latestProfile = this._updateMap(userID, this._getLatestProfileFromResponse(userID, userProfileItem[i].profileItem));
          profileArray.push(latestProfile);
        }

        logger.log('ProfileHandler._handleResponse cost ' + (TimeUtil.now() - now) + ' ms');
        return profileArray;
      }
      /**
       * 从server response里获取最新的profile
       * @param {*} userID 用户账号
       * @param {*} profileList [{tag1, value1}, {tag2, value2}, ...]
       */

    }, {
      key: "_getLatestProfileFromResponse",
      value: function _getLatestProfileFromResponse(userID, profileList) {
        var ret = {};
        ret.userID = userID; // profileList可能为undefined，需要做防御

        if (!isEmpty(profileList)) {
          for (var j = 0, length = profileList.length; j < length; j++) {
            switch (profileList[j].tag) {
              case STANDARD_IM_PROFILE.NICK:
                ret.nick = profileList[j].value;
                break;

              case STANDARD_IM_PROFILE.GENDER:
                ret.gender = profileList[j].value;
                break;

              case STANDARD_IM_PROFILE.BIRTHDAY:
                ret.birthday = profileList[j].value;
                break;

              case STANDARD_IM_PROFILE.LOCATION:
                ret.location = profileList[j].value;
                break;

              case STANDARD_IM_PROFILE.SELFSIGNATURE:
                ret.selfSignature = profileList[j].value;
                break;

              case STANDARD_IM_PROFILE.ALLOWTYPE:
                ret.allowType = profileList[j].value;
                break;

              case STANDARD_IM_PROFILE.LANGUAGE:
                ret.language = profileList[j].value;
                break;

              case STANDARD_IM_PROFILE.AVATAR:
                ret.avatar = profileList[j].value;
                break;

              case STANDARD_IM_PROFILE.MESSAGESETTINGS:
                ret.messageSettings = profileList[j].value;
                break;

              case STANDARD_IM_PROFILE.ADMINFORBIDTYPE:
                ret.adminForbidType = profileList[j].value;
                break;

              case STANDARD_IM_PROFILE.LEVEL:
                ret.level = profileList[j].value;
                break;

              case STANDARD_IM_PROFILE.ROLE:
                ret.role = profileList[j].value;
                break;

              default:
                logger.warn('ProfileHandler._handleResponse unkown tag->', profileList[j].tag);
            }
          }
        }

        return ret;
      } // 更新我的资料

    }, {
      key: "updateMyProfile",
      value: function updateMyProfile(options) {
        var _this2 = this;

        var _this$uc$tim2 = this.uc.tim,
            connectionController = _this$uc$tim2.connectionController,
            outerEmitter = _this$uc$tim2.outerEmitter; // 检测传入的配置是否有效

        var profile = new Profile();
        var ret = profile.validate(options);

        if (!ret.valid) {
          logger.error('ProfileHandler.updateMyProfile info:' + ret.tips);
          return IMPromise.reject({
            code: ERROR_CODE.UPDATE_PROFILE_INVALID_PARAM,
            message: ERROR_MESSAGE.UPDATE_PROFILE_INVALID_PARAM
          });
        } // 转为server需要的格式


        var profileItem = [];

        for (var k in options) {
          profileItem.push({
            tag: STANDARD_IM_PROFILE[k.toUpperCase()],
            value: options[k]
          });
        } // 请求并处理


        var capsule = this.uc.makeCapsule(this.TAG, this.Actions.U, {
          fromAccount: this.uc.getMyAccount(),
          profileItem: profileItem
        });
        var result = connectionController.request(capsule);
        return result.then(function (response) {
          logger.info('ProfileHandler.updateMyProfile ok');

          var latestProfile = _this2._updateMap(_this2.uc.getMyAccount(), options);

          outerEmitter.emit(TIM_OUTER_EVENT.PROFILE_UPDATED, [latestProfile]); // 事件统一对应数组形式

          return IMPromise.resolve(latestProfile);
        })["catch"](function (error) {
          logger.error('ProfileHandler.updateMyProfile error:', error);
          return IMPromise.reject(error, true);
        });
      } // 当收到其他用户profile更新的通知时处理

    }, {
      key: "onProfileModified",
      value: function onProfileModified(modifiedData) {
        var data = modifiedData.data;

        if (isEmpty(data)) {
          return;
        }

        var length = data.length;
        logger.info('ProfileHandler.onProfileModified length=' + length);
        var userID;
        var latestProfile;
        var latestProfileArray = [];

        for (var i = 0; i < length; i++) {
          userID = data[i].userID; // 用户有可能在其它端修改自己的profile
          // if (userID == this.uc.getMyAccount()) {
          //   continue;
          // }
          // 先写入内存的map，然后择机写入缓存（不填充默认值，增量更新）

          latestProfile = this._updateMap(userID, this._getLatestProfileFromResponse(userID, data[i].profileList));
          latestProfileArray.push(latestProfile);
        }

        var _this$uc$tim3 = this.uc.tim,
            innerEmitter = _this$uc$tim3.innerEmitter,
            outerEmitter = _this$uc$tim3.outerEmitter;
        innerEmitter.emit(TIM_INNER_EVENT.PROFILE_UPDATED, {
          data: latestProfileArray
        }); // TODO: 后续统一修改

        outerEmitter.emit(TIM_OUTER_EVENT.PROFILE_UPDATED, latestProfileArray); // 事件统一对应数组形式
      } // 读取本地在有效期内的缓存并填充account-profile map

    }, {
      key: "_fillMap",
      value: function _fillMap() {
        if (this.accountProfileMap.size == 0) {
          var cachedProfileArray = this._getCachedProfiles();

          var now = Date.now();

          for (var i = 0, len = cachedProfileArray.length; i < len; i++) {
            if (now - cachedProfileArray[i].lastUpdatedTime < this.expirationTime) {
              this.accountProfileMap.set(cachedProfileArray[i].userID, cachedProfileArray[i]);
            }
          }

          logger.log('ProfileHandler._fillMap from chache, map.size=' + this.accountProfileMap.size);
        }
      } // 更新account-profile map，并调用接口写缓存

    }, {
      key: "_updateMap",
      value: function _updateMap(account, options) {
        var profile;
        var now = Date.now();

        if (!this._containsAccount(account)) {
          // 这个操作会填充默认值（全量更新）
          profile = new Profile(options); // 只存自己和好友的profile

          if (this.uc.isMyFriend(account) || account == this.uc.getMyAccount()) {
            profile.lastUpdatedTime = now;
            this.accountProfileMap.set(account, profile);
          }
        } else {
          profile = this._getProfileFromMap(account);
          deepMerge(profile, options);
          profile.lastUpdatedTime = now;
        }

        this._flushMap();

        return profile;
      } // 将account-profile map的内容写入本地缓存（全量更新）

    }, {
      key: "_flushMap",
      value: function _flushMap() {
        this._cacheProfiles(_toConsumableArray(this.accountProfileMap.values()));
      } // account-profile map是否有缓存指定account的profile

    }, {
      key: "_containsAccount",
      value: function _containsAccount(account) {
        return this.accountProfileMap.has(account);
      } // 从account-profile map读取指定account的profile

    }, {
      key: "_getProfileFromMap",
      value: function _getProfileFromMap(account) {
        return this.accountProfileMap.get(account);
      } // 从本地缓存里读取profile

    }, {
      key: "_getCachedProfiles",
      value: function _getCachedProfiles() {
        var storage = this.uc.tim.storage;
        var cachedProfileArray = storage.getItem(this.TAG);

        if (isEmpty(cachedProfileArray)) {
          return [];
        }

        return cachedProfileArray;
      } // 存储最新的profile到本地

    }, {
      key: "_cacheProfiles",
      value: function _cacheProfiles(profileArray) {
        var storage = this.uc.tim.storage;
        logger.debug('ProfileHandler._cacheProfiles length=' + profileArray.length);
        storage.setItem(this.TAG, profileArray);
      } // 收到会话列表发过来的Profile更新通知。如果userID对应的profile在map里不存在，则拉取最新的，成功后好友资料保存到map
      // 如果userID对应的profile在map里存在，但nick或avatar跟map里保存的不同，则表明用户的profile有更新，拉取最新的，成功后好友资料保存到map

    }, {
      key: "onConversationsProfileUpdated",
      value: function onConversationsProfileUpdated(profileArray) {
        var tempObj;
        var userID;
        var toAccount = [];
        var currentProfile;

        for (var i = 0, length = profileArray.length; i < length; i++) {
          tempObj = profileArray[i];
          userID = tempObj.userID;

          if (!this._containsAccount(userID)) {
            toAccount.push(tempObj.userID);
          } else {
            currentProfile = this._getProfileFromMap(userID); // 有合并项，说明本地保存的profile已经过时了，需要拉取最新的

            if (deepMerge(currentProfile, tempObj) > 0) {
              toAccount.push(userID);
            }
          }
        }

        if (toAccount.length == 0) {
          return;
        }

        logger.info('ProfileHandler.onConversationsProfileUpdated toAccount:', toAccount);
        this.getUserProfile({
          userIDList: toAccount
        });
      }
    }, {
      key: "reset",
      value: function reset() {
        this._flushMap();

        this.accountProfileMap.clear();
      }
    }]);

    return ProfileHandler;
  }();

  /**
   * 用于打点测试,可以用于函数、流程的性能分析
   * @example
   * var p= new Pointer(true);
   * p.newTask('taskName');
   * //xxxx code
   * p.dot('pointerName01', 'taskName');
   * //logic coding....
   * p.dot('pointerName02', 'taskName');
   * p.report('taskName');
   */
  var Pointer =
  /*#__PURE__*/
  function () {
    function Pointer(tim) {
      _classCallCheck(this, Pointer);

      // this.pointsList = [];
      this.options = tim ? tim.options : {
        enablePointer: true
      };
      this.pointsList = {};
      this.reportText = {};
      this.maxNameLen = 0;
      this.gapChar = '-';
      this.log = console.log;
      this.currentTask = '';
    }
    /**
     * 创建新的打点任务
     * @param {*} taskName 
     */


    _createClass(Pointer, [{
      key: "newTask",
      value: function newTask(taskName) {
        if (this.options.enablePointer === false) {
          return;
        }

        if (!taskName) {
          taskName = ['task', this._timeFormat()].join('-');
        }

        this.pointsList[taskName] = [];
        this.currentTask = taskName;
        console.log("Pointer new Task : ".concat(this.currentTask));
      }
      /**
       * 删除掉某一个任务
       * @param {*} taskName 
       */

    }, {
      key: "deleteTask",
      value: function deleteTask(taskName) {
        if (this.options.enablePointer === false) {
          return;
        }

        if (!taskName) {
          taskName = this.currentTask;
        }

        this.pointsList[taskName].length = 0;
        delete this.pointsList[taskName];
      }
      /**
       * 打点，`pointerName`将会记录到`pointsList`中
       * @param {String} pointerName
       */

    }, {
      key: "dot",
      value: function dot() {
        var pointerName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
        var taskName = arguments.length > 1 ? arguments[1] : undefined;

        if (this.options.enablePointer === false) {
          return;
        }

        taskName = taskName ? taskName : this.currentTask;
        var time = +new Date();
        this.maxNameLen = this.maxNameLen < pointerName.length ? pointerName.length : this.maxNameLen;
        this.flen = this.maxNameLen + 10;
        this.pointsList[taskName].push({
          pointerName: pointerName,
          time: time
        });
      }
      /**
       * 分析打点结果，生成汇总数据
       * @name _analisys
       * @private
       * @param {String} taskName - 任务名称
       */

    }, {
      key: "_analisys",
      value: function _analisys(taskName) {
        if (this.options.enablePointer === false) {
          return;
        }

        taskName = taskName ? taskName : this.currentTask;
        var list = this.pointsList[taskName];
        var len = list.length;
        var tempArr = [];
        var tmpArr = [];

        for (var i = 0; i < len; i++) {
          if (i === 0) {
            continue;
          }

          tmpArr = this._analisysTowPoints(list[i - 1], list[i]);
          tempArr.push(tmpArr.join(''));
        }

        tmpArr = this._analisysTowPoints(list[0], list[len - 1], true);
        tempArr.push(tmpArr.join(''));
        return tempArr.join('');
      }
    }, {
      key: "_analisysTowPoints",
      value: function _analisysTowPoints(last, curr) {
        var color = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

        if (this.options.enablePointer === false) {
          return;
        }

        var flen = this.flen;
        var timeDiff = curr.time - last.time;
        var timtStr = timeDiff.toString();
        var v1 = last.pointerName + this.gapChar.repeat(flen - last.pointerName.length);
        var v2 = curr.pointerName + this.gapChar.repeat(flen - curr.pointerName.length);
        var v3 = this.gapChar.repeat(4 - timtStr.length) + timtStr;
        var tmpArr = color ? ['%c', v1, v2, v3, 'ms\n%c'] : [v1, v2, v3, 'ms\n'];
        return tmpArr;
      }
      /**
       * 输出当前任务的分析数据
       * @param {String} taskName
       */

    }, {
      key: "report",
      value: function report(taskName) {
        if (this.options.enablePointer === false) {
          return;
        }

        taskName = taskName ? taskName : this.currentTask;

        var reportText = this._analisys(taskName);

        this.pointsList = []; // let title = taskName

        var time = this._timeFormat();

        var title = "Pointer[".concat(taskName, "(").concat(time, ")]");
        var maxLen = this.maxNameLen * 4;
        var hafLen = (maxLen - title.length) / 2;
        console.log(['-'.repeat(hafLen), title, '-'.repeat(hafLen)].join(''));
        console.log('%c' + reportText, 'color:#66a', 'color:red', 'color:#66a');
        console.log('-'.repeat(maxLen));
      }
    }, {
      key: "_timeFormat",
      value: function _timeFormat() {
        var date = new Date();
        var m = this.zeroFix(date.getMonth() + 1, 2);
        var d = this.zeroFix(date.getDate(), 2);
        return "".concat(m, "-").concat(d, " ").concat(date.getHours(), ":").concat(date.getSeconds(), ":").concat(date.getMinutes(), "~").concat(date.getMilliseconds());
      }
    }, {
      key: "zeroFix",
      value: function zeroFix(num, length) {
        return ('000000000' + num).slice(-length);
      }
      /**
       *输出所有任务的报告
       */

    }, {
      key: "reportAll",
      value: function reportAll() {
        if (this.options.enablePointer === false) {
          return;
        }

        for (var taskName in this.pointsList) {
          this.eport(taskName);
        }
      }
    }]);

    return Pointer;
  }();

  var Friend = function Friend(userID, snsProfileItem) {
    _classCallCheck(this, Friend);

    this.userID = userID;
    var ret = {};
    ret.userID = userID; // snsProfileItem可能为undefined，需要做防御

    if (!isEmpty(snsProfileItem)) {
      for (var j = 0, length = snsProfileItem.length; j < length; j++) {
        switch (snsProfileItem[j].tag) {
          case STANDARD_IM_PROFILE.NICK:
            ret.nick = snsProfileItem[j].value;
            break;

          case STANDARD_IM_PROFILE.GENDER:
            ret.gender = snsProfileItem[j].value;
            break;

          case STANDARD_IM_PROFILE.BIRTHDAY:
            ret.birthday = snsProfileItem[j].value;
            break;

          case STANDARD_IM_PROFILE.LOCATION:
            ret.location = snsProfileItem[j].value;
            break;

          case STANDARD_IM_PROFILE.SELFSIGNATURE:
            ret.selfSignature = snsProfileItem[j].value;
            break;

          case STANDARD_IM_PROFILE.ALLOWTYPE:
            ret.allowType = snsProfileItem[j].value;
            break;

          case STANDARD_IM_PROFILE.LANGUAGE:
            ret.language = snsProfileItem[j].value;
            break;

          case STANDARD_IM_PROFILE.AVATAR:
            ret.avatar = snsProfileItem[j].value;
            break;

          case STANDARD_IM_PROFILE.MESSAGESETTINGS:
            ret.messageSettings = snsProfileItem[j].value;
            break;

          case STANDARD_IM_PROFILE.ADMINFORBIDTYPE:
            ret.adminForbidType = snsProfileItem[j].value;
            break;

          case STANDARD_IM_PROFILE.LEVEL:
            ret.level = snsProfileItem[j].value;
            break;

          case STANDARD_IM_PROFILE.ROLE:
            ret.role = snsProfileItem[j].value;
            break;

          default:
            logger.warn('snsProfileItem unkown tag->', snsProfileItem[j].tag);
        }
      }
    }

    this.profile = new Profile(ret);
  };

  /**
   * 处理friend相关
   */

  var FriendHandler =
  /*#__PURE__*/
  function () {
    function FriendHandler(userController) {
      _classCallCheck(this, FriendHandler);

      this.uc = userController;
      this.TAG = 'friend';
      this.Actions = {
        G: 'get',
        D: 'delete'
      };
      this.friends = new Map();
      this.pointer = new Pointer();
    }
    /**
     * 判断某用户是否为我的朋友
     * @param {*} userID 
     */


    _createClass(FriendHandler, [{
      key: "isMyFriend",
      value: function isMyFriend(userID) {
        var ret = this.friends.has(userID);

        if (!ret) {
          logger.debug('FriendHandler.isMyFriend ' + userID + ' is not my friend');
        }

        return ret;
      }
    }, {
      key: "_transformFriendList",
      value: function _transformFriendList(data) {
        if (isEmpty(data) || isEmpty(data.infoItem)) {
          // poor boy，一个朋友也没有...
          return;
        }

        logger.info('FriendHandler._transformFriendList friendNum=' + data.friendNum);
        var infoItems = data.infoItem;
        var friend;
        var userID;

        for (var i = 0, length = infoItems.length; i < length; i++) {
          userID = infoItems[i].infoAccount;
          friend = new Friend(userID, infoItems[i].snsProfileItem);
          this.friends.set(userID, friend);
        }
      }
    }, {
      key: "_friends2map",
      value: function _friends2map(friends) {
        var map = new Map();

        for (var friend in friends) {
          map.set(friend, friends[friend]);
        }

        return map;
      }
      /**
       * @description 拉取我的好友列表 [详细的参数信息]{@link https://cloud.tencent.com/document/product/269/1647}
       * @param {Object} options - 请求参数
       * @param {Array.<string>} options.tagList - 必填 指定要拉取的字段 Tag
       * @param {Number} [options.startIndex=0] - 选填 拉取的开始位置
       * @param {Number} [options.lastStandardSequence=0] - 选填 上次拉取标配关系链的 Sequence，仅在只拉取标配关系链字段时有用
       * @param {Number} [options.getCount=100] - 选填 每页需要拉取的好友数量
       * @returns {Promise}
       */

    }, {
      key: "getFriendList",
      value: function getFriendList() {
        var _this = this;

        var _this$uc$tim = this.uc.tim,
            connectionController = _this$uc$tim.connectionController,
            outerEmitter = _this$uc$tim.outerEmitter; // 不管外面的fromAccount填的是谁，强行设置为“我”的，避免查到别人的好友关系

        var options = {};
        options.fromAccount = this.uc.getMyAccount();
        logger.info('FriendHandler.getFriendList myAccount=' + options.fromAccount);
        var capsule = this.uc.makeCapsule(this.TAG, this.Actions.G, options);
        var result = connectionController.request(capsule);
        return result.then(function (response) {
          logger.info('FriendHandler.getFriendList ok');

          _this._transformFriendList(response.data);

          var friendsArray = _toConsumableArray(_this.friends.values());

          outerEmitter.emit(TIM_OUTER_EVENT.FRIENDLIST_GET_SUCCESS, friendsArray);
          return IMPromise.resolve(friendsArray);
        })["catch"](function (error) {
          logger.error('FriendHandler.getFriendList error:', error);
          return IMPromise.reject(error, true);
        });
      }
      /**
       * 删除好友
       *
       * @param {Object} options
       * @param {array} options.toAccount - 待删除的好友的 Identifier 列表，单次请求的 To_Account 数不得超过 1000
       * @param {String} options.deleteType - 删除模式，[详情参考]{@link https://cloud.tencent.com/document/product/269/1501#.E5.88.A0.E9.99.A4.E5.A5.BD.E5.8F.8B}
       * @memberOf UserController
       * @returns {Promise}
       * @example
       * app.userController.deleteFriend({
        *  toAccount: ['User4Test02'],
        *  deleteType: 'CheckResult_Type_Singal'
        * })
        */

    }, {
      key: "deleteFriend",
      value: function deleteFriend(options) {
        if (!Array.isArray(options.toAccount)) {
          logger.error('FriendHandler.deleteFriend options.toAccount 必需是数组');
          return IMPromise.reject({
            code: ERROR_CODE.DEL_FRIEND_INVALID_PARAM,
            message: ERROR_MESSAGE.DEL_FRIEND_INVALID_PARAM
          });
        }

        if (options.toAccount.length > 1000) {
          logger.warn('FriendHandler.deleteFriend 删除好友人数不能超过1000人');
          options.toAccount.length = 1000;
        }

        var _this$uc$tim2 = this.uc.tim,
            connectionController = _this$uc$tim2.connectionController,
            outerEmitter = _this$uc$tim2.outerEmitter;
        var capsule = this.uc.makeCapsule(this.TAG, this.Actions.D, options);
        var result = connectionController.request(capsule);
        return result.then(function (response) {
          logger.info('FriendHandler.deleteFriend ok');
          outerEmitter.emit(TIM_OUTER_EVENT.FRIEND_DELETE_SUCCESS);
          return IMPromise.resolve();
        })["catch"](function (error) {
          logger.error('FriendHandler.deleteFriend error:', error);
          return IMPromise.reject(error, true);
        });
      }
    }]);

    return FriendHandler;
  }();

  /**
   * 黑名单的具体信息，描述用户id，及该id被添加到黑名单的时间戳
   * @class BannedAccount
   * @param {Object} options
   * @param {String} options.userID 用户账号
   * @param {String} options.timeStamp 添加到黑名单的时间
   */

  var BannedInfo = function BannedInfo(options) {
    _classCallCheck(this, BannedInfo);

    if (!isEmpty) {
      this.userID = options.userID || '';
      this.timeStamp = options.timeStamp || 0;
    }
  };

  /**
   * 处理黑名单相关
   */

  var BlacklistHandler =
  /*#__PURE__*/
  function () {
    function BlacklistHandler(userController) {
      _classCallCheck(this, BlacklistHandler);

      this.uc = userController;
      this.TAG = 'blacklist';
      this.Actions = {
        G: 'get',
        C: 'create',
        D: 'delete'
      };
      this.blacklistMap = new Map();
      this.startIndex = 0;
      this.maxLimited = 100;
      this.curruentSequence = 0;
    } // 获取黑名单


    _createClass(BlacklistHandler, [{
      key: "getBlacklist",
      value: function getBlacklist() {
        var _this = this;

        var connectionController = this.uc.tim.connectionController;
        var options = {};
        options.fromAccount = this.uc.getMyAccount();
        options.maxLimited = this.maxLimited; // 每页最多拉取的黑名单数

        options.startIndex = 0; // 拉取的起始位置

        options.lastSequence = this.curruentSequence; // 上一次拉黑名单时后台返回给客户端的 Seq，初次拉取时为0

        var capsule = this.uc.makeCapsule(this.TAG, this.Actions.G, options);
        var result = connectionController.request(capsule);
        return result.then(function (response) {
          logger.info('BlacklistHandler.getBlacklist ok');
          _this.curruentSequence = response.data.curruentSequence; // 黑名单最新的 Seq

          _this._handleResponse(response.data.blackListItem, true);

          return _this._onBlacklistUpdated();
        })["catch"](function (error) {
          logger.error('BlacklistHandler.getBlacklist error:', error);
          return IMPromise.reject(error, true);
        });
      } // 增加黑名单

    }, {
      key: "addBlacklist",
      value: function addBlacklist(options) {
        var _this2 = this;

        if (!isArray(options.userIDList)) {
          logger.error('BlacklistHandler.addBlacklist options.userIDList 必需是数组');
          return IMPromise.reject({
            code: ERROR_CODE.ADD_BLACKLIST_INVALID_PARAM,
            message: ERROR_MESSAGE.ADD_BLACKLIST_INVALID_PARAM
          });
        }

        var selfUserID = this.uc.tim.loginInfo.identifier; // 不能把自己拉进黑名单

        if (options.userIDList.length === 1 && options.userIDList[0] === selfUserID) {
          logger.error('BlacklistHandler.addBlacklist 不能把自己拉黑');
          return IMPromise.reject({
            code: ERROR_CODE.CANNOT_ADD_SELF_TO_BLACKLIST,
            message: ERROR_MESSAGE.CANNOT_ADD_SELF_TO_BLACKLIST
          });
        } // 若批量拉黑，且有自己，过滤掉即可


        if (options.userIDList.includes(selfUserID)) {
          options.userIDList = options.userIDList.filter(function (userID) {
            return userID !== selfUserID;
          });
          logger.warn('BlacklistHandler.addBlacklist 不能把自己拉黑，已过滤');
        }

        var connectionController = this.uc.tim.connectionController;
        options.fromAccount = this.uc.getMyAccount();
        options.toAccount = options.userIDList;
        var capsule = this.uc.makeCapsule(this.TAG, this.Actions.C, options);
        var result = connectionController.request(capsule);
        return result.then(function (response) {
          logger.info('BlacklistHandler.addBlacklist ok');

          _this2._handleResponse(response.data.resultItem, true);

          return _this2._onBlacklistUpdated();
        })["catch"](function (error) {
          logger.error('BlacklistHandler.addBlacklist error:', error);
          return IMPromise.reject(error, true);
        });
      } // 处理服务器响应数据，bAdd为true，表示往blacklistMap里插入数据，false表示从blacklistMap删除数据

    }, {
      key: "_handleResponse",
      value: function _handleResponse(items, bAdd) {
        if (!isEmpty(items)) {
          var bannedInfo;
          var userID;
          var resultCode; // 服务器返回的结果码

          for (var i = 0, length = items.length; i < length; i++) {
            userID = items[i].to;
            resultCode = items[i].resultCode;

            if (isUndefined(resultCode) || resultCode == 0) {
              if (bAdd) {
                // add
                !this.blacklistMap.has(userID) ? bannedInfo = new BannedInfo() : bannedInfo = this.blacklistMap.get(userID);
                bannedInfo.userID = userID;
                !isEmpty(items[i].addBlackTimeStamp) && (bannedInfo.timeStamp = items[i].addBlackTimeStamp);
                this.blacklistMap.set(userID, bannedInfo);
              } else {
                // remove
                if (this.blacklistMap.has(userID)) {
                  bannedInfo = this.blacklistMap.get(userID);
                  this.blacklistMap["delete"](userID);
                }
              }
            }
          }
        }

        logger.log('BlacklistHandler._handleResponse total=' + this.blacklistMap.size + ' bAdd=' + bAdd);
      } // 删除黑名单

    }, {
      key: "deleteBlacklist",
      value: function deleteBlacklist(options) {
        var _this3 = this;

        if (!isArray(options.userIDList)) {
          logger.error('BlacklistHandler.deleteBlacklist options.userIDList 必需是数组');
          return IMPromise.reject({
            code: ERROR_CODE.DEL_BLACKLIST_INVALID_PARAM,
            message: ERROR_MESSAGE.DEL_BLACKLIST_INVALID_PARAM
          });
        }

        var connectionController = this.uc.tim.connectionController;
        options.fromAccount = this.uc.getMyAccount();
        options.toAccount = options.userIDList;
        var capsule = this.uc.makeCapsule(this.TAG, this.Actions.D, options);
        var result = connectionController.request(capsule);
        return result.then(function (response) {
          logger.info('BlacklistHandler.deleteBlacklist ok');

          _this3._handleResponse(response.data.resultItem, false);

          return _this3._onBlacklistUpdated();
        })["catch"](function (error) {
          logger.error('BlacklistHandler.deleteBlacklist error:', error);
          return IMPromise.reject(error, true);
        });
      }
    }, {
      key: "_onBlacklistUpdated",
      value: function _onBlacklistUpdated() {
        var outerEmitter = this.uc.tim.outerEmitter; // 全量黑名单

        var bannedAccounts = _toConsumableArray(this.blacklistMap.keys());

        outerEmitter.emit(TIM_OUTER_EVENT.BLACKLIST_UPDATED, bannedAccounts);
        return IMPromise.resolve(bannedAccounts);
      } // 处理从黑名单删除账号的通知

    }, {
      key: "handleBlackListDelAccount",
      value: function handleBlackListDelAccount(accounts) {
        var delUserIDList = [];
        var userID;

        for (var i = 0, length = accounts.length; i < length; i++) {
          userID = accounts[i];

          if (this.blacklistMap.has(userID)) {
            this.blacklistMap["delete"](userID);
            delUserIDList.push(userID);
          }
        } // 有更新才派发事件


        if (delUserIDList.length > 0) {
          logger.log('BlacklistHandler.handleBlackListDelAccount delCount=' + delUserIDList.length + ' : ' + delUserIDList.join(','));
          this.tim.outerEmitter.emit(TIM_OUTER_EVENT.BLACKLIST_UPDATED, _toConsumableArray(this.blacklistMap.keys()));
        }
      } // 处理添加账号到黑名单的通知

    }, {
      key: "handleBlackListAddAccount",
      value: function handleBlackListAddAccount(accounts) {
        var addUserIDList = [];
        var userID;

        for (var i = 0, length = accounts.length; i < length; i++) {
          userID = accounts[i];

          if (!this.blacklistMap.has(userID)) {
            this.blacklistMap.set(userID, new BannedInfo({
              userID: userID
            }));
            addUserIDList.push(userID);
          }
        } // 有更新才派发事件


        if (addUserIDList.length > 0) {
          logger.log('BlacklistHandler.handleBlackListAddAccount addCount=' + addUserIDList.length + ' : ' + addUserIDList.join(','));
          this.tim.outerEmitter.emit(TIM_OUTER_EVENT.BLACKLIST_UPDATED, _toConsumableArray(this.blacklistMap.keys()));
        }
      }
    }, {
      key: "reset",
      value: function reset() {
        this.blacklistMap.clear();
        this.startIndex = 0;
        this.maxLimited = 100;
        this.curruentSequence = 0;
      }
    }]);

    return BlacklistHandler;
  }();

  /**
   * 处理申请相关
   */

  var ApplyC2CHandler =
  /*#__PURE__*/
  function () {
    function ApplyC2CHandler(userController) {
      _classCallCheck(this, ApplyC2CHandler);

      this.uc = userController;
      this.TAG = 'applyC2C';
      this.Actions = {
        C: 'create',
        G: 'get',
        D: 'delete',
        U: 'update'
      };
    }
    /**
     * 申请添加好友，
     * @description [详细的参数信息]{@link https://cloud.tencent.com/document/product/269/1643#.E8.AF.B7.E6.B1.82.E5.8C.85.E5.AD.97.E6.AE.B5.E8.AF.B4.E6.98.8E}
     * @param {Object} options - 添加好友的参数配置
     * @param {Array} options.addFriendItem - 必填，添加好友的对象结构
     * @param {String} options.addFriendItem.toAccount - 必填，需要添加的好友identifier
     * @param {String} options.addFriendItem.remark - 选填，备注信息
     * @param {String} options.addFriendItem.groupName - 选填，分组名称
     * @param {String} options.addFriendItem.addSource - 选填，好友来源
     * @param {String} options.addFriendItem.addWording - 选填，附言信息
     * @param {String} options.addType - 选填，加好友方式，单向加好友："Add_Type_Single"; 双向加好友:"Add_Type_Both"，默认为"Add_Type_Both"
     * @param {String} options.forceAddFlags - 选填，管理员强制加好友标记：1 表示强制加好友；0 表示常规加好友方式
     * @fires TIM_EVENT.APPLY.ADD_FRIEND.SUCCESS
     * @fires TIM_EVENT.APPLY.ADD_FRIEND.FAIL
     * @returns {Promise}
     * @throws {IMError}
     */


    _createClass(ApplyC2CHandler, [{
      key: "applyAddFriend",
      value: function applyAddFriend(options) {
        var _this = this;

        var _this$uc$tim = this.uc.tim,
            outerEmitter = _this$uc$tim.outerEmitter,
            connectionController = _this$uc$tim.connectionController;
        var capsule = this.uc.makeCapsule(this.TAG, this.Actions.C, options);
        var result = connectionController.request(capsule);
        result.then(function (response) {
          if (_this.uc.isActionSuccessful('applyAddFriend', _this.Actions.C, response)) {
            outerEmitter.emit(TIM_OUTER_EVENT.APPLY_ADD_FRIEND_SUCCESS, {
              data: response.data
            });
          } else {
            outerEmitter.emit(TIM_OUTER_EVENT.APPLY_ADD_FRIEND_FAIL, {
              data: response.data
            });
          }
        })["catch"](function (error) {
          outerEmitter.emit(TIM_OUTER_EVENT.APPLY_ADD_FRIEND_FAIL, {
            data: error
          });
        });
        return result;
      }
      /**
       * 获取未受理的好友申请
       *
       * @param {Object} options
       * @param {String} [options.pendencyType='Pendency_Type_ComeIn'] - Pendency_Type_ComeIn: 别人发给我的; Pendency_Type_SendOut: 我发给别人的
       * @param {Number} [options.startTime=0] - 好友申请的起始时间
       * @param {Number} [options.maxLimited=30] - 分页大小，如果取值为30 则表示客户端要求服务器端每页最多返回30个好友申请
       * @param {Number} [options.lastSequence=0] - 好友申请数据的版本号，用户每收到或删除一条好友申请，服务器端就自增一次好友申请数据版本号，一般传0，表示拉取最新的数据
       * @returns {Promise}
       * @memberof UserController
       */

    }, {
      key: "getPendency",
      value: function getPendency(options) {
        var _this2 = this;

        var _this$tim = this.tim,
            connectionController = _this$tim.connectionController,
            outerEmitter = _this$tim.outerEmitter;
        var capsule = this.uc.makeCapsule(this.TAG, this.Actions.G, options);
        var result = connectionController.request(capsule);
        result.then(function (response) {
          if (_this2.uc.isActionSuccessful('getPendency', _this2.Actions.G, response)) {
            outerEmitter.emit(TIM_OUTER_EVENT.GET_PENDENCY_SUCCESS, {
              data: response.data
            });
          } else {
            outerEmitter.emit(TIM_OUTER_EVENT.GET_PENDENCY_FAIL, {
              data: response.data
            });
          }
        })["catch"](function (error) {
          outerEmitter.emit(TIM_OUTER_EVENT.GET_PENDENCY_FAIL, {
            data: error
          });
        });
        return result;
      }
      /**
       * 删除好友申请
       *
       * @param {Object} options
       * @param {string[]} options.toAccount - 用户账号或昵称
       * @param {String} [options.pendencyType='Pendency_Type_ComeIn'] - Pendency_Type_ComeIn: 别人发给我的; Pendency_Type_SendOut: 我发给别人的
       * @returns {Promise}
       * @memberof UserController
       */

    }, {
      key: "deletePendency",
      value: function deletePendency(options) {
        var _this3 = this;

        var _this$tim2 = this.tim,
            connectionController = _this$tim2.connectionController,
            outerEmitter = _this$tim2.outerEmitter;
        var capsule = this.uc.makeCapsule(this.TAG, this.Actions.D, options);
        var result = connectionController.request(capsule);
        result.then(function (response) {
          if (_this3.uc.isActionSuccessful('deletePendency', _this3.Actions.D, response)) {
            outerEmitter.emit(TIM_OUTER_EVENT.DELETE_PENDENCY_SUCCESS, {
              data: response.data
            });
          } else {
            outerEmitter.emit(TIM_OUTER_EVENT.DELETE_PENDENCY_FAIL, {
              data: response.data
            });
          }
        })["catch"](function (error) {
          outerEmitter.emit(TIM_OUTER_EVENT.DELETE_PENDENCY_FAIL, {
            data: error
          });
        });
        return result;
      }
      /**
       *
       *
       * @param {Object} options - 请求参数
       * @param {String} options.toAccount - 目标用户名
       * @param {Number} options.action - 0（同意） / 1（同意并加为好友）/ -1 (拒绝)
       * @param {Object[]} [options.items] - 可选字段，用于批量处理好友申请。当使用该字段时则options.toAccount和options.action失效。
       * @param {String} [options.items.toAccount] - 目标用户名
       * @param {Number} [options.items.action] - 0（同意） / 1（同意并加为好友）/ -1 (拒绝)
       * @returns {Promise}
       * @memberof UserController
       */

    }, {
      key: "replyPendency",
      value: function replyPendency() {
        var _this4 = this;

        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var _this$tim3 = this.tim,
            connectionController = _this$tim3.connectionController,
            outerEmitter = _this$tim3.outerEmitter;
        var capsule = this.uc.makeCapsule(this.TAG, this.Actions.U, options);
        var result = connectionController.request(capsule);
        result.then(function (response) {
          if (_this4.uc.isActionSuccessful('replyPendency', _this4.Actions.U, response)) {
            outerEmitter.emit(TIM_OUTER_EVENT.REPLY_PENDENCY_SUCCESS, {
              data: response.data
            });
          } else {
            outerEmitter.emit(TIM_OUTER_EVENT.REPLY_PENDENCY_FAIL, {
              data: response.data
            });
          }
        })["catch"](function (error) {
          outerEmitter.emit(TIM_OUTER_EVENT.REPLY_PENDENCY_FAIL, {
            data: error
          });
        });
        return result;
      }
    }]);

    return ApplyC2CHandler;
  }();

  /**
   * 用户资料类，管理profile friends blacklist apply等
   * @class
   * @extends IMController
   * @uses TransportCapsule
   */

  var UserController =
  /*#__PURE__*/
  function (_IMController) {
    _inherits(UserController, _IMController);

    /**
     * @constructor
     * @param { TIM } tim
     */
    function UserController(tim) {
      var _this;

      _classCallCheck(this, UserController);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(UserController).call(this, tim));
      _this.profileHandler = new ProfileHandler(_assertThisInitialized(_this));
      _this.friendHandler = new FriendHandler(_assertThisInitialized(_this));
      _this.blacklistHandler = new BlacklistHandler(_assertThisInitialized(_this));
      _this.applyC2CHandler = new ApplyC2CHandler(_assertThisInitialized(_this));

      _this._initializeListener();

      return _this;
    }

    _createClass(UserController, [{
      key: "_initializeListener",
      value: function _initializeListener(event) {
        var innerEmitter = this.tim.innerEmitter; // 登录态变更时触发，登录成功必触发一次

        innerEmitter.on(TIM_INNER_EVENT.CONTEXT_A2KEY_AND_TINYID_UPDATED, this.onContextUpdated, this);
        innerEmitter.on(TIM_INNER_EVENT.NOTICE_LONGPOLL_PROFILE_MODIFIED, this.onProfileModified, this);
        innerEmitter.on(TIM_INNER_EVENT.NOTICE_LONGPOLL_NEW_FRIEND_MESSAGES, this.onNewFriendMessages, this);
        innerEmitter.on(TIM_INNER_EVENT.CONVERSATION_LIST_PROFILE_UPDATED, this.onConversationsProfileUpdated, this);
      }
    }, {
      key: "onContextUpdated",
      value: function onContextUpdated(event) {
        // 在 context.a2Key 和 context.tinyID 没赋值的情况下， 不继续执行查询。
        var context = event.data.context; // event.data.context -> tim.context

        if (!!context.a2Key === false || !!context.tinyID === false) {
          return;
        }

        this.profileHandler.getMyProfile();
        this.friendHandler.getFriendList();
        this.blacklistHandler.getBlacklist();
      } // 获取个人资料成功，triggerReady

    }, {
      key: "onGotMyProfile",
      value: function onGotMyProfile() {
        this.triggerReady();
      }
    }, {
      key: "onProfileModified",
      value: function onProfileModified(event) {
        this.profileHandler.onProfileModified(event);
      }
    }, {
      key: "onNewFriendMessages",
      value: function onNewFriendMessages(event) {
        logger.debug('onNewFriendMessages', JSON.stringify(event.data));

        if (!isEmpty(event.data.blackListDelAccount)) {
          this.blacklistHandler.handleBlackListDelAccount(event.data.blackListDelAccount);
        }

        if (!isEmpty(event.data.blackListAddAccount)) {
          this.blacklistHandler.handleBlackListAddAccount(event.data.blackListAddAccount);
        }
      }
    }, {
      key: "onConversationsProfileUpdated",
      value: function onConversationsProfileUpdated(event) {
        this.profileHandler.onConversationsProfileUpdated(event.data);
      } // 获取我的账号

    }, {
      key: "getMyAccount",
      value: function getMyAccount() {
        return this.tim.context.identifier;
      }
    }, {
      key: "isMyFriend",
      value: function isMyFriend(userID) {
        return this.friendHandler.isMyFriend(userID);
      } // 生成一个用于请求的“胶囊”对象

    }, {
      key: "makeCapsule",
      value: function makeCapsule(name, action, options) {
        return this.createPackage({
          name: name,
          action: action,
          param: options
        });
      } // 拉取个人资料

    }, {
      key: "getMyProfile",
      value: function getMyProfile() {
        return this.profileHandler.getMyProfile();
      } // 拉取其他用户资料（也可用于搜索用户）

    }, {
      key: "getUserProfile",
      value: function getUserProfile(options) {
        return this.profileHandler.getUserProfile(options);
      } // 更新个人资料

    }, {
      key: "updateMyProfile",
      value: function updateMyProfile(options) {
        return this.profileHandler.updateMyProfile(options);
      } // 拉取我的好友列表

    }, {
      key: "getFriendList",
      value: function getFriendList() {
        return this.friendHandler.getFriendList();
      }
      /**
       * 删除好友
       *
       * @param {Object} options
       * @param {array} options.toAccount - 待删除的好友的 Identifier 列表，单次请求的 To_Account 数不得超过 1000
       * @param {String} options.deleteType - 删除模式，[详情参考]{@link https://cloud.tencent.com/document/product/269/1501#.E5.88.A0.E9.99.A4.E5.A5.BD.E5.8F.8B}
       * @memberOf UserController
       * @returns {Promise}
       * @example
       * app.userController.deleteFriend({
       *  toAccount: ['User4Test02'],
       *  deleteType: 'CheckResult_Type_Singal'
       * })
       */

    }, {
      key: "deleteFriend",
      value: function deleteFriend(options) {
        return this.friendHandler.deleteFriend(options);
      } // 获取黑名单

    }, {
      key: "getBlacklist",
      value: function getBlacklist() {
        return this.blacklistHandler.getBlacklist();
      } // 增加黑名单

    }, {
      key: "addBlacklist",
      value: function addBlacklist(options) {
        return this.blacklistHandler.addBlacklist(options);
      } // 删除黑名单

    }, {
      key: "deleteBlacklist",
      value: function deleteBlacklist(options) {
        return this.blacklistHandler.deleteBlacklist(options);
      }
      /**
       * 添加好友申请
       * @param { array.<[{To_Account: string, Remark: string, GroupName: string, AddSource: string, AddWording: string}]> } options - 添加好友信息的结构数组，详情请参考：{@link https://cloud.tencent.com/document/product/269/1643#.E8.AF.B7.E6.B1.82.E5.8C.85.E5.AD.97.E6.AE.B5.E8.AF.B4.E6.98.8E | 添加好友API}
       * @param {String} options[n].To_Account - 必填，添加的好友的账号
       * @param {String} options[n].Remark - 选填，备注
       * @param {String} options[n].GroupName - 选填，分组信息
       * @param {String} options[n].AddSource - 选填，好友来源
       * @param {String} options[n].AddWording - 选填，附言
       * @param {String} options.AddType - 选填，加好友方式，"Add_Type_Single" 表示单向加好友，"Add_Type_Both"表示双向加好友，默认为"Add_Type_Both"
       * @description
       */

    }, {
      key: "applyAddFriend",
      value: function applyAddFriend(options) {
        return this.applyC2CHandler.applyAddFriend(options);
      }
      /**
       * 获取未受理的好友申请
       *
       * @param {Object} options
       * @param {String} [options.pendencyType='Pendency_Type_ComeIn'] - Pendency_Type_ComeIn: 别人发给我的; Pendency_Type_SendOut: 我发给别人的
       * @param {Number} [options.startTime=0] - 好友申请的起始时间
       * @param {Number} [options.maxLimited=30] - 分页大小，如果取值为30 则表示客户端要求服务器端每页最多返回30个好友申请
       * @param {Number} [options.lastSequence=0] - 好友申请数据的版本号，用户每收到或删除一条好友申请，服务器端就自增一次好友申请数据版本号，一般传0，表示拉取最新的数据
       * @returns {Promise}
       * @memberof UserController
       */

    }, {
      key: "getPendency",
      value: function getPendency(options) {
        return this.applyC2CHandler.getPendency(options);
      }
      /**
       * 删除好友申请
       *
       * @param {Object} options
       * @param {string[]} options.toAccount - 用户账号或昵称
       * @param {String} [options.pendencyType='Pendency_Type_ComeIn'] - Pendency_Type_ComeIn: 别人发给我的; Pendency_Type_SendOut: 我发给别人的
       * @returns {Promise}
       * @memberof UserController
       */

    }, {
      key: "deletePendency",
      value: function deletePendency(options) {
        return this.applyC2CHandler.deletePendency(options);
      }
      /**
       *
       *
       * @param {Object} options - 请求参数
       * @param {String} options.toAccount - 目标用户名
       * @param {Number} options.action - 0（同意） / 1（同意并加为好友）/ -1 (拒绝)
       * @param {Object[]} [options.items] - 可选字段，用于批量处理好友申请。当使用该字段时则options.toAccount和options.action失效。
       * @param {String} [options.items.toAccount] - 目标用户名
       * @param {Number} [options.items.action] - 0（同意） / 1（同意并加为好友）/ -1 (拒绝)
       * @returns {Promise}
       * @memberof UserController
       */

    }, {
      key: "replyPendency",
      value: function replyPendency(options) {
        return this.applyC2CHandler.replyPendency(options);
      }
    }, {
      key: "reset",
      value: function reset() {
        logger.warn('UserController.reset');
        this.resetReady();
        this.profileHandler.reset();
        this.blacklistHandler.reset(); // 是否需要清理定时器？

        this.checkTimes = 0;
      }
    }]);

    return UserController;
  }(IMController);

  /**
   * @class TextElement
   * @param { Object } options  - 配置参数
   * @example
   * let textElement = new TIM.TextElement({text:'text'});
   * 
   */

  var TextElement =
  /*#__PURE__*/
  function () {
    /**
     * 
     * @param {Object} options - 初始化参数 
     * @param {String} options.text - 文本类型，参数。不排队以后会有富文本类型。
     */
    function TextElement(options) {
      _classCallCheck(this, TextElement);

      // request form data 
      // {
      //     MsgType: "TIMTextElem",
      //     MsgContent: {
      //         Text: "12"
      //     }
      // }        
      this.type = MESSAGE.ELEMENT_TYPES.TEXT;
      this.content = {
        text: options.text || ''
      };
    }

    _createClass(TextElement, [{
      key: "setText",
      value: function setText(text) {
        this.content.text = text;
      }
    }, {
      key: "isEmpty",
      value: function isEmpty() {
        if (this.content.text.length === 0) {
          return true;
        }

        return false;
      }
    }]);

    return TextElement;
  }();

  /**
   * @class ImageElement
   * @param { Object } options  - 配置参数
   * @param {String} options.uuid 图片唯一标识
   * @param {String} options.imageFormat 图片格式类型 参考 TIM_TYPES.MESSAGE.IMAGE_FORMAT
   * @param {Array} options.imageInfoArray 图片描述对象数组, 对象包含属性 {type:'', size:'', width:'', height:'', url:'' }
   * @param {HTMLFileElement} options.file - 如果传入file 实例，而会把 file 读取为 base64 编码
   * @example
   * let options = {
   *  uuid:'',
   *  imageFormat:'',
   *  imageInfoArray:[],
   * }
   * let imageElement = new ImageElement(options);
   */
  // request form data
  // {
  //     "MsgType": "TIMImageElem",
  //     "MsgContent": {
  //         "ImageFormat": 255,
  //         "UUID": "959129_87EB4A03E2159F904C3B4A8F4318AF6A",
  //         "ImageInfoArray": [{
  //             "Type": 3,
  //             "Size": 19606,
  //             "Width": 298,
  //             "Height": 184,
  //             "URL": "http://p.qpic.cn/opensdk_im/0/10153358846003601680_0_87EB4A03E2159F904C3B4A8F4318AF6A/198"
  //         }, {
  //             "Type": 2,
  //             "Size": 19606,
  //             "Width": 298,
  //             "Height": 184,
  //             "URL": "http://p.qpic.cn/opensdk_im/0/10153358846003601680_0_87EB4A03E2159F904C3B4A8F4318AF6A/720"
  //         }, {
  //             "Type": 1,
  //             "Size": 959129,
  //              "Width": 298,
  //             "Height": 184,
  //             "URL": "http://p.qpic.cn/opensdk_im/0/10153358846003601680_0_87EB4A03E2159F904C3B4A8F4318AF6A/0"
  //         }]
  //     }
  // }

  var ImageElement =
  /*#__PURE__*/
  function () {
    function ImageElement(options) {
      _classCallCheck(this, ImageElement);

      this._imageMemoryURL = '';
      this._file = options.file; // 暂存File实例，重发的时候用
      // 如果传入了 file 实例，则读取出 blob 的访问地址

      if (!IN_WX_MINI_APP) {
        this.createImageDataASURLInWeb(options.file);
      } else {
        this.createImageDataASURLInWXMiniApp(options.file);
      }

      this._initImageInfoModel();

      this.type = MESSAGE.ELEMENT_TYPES.IMAGE;
      this._percent = 0;
      this.content = {
        imageFormat: MESSAGE.IMAGE_FORMAT[options.imageFormat] || MESSAGE.IMAGE_FORMAT['UNKNOWN'],
        // imageFormat: TIM_TYPES.MESSAGE.IMAGE_FORMAT['UNKNOWN'],
        uuid: options.uuid,
        imageInfoArray: []
      };
      this.initImageInfoArray(options.imageInfoArray);
      this._defaultImage = 'http://imgcache.qq.com/open/qcloud/video/act/webim-images/default.jpg'; // 默认图片地址

      this._autoFixUrl();
    }
    /**
     * 初始化 imageInfo 模型
     */


    _createClass(ImageElement, [{
      key: "_initImageInfoModel",
      value: function _initImageInfoModel() {
        var father = this; // const urlList = {};

        this._ImageInfoModel = function (options) {
          this.instanceID = randomInt(9999999);
          this.sizeType = options.type || 0;
          this.size = options.size || 0;
          this.width = options.width || 1024;
          this.height = options.height || 800;
          this.imageUrl = options.url || '';
          this.url = options.url || father._imageMemoryURL || father._defaultImage; // 默认图片地址
          // urlList[this.instanceID] = options.url || father._imageMemoryURL || father._defaultImage; // 默认图片地址
        };

        this._ImageInfoModel.prototype = {
          setSizeType: function setSizeType(value) {
            this.sizeType = value;
          },
          setImageUrl: function setImageUrl(newUrl) {
            if (newUrl) {
              this.imageUrl = newUrl;

              if (IN_WX_MINI_APP) {
                this.url = newUrl;
              }
            }
          },
          getImageUrl: function getImageUrl() {
            return this.imageUrl;
          }
        };
      }
      /**
       * @description 初始化图片消息数组
       * @param {array} infoArray - 图片信息数组
       */

    }, {
      key: "initImageInfoArray",
      value: function initImageInfoArray(infoArray) {
        var i = 2;
        var imageInfo = null;
        var infoOptions = null;

        while (i >= 0) {
          typeof infoArray === 'undefined' || typeof infoArray[i] === 'undefined' ? infoOptions = {
            type: 0,
            size: 0,
            width: 0,
            height: 0,
            url: ''
          } : infoOptions = infoArray[i];
          imageInfo = new this._ImageInfoModel(infoOptions);
          imageInfo.setSizeType(i + 1);
          this.addImageInfo(imageInfo); // this.replaceImageInfo(imageInfo,i);

          i--;
        }
      }
      /**
       * @description 更新图片信息数组
       * @param {*} options - 更新参数
       * @param {Number} options.size - 图片大小
       * @param {String} options.url - 图片URL
       */

    }, {
      key: "updateImageInfoArray",
      value: function updateImageInfoArray(options) {
        var len = this.content.imageInfoArray.length;

        for (var i = 0; i < len; i++) {
          options.size ? this.content.imageInfoArray[i].size = options.size : null;

          if (options.url) {
            this.content.imageInfoArray[i].setImageUrl(options.url);
          }
        }
      }
      /**
       * 强制修正一下URL,因为后端存储的URL是不带有 http/https 前缀的，万一用户在file协议下使用SDK就会出现 "//xxx/image" 被自动替换为“file://xxx/image” ，导致图片无法访问。
       * @private
       */

    }, {
      key: "_autoFixUrl",
      value: function _autoFixUrl() {
        var len = this.content.imageInfoArray.length;
        var onlyUrl = '';
        var preFix = '';
        var accessPrefix = ['http', 'https'];
        var info = null;

        for (var i = 0; i < len; i++) {
          if (!this.content.imageInfoArray[i].url) {
            continue;
          }

          info = this.content.imageInfoArray[i];

          if (info.imageUrl === '') {
            continue;
          }

          preFix = info.imageUrl.slice(0, info.imageUrl.indexOf('://') + 1);
          onlyUrl = info.imageUrl.slice(info.imageUrl.indexOf('://') + 1);

          if (accessPrefix.indexOf(preFix) < 0) {
            preFix = 'http:';
          }

          this.content.imageInfoArray[i].setImageUrl([preFix, onlyUrl].join(''));
        }
      }
      /**
       * 更新百分比数据
       * @param {Number} newValue - 百分比数值
       */

    }, {
      key: "updatePercent",
      value: function updatePercent(newValue) {
        this._percent = newValue;

        if (this._percent > 1) {
          this._percent = 1;
        }
      }
      /**
       * @description 更新文件格式信息
       * @param {String} format - 图片格式
       */

    }, {
      key: "updateImageFormat",
      value: function updateImageFormat(format) {
        this.content.imageFormat = format;
      }
      /**
       * 以blob形式读取图片，并生成URL
       * @param {File} file - 文件对象
       */

    }, {
      key: "createImageDataASURLInWeb",
      value: function createImageDataASURLInWeb(file) {
        // 限制读取一个，不允许传多个文件
        if (typeof file !== 'undefined' && file.files.length > 0) {
          this._imageMemoryURL = window.URL.createObjectURL(file.files[0]);
        }
      }
      /**
       * 小程序环境，直接获取 tempFilePaths
       * @param {File} file - 文件对象
       */

    }, {
      key: "createImageDataASURLInWXMiniApp",
      value: function createImageDataASURLInWXMiniApp(file) {
        // 限制读取一个，不允许传多个文件
        if (file && file.tempFilePaths[0]) {
          this._imageMemoryURL = file.tempFilePaths[0];
        }
      }
      /**
       *
       * @param {*} infoInstance - 图片信息实例
       * @param {*} index - 索引ID
       */

    }, {
      key: "replaceImageInfo",
      value: function replaceImageInfo(infoInstance, index) {
        var oldInfo = this.content.imageInfoArray[index];

        if (oldInfo instanceof this._ImageInfoModel) {
          return;
        }

        this.content.imageInfoArray[index] = infoInstance;
      }
      /**
       * @description 设置文件消息元素
       * @param {Object} options 图片描述对象
       * @param {String} options.sizeType - 图片尺寸的类型，
       * @param {String} options.width - 图片宽度，单位为px
       * @param {String} options.height - 图片高度，单位为px
       * @param {String} options.url - 图片图片地址
       * @example
       * // 可以添加3组图片描述对象，小缩略图、大缩略图、原图
       * let imageElement = new ImageElement({uuid:'', imageFormat:''});
       * imageElement.addImageInfo({ type:'', size:'', width:'', height:'', url:'' });
       */

    }, {
      key: "addImageInfo",
      value: function addImageInfo(options) {
        if (this.content.imageInfoArray.length >= 3) {
          return;
        }

        this.content.imageInfoArray.push(options);
      }
      /**
       * 允许发送空的 ImageElement
       * @returns {boolean}
       */

    }, {
      key: "isEmpty",
      value: function isEmpty() {
        if (this.content.imageInfoArray.length === 0) {
          return true;
        }

        if (this.content.imageInfoArray[0].imageUrl === '') {
          return true;
        }

        return false;
      }
    }]);

    return ImageElement;
  }();

  var FaceElement =
  /*#__PURE__*/
  function () {
    function FaceElement(options) {
      _classCallCheck(this, FaceElement);

      this.type = MESSAGE.ELEMENT_TYPES.FACE;
      this.content = options || null;
    }

    _createClass(FaceElement, [{
      key: "isEmpty",
      value: function isEmpty() {
        if (this.content === null) {
          return true;
        }

        return false;
      }
    }]);

    return FaceElement;
  }();

  /**
   * @class
   * @author saxongao
   */

  var SoundElement =
  /*#__PURE__*/
  function () {
    /**
     *
     * @param {*} options
     */
    function SoundElement(options) {
      _classCallCheck(this, SoundElement);

      this.type = MESSAGE.ELEMENT_TYPES.SOUND;
      this.content = {
        downloadFlag: 2,
        second: options.second,
        size: options.size,
        url: options.url,
        uuid: options.uuid
      };
    }

    _createClass(SoundElement, [{
      key: "isEmpty",
      value: function isEmpty() {
        if (this.content.url === '') {
          return true;
        }

        return false;
      }
    }]);

    return SoundElement;
  }();

  var legalGroupProfileKeys = {
    from: true,
    groupID: true,
    groupName: true,
    to: true
  };
  /**
   * @class
   * @param {String} type 元素类型
   * @param {Object} content 元素内容
   * @param {Number} content.operationType 操作类型
   * @param {String} content.operatorID 执行该操作的用户 ID
   * @param {Number} content.memberNum 群成员数量
   * @param {String[]} content.userIDList 相关的 userID 列表
   * @param {Object} content.newGroupProfile 若是群资料变更，该字段存放变更的群资料 {@link Group}
   */

  var GroupTipElement =
  /*#__PURE__*/
  function () {
    function GroupTipElement(options) {
      _classCallCheck(this, GroupTipElement);

      this.type = MESSAGE.ELEMENT_TYPES.GROUP_TIP;
      this.content = {};

      this._initContent(options);
    }

    _createClass(GroupTipElement, [{
      key: "_initContent",
      value: function _initContent(options) {
        var _this = this;

        Object.keys(options).forEach(function (key) {
          switch (key) {
            case 'remarkInfo':
              //TODO: 含义还不明确，先不放上去
              break;

            case 'groupProfile':
              _this.content.groupProfile = {};

              _this._initGroupProfile(options[key]);

              break;

            case 'operatorInfo':
              break;

            case 'memberInfoList':
              break;

            default:
              _this.content[key] = options[key];
          }
        }); // 有的ev4 无userIDList返回，此时手动赋值。

        if (!this.content.userIDList) {
          this.content.userIDList = [this.content.operatorID];
        }
      }
    }, {
      key: "_initGroupProfile",
      value: function _initGroupProfile(options) {
        var keys = Object.keys(options);

        for (var i = 0; i < keys.length; i++) {
          var key = keys[i];

          if (!legalGroupProfileKeys[key]) {
            continue;
          }

          this.content.groupProfile[key] = options[key];
        }
      }
    }]);

    return GroupTipElement;
  }();

  var legalGroupProfileKeys$1 = {
    from: true,
    groupID: true,
    groupName: true,
    to: true
  };
  /**
   * @class GroupSystemNoticeElement
   * @param {String} type 元素类型
   * @param {Object} content 元素内容
   * @param {Number} content.operationType 操作类型
   * @param {String} content.operatorID 执行该操作的用户 ID
   * @param {String} content.authentication 删除消息时需使用该字段
   * @param {Number} content.messageKey 删除消息时需使用该字段
   * @param {Object} content.groupProfile 相关群组信息
   * @param {String} content.handleMessage 操作人的附言
   */

  var GroupSystemNoticeElement =
  /*#__PURE__*/
  function () {
    function GroupSystemNoticeElement(options) {
      _classCallCheck(this, GroupSystemNoticeElement);

      this.type = MESSAGE.ELEMENT_TYPES.GROUP_SYSTEM_NOTICE;
      this.content = {};

      this._initContent(options);
    }

    _createClass(GroupSystemNoticeElement, [{
      key: "_initContent",
      value: function _initContent(options) {
        var _this = this;

        Object.keys(options).forEach(function (key) {
          switch (key) {
            case 'memberInfoList':
              break;

            case 'remarkInfo':
              _this.content['handleMessage'] = options[key];
              break;

            case 'groupProfile':
              _this.content.groupProfile = {};

              _this._initGroupProfile(options[key]);

              break;

            default:
              _this.content[key] = options[key];
          }
        });
      }
    }, {
      key: "_initGroupProfile",
      value: function _initGroupProfile(options) {
        var keys = Object.keys(options);

        for (var i = 0; i < keys.length; i++) {
          var key = keys[i];

          if (!legalGroupProfileKeys$1[key]) {
            continue;
          }

          this.content.groupProfile[key] = options[key];
        }
      }
    }]);

    return GroupSystemNoticeElement;
  }();

  /**
   * 文件类型元素
   * @class FileElement
   * @author saxongao
   */

  var FileElement =
  /*#__PURE__*/
  function () {
    function FileElement(options) {
      _classCallCheck(this, FileElement);

      var checkResult = this._check(options);

      if (checkResult instanceof IMError) {
        throw checkResult;
      }

      this.type = MESSAGE.ELEMENT_TYPES.FILE;
      this._percent = 0;

      var fileInfo = this._getFileInfo(options);

      this.content = {
        downloadFlag: 2,
        fileUrl: options.url || '',
        uuid: ['fake', randomInt(999), randomInt(9999)].join('-'),
        // UUID 为大数据通道专用，已废弃，这里使用 fake 数据
        fileName: fileInfo.name || '',
        fileSize: fileInfo.size || 0
      }; // this.content = options.content || null;
    }
    /**
     * @description 获取文件信息
     * @param {Object} options 
     */


    _createClass(FileElement, [{
      key: "_getFileInfo",
      value: function _getFileInfo(options) {
        if (options.fileName && options.fileSize) {
          return {
            size: options.fileSize,
            name: options.fileName
          };
        }

        if (IN_WX_MINI_APP) {
          return {};
        }

        var file = options.file.files[0];
        return {
          size: file.size,
          name: file.name,
          type: file.type.slice(file.type.lastIndexOf('/') + 1).toUpperCase()
        };
      }
      /**
       * 更新百分比数据 
       * @param {Number} newValue 
       */

    }, {
      key: "updatePercent",
      value: function updatePercent(newValue) {
        this._percent = newValue;

        if (this._percent > 1) {
          this._percent = 1;
        }
      }
    }, {
      key: "updateFileUrl",
      value: function updateFileUrl(newUrl) {
        this.content.fileUrl = newUrl;
      }
    }, {
      key: "_check",
      value: function _check(options) {
        if (options.size > UPLOAD_FILE_SIZE_LIMIT) {
          return new IMError({
            code: ERROR_CODE.MESSAGE_FILE_SIZE_LIMIT,
            message: "".concat(ERROR_MESSAGE.MESSAGE_FILE_SIZE_LIMIT, ": ").concat(UPLOAD_FILE_SIZE_LIMIT, " bytes")
          });
        }
      }
    }, {
      key: "isEmpty",
      value: function isEmpty() {
        // 如果 url 为空， 视为空
        if (this.content.fileUrl === '') {
          return true;
        } // 如果 fileName 为空， 视为空


        if (this.content.fileName === '') {
          return true;
        } // 如果 fileSize 为空， 视为空


        if (this.content.fileSize === 0) {
          return true;
        }

        return false;
      }
    }]);

    return FileElement;
  }();

  var CustomElement =
  /*#__PURE__*/
  function () {
    /**
    * @class TextElement
    * @param { Object } options - 配置参数
    * @param {*} options.data - 自定义数据
    * @param {*} options.description - 自定义描述
    * @param {*} options.extension - 自定义扩展
    * @example
    * let customElement = new TIM.CustomElement({data:'', description:'', extension:''});
    * 
    */
    function CustomElement(options) {
      _classCallCheck(this, CustomElement);

      // request form data 
      // {
      //     MsgType: "TIMTextElem",
      //     MsgContent: {
      //         Data: "",
      //         Desc: "",
      //         Ext: ""
      //     }
      // }   
      this.type = MESSAGE.ELEMENT_TYPES.CUSTOM;
      this.content = {
        data: options.data || '',
        description: options.description || '',
        extension: options.extension || ''
      };
    }

    _createClass(CustomElement, [{
      key: "setData",
      value: function setData(text) {
        this.content.data = text;
        return this;
      }
    }, {
      key: "setDescription",
      value: function setDescription(text) {
        this.content.description = text;
        return this;
      }
    }, {
      key: "setExtension",
      value: function setExtension(text) {
        this.content.extension = text;
        return this;
      }
    }, {
      key: "isEmpty",
      value: function isEmpty() {
        if (this.content.data.length === 0 && this.content.description.length === 0 && this.content.extension.length === 0) {
          return true;
        }

        return false;
      }
    }]);

    return CustomElement;
  }();

  /**
   * 用于描述消息中图片元素的结构
   * @class VideoElement
   */

  var VideoElement =
  /**
   * @param {*} options
   * @param {String} options.videoFormat  - 视频文件的格式
   * @param {String} options.url  - 视频文件的地址
   * @param {String} options.downloadFlag - 下载标志位
   * @param {String} options.uuid - UUID 只有老版本使用大数据通道发送的文件，才会有UUID, 新版本web sdk 使用cos上传文件，且uuid使用 fake-xxxx-xxxx的格式
   * @private
   * @constructor
   */
  function VideoElement(options) {
    _classCallCheck(this, VideoElement);

    this.type = MESSAGE.ELEMENT_TYPES.VIDEO;
    this.content = {
      videoFormat: options.videoFormat,
      videoUrl: options.url,
      downloadFlag: options.downloadFlag,
      UUID: options.uuid
    };
  };

  /**
   * 文本消息的 content 结构
   * @typedef TextPayload
   * @property {String} text 文本消息内容
   * @memberof Message
   */

  /**
   * 图片消息的 content 结构
   * @typedef ImagePayload
   * @property {String} uuid 图片唯一标识
   * @property {String} imageFormat 图片格式类型
   * @property {Object[]} imageInfoArray 图片信息
   * @property {Number} imageInfoArray.width 宽度
   * @property {Number} imageInfoArray.height 高度
   * @property {String} imageInfoArray.url 图片地址，可用于渲染。
   * @property {Number} imageInfoArray.size 图片大小，单位字节。
   * @property {Number} imageInfoArray.sizeType 图片大小类型。值为 1 时表示原图，数值越大表示压缩比率越高。
   * @memberof Message
   */

  /**
   * 音频消息的 content 结构
   * @typedef SoundPayload
   * @property {String} uuid 唯一标识
   * @property {String} url 音频地址
   * @property {Number} size 文件大小，单位字节
   * @property {Number} second 音频时长，单位：秒
   * @memberof Message
   */

  /**
   * 文件消息的 content 结构
   * @typedef FilePayload
   * @property {String} uuid 唯一标识
   * @property {String} fileName 文件名
   * @property {String} fileUrl 文件地址
   * @property {Number} fileSize 文件大小，单位字节
   * @memberof Message
   */

  /**
   * 自定义消息的 content 结构
   * @typedef CustomPayload
   * @property {String} data 自定义消息的 data 字段
   * @property {String} description 自定义消息的 description 字段
   * @property {String} extension 自定义消息的 extension 字段
   * @memberof Message
   */

  /**
   * 群提示消息的 content 结构。系统会在恰当的时机，向全体群成员发出群提示消息。例如：有群成员退群/进群，系统会给所有群成员发对应的群提示消息。
   * @typedef GroupTipPayload
   * @property {String} operatorID 执行该操作的用户 ID
   * @property {Number} operationType 操作类型，具体如下:<br/>
   * | 操作类型 | 值 | 含义 |
   * | :--- | :---- | :---- |
   * | TIM.TYPES.GRP_TIP_MBR_JOIN | 1 | 有成员加群
   * | TIM.TYPES.GRP_TIP_MBR_QUIT | 2 | 有群成员退群
   * | TIM.TYPES.GRP_TIP_MBR_KICKED_OUT | 3 | 有群成员被踢出群
   * | TIM.TYPES.GRP_TIP_MBR_SET_ADMIN | 4 | 有群成员被设为管理员
   * | TIM.TYPES.GRP_TIP_MBR_CANCELED_ADMIN | 5 | 有群成员被撤销管理员
   * | TIM.TYPES.GRP_TIP_GRP_PROFILE_UPDATED | 6 | 群组资料变更
   * | TIM.TYPES.GRP_TIP_MBR_PROFILE_UPDATED | 7 | 群成员资料变更
   * @property {String[]} userIDList 相关的 userID 列表
   * @property {Object} newGroupProfile 若是群资料变更，该字段存放变更的群资料
   * @memberof Message
   */

  /**
   * @description 群系统通知的 content 结构。系统会在恰当的时机，向特定用户发出群系统通知。例如：user1 被踢出群组，系统会给 user1 发送对应的群系统消息。
   * @typedef GroupSystemNoticePayload
   * @property {String} operatorID 执行该操作的用户 ID
   * @property {Number} operationType 操作类型，具体如下：<br/>
   * | 值 | 描述 | 接收对象 |
   * | :--- | :--------------------------------- | :---|
   * | 1 | 有用户申请加群 | 群管理员/群主接收 |
   * | 2 | 申请加群被同意 | 申请加群的用户接收 |
   * | 3 | 申请加群被拒绝 | 申请加群的用户接收 |
   * | 4 | 被踢出群组 | 被踢出的用户接收 |
   * | 5 | 群组被解散 | 全体群成员接收 |
   * | 6 | 创建群组 | 创建者接收 |
   * | 7 | 邀请加群 | 被邀请者接收 |
   * | 8 | 退群 | 退群者接收 |
   * | 9 | 设置管理员 | 被设置方接收 |
   * | 10 | 取消管理员 | 被取消方接收 |
   * | 255 | 用户自定义通知 | 默认全员接收 |
   * @property {Object} groupProfile 相关的群组资料
   * @property {Object} handleMessage 处理的附言。例如：user1 申请加入 group1 时，若进群需要验证，且 user1 填写了申请加群的附言。则 group1 的管理员会在相应群系统通知中看到该字段。
   * @memberof Message
   */
  // 暂不展示
  // * | 11 | 群已被回收。全员接收, 不展示
  // * | 12 | 邀请人加群。被邀请者需同意
  // * | 15 | 群消息已读同步

  var Message =
  /*#__PURE__*/
  function () {
    // eslint-disable-next-line valid-jsdoc

    /**
     * @description 消息对象，用于描述一条消息具有的属性，如类型、消息的内容、所属的会话 ID 等。
     * @property {String}  ID - 消息 ID
     * @property {String}  type - 消息类型，具体如下：<br/>
     * | 类型 | 含义 |
     * | :--- | :---- |
     * | TIM.TYPES.MSG_TEXT | 文本消息 |
     * | TIM.TYPES.MSG_IMAGE | 图片消息 |
     * | TIM.TYPES.MSG_SOUND | 音频消息 |
     * | TIM.TYPES.MSG_FILE | 文件消息 |
     * | TIM.TYPES.MSG_GRP_TIP | 群提示消息 |
     * | TIM.TYPES.MSG_GRP_SYS_NOTICE | 群系统通知消息 |
     * @property {Object}  payload - 消息的内容，具体如下：<br/>
     * - {@link Message.TextPayload 文本}
     * - {@link Message.ImagePayload 图片}
     * - {@link Message.SoundPayload 音频}
     * - {@link Message.FilePayload 文件}
     * - {@link Message.CustomPayload 自定义}
     * - {@link Message.GroupTipPayload 群提示消息}
     * - {@link Message.GroupSystemNoticePayload 群系统通知}
     * @property {String}  conversationID - 消息所属的会话 ID
     * @property {String}  conversationType - 消息所属会话的类型，具体如下：<br/>
     * | 类型 | 含义 |
     * | :--- | :---- |
     * | TIM.TYPES.CONV_C2C | C2C(Client to Client, 端到端) 会话 |
     * | TIM.TYPES.CONV_GROUP | GROUP(群组) 会话 |
     * | TIM.TYPES.CONV_SYSTEM | SYSTEM(系统) 会话 |
     * @property {String}  to - 接收方的 userID
     * @property {String}  from - 发送方的 userID，在消息发送时，会默认设置为当前登录的用户
     * @property {String}  flow - 消息的流向<br/>
     * - in 为收到的消息
     * - out 为发出的消息
     * @property {Number}  time - 消息时间戳。单位：秒
     * @property {String}  status - 消息状态。
     * - unSend(未发送)
     * - success(发送成功)
     * - fail(发送失败)
     * @property {Boolean} isRead=false - 是否已读
     * @property {Boolean} isResend=false - 是否为重发消息
     */
    function Message(options) {
      _classCallCheck(this, Message);

      this.ID = ''; // 消息ID

      this.conversationID = options.conversationID || null; // 这里的赋值是为了方便重建消息对象，不需要传入
      // eslint-disable-next-line max-len

      this.conversationType = options.conversationType || CONVERSATION_TYPES.C2C;
      this.conversationSubType = options.conversationSubType;
      this.time = options.time || Math.ceil(Date.now() / 1000);
      this.sequence = options.sequence || 0; // 服务端的 sequence

      this.clientSequence = options.clientSequence || options.sequence || 0; // clinet 端的 sequence

      this.random = options.random || randomInt();
      this.messagePriority = options.messagePriority || 0; // 看字面意义是消息优先级？目前出现在 Event = 3 的 groupMessageArray 中

      /**
       * 用于存储消息元素
       * @member {Object[]}
       * @private
       * @example
       *
       * // 文本元素
       * message.elements = [
       *  {
       *    type: 'TIMTextElem',
       *    content: '你好~'
       *  }
       * ];
       * // 图片元素
       * message.elements = [
       *  {
       *    type: 'TIMImageElem'
       *    content: {
       *       imageFormat: 1, // 图片格式类型 JPG: 1, JPEG: 1, GIF: 2, PNG: 3, BMP: 4, UNKNOWN: 255
       *       uuid: 'xxxxxx', // 图片唯一标识
       *       imageInfoArray: [
       *        {type:3, size:9689, width:198, height:198, url:'http://xxxx' }, // 缩略小图 type:3
       *        {type:2, size:16828, width:720, height:720, url:'http://xxxx' }, // 缩略大图 type:2
       *        {type:1, size:21712, width:1920, height:1080, url:'http://xxxx' }  // 原图 type:r31
       *       ]
       *    }
       *  }
       * ];
       * // 自定义元素
       * message.elements = [
       *  {
       *    type: 'TIMCustomElem',
       *    content: {
       *     data: '', // 自定义数据
       *     description: '', // 自定义描述
       *     extension: '' // 自定义扩展
       *    }
       *  }
       * ];
       */

      this.elements = options.elements || null; // 消息元素数组

      this.isPlaceMessage = false; // 是否为占位消息，有些消息被撤回或者被删除了，或者因为其他原因导致不能展示出来，塞一个空消息进去，以保证群消息的sequence是连续的。

      this.geo = {}; // 地理位置消息内容

      this.from = options.from || null; // 消息的发送方

      this.to = options.to || null; // 消息接收方
      // this.groupID = options.groupID || null; // 群组ID

      this.flow = ''; // in || out 用来表示消息的流向

      this.isSystemMessage = options.isSystemMessage || false; // 标记这条消息是否为系统发送的消息，但对于群历史和 notice channel 下来的Event 为  4 的 GroupTips 而言，这个字段有歧义：群历史有，但notice channel 没有；使用时请注意这一点。

      this.protocol = options.protocol || 'JSON'; // 此消息使用的协议

      this.isResend = false; // 是否为重发的消息

      this.isRead = false; // 是否已读

      this.status = options.status || TIM_STATUS.MESSAGE_STATUS.SUCCESS; // 仅对 flow out 的消息

      this._error = 0; // 用来标记消息是否出错，出错的消息不能发送，0为正确，非零为出错

      this._errorInfo = '';
      this.reInitialize(options.currentUser);
      this.extractGroupInfo(options.groupProfile || null); // 提取出消息包体中的群组信息：成员头像地址和群名片
    }
    /**
     * 设置消息的 _error 属性
     * @param {Boolean} value - 是否为错误的信息
     * @param {string} info - 错误信息
     * @private
     */


    _createClass(Message, [{
      key: "setError",
      value: function setError(value, info) {
        if (typeof value === 'number') {
          this._error = value;
        }

        if (info) {
          this._errorInfo = info;
        } else {
          this._errorInfo = 'message elements error!';
        }
      }
      /**
       * 提取出群组信息的 avatar(个人资料) 和 nameCard （群名片）
       * @param {object} groupProfile - 消息包体中的群组信息对象
       * @private
       */

    }, {
      key: "extractGroupInfo",
      value: function extractGroupInfo(groupProfile) {
        if (groupProfile === null) {
          return;
        }

        var messageFromAccountExtraInformation = groupProfile.messageFromAccountExtraInformation;
        this.nick = '';

        if (typeof groupProfile.fromAccountNick === 'string') {
          this.nick = groupProfile.fromAccountNick;
        }

        this.avatar = '';

        if (typeof groupProfile.fromAccountHeadurl === 'string') {
          this.avatar = groupProfile.fromAccountHeadurl;
        } // MsgFrom_AccountExtraInfo.NameCard


        this.nameCard = '';

        if (_typeof(messageFromAccountExtraInformation) === 'object' && messageFromAccountExtraInformation.hasOwnProperty('nameCard')) {
          this.nameCard = messageFromAccountExtraInformation.nameCard;
        }
      }
      /**
       * 获取消息是否出错，出错的消息不能发送
       * @returns {Boolean} - true ： 说明消息出错。false: 说明消息没有出错
       * @private
       */

    }, {
      key: "isError",
      value: function isError() {
        return this._error === 0 ? false : true;
      }
      /**
       * 获取错误描述
       * @returns {IMError} - 错误描述信息
       * @private
       */

    }, {
      key: "getIMError",
      value: function getIMError() {
        return new IMError({
          code: this._error,
          message: this._errorInfo
        });
      }
      /**
       * 初始化 type 和 content 属性，用于拍平消息结构，同时保留 elements
       * @private
       */

    }, {
      key: "_initProxy",
      value: function _initProxy() {
        if (IN_WX_MINI_APP) {
          this.payload = this.elements[0].content;
          this.type = this.elements[0].type;
          return;
        }

        var self = this;
        Object.defineProperty(this, 'type', {
          get: function get() {
            return self.elements[0].type;
          }
        });
        Object.defineProperty(this, 'payload', {
          get: function get() {
            return self.elements[0].content;
          }
        });
      }
      /**
       * @description 注册一个 _onReadyHandle 回调，当 ready() 时会触发，或 isSendable() 返回true时，马上触发
       * @param {function} callback - 初始化完成后的回调函数
       * @private
       */

    }, {
      key: "afterOperated",
      value: function afterOperated(callback) {
        this._onOperatedHandle = null;

        if (typeof callback === 'function') {
          this._onOperatedHandle = callback;
        }

        if (this.isSendable() === true) {
          this.triggerOperated();
        }
      }
      /**
       * 当消息的初始化过程已经处理完成时调用，会触发 _onSanableCallback 回调
       * @private
       */

    }, {
      key: "triggerOperated",
      value: function triggerOperated() {
        if (this._onOperatedHandle === null) {
          return;
        }

        if (typeof this._onOperatedHandle !== 'function') {
          return;
        }

        this._onOperatedHandle(this);
      }
      /**
       * 重初始化
       * @param {String} [currentUser] - 当前用户，发消息时要传入
       * @private
       */

    }, {
      key: "reInitialize",
      value: function reInitialize(currentUser) {
        if (currentUser) {
          this.status = this.from ? TIM_STATUS.MESSAGE_STATUS.SUCCESS : TIM_STATUS.MESSAGE_STATUS.UNSEND;
          !this.from ? this.from = currentUser : null;
          this.isRead = true;
        } // this._initTo();


        this._initFlow(currentUser);

        this._initielizeSequence(currentUser); // this.offlinePushInfo = ''; // 离线推送相关，先注释掉


        this._concactConversationID(currentUser);

        this._concactMessageID(currentUser);
      }
      /**
       * 判断本消息实例是否已经可以发送
       * @returns {booleam}
       * @private
       */

    }, {
      key: "isSendable",
      value: function isSendable() {
        // 先检测 this.content 是否为空数组
        if (this.elements.length === 0) {
          return false;
        }

        if (typeof this.elements[0].isEmpty !== 'function') {
          logger.warn("".concat(this.elements[0].type, " need \"booleam : isEmpty()\" method"));
          return false;
        }

        if (this.elements[0].isEmpty() === true) {
          return false;
        }

        return true;
      }
    }, {
      key: "_initTo",
      value: function _initTo(options) {
        if (this.conversationType === CONVERSATION_TYPES.GROUP) {
          this.to = options.groupID;
        }
      }
      /**
       * @description 生成 sequence, 只有在发消息时执行
       * @param {string} currentUser - 当前用户
       * @private
       */

    }, {
      key: "_initielizeSequence",
      value: function _initielizeSequence(currentUser) {
        if (this.clientSequence === 0 && currentUser) {
          this.clientSequence = autoincrementIndex(currentUser);
        }

        if (this.sequence === 0 && this.conversationType === CONVERSATION_TYPES.C2C) {
          this.sequence = this.clientSequence;
        }
      }
      /**
       * @description 生成消息 ID
       * @param {string} currentUser - 当前用户
       * @private
       */

    }, {
      key: "_concactMessageID",
      value: function _concactMessageID(currentUser) {
        var isMySendedMessage = currentUser === this.from ? 1 : 0; // 是否为我自己发送的消息

        var sequence = this.clientSequence > 0 ? this.clientSequence : this.sequence; // 不加random可能和自己发过的消息ID撞车(详见sequence的生成规则)，加上random做规避
        // eslint-disable-next-line max-len

        this.ID = "".concat(this.conversationID, "-").concat(sequence, "-").concat(this.random, "-").concat(isMySendedMessage);
      }
      /**
       * @description 初始化消息的流向 flow
       * @param {string} currentUser - 当前用户
       * @private
       */

    }, {
      key: "_initFlow",
      value: function _initFlow(currentUser) {
        if (currentUser === '') {
          return;
        }

        this.flow = currentUser === this.from ? 'out' : 'in';
      }
      /**
       * @description 拼装出 会话ID `conversationID`
       * @param {string} currentUser - 当前用户
       * @private
       */

    }, {
      key: "_concactConversationID",
      value: function _concactConversationID(currentUser) {
        var to = this.to;
        var CONVERSATION_TYPES$1 = CONVERSATION_TYPES;
        var target = '';
        var type = this.conversationType; // 如果是系统消息，conversationID直接设置为系统类型的值

        if (type === CONVERSATION_TYPES$1.SYSTEM) {
          this.conversationID = CONVERSATION_TYPES$1.SYSTEM;
          return;
        }

        if (type === CONVERSATION_TYPES$1.C2C) {
          target = currentUser === this.from ? to : this.from;
        } else {
          target = this.to;
        }

        this.conversationID = "".concat(type).concat(target);
      }
    }, {
      key: "isElement",
      value: function isElement(element) {
        return element instanceof TextElement || element instanceof ImageElement || element instanceof FaceElement || element instanceof SoundElement || element instanceof FileElement || element instanceof GroupTipElement || element instanceof GroupSystemNoticeElement || element instanceof CustomElement;
      }
      /**
       * @description 设置消息元素, 如果content过于复杂这里需要优化
       * @param {Element | Object} options 标准Element对象，或者数据对象字面量
       * @private
       */

    }, {
      key: "setElement",
      value: function setElement(options) {
        var _this = this;

        // 支持 options 直接传 elements
        if (this.isElement(options)) {
          this.elements = [options];

          this._initProxy();

          return;
        }

        var setElementItem = function setElementItem(options) {
          // 支持 options 非标准 element 类型， 但必须有type 和content 属性
          switch (options.type) {
            case MESSAGE.ELEMENT_TYPES.TEXT:
              _this.setTextElement(options.content);

              break;

            case MESSAGE.ELEMENT_TYPES.IMAGE:
              _this.setImageElement(options.content);

              break;

            case MESSAGE.ELEMENT_TYPES.SOUND:
              _this.setSoundElement(options.content);

              break;

            case MESSAGE.ELEMENT_TYPES.FILE:
              _this.setFileElement(options.content);

              break;

            case MESSAGE.ELEMENT_TYPES.VIDEO:
              _this.setVideoElement(options.content);

              break;

            case MESSAGE.ELEMENT_TYPES.CUSTOM:
              _this.setCustomElement(options.content);

              break;

            case MESSAGE.ELEMENT_TYPES.GEO:
              _this.setGEOElement(options.content);

              break;

            case MESSAGE.ELEMENT_TYPES.GROUP_TIP:
              _this.setGroupTipElement(options.content);

              break;

            case MESSAGE.ELEMENT_TYPES.GROUP_SYSTEM_NOTICE:
              _this.setGroupSystemNoticeElement(options.content);

              break;

            case MESSAGE.ELEMENT_TYPES.FACE:
              _this.setFaceElement(options.content);

              break;

            default:
              logger.warn(options.type, options.content, 'no operation......');
          }
        };

        if (Array.isArray(options)) {
          for (var i = 0; i < options.length; i++) {
            setElementItem(options[i]);
          }
        } else {
          setElementItem(options);
        }

        this._initProxy();
      }
      /**
       * @description 设置文件消息元素
       * @param {String | Object} options 文本消息内容，或者包含文本消息的对象 eg. options = 'text content' , options = {text: 'text content'}
       * @private
       */

    }, {
      key: "setTextElement",
      value: function setTextElement(options) {
        var text = typeof options === 'string' ? options : options.text;
        var textElement = new TextElement({
          text: text
        });
        this.elements = [textElement];
      }
      /**
       * @description 设置图片消息元素
       * @param {Object} options options = {type: '', uuid: '', imageInfoArray: []}
       * @param {String} options.uuid 图片唯一标识
       * @param {String} options.imageFormat 图片格式类型
       * @param {Array} options.imageInfoArray 图片描述对象数组, 对象包含属性 {type:'', size:'', width:'', height:'', url:'' }
       * @private
       */

    }, {
      key: "setImageElement",
      value: function setImageElement(options) {
        var imageElement = new ImageElement(options);
        this.elements = [imageElement];
      }
      /**
       * @description 设置语音消息元素
       * @param {Object} options - 语音元素参数对象
       * @private
       */

    }, {
      key: "setSoundElement",
      value: function setSoundElement(options) {
        var element = new SoundElement(options);
        this.elements = [element];
      }
      /**
       * @description 设置文件消息元素
       * @param {Object} options - 文本元素参数对象
       * @private
       */

    }, {
      key: "setFileElement",
      value: function setFileElement(options) {
        var fileElement = new FileElement(options);
        this.elements = [fileElement];
      }
      /**
       * @param {Object} options - 视频元素参数对象
       * @param {String} options.videoFormat  - 视频文件的格式
       * @param {String} options.url  - 视频文件的地址
       * @param {String} options.downloadFlag - 下载标志位
       * @param {String} options.uuid - UUID 只有老版本使用大数据通道发送的文件，才会有UUID, 新版本web sdk 使用cos上传文件，且uuid使用 fake-xxxx-xxxx的格式
       * @private
       */

    }, {
      key: "setVideoElement",
      value: function setVideoElement(options) {
        var element = new VideoElement(options);
        this.elements = [element];
      }
      /**
       * @description 设置地理定位消息元素
       * @param {object} options - 地址定位元素参数对象
       * @private
       */

    }, {
      key: "setGEOElement",
      value: function setGEOElement(options) {} // 预留

      /**
       * @description 设置自定义消息元素
       * @param {Object} options - 参数对象
       * @param {*} options.data - 自定义数据
       * @param {*} options.description - 自定义描述
       * @param {*} options.extension - 自定义扩展
       * @private
       */

    }, {
      key: "setCustomElement",
      value: function setCustomElement(options) {
        var element = new CustomElement(options);
        this.elements = [element];
      }
      /**
       * 设置 Event 4 的群消息
       * @param {*} options - 参数对象
       * @private
       */

    }, {
      key: "setGroupTipElement",
      value: function setGroupTipElement(options) {
        var groupTipElement = new GroupTipElement(options);
        this.elements = [groupTipElement];
      }
      /**
       * 设置 Event 5 的群系统通知
       * @param {*} options - 参数对象
       * @private
       */

    }, {
      key: "setGroupSystemNoticeElement",
      value: function setGroupSystemNoticeElement(options) {
        var groupSystemNotice = new GroupSystemNoticeElement(options);
        this.elements = [groupSystemNotice];
      }
      /**
       * 设置 TIMFaceElem 元素
       * @param {object} options - 参数对象
       * @private
       */

    }, {
      key: "setFaceElement",
      value: function setFaceElement(options) {
        var faceElement = new FaceElement(options);
        this.elements = [faceElement];
      }
    }]);

    return Message;
  }();

  var validGroupProperty = ['groupID', 'name', 'avatar', 'type', 'introduction', 'notification', 'ownerID', 'selfInfo', 'createTime', 'infoSequence', 'lastInfoTime', 'lastMessage', 'nextMessageSeq', 'memberNum', 'maxMemberNum', 'memberList', 'joinOption', 'groupCustomField'];
  /**
   * 群组对象，用于描述群组具有的属性，如类型、群组公告、创建时间等。
   * @class Group
   * @property {String} groupID 群组的唯一标识，群组 ID，App 内保证唯一，其格式前缀为 @TGS#。另外，App 亦可自定义群组 ID
   * @property {String} name 群组名称，最长30字节，不可调整
   * @property {String} avatar 群组头像 URL，最长100字节，不可调整
   * @property {String} type 群组类型，当前 SDK 支持的类型如下：<br/>
   * | 类型 | 含义 |
   * | :--- | :---- |
   * | TIM.TYPES.GRP_PRIVATE | 私有群 |
   * | TIM.TYPES.GRP_PUBLIC | 公开群 |
   * | TIM.TYPES.GRP_CHATROOM | 聊天室 |
   * | TIM.TYPES.GRP_AVCHATROOM | 音视频聊天室 |
   * @property {String} introduction 群组简介，最长120字节，不可调整
   * @property {String} notification 群组公告，最长150字节，不可调整
   * @property {String} ownerID 群主 ID
   * @property {Number} createTime 群组的创建时间
   * @property {Number} infoSequence 群资料的每次变都会增加该值
   * @property {Number} lastInfoTime 群组最后一次信息变更时间
   * @property {Object} selfInfo 当前用户在群组中的信息
   * @property {String} selfInfo.role 角色
   * @property {String} selfInfo.messageRemindType 消息接收选项<br/>
   * - TIM.TYPES.MSG_REMIND_ACPT_AND_NOTE - SDK 接收消息并通知接入侧（抛出 {@link  module:EVENT.MESSAGE_RECEIVED 收到消息事件}），接入侧做提示
   * - TIM.TYPES.MSG_REMIND_ACPT_NOT_NOTE - SDK 接收消息并通知接入侧（抛出 {@link  module:EVENT.MESSAGE_RECEIVED 收到消息事件}），接入侧不做提示
   * - TIM.TYPES.MSG_REMIND_DISCARD - SDK 拒收消息
   * @property {Number} selfInfo.joinTime 入群时间
   * @property {String} selfInfo.nameCard 群名片
   * @property {Object} lastMessage 群组最后一条消息
   * @property {Number} lastMessage.lastTime 群组最后一条消息的时间戳，单位：秒
   * @property {Number} lastMessage.lastSequence - 当前群组类型会话的最新消息的 Seq
   * @property {Number} lastMessage.fromAccount 群组最后一条消息的来源用户
   * @property {Number} lastMessage.messageForShow 用于展示的群组最后一条消息的简要内容，文本则展示原内容，图片则展示“[图片]”。
   * @property {Number} nextMessageSeq 群内下一条消息的 Seq，群组内每一条消息都有一条唯一的消息 Seq，且该 Seq 是按照发消息顺序而连续的。从 1 开始，群内每增加一条消息，nextMessageSeq 就会增加 1
   * @property {Number} memberNum 当前成员数量
   * @property {Number} maxMemberNum 最大成员数量
   * @property {String} joinOption 申请加群选项。
     * - TIM.TYPES.JOIN_OPTIONS_FREE_ACCESS（自由加入，音视频聊天室固定为该值）
     * - TIM.TYPES.JOIN_OPTIONS_NEED_PERMISSION（需要验证）
     * - TIM.TYPES.JOIN_OPTIONS_DISABLE_APPLY（禁止加群，私有群固定为该值）
   * @property {Object} groupCustomField 群组自定义字段。默认情况是没有的。开通群组维度的自定义字段详情请参见 {@link https://cloud.tencent.com/document/product/269/1502#.E8.87.AA.E5.AE.9A.E4.B9.89.E5.AD.97.E6.AE.B5 自定义字段}
   */

  var Group =
  /*#__PURE__*/
  function () {
    function Group(options) {
      _classCallCheck(this, Group);

      this.groupID = '';
      this.name = '';
      this.avatar = '';
      this.type = '';
      this.introduction = '';
      this.notification = '';
      this.ownerID = '';
      this.createTime = '';
      this.infoSequence = '';
      this.lastInfoTime = '';
      this.selfInfo = {
        messageRemindType: '',
        joinTime: '',
        nameCard: '',
        role: ''
      };
      this.lastMessage = {};
      this.nextMessageSeq = ''; //TODO: 改成nextMessageSequence 

      this.memberNum = '';
      this.maxMemberNum = '';
      this.joinOption = '';
      this.groupCustomField = [];

      this._initGroup(options);
    }

    _createClass(Group, [{
      key: "_initGroup",
      value: function _initGroup(options) {
        for (var key in options) {
          if (validGroupProperty.indexOf(key) < 0) continue;
          this[key] = options[key];
        }
      }
      /**
       * 更新群组信息
       * @private
       * @param {*} group
       * @memberof Group
       */

    }, {
      key: "updateGroup",
      value: function updateGroup(group) {
        deepMerge(this, group, ['members', 'errorCode']);
      }
    }]);

    return Group;
  }();

  var mapMessageForShow = function mapMessageForShow(elements) {
    var element = elements[0];

    if (isUndefined(element)) {
      return '';
    }

    switch (element.type) {
      case MESSAGE.ELEMENT_TYPES.TEXT:
        return element.content.text;

      case MESSAGE.ELEMENT_TYPES.IMAGE:
        return '[图片]';

      case MESSAGE.ELEMENT_TYPES.GEO:
        return '[位置]';

      case MESSAGE.ELEMENT_TYPES.SOUND:
        return '[语音]';

      case MESSAGE.ELEMENT_TYPES.FILE:
        return '[文件]';

      case MESSAGE.ELEMENT_TYPES.CUSTOM:
        return '[其他]';

      case MESSAGE.ELEMENT_TYPES.GROUP_TIP:
        return '[群提示消息]';

      case MESSAGE.ELEMENT_TYPES.GROUP_SYSTEM_NOTICE:
        return '[群系统通知]';

      default:
        return '';
    }
  };
  /**
   * 计算 lastMessage
   * @param {Object|Message} message 消息
   * @returns {Object}
   * @private
   */


  var computeLastMessage = function computeLastMessage(message) {
    if (isUndefined(message)) {
      return {
        lastTime: 0,
        lastSequence: 0,
        fromAccount: 0,
        messageForShow: '',
        payload: null,
        type: ''
      };
    }

    if (message instanceof Message) {
      return {
        lastTime: message.time || 0,
        lastSequence: message.sequence || 0,
        fromAccount: message.from || '',
        messageForShow: mapMessageForShow(message.elements) || '',
        payload: message.elements[0] ? message.elements[0].content : null,
        type: message.elements[0] ? message.elements[0].type : ''
      };
    }

    return message;
  };
  /**
   * 会话对象，用于描述会话具有的属性，如类型、消息未读计数、最新消息等。
   * @class Conversation
   * @property {String} conversationID - 会话 ID。会话ID组成方式：<br/>
   * - C2C+userID（单聊）
   * - GROUP+groupID（群聊）
   * - @TIM#SYSTEM（系统通知会话）
   * @property {String} type - 会话类型，具体如下：<br/>
   * | 类型 | 含义 |
   * | :--- | :---- |
   * | TIM.TYPES.CONV_C2C | C2C（Client to Client, 端到端）会话 |
   * | TIM.TYPES.CONV_GROUP | GROUP（群组）会话 |
   * | TIM.TYPES.CONV_SYSTEM | SYSTEM（系统）会话。该会话只能接收来自系统的通知消息，不能发送消息。 |
   * @property {String} subType - 群组会话的群组类型，具体如下：<br/>
   * | 类型 | 含义 |
   * | :--- | :---- |
   * | TIM.TYPES.GRP_PRIVATE | 私有群 |
   * | TIM.TYPES.GRP_PUBLIC | 公开群 |
   * | TIM.TYPES.GRP_CHATROOM | 聊天室 |
   * | TIM.TYPES.GRP_AVCHATROOM | 音视频聊天室 |
   * @property {Number} unreadCount - 未读计数。TIM.TYPES.GRP_CHATROOM / TIM.TYPES.GRP_AVCHATROOM 类型的群组会话不记录未读计数，该字段值为0
   * @property {Object} lastMessage - 会话最新的消息
   * @property {Number} lastMessage.lastTime - 当前会话最新消息的时间戳，单位：秒
   * @property {Number} lastMessage.lastSequence - 当前会话的最新消息的 Sequence
   * @property {String} lastMessage.fromAccount - 最新消息来源用户的 userID
   * @property {String} lastMessage.messageForShow - 最新消息的内容，用于展示。可能值：文本消息内容、"[图片]"、"[语音]"、"[位置]"、"[表情]"、"[文件]"、"[其他]"(自定义消息)。<br/>
   * 若该字段不满足您的需求，您可以使用 payload 来自定义渲染。
   * @property {String} lastMessage.type - 消息类型，具体如下：<br/>
   * | 类型 | 含义 |
   * | :--- | :---- |
   * | TIM.TYPES.MSG_TEXT | 文本消息 |
   * | TIM.TYPES.MSG_IMAGE | 图片消息 |
   * | TIM.TYPES.MSG_SOUND | 音频消息 |
   * | TIM.TYPES.MSG_FILE | 文件消息 |
   * | TIM.TYPES.MSG_GRP_TIP | 群提示消息 |
   * | TIM.TYPES.MSG_GRP_SYS_NOTICE | 群系统通知消息 |
   * @property {Object} lastMessage.payload - 消息的内容，具体如下：<br/>
   * - {@link Message.TextPayload 文本}
   * - {@link Message.ImagePayload 图片}
   * - {@link Message.SoundPayload 音频}
   * - {@link Message.FilePayload 文件}
   * - {@link Message.CustomPayload 自定义}
   * - {@link Message.GroupTipPayload 群提示消息}
   * - {@link Message.GroupSystemNoticePayload 群系统通知} <br/>
   * 注意：收到的音频 / 文件消息的 payload 中没有 url 字段。
   * @property {Group} groupProfile - 群组会话的群组资料
   * @property {Profile} userProfile - C2C会话的用户资料
   *
   */


  var Conversation =
  /*#__PURE__*/
  function () {
    function Conversation(options) {
      _classCallCheck(this, Conversation);

      this.conversationID = options.conversationID || '';
      this.unreadCount = options.unreadCount || 0;
      this.type = options.type || '';
      this.subType = options.subType || '';
      this.lastMessage = computeLastMessage(options.lastMessage); // this._hasInfo = false; // 是否有 userProfile / groupProfile，用于渲染会话列表

      this._isInfoCompleted = false; // userProfile / groupProfile 信息是否完整，用于渲染当前会话

      this._initProfile(options);
    }

    _createClass(Conversation, [{
      key: "_initProfile",
      value: function _initProfile(options) {
        var _this = this;

        Object.keys(options).forEach(function (key) {
          switch (key) {
            case 'userProfile':
              _this.userProfile = options.userProfile;
              break;

            case 'groupProfile':
              _this.groupProfile = options.groupProfile;
              break;
          }
        });

        if (isUndefined(this.userProfile) && this.type === CONVERSATION_TYPES.C2C) {
          this.userProfile = new Profile({
            userID: options.conversationID.replace('C2C', '')
          });
        } else if (isUndefined(this.groupProfile) && this.type === CONVERSATION_TYPES.GROUP) {
          this.groupProfile = new Group({
            groupID: options.conversationID.replace('GROUP', '')
          });
        }
      }
    }, {
      key: "toAccount",
      get: function get() {
        return this.conversationID.replace('C2C', '').replace('GROUP', '');
      }
      /**
       * 判断是否有 Profile
       * @private
       * @readonly
       * @memberof Conversation
       */

    }, {
      key: "hasProfile",
      get: function get() {
        return !isUndefined(this.userProfile) || !isUndefined(this.groupProfile);
      }
    }]);

    return Conversation;
  }();

  /**
   * 会话管理
   * @class ConversationController
   * @extends {IMController}
   * @author rychouwei
   */

  var ConversationController =
  /*#__PURE__*/
  function (_IMController) {
    _inherits(ConversationController, _IMController);

    function ConversationController(tim) {
      var _this;

      _classCallCheck(this, ConversationController);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(ConversationController).call(this, tim));
      _this.conversationMap = new Map();
      _this.hasLocalConversationList = false; // 该字段用于防止：更新对应群组会话的groupProfile时，但内存中还没有conversationMap，导致会话群组信息更新被忽略

      _this.tempGroupList = [];

      _this._initListeners();

      return _this;
    }
    /**
     * 创建临时会话
     * @param {String} conversationID
     * @memberof ConversationController
     */


    _createClass(ConversationController, [{
      key: "createLocalConversation",
      value: function createLocalConversation(conversationID) {
        // 如果内存没有当前会话，则创建
        if (this.conversationMap.has(conversationID)) {
          return this.conversationMap.get(conversationID);
        }

        return new Conversation({
          conversationID: conversationID,
          type: conversationID.slice(0, 3) === CONVERSATION_TYPES.C2C ? CONVERSATION_TYPES.C2C : CONVERSATION_TYPES.GROUP
        });
      }
      /**
       * 判断内存中某会话是否存在
       * @param {String} conversationID
       * @returns {Boolean} 是否存在某会话
       */

    }, {
      key: "hasLocalConversation",
      value: function hasLocalConversation(conversationID) {
        return this.conversationMap.has(conversationID);
      }
      /**
       * 获取会话列表
       * @param {Boolean} [isInitConversations=false] 是否是初始化会话列表时调用，在初始化时调用时不抛外部事件，待同步消息更新会话列表后再抛事件。
       * @returns
       * @memberof ConversationController
       */

    }, {
      key: "getConversationList",
      value: function getConversationList() {
        var _this2 = this;

        var isInitConversations = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
        var emitOuterEvent = !isInitConversations;
        var pack = this.createPackage({
          name: 'conversation',
          action: 'query'
        });
        logger.log('ConversationController.getConversationList.');
        return this.tim.connectionController.request(pack).then(function (_ref) {
          var _ref$data$conversatio = _ref.data.conversations,
              conversations = _ref$data$conversatio === void 0 ? [] : _ref$data$conversatio;

          var conversationOptions = _this2._getConversationOptions(conversations); // 1. 初始化时会话列表时，删除本地比远端多出的会话


          if (isInitConversations) {
            _this2._conversationMapTreeShaking(conversationOptions);
          } // 2. 更新会话列表


          _this2._updateLocalConversationList(conversationOptions, true); // 3. 写入 storage


          _this2._setStorageConversationList(); // 4. 检查是否有暂存的待更新的群组列表，有则更新对应会话的群组信息


          if (_this2.tempGroupList.length > 0) {
            _this2._onUpdateConversationGroupProfile(_this2.tempGroupList);

            _this2.tempGroupList = [];
          } // 5. Not ready则不抛外部事件


          if (_this2._isReady) {
            _this2._emitConversationUpdate(emitOuterEvent);
          } // 6. trigger Ready


          _this2.triggerReady();

          logger.log('ConversationController.getConversationList ok.');
          return IMPromise.resolve({
            conversationList: _this2.getLocalConversationList()
          });
        })["catch"](function (error) {
          logger.error('ConversationController.getConversationList error:', error);
          return IMPromise.reject(error);
        });
      }
      /**
       * 获取会话信息
       * @param {String} conversationID
       */

    }, {
      key: "getConversationProfile",
      value: function getConversationProfile(conversationID) {
        var conversation = this.conversationMap.has(conversationID) ? this.conversationMap.get(conversationID) : this.createLocalConversation(conversationID); // 1. 若会话资料已经完整 或 群系统类型会话，则直接返回对应会话

        if (conversation._isInfoCompleted || conversation.type === CONVERSATION_TYPES.SYSTEM) {
          return IMPromise.resolve({
            conversation: conversation
          });
        } // 2. 完整更新会话 Info


        logger.log('ConversationController.getConversationProfile. conversationID:', conversationID);
        return this._updateUserOrGroupProfileCompletely(conversation).then(function (imResponse) {
          logger.log('ConversationController.getConversationProfile ok. conversationID:', conversationID);
          return imResponse;
        })["catch"](function (imError) {
          logger.error('ConversationController.getConversationProfile error:', imError);
          return IMPromise.reject(imError, true);
        });
      }
      /**
       * 删除会话。
       * 注意：如果没有该会话，会返回true。
       * @param {String|Number} conversationID
       * @returns {Promise} 若删除成功则执行then，否则执行catch
       * @memberof ConversationController
       */

    }, {
      key: "deleteConversation",
      value: function deleteConversation(conversationID) {
        var _this3 = this;

        var options = {};

        if (!this.conversationMap.has(conversationID)) {
          var error = new IMError({
            code: ERROR_CODE.CONVERSATION_NOT_FOUND,
            message: ERROR_MESSAGE.CONVERSATION_NOT_FOUND
          });
          return IMPromise.reject(error);
        }

        switch (this.conversationMap.get(conversationID).type) {
          case CONVERSATION_TYPES.C2C:
            options.type = 1;
            options.toAccount = conversationID.slice(3);
            break;

          case CONVERSATION_TYPES.GROUP:
            options.type = 2;
            options.toGroupID = conversationID.slice(5);
            break;

          case CONVERSATION_TYPES.SYSTEM:
            // 删除所有群系统消息
            this.tim.deleteGroupSystemNotice({
              messageList: this.tim.messageController.getLocalMessageList(conversationID)
            });

            this._deleteLocalConversation(conversationID);

            return IMPromise.resolve({
              conversationID: conversationID
            });

          default:
            {
              var _error = new IMError({
                code: ERROR_CODE.CONVERSATION_UN_RECORDED_TYPE,
                message: ERROR_MESSAGE.CONVERSATION_UN_RECORDED_TYPE
              });

              return IMPromise.reject(_error);
            }
        }

        logger.log('ConversationController.deleteConversation. conversationID:', conversationID);
        var pack = this.createPackage({
          name: 'conversation',
          action: 'delete',
          param: options
        });
        return this.tim.setMessageRead({
          conversationID: conversationID
        }).then(function () {
          return _this3.connectionController.request(pack);
        }).then(function () {
          logger.log('ConversationController.deleteConversation ok. conversationID:', conversationID);

          _this3._deleteLocalConversation(conversationID);

          return IMPromise.resolve({
            conversationID: conversationID
          });
        })["catch"](function (error) {
          logger.error('ConversationController.deleteConversation error:', error);
          return IMPromise.reject(error, true);
        });
      }
      /**
       * 获取群组会话的 最后一条消息的Sequence
       * @param {String} conversationID
       * @returns {Number} lastSequence
       * @memberof ConversationController
       */

    }, {
      key: "getLocalConversationLastSequence",
      value: function getLocalConversationLastSequence(conversationID) {
        if (!this.hasLocalConversation(conversationID)) {
          return 0;
        }

        var conversation = this.conversationMap.get(conversationID);
        var hasLastSequence = !!conversation.lastMessage.lastSequence; // 群组会话从资料中计算得出 lastSequence

        if (!hasLastSequence && conversation.type === TYPES.CONV_GROUP) {
          return conversation.groupProfile.nextMessageSeq - 1;
        }

        return conversation.lastMessage.lastSequence;
      }
      /**
       * 获取会话列表
       * @returns {Promise}
       * @memberof ConversationController
       */

    }, {
      key: "getLocalConversationList",
      value: function getLocalConversationList() {
        return _toConsumableArray(this.conversationMap.values());
      }
      /**
       * 会话对象
       * @typedef {Object} Conversation
       */

      /**
       * 根据conversationID获取会话
       * @param {String} conversationID
       * @returns {Conversation}
       * @memberof ConversationController
       */

    }, {
      key: "getLocalConversation",
      value: function getLocalConversation(conversationID) {
        return this.conversationMap.get(conversationID);
      }
      /**
       * 初始化会话列表。若缓存有则用缓存初始化会话列表，等待消息初始化完成并组装最后一条消息，排序后，向外抛事件
       * @private
       * @memberof ConversationController
       */

    }, {
      key: "_initLocalConversationList",
      value: function _initLocalConversationList() {
        logger.time(label.INIT_CONVERSATION_LIST);
        logger.log('ConversationController._initLocalConversationList init');

        var localConversationList = this._getStorageConversationList();

        this.hasLocalConversationList = localConversationList !== null && localConversationList.length !== 0; // 1. 从本地 storage 初始化会话列表

        if (this.hasLocalConversationList) {
          // 由本地缓存初始化会话列表。本地缓存的会话结构：[[conversationID, 存有会话数据的对象],[conversationID, 存有会话数据的对象]]
          for (var i = 0, length = localConversationList.length; i < length; i++) {
            this.conversationMap.set(localConversationList[i].conversationID, new Conversation(localConversationList[i]));
          }

          this._emitConversationUpdate(true, false);
        } // 2. 从远端拉取数据，更新本地会话列表


        this.getConversationList(true).then(function () {
          logger.log("ConversationController._initLocalConversationList init ok. initCost=".concat(logger.timeEnd(label.INIT_CONVERSATION_LIST), "ms"));
        });
      }
      /**
       * 获取本地 Storage 的会话列表
       * @private
       * @returns {Object}
       * @memberof ConversationController
       */

    }, {
      key: "_getStorageConversationList",
      value: function _getStorageConversationList() {
        return this.tim.storage.getItem('conversationMap');
      }
      /**
       * 设置本地 Storage 会话列表
       * @private
       * @param {Object} conversationMap
       * @memberof ConversationController
       */

    }, {
      key: "_setStorageConversationList",
      value: function _setStorageConversationList() {
        var tempConversationList = [];
        this.conversationMap.forEach(function (_ref2) {
          var conversationID = _ref2.conversationID,
              type = _ref2.type,
              subType = _ref2.subType,
              lastMessage = _ref2.lastMessage,
              groupProfile = _ref2.groupProfile,
              userProfile = _ref2.userProfile;
          tempConversationList.push({
            conversationID: conversationID,
            type: type,
            subType: subType,
            lastMessage: lastMessage,
            groupProfile: groupProfile,
            userProfile: userProfile
          });
        });
        this.tim.storage.setItem('conversationMap', tempConversationList);
      }
      /**
       * 注册监听器
       * @private
       * @memberof ConversationController
       */

    }, {
      key: "_initListeners",
      value: function _initListeners() {
        // 登录态变更时触发，登录成功必触发一次
        this.tim.innerEmitter.once(TIM_INNER_EVENT.CONTEXT_A2KEY_AND_TINYID_UPDATED, this._initLocalConversationList, this); // 发送消息入库后立即触发，

        this.tim.innerEmitter.on(TIM_INNER_EVENT.MESSAGE_SENDING, this._onSendOrReceiveMessage, this); // 发送私聊消息成功

        this.tim.innerEmitter.on(TIM_INNER_EVENT.MESSAGE_SENDINGSEND_SUCCESS, this._onSendOrReceiveMessage, this); // 发送群组消息成功，临时ID入库

        this.tim.innerEmitter.on(TIM_INNER_EVENT.MESSAGE_GROUP_SEND_SUCCESS, this._onSendOrReceiveMessage, this); // 收到消息推送,C2C消息

        this.tim.innerEmitter.on(TIM_INNER_EVENT.MESSAGE_C2C_INSTANT_RECEIVED, this._onSendOrReceiveMessage, this);
        this.tim.innerEmitter.on(TIM_INNER_EVENT.MESSAGE_GROUP_INSTANT_RECEIVED, this._onSendOrReceiveMessage, this);
        this.tim.innerEmitter.on(TIM_INNER_EVENT.MESSAGE_GROUP_SYSTEM_NOTICE_RECEIVED, this._onSendOrReceiveMessage, this); // TODO: 触发条件需补充

        this.tim.innerEmitter.on(TIM_INNER_EVENT.GROUP_LIST_UPDATED, this._onUpdateConversationGroupProfile, this);
        this.tim.innerEmitter.on(TIM_INNER_EVENT.PROFILE_UPDATED, this._onUpdateConversationUserProfile, this);
      }
      /**
       * 更新会话的群组信息
       * @private
       * @param {Array} groupList
       * @memberof ConversationController
       */

    }, {
      key: "_onUpdateConversationGroupProfile",
      value: function _onUpdateConversationGroupProfile(groupList) {
        var _this4 = this;

        if (!this.hasLocalConversationList) {
          this.tempGroupList = groupList; // 该字段用于处理 本地无数据，对方请求先回来导致，更新被忽略的问题。
        }

        groupList.forEach(function (group) {
          var conversationID = "GROUP".concat(group.groupID);

          if (_this4.conversationMap.has(conversationID)) {
            var conversation = _this4.conversationMap.get(conversationID);

            conversation.groupProfile = group;
            conversation.lastMessage.lastSequence = group.nextMessageSeq - 1;

            if (!conversation.subType) {
              conversation.subType = group.type;
            }
          }
        });

        this._emitConversationUpdate(true, false);
      }
      /**
       * 更新会话的 userProfile
       * 当有用户资料更新时，会调用该函数
       * @param {Profile[]} profileList
       * @memberof ConversationController
       */

    }, {
      key: "_onUpdateConversationUserProfile",
      value: function _onUpdateConversationUserProfile(_ref3) {
        var _this5 = this;

        var profileList = _ref3.data;
        profileList.forEach(function (profile) {
          var conversationID = "C2C".concat(profile.userID);

          if (_this5.conversationMap.has(conversationID)) {
            _this5.conversationMap.get(conversationID).userProfile = profile;
          }
        });

        this._emitConversationUpdate(true, false);
      }
      /**
       * 收到消息或者发送消息时，更新会话
       * @private
       * @param {Object} event
       * @memberof ConversationController
       */

    }, {
      key: "_onSendOrReceiveMessage",
      value: function _onSendOrReceiveMessage(event) {
        var _this6 = this;

        var conversations = event.data.eventDataList;

        if (!this._isReady) {
          this.ready(function () {
            _this6._onSendOrReceiveMessage(event);
          });
          return;
        }

        if (conversations.length === 0) {
          return;
        } // 1. 更新内存的会话列表


        this._updateLocalConversationList(conversations, false); // 2. 同步到 storage


        this._setStorageConversationList(); // 3. emit事件


        this._emitConversationUpdate();
      }
      /**
       * 更新会话。若已有会话则更新会话，否则新建会话
       * @private
       * @param {Array} conversationOptions 创建会话所需的配置
       * @param {Boolean} isFromGetConversations 是否来自于拉取会话列表。用于 unreadCount 的更新。
       * @example
       * // 会话更新逻辑
       * let conversations = ['a','b','c','d','e']; //现有的会话列表
       * // 若 d,e 会话先后收到消息，则更新逻辑为
       * // 1.取出更新的部分,并删除原会话列表更新的部分
       * let temp = ['d','e']; //更新的会话
       * let conversations = ['a','b','c'] // 删除待更新会话后的会话列表
       * // 2.排序更新的部分
       * let sortedTemp = ['e','d']; //排序后的临时会话
       * // 3.从头部插入
       * new Map([...temp, ...conversations])
       */

    }, {
      key: "_updateLocalConversationList",
      value: function _updateLocalConversationList(conversationOptions, isFromGetConversations) {
        var temp = {
          conversations: [],
          // 临时会话列表，存有所有待更新的会话
          newerConversations: [] // 存有新增的会话，后续要更新这些会话的 userProfile || groupProfile

        }; // 1. 更新临时会话列表

        temp = this._updateTempConversations(conversationOptions, isFromGetConversations); // 2. 合并会话列表后 排序

        this.conversationMap = new Map(this._sortConversations([].concat(_toConsumableArray(temp.conversations), _toConsumableArray(this.conversationMap)))); // 3. 【异步】 更新新增的会话中的 userProfile || groupProfile

        this._updateUserOrGroupProfile(temp.newerConversations);
      }
      /**
       * 更新临时会话列表
       * @param {Obejct[]} conversations
       * @param {Boolean} isFromGetConversations
       * @returns
       * @memberof ConversationController
       */

    }, {
      key: "_updateTempConversations",
      value: function _updateTempConversations(conversationOptions, isFromGetConversations) {
        // 临时保存更新的会话，对更新的部分进行排序（减少排序的数量，降低复杂度），然后用 new Map([...tempConversations, ...this.conversationMap])实现更新
        var tempConversations = [];
        var tempNewerConversations = [];

        for (var i = 0, length = conversationOptions.length; i < length; i++) {
          // 1. 创建临时会话 和 取得现有会话
          var tempConversation = new Conversation(conversationOptions[i]); // 临时会话

          var conversation = this.conversationMap.get(tempConversation.conversationID); // 现有会话
          // 2. 记录新增的会话，后续要更新这个数组内的 userProfile || groupProfile

          if (!this.conversationMap.has(tempConversation.conversationID)) {
            tempNewerConversations.push(tempConversation);
            tempConversations.push([tempConversation.conversationID, tempConversation]);
          } else {
            // 忽略 payload 的 merge。因为不同类型消息的 payload merge 后会导致：payload 混杂各种消息类型的消息体。
            var keysToIgnoreMerge = ['unreadCount', 'allowType', 'adminForbidType', 'payload'];
            var valuesIgnore = [null, undefined, '', 0, NaN];
            deepMerge(conversation, tempConversation, keysToIgnoreMerge, valuesIgnore); // 3. 更新临时会话的未读计数

            conversation.unreadCount = this._updateUnreadCount(conversation, tempConversation, isFromGetConversations); // 4. 更新 payload

            conversation.lastMessage.payload = conversationOptions[i].lastMessage.payload; // 5. 移除现有会话

            this.conversationMap["delete"](conversation.conversationID); // 6. 将临时会话插入 tempConversations

            tempConversations.push([conversation.conversationID, conversation]);
          }
        }

        return {
          conversations: tempConversations,
          newerConversations: tempNewerConversations
        };
      }
      /**
       * 更新未读计数
       * 更新逻辑：
       * 1. 若是来自拉取会话列表
       * C2C: 用原值
       * GROUP: 用后端计算好的值
       * 2. 若不是
       * 传来的值 + 原值
       * 3. 特殊逻辑
       * ChatRoom 和 AVChatRoom 无未读计数
       * @param {Conversation} conversation 现有的会话
       * @param {Conversation} tempConversation 临时会话
       * @param {Boolean} isFromGetConversations
       * @returns
       * @memberof ConversationController
       */

    }, {
      key: "_updateUnreadCount",
      value: function _updateUnreadCount(conversation, tempConversation, isFromGetConversations) {
        // ChatRoom 和 AVChatRoom 的 unreadCount 值为 0
        if ([GROUP_TYPES.CHATROOM, GROUP_TYPES.AVCHATROOM].includes(conversation.subType)) {
          return 0;
        }

        if (isFromGetConversations) {
          // 若是【拉取会话列表】后更新会话，C2C用原有会话的未读计数。
          if (conversation.type === CONVERSATION_TYPES.C2C) {
            return conversation.unreadCount;
          }

          if (conversation.type === CONVERSATION_TYPES.GROUP) {
            // Group 用后端计算好的未读计数
            return tempConversation.unreadCount;
          }
        }

        return tempConversation.unreadCount + conversation.unreadCount;
      }
      /**
       * 排序会话列表
       * @param {Object[]} conversations
       * @returns
       * @memberof ConversationController
       */

    }, {
      key: "_sortConversations",
      value: function _sortConversations(conversations) {
        return conversations.sort(function (a, b) {
          return b[1].lastMessage.lastTime - a[1].lastMessage.lastTime;
        });
      }
      /**
       * 更新会话的 userProfile/groupProfile，更新至够渲染会话列表。
       * @param {*} conversations
       * @returns
       * @memberof ConversationController
       */

    }, {
      key: "_updateUserOrGroupProfile",
      value: function _updateUserOrGroupProfile(conversations) {
        var _this7 = this;

        var C2CUserIDList = [];
        var groupIDList = []; // 1. 遍历找出哪些会话需要更新 userProfile / groupProfile

        conversations.forEach(function (conversation) {
          if (!conversation.hasProfile) {
            if (conversation.type === CONVERSATION_TYPES.C2C) {
              C2CUserIDList.push(conversation.toAccount);
            } else if (conversation.type === CONVERSATION_TYPES.GROUP) {
              var groupID = conversation.toAccount; // 若群组列表中已经有该群，则不需要发请求

              if (_this7.tim.groupController.getLocalGroupProfile(groupID)) {
                conversation.groupProfile = _this7.tim.groupController.getLocalGroupProfile(groupID);
              } else {
                groupIDList.push(conversation.toAccount);
              }
            }
          }
        }); // 2. 更新 userProfile

        if (C2CUserIDList.length > 0) {
          return this.tim.getUserProfile({
            userIDList: C2CUserIDList
          }).then(function (_ref4) {
            var data = _ref4.data;

            if (isArray(data)) {
              data.forEach(function (item) {
                _this7.conversationMap.get("C2C".concat(item.userID)).userProfile = item;
              });
            } else {
              _this7.conversationMap.get("C2C".concat(data.userID)).userProfile = data;
            }
          });
        } // 3. 更新 groupProfile


        if (groupIDList.length > 0) {
          return this.tim.getGroupProfileAdvance({
            groupIDList: groupIDList,
            responseFilter: {
              groupBaseInfoFilter: ['Type', 'Name', 'FaceUrl']
            }
          }).then(function (_ref5) {
            var groups = _ref5.data.successGroupList;
            groups.forEach(function (group) {
              var conversationID = "GROUP".concat(group.groupID);

              if (_this7.conversationMap.has(conversationID)) {
                var conversation = _this7.conversationMap.get(conversationID);

                deepMerge(conversation.groupProfile, group, [], [null, undefined, '', 0, NaN]); // 更新subType

                if (!conversation.subType && group.type) {
                  conversation.subType = group.type;
                }
              }
            });
          });
        }
      }
      /**
       * 全量更新会话的 userProfile/groupProfile，更新至够渲染会话完整资料
       * @param {String} conversationID
       * @returns
       * @memberof ConversationController
       */

    }, {
      key: "_updateUserOrGroupProfileCompletely",
      value: function _updateUserOrGroupProfileCompletely(conversation) {
        var _this8 = this;

        if (conversation.type === CONVERSATION_TYPES.C2C) {
          return this.tim.getUserProfile({
            userIDList: [conversation.toAccount]
          }).then(function (_ref6) {
            var data = _ref6.data;

            if (data.length === 0) {
              return IMPromise.reject(new IMError({
                code: ERROR_CODE.USER_OR_GROUP_NOT_FOUND,
                message: ERROR_MESSAGE.USER_OR_GROUP_NOT_FOUND
              }));
            }

            conversation.userProfile = data[0];
            conversation._isInfoCompleted = true;

            _this8._unshiftConversation(conversation);

            return IMPromise.resolve({
              conversation: conversation
            });
          });
        }

        return this.tim.getGroupProfile({
          groupID: conversation.toAccount
        }).then(function (response) {
          conversation.groupProfile = response.data.group;
          conversation._isInfoCompleted = true;

          _this8._unshiftConversation(conversation);

          return IMPromise.resolve({
            conversation: conversation
          });
        });
      }
      /**
       * 从conversationMap头部插入会话
       * @private
       * @param {Object} conversation
       * @memberof ConversationController
       */

    }, {
      key: "_unshiftConversation",
      value: function _unshiftConversation(conversation) {
        if (conversation instanceof Conversation && !this.conversationMap.has(conversation.conversationID)) {
          this.conversationMap = new Map([[conversation.conversationID, conversation]].concat(_toConsumableArray(this.conversationMap)));

          this._setStorageConversationList();

          this._emitConversationUpdate(true, false);
        }
      }
      /**
       * 删除内存中的会话
       * @private
       * @param {String} conversationID
       */

    }, {
      key: "_deleteLocalConversation",
      value: function _deleteLocalConversation(conversationID) {
        this.conversationMap["delete"](conversationID);

        this._setStorageConversationList();

        this._emitConversationUpdate(true, false);

        return this.conversationMap.has(conversationID);
      }
      /**
       * 从后端返回的会话列表，解析出能够初始化 Conversation 的 options
       * @private
       * @param {Array} conversations
       */

    }, {
      key: "_getConversationOptions",
      value: function _getConversationOptions(conversations) {
        // 用于 ProfileHandler 控制缓存数据更新
        var profiles = [];
        var conversationOptions = conversations.map(function (conversation) {
          // C2C 类型
          if (conversation.type === 1) {
            var profileOptions = {
              userID: conversation.userID,
              nick: conversation.c2CNick,
              avatar: conversation.c2CImage
            };
            profiles.push(profileOptions);
            return {
              conversationID: "C2C".concat(conversation.userID),
              type: 'C2C',
              lastMessage: {
                lastTime: conversation.time,
                lastSequence: conversation.sequence,
                fromAccount: conversation.lastC2CMsgFromAccount,
                messageForShow: conversation.messageShow,
                type: conversation.lastMsg.elements[0] ? conversation.lastMsg.elements[0].type : null,
                payload: conversation.lastMsg.elements[0] ? conversation.lastMsg.elements[0].content : null
              },
              userProfile: new Profile(profileOptions)
            };
          } // GROUP 类型


          return {
            conversationID: "GROUP".concat(conversation.groupID),
            type: 'GROUP',
            lastMessage: {
              lastTime: conversation.time,
              lastSequence: conversation.messageReadSeq + conversation.unreadCount,
              fromAccount: conversation.msgGroupFromAccount,
              messageForShow: conversation.messageShow,
              type: conversation.lastMsg.elements[0] ? conversation.lastMsg.elements[0].type : null,
              payload: conversation.lastMsg.elements[0] ? conversation.lastMsg.elements[0].content : null
            },
            groupProfile: new Group({
              groupID: conversation.groupID,
              name: conversation.groupNick,
              avatar: conversation.groupImage
            }),
            unreadCount: conversation.unreadCount
          };
        }); // 抛事件通知 ProfileHandler

        if (profiles.length > 0) {
          this.tim.innerEmitter.emit(TIM_INNER_EVENT.CONVERSATION_LIST_PROFILE_UPDATED, {
            data: profiles
          });
        }

        return conversationOptions;
      }
      /**
       * 更新群组会话的 unreadCount 和 subType
       * @private
       * @param {Array} conversations
       */
      // _updateGroupConversationsUnreadCountAndSubType(conversations) {
      //   // 1 保存群组类型会话的 messageReadSeq，用于后面计算未读计数
      //   let tempMessageReadSeq = {};
      //   // 2 取得群组类型会话的 groupID列表
      //   let groupIDList = conversations
      //     .filter(conversation => conversation.type === 2)
      //     .map(conversation => {
      //       tempMessageReadSeq[conversation.groupID] = conversation.messageReadSeq;
      //       return conversation.groupID;
      //     });
      //   // 3 若 groupIDList 为空 则直接返回
      //   if (groupIDList.length === 0) {
      //     return Promise.resolve(this.getLocalConversationList());
      //   }
      //   return this.tim
      //     .getGroupProfileAdvance({
      //       groupIDList,
      //       responseFilter: {
      //         groupBaseInfoFilter: ['NextMsgSeq', 'Type']
      //       }
      //     })
      //     .then(({ data: { successGroupList: groups } }) => {
      //       // 4 更新群组会话的 lastSequence, subType, unreadCount
      //       for (let i = 0, len = groups.length; i < len; i++) {
      //         let groupID = groups[i].groupID;
      //         let conversation = this.conversationMap.get(`GROUP${groupID}`);
      //         conversation.lastMessage.lastSequence = groups[i].nextMessageSeq - 1;
      //         conversation.subType = groups[i].type;
      //         // 若是 ChatRoom 类型的群会话，则未读置为 0，因为 ChatRoom 无未读
      //         conversation.unreadCount =
      //           groups[i].type === 'ChatRoom' ? 0 : conversation.lastMessage.lastSequence - tempMessageReadSeq[groupID];
      //       }
      //       return this.getLocalConversationList();
      //     });
      // }

      /**
       * 抛出 会话更新 事件
       * @param {Conversation[]} conversations
       * @param {Boolean} [outer=true] 是否抛外部事件 默认抛外部
       * @param {Boolean} [inner=true] 是否抛内部事件 默认抛内部
       * @memberof ConversationController
       */

    }, {
      key: "_emitConversationUpdate",
      value: function _emitConversationUpdate() {
        var outer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
        var inner = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

        var conversationList = _toConsumableArray(this.conversationMap.values());

        if (inner) {
          this.tim.innerEmitter.emit(TIM_INNER_EVENT.CONVERSATION_LIST_UPDATED, conversationList);
        }

        if (outer) {
          this.tim.outerEmitter.emit(TIM_OUTER_EVENT.CONVERSATION_LIST_UPDATED, conversationList);
        }
      }
      /**
       * 删除本地会话Map中比远端多处的部分
       * 不直接清空本地Map的原因是：防止原有的数据丢失
       * @param {Object} conversationOptions 会话配置列表
       * @memberof ConversationController
       */

    }, {
      key: "_conversationMapTreeShaking",
      value: function _conversationMapTreeShaking(conversationOptions) {
        var _this9 = this;

        var tempConversationMap = new Map(_toConsumableArray(this.conversationMap));
        conversationOptions.forEach(function (item) {
          return tempConversationMap["delete"](item.conversationID);
        }); // 找出多出的会话
        // 忽略系统通知会话

        if (tempConversationMap.has(SYSTEM_CONVERSATION_ID)) {
          tempConversationMap["delete"](SYSTEM_CONVERSATION_ID);
        } // 忽略加入的AVChatRoom


        if (this.tim.groupController.AVChatRoomHandler.isJoined) {
          tempConversationMap["delete"]("".concat(CONVERSATION_TYPES.GROUP).concat(this.tim.groupController.AVChatRoomHandler.group.groupID));
        }

        var keysToDelete = _toConsumableArray(tempConversationMap.keys());

        keysToDelete.forEach(function (key) {
          return _this9.conversationMap["delete"](key);
        });
      }
      /**
       * reset ConversationController
       */

    }, {
      key: "reset",
      value: function reset() {
        this.conversationMap.clear();
        this.hasLocalConversationList = false;
        this.resetReady();
        this.tim.innerEmitter.once(TIM_INNER_EVENT.CONTEXT_A2KEY_AND_TINYID_UPDATED, this._initLocalConversationList, this);
      }
    }]);

    return ConversationController;
  }(IMController);

  /**
   * 消息列表, 同时也负责管理消息的缓存
   * @author SaxonGao
   */

  var MessagesList =
  /*#__PURE__*/
  function () {
    function MessagesList(options) {
      _classCallCheck(this, MessagesList);

      if (typeof options === 'undefined') {
        throw new IMError({
          code: ERROR_CODE.MESSAGE_LIST_CONSTRUCTOR_NEED_OPTIONS,
          message: ERROR_MESSAGE.MESSAGE_LIST_CONSTRUCTOR_NEED_OPTIONS
        });
      }

      if (typeof options.tim === 'undefined') {
        throw new IMError({
          code: ERROR_CODE.MESSAGE_LIST_CONSTRUCTOR_NEED_OPTIONS,
          message: "".concat(ERROR_MESSAGE.MESSAGE_LIST_CONSTRUCTOR_NEED_OPTIONS, ".tim")
        });
      }

      this.list = new Map();
      this.tim = options.tim;

      this._initializeOptions(options);
    }
    /**
     * 获取某个会话下最旧的一条消息
     * @param {String} conversationID - 会话ID
     */


    _createClass(MessagesList, [{
      key: "getLocalOldestMessageByConversationID",
      value: function getLocalOldestMessageByConversationID(conversationID) {
        if (!conversationID) {
          return null;
        }

        if (!this.list.has(conversationID)) {
          return null;
        }

        var messagesIterator = this.list.get(conversationID).values();

        if (!messagesIterator) {
          return null;
        }

        return messagesIterator.next().value;
      }
      /**
       * 初始化配置参数
       * @param {object} param
       */

    }, {
      key: "_initializeOptions",
      value: function _initializeOptions(param) {
        this.options = {};
        var defaultOptions = {
          memory: {
            maxDatasPerKey: 100,
            // 每个 key 下最多存储的数据条数, 默认100，0为不限制
            maxBytesPerData: 256,
            // 每条数据的大小限制，单位是字节，默认256 , 0 为不限制
            maxKeys: 0 // key的总数限制,默认为0，不限制

          },
          cache: {
            maxDatasPerKey: 10,
            // 每个 key 下最多存储的数据条数, 默认100，0为不限制
            maxBytesPerData: 256,
            // 每条数据的大小限制，单位是字节，默认256 , 0 为不限制
            maxKeys: 0 // key的总数限制,默认为0，不限制

          }
        };

        for (var p in defaultOptions) {
          if (typeof param[p] === 'undefined') {
            this.options[p] = defaultOptions[p];
            continue;
          }

          var typesOptions = defaultOptions[p];

          for (var key in typesOptions) {
            if (typeof param[p][key] === 'undefined') {
              this.options[p][key] = typesOptions[key];
              continue;
            }

            this.options[p][key] = param[p][key];
          }
        }
      }
      /**
       * 把 message 包装为 key - value的形式， 其中 key 是会话ID , value 是消息的结构
       * @param {Object} message
       */

    }, {
      key: "_parseMessageFormLikeKeyValue",
      value: function _parseMessageFormLikeKeyValue(message) {
        var cacheOptions = [message.conversationID, message];
        return cacheOptions;
      }
      /**
       * 把一条消息从 MessageList 底部插入
       * @param {Object} message
       */

    }, {
      key: "pushIn",
      value: function pushIn(message) {
        var cacheData = this._parseMessageFormLikeKeyValue(message); // 是否是重复的消息


        var isRepeated = false; // logger.log('pushIn', cacheData);
        // this.list.set(cacheData);

        if (typeof this.list.get(cacheData[0]) === 'undefined') {
          this.list.set(cacheData[0], new Map());
        }

        if (this.list.has(message.conversationID) && this.list.get(message.conversationID).has(cacheData[1].ID)) {
          isRepeated = true;
        }

        this.list.get(cacheData[0]).set(cacheData[1].ID, cacheData[1]);

        if (!isRepeated) {
          return message;
        }
      }
      /**
       * 从MessageList的顶部插入消息
       * @param {Object} messages
       */

    }, {
      key: "shiftIn",
      value: function shiftIn(messages) {
        if (!Array.isArray(messages)) {
          this._shiftSingleMessage(messages);

          return this;
        }

        if (messages.length === 0) {
          return this;
        }

        this._shiftInMultipleMessages(messages);

        return this;
      }
      /**
       * 把一条消息从 MessageList 顶部插入
       * @param {*} message
       */

    }, {
      key: "_shiftSingleMessage",
      value: function _shiftSingleMessage(message) {
        var cacheData = this._parseMessageFormLikeKeyValue(message);

        if (typeof this.list.get(cacheData[0]) === 'undefined') {
          this.list.set(cacheData[0], new Map());
          this.list.get(cacheData[0]).set(cacheData[1].ID, cacheData[1]);
          return;
        } // Map 对象无法直接做shift 操作，先转化为数组


        var conversationsMessageListArray = Array.from(this.list.get(cacheData[0])); // shift

        conversationsMessageListArray.unshift([cacheData[1].ID, cacheData[1]]); // 重新转化为Map

        this.list.set(cacheData[0], new Map(conversationsMessageListArray));
      }
      /**
       * 把多条消息从 MessageList 顶部插入
       * @param {*} messages
       */

    }, {
      key: "_shiftInMultipleMessages",
      value: function _shiftInMultipleMessages(messages) {
        var len = messages.length; // let cacheData = [];

        var tempList = [];
        var conversationID = messages[0].conversationID;
        var conversationsMessageListArray = this.list.has(conversationID) ? Array.from(this.list.get(conversationID)) : [];

        for (var i = 0; i < len; i++) {
          // cacheData = this._parseMessageFormLikeKeyValue(messages[i]);
          tempList.push([messages[i].ID, messages[i]]);
        }

        this.list.set(conversationID, new Map(tempList.concat(conversationsMessageListArray)));
      }
      /**
       * 从消息列表中删除一条消息
       * @param {Message} message
       * @returns {MessagesList} - 返回MessagesList的实例
       */

    }, {
      key: "remove",
      value: function remove(message) {
        var conversationID = message.conversationID,
            ID = message.ID;
        this.list.get(conversationID)["delete"](ID);
        return this;
      }
    }]);

    return MessagesList;
  }();

  var ReadReportHandler =
  /*#__PURE__*/
  function () {
    function ReadReportHandler(tim) {
      _classCallCheck(this, ReadReportHandler);

      this.tim = tim;
    }
    /**
     * 消息已读上报
     * @param {Object} options
     * @param {String} options.conversationID
     * @param {String} options.messageID
     * @returns
     * @memberof ConversationController
     */


    _createClass(ReadReportHandler, [{
      key: "setMessageRead",
      value: function setMessageRead(_ref) {
        var conversationID = _ref.conversationID,
            messageID = _ref.messageID;
        var conversation = this.tim.conversationController.getLocalConversation(conversationID);

        if (!conversation || conversation.unreadCount === 0) {
          return IMPromise.resolve();
        }

        var message = messageID ? this.tim.messageController.getLocalMessage(conversationID, messageID) : null;

        switch (conversation.type) {
          case CONVERSATION_TYPES.C2C:
            return this._setC2CMessageRead({
              conversationID: conversationID,
              lastMessageTime: message ? message.time : conversation.lastMessage.lastTime
            });

          case CONVERSATION_TYPES.GROUP:
            return this._setGroupMessageRead({
              conversationID: conversationID,
              lastMessageSeq: message ? message.sequence : conversation.lastMessage.lastSequence
            });

          case CONVERSATION_TYPES.SYSTEM:
            conversation.unreadCount = 0;
            return IMPromise.resolve();

          default:
            return IMPromise.resolve();
        }
      }
      /**
       * C2C 消息已读
       * @param {*} options
       * @memberof ConversationController
       */

    }, {
      key: "_setC2CMessageRead",
      value: function _setC2CMessageRead(_ref2) {
        var _this = this;

        var conversationID = _ref2.conversationID,
            lastMessageTime = _ref2.lastMessageTime;
        var pack = this.tim.messageController.createPackage({
          name: 'conversation',
          action: 'setC2CMessageRead',
          param: {
            C2CMsgReaded: {
              cookie: '',
              C2CMsgReadedItem: [{
                toAccount: conversationID.replace('C2C', ''),
                lastMessageTime: lastMessageTime
              }]
            }
          }
        });

        this._updateIsReadAfterReadReport({
          conversationID: conversationID,
          lastMessageTime: lastMessageTime
        });

        this._updateUnreadCount(conversationID);

        return this.tim.connectionController.request(pack).then(function () {
          return new IMResponse();
        })["catch"](function (error) {
          _this.tim.innerEmitter.emit(TIM_INNER_EVENT.ERROR_DETECTED, error);

          return Promise.reject(new IMResponse(error));
        });
      }
      /**
       * 群消息已读
       * @param {Object} options
       * @memberof ConversationController
       */

    }, {
      key: "_setGroupMessageRead",
      value: function _setGroupMessageRead(_ref3) {
        var _this2 = this;

        var conversationID = _ref3.conversationID,
            lastMessageSeq = _ref3.lastMessageSeq;
        var pack = this.tim.messageController.createPackage({
          name: 'conversation',
          action: 'setGroupMessageRead',
          param: {
            groupID: conversationID.replace('GROUP', ''),
            messageReadSeq: lastMessageSeq
          }
        });

        this._updateIsReadAfterReadReport({
          conversationID: conversationID,
          lastMessageSeq: lastMessageSeq
        });

        this._updateUnreadCount(conversationID);

        return this.tim.connectionController.request(pack).then(function () {
          return new IMResponse();
        })["catch"](function (error) {
          _this2.tim.innerEmitter.emit(TIM_INNER_EVENT.ERROR_DETECTED, error);

          return Promise.reject(new IMResponse(error));
        });
      }
      /**
       * 更新会话的未读数
       * 调用时机：上报已读后
       * @param {String} conversationID
       * @returns
       * @memberof ReadReportHandler
       */

    }, {
      key: "_updateUnreadCount",
      value: function _updateUnreadCount(conversationID) {
        var _this$tim = this.tim,
            conversationController = _this$tim.conversationController,
            messageController = _this$tim.messageController;
        var conversation = conversationController.getLocalConversation(conversationID);
        var messageList = messageController.getLocalMessageList(conversationID);

        if (!conversation) {
          return;
        }

        conversation.unreadCount = messageList.filter(function (item) {
          return !item.isRead;
        }).length;
      }
      /**
       * 更新消息列表的 isRead 值
       * 调用时机：上报已读后调用
       * @private
       * @param {Object} options
       * @param {String} options.conversationID
       * @param {Number} [options.lastMessageTime] 更新C2C会话lastMessageTime之前的消息的isRead值为 true
       * @param {Number} [options.lastMessageSeq] 更新GROUP会话lastMessageSeq之前的消息的isRead值为 true
       * @memberof ReadReportHandler
       */

    }, {
      key: "_updateIsReadAfterReadReport",
      value: function _updateIsReadAfterReadReport(_ref4) {
        var conversationID = _ref4.conversationID,
            lastMessageSeq = _ref4.lastMessageSeq,
            lastMessageTime = _ref4.lastMessageTime;
        var messageList = this.tim.messageController.getLocalMessageList(conversationID);

        if (messageList.length === 0) {
          return;
        } // 从后往前遍历


        for (var i = messageList.length - 1; i >= 0; i--) {
          var message = messageList[i]; // 不在上报范围的消息 continue

          if (lastMessageTime && message.time > lastMessageTime || lastMessageSeq && message.sequence > lastMessageSeq) {
            continue;
          } // 遇到 收到的 且 isRead 为true的消息时，跳出循环。因为该消息之前的isRead都为true


          if (message.flow === 'in' && message.isRead) {
            break;
          }

          message.isRead = true;
        }
      }
      /**
       * 更新消息列表的 isRead 值
       * 调用时机：拉取历史消息后
       * @param {String} conversationID
       * @memberof ReadReportHandler
       */

    }, {
      key: "updateIsRead",
      value: function updateIsRead(conversationID) {
        var _this$tim2 = this.tim,
            conversationController = _this$tim2.conversationController,
            messageController = _this$tim2.messageController; // 会话

        var conversation = conversationController.getLocalConversation(conversationID); // 会话的消息列表

        var messageList = messageController.getLocalMessageList(conversationID);

        if (!conversation || messageList.length === 0 || ![CONVERSATION_TYPES.C2C, CONVERSATION_TYPES.GROUP].includes(conversation.type)) {
          return;
        } // 从前往后遍历


        for (var i = 0; i < messageList.length - conversation.unreadCount; i++) {
          // 遇到isRead为true的消息时则跳出循环，因为此后的消息isRead都是true
          if (messageList[i].isRead) {
            break;
          }

          messageList[i].isRead = true;
        }
      }
    }]);

    return ReadReportHandler;
  }();

  var GetMessageHandler =
  /*#__PURE__*/
  function () {
    function GetMessageHandler(_ref) {
      var tim = _ref.tim,
          messageController = _ref.messageController;

      _classCallCheck(this, GetMessageHandler);

      this.tim = tim;
      this.messageController = messageController;
      this.completedMap = new Map();

      this._initListener();
    }
    /**
     * 获取消息列表
     * @param {Object} options
     * @memberof GetMessageHandler
     */


    _createClass(GetMessageHandler, [{
      key: "getMessageList",
      value: function getMessageList(_ref2) {
        var _this = this;

        var conversationID = _ref2.conversationID,
            nextReqMessageID = _ref2.nextReqMessageID,
            _ref2$count = _ref2.count,
            count = _ref2$count === void 0 ? 15 : _ref2$count;

        // 1. 计算剩余消息数量
        var leftCount = this._computeLeftCount({
          conversationID: conversationID,
          nextReqMessageID: nextReqMessageID
        }); // 2. 判断是否要拉历史记录


        if (this._needGetHistory({
          conversationID: conversationID,
          leftCount: leftCount,
          count: count
        })) {
          return this.messageController.getHistoryMessages({
            conversationID: conversationID,
            count: 20
          }).then(function () {
            leftCount = _this._computeLeftCount({
              conversationID: conversationID,
              nextReqMessageID: nextReqMessageID
            });
            return new IMResponse(_this._computeResult({
              conversationID: conversationID,
              nextReqMessageID: nextReqMessageID,
              count: count,
              leftCount: leftCount
            }));
          });
        } // 3. 不拉历史则返回数据


        return IMPromise.resolve(this._computeResult({
          conversationID: conversationID,
          nextReqMessageID: nextReqMessageID,
          count: count,
          leftCount: leftCount
        }));
      }
      /**
       * 记录某会话已经拉完历史消息
       * @param {String} conversationID
       * @memberof GetMessageHandler
       */

    }, {
      key: "setCompleted",
      value: function setCompleted(conversationID) {
        this.completedMap.set(conversationID, true);
      }
    }, {
      key: "_initListener",
      value: function _initListener() {
        var _this2 = this;

        this.tim.innerEmitter.on(TIM_INNER_EVENT.SDK_READY, function () {
          // SDK_READY时说明已经同步完未读，这时候群系统通知会话的ev5都拉下来了。将群系统通知会话加入completedMap中
          _this2.completedMap.set(CONVERSATION_TYPES.SYSTEM, true);
        });
        this.tim.innerEmitter.on(TIM_INNER_EVENT.AVCHATROOM_JOIN_SUCCESS, function (_ref3) {
          var groupID = _ref3.data;

          _this2.completedMap.set("".concat(CONVERSATION_TYPES.GROUP).concat(groupID));
        });
      }
      /**
       * 判断本地是否有某会话的消息列表
       * @private
       * @param {String} conversationID
       * @returns {Boolean}
       * @memberof GetMessageHandler
       */

    }, {
      key: "_hasMessageList",
      value: function _hasMessageList(conversationID) {
        return this.messageController.messagesList.list.has(conversationID);
      }
      /**
       * 获取本地某会话的消息列表大小
       * @private
       * @param {String} conversationID
       * @returns {Number}
       * @memberof GetMessageHandler
       */

    }, {
      key: "_getMessageListSize",
      value: function _getMessageListSize(conversationID) {
        var messageList = this.messageController.messagesList.list.get(conversationID);
        return messageList ? messageList.size : 0;
      }
      /**
       * 判断是否需要拉历史消息
       * @private
       * @param {Object} options
       * @param {Object} options.conversationID
       * @param {Object} options.leftCount 符合要求的剩余消息数量
       * @param {Object} options.count 用户需要的消息数量
       * @returns {Boolean}
       * @memberof GetMessageHandler
       */

    }, {
      key: "_needGetHistory",
      value: function _needGetHistory(_ref4) {
        var conversationID = _ref4.conversationID,
            leftCount = _ref4.leftCount,
            count = _ref4.count;
        var conversation = this.tim.conversationController.getLocalConversation(conversationID);
        var isSystemConversation = conversation ? conversation.type === CONVERSATION_TYPES.SYSTEM : false;
        var isAVChatRoom = conversation ? conversation.subType === GROUP_TYPES.AVCHATROOM : false; // 群系统通知 和 AVChatRoom 会话不拉历史

        if (isSystemConversation || isAVChatRoom) {
          return false;
        } // 剩余消息数不够 且 未拉完历史消息时 需要拉历史消息


        return leftCount < count && !this.completedMap.has(conversationID);
      }
      /**
       * 计算 getMessageList 的返回结果
       * @private
       * @param {Object} options
       * @param {Object} options.conversationID
       * @param {Object} options.nextReqMessageID
       * @param {Object} options.leftCount 符合要求的剩余消息数量
       * @param {Object} options.count 用户需要的消息数量
       * @returns {Boolean}
       * @memberof GetMessageHandler
       */

    }, {
      key: "_computeResult",
      value: function _computeResult(_ref5) {
        var conversationID = _ref5.conversationID,
            nextReqMessageID = _ref5.nextReqMessageID,
            count = _ref5.count,
            leftCount = _ref5.leftCount;

        var messageList = this._computeMessageList({
          conversationID: conversationID,
          nextReqMessageID: nextReqMessageID,
          count: count
        });

        var isCompleted = this._computeIsCompleted({
          conversationID: conversationID,
          leftCount: leftCount,
          count: count
        });

        return {
          messageList: messageList,
          nextReqMessageID: this._computeNextReqMessageID({
            messageList: messageList,
            isCompleted: isCompleted,
            conversationID: conversationID
          }),
          isCompleted: isCompleted
        };
      }
      /**
       * 计算 nextReqMessageID
       * @private
       * @param {Obejct} options
       * @param {Array} options.messageList
       * @param {Array} options.isCompleted true 时表示没有更多消息可拉取
       * @returns {String}
       * @memberof GetMessageHandler
       */

    }, {
      key: "_computeNextReqMessageID",
      value: function _computeNextReqMessageID(_ref6) {
        var messageList = _ref6.messageList,
            isCompleted = _ref6.isCompleted,
            conversationID = _ref6.conversationID;

        if (!isCompleted) {
          return messageList.length === 0 ? '' : messageList[0].ID;
        }

        var completedMessageList = this.messageController.getLocalMessageList(conversationID);
        return completedMessageList.length === 0 ? '' : completedMessageList[0].ID;
      }
      /**
       * 计算 getMessageList 返回的消息列表
       * @private
       * @param {Object} options
       * @param {String} options.conversationID
       * @param {String} options.nextReqMessageID
       * @param {Number} options.count 用户需要的消息数量
       * @returns {Message[]}
       * @memberof GetMessageHandler
       */

    }, {
      key: "_computeMessageList",
      value: function _computeMessageList(_ref7) {
        var conversationID = _ref7.conversationID,
            nextReqMessageID = _ref7.nextReqMessageID,
            count = _ref7.count;
        var messageList = this.messageController.getLocalMessageList(conversationID);

        var indexEnd = this._computeIndexEnd({
          nextReqMessageID: nextReqMessageID,
          messageList: messageList
        });

        var indexStart = this._computeIndexStart({
          indexEnd: indexEnd,
          count: count
        });

        return messageList.slice(indexStart, indexEnd);
      }
      /**
       * 计算 slice 的 indexEnd
       * @private
       * @param {Object} options
       * @param {Message[]} [options.messageList=[]]
       * @param {String} options.nextReqMessageID
       * @returns {Number}
       * @memberof GetMessageHandler
       */

    }, {
      key: "_computeIndexEnd",
      value: function _computeIndexEnd(_ref8) {
        var _ref8$messageList = _ref8.messageList,
            messageList = _ref8$messageList === void 0 ? [] : _ref8$messageList,
            nextReqMessageID = _ref8.nextReqMessageID;
        return !nextReqMessageID ? messageList.length : messageList.findIndex(function (message) {
          return message.ID === nextReqMessageID;
        });
      }
      /**
       * 计算 slice 的 indexStart
       * @private
       * @param {Object} options
       * @param {Number} options.indexEnd
       * @param {Number} options.count
       * @returns {Number}
       * @memberof GetMessageHandler
       */

    }, {
      key: "_computeIndexStart",
      value: function _computeIndexStart(_ref9) {
        var indexEnd = _ref9.indexEnd,
            count = _ref9.count;
        return indexEnd > count ? indexEnd - count : 0;
      }
      /**
       * 计算剩余消息数量
       * @private
       * @returns
       * @memberof GetMessageHandler
       */

    }, {
      key: "_computeLeftCount",
      value: function _computeLeftCount(_ref10) {
        var conversationID = _ref10.conversationID,
            nextReqMessageID = _ref10.nextReqMessageID;

        // 1. 第一次调用，剩余数量为内存中的消息列表长度
        if (!nextReqMessageID) {
          return this._getMessageListSize(conversationID);
        } // 2. 非第一次调用，剩余数量等于 nextReqMessageID 在内存消息列表的索引值


        return this.messageController.getLocalMessageList(conversationID).findIndex(function (message) {
          return message.ID === nextReqMessageID;
        });
      }
      /**
       * 计算返回值中的 isCompleted 字段
       * isCompleted 为true，表示 UI 层已经拉完了所有的历史记录
       * @private
       * @param {Object} options
       * @param {String} options.conversationID
       * @param {Number} options.leftCount
       * @param {Number} options.count
       * @returns {Boolean}
       * @memberof GetMessageHandler
       */

    }, {
      key: "_computeIsCompleted",
      value: function _computeIsCompleted(_ref11) {
        var conversationID = _ref11.conversationID,
            leftCount = _ref11.leftCount,
            count = _ref11.count;

        if (leftCount <= count && this.completedMap.has(conversationID)) {
          return true;
        }

        return false;
      }
    }, {
      key: "reset",
      value: function reset() {
        this.completedMap.clear();
      }
    }]);

    return GetMessageHandler;
  }();

  /**
   * 平均值计算器。
   * 用于统一输出logger。
   * 如发消息时，使用该类来统一输出耗时的，平均值、最大值、最小值等。
   * @class AverageCalculator
   * @property {Map.<string: Number[]>} map 
   * @property {Number} thresholdValue 输出阈值 
   */

  var AverageCalculator =
  /*#__PURE__*/
  function () {
    function AverageCalculator() {
      _classCallCheck(this, AverageCalculator);

      this.map = new Map();
      this.thresholdValue = 10; // 输出阈值
    }
    /**
     * push数据
     * @param {String} key
     * @param {Number} timeCost 耗时. 单位毫秒
     * @memberof AverageCalculator
     * @example
     * // push 发消息耗时
     * // 1. 发消息开始时
     * logger.time(label.SEND_MESSAGE + message.ID); // 加 ID，防止频繁发消息时，统计耗时的起始时间被刷新。
     * // 2. 发消息成功时
     * averageCalculator.push(label.SEND_MESSAGE, logger.timeEnd(label.SEND_MESSAGE + message.ID));
     */


    _createClass(AverageCalculator, [{
      key: "push",
      value: function push(key, timeCost) {
        if (this.map.has(key)) {
          var arr = this.map.get(key);
          arr.push(timeCost);

          if (this.needReport(arr)) {
            this.report(arr, key);
            this.map["delete"](key);
          }
        } else {
          this.map.set(key, [timeCost]);
        }
      }
    }, {
      key: "needReport",
      value: function needReport(arr) {
        return arr.length === this.thresholdValue;
      }
    }, {
      key: "report",
      value: function report(arr, key) {
        var totalValue = arr.reduce(function (accumulator, currentValue) {
          return accumulator + currentValue;
        });
        var average = totalValue / arr.length;
        var min = Math.min.apply(null, arr);
        var max = Math.max.apply(null, arr);
        logger.log("AverageCalculator.report ".concat(key, " count=").concat(arr.length, " average=").concat(average, "ms max=").concat(max, "ms min=").concat(min, "ms"));
      }
    }, {
      key: "reset",
      value: function reset() {
        this.map.clear();
      }
    }]);

    return AverageCalculator;
  }();

  var averageCalculator = new AverageCalculator();

  /**
   * 用于打点测试,可以用于函数、流程的性能分析
   * @example
   * var p= pointerTask('任务名称');
   * p.newTask('taskName');
   * //xxxx code
   * p.dot('pointerName01', 'taskName');
   * //logic coding....
   * p.dot('pointerName02', 'taskName');
   * p.report('taskName');
   */

  var Task =
  /*#__PURE__*/
  function () {
    function Task(taskName, options) {
      _classCallCheck(this, Task);

      // this.pointsList = [];
      this.options = options ? options : {
        enablePointer: true
      };

      if (!taskName) {
        this.taskName = ['task', this._timeFormat()].join('-');
      } else {
        this.taskName = taskName;
      }

      this.pointsList = [];
      this.reportText = {};
      this.maxNameLen = 0;
      this.gapChar = '…';
      this.log = console.log;
      this.currentTask = '';
    }
    /**
     * 打点，`pointerName`将会记录到`pointsList`中
     * @param {String} pointerName
     */


    _createClass(Task, [{
      key: "dot",
      value: function dot() {
        var pointerName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';

        if (this.options.enablePointer === false) {
          return;
        }

        var time = Date.now();
        this.maxNameLen = this.maxNameLen < pointerName.length ? pointerName.length : this.maxNameLen;
        this.flen = this.maxNameLen + 10;
        this.pointsList.push({
          pointerName: pointerName,
          time: time
        });
      }
      /**
       * 分析打点结果，生成汇总数据
       * @name _analisys
       * @private
       */

    }, {
      key: "_analisys",
      value: function _analisys() {
        if (this.options.enablePointer === false) {
          return;
        }

        var list = this.pointsList;
        var len = list.length;
        var tempArr = [];
        var tmpArr = [];

        for (var i = 0; i < len; i++) {
          if (i === 0) {
            continue;
          }

          tmpArr = this._analisysTowPoints(list[i - 1], list[i]);
          tempArr.push(tmpArr.join(''));
        }

        tmpArr = this._analisysTowPoints(list[0], list[len - 1], true);
        tempArr.push(tmpArr.join(''));
        return tempArr.join('');
      }
    }, {
      key: "_analisysTowPoints",
      value: function _analisysTowPoints(last, curr) {
        if (this.options.enablePointer === false) {
          return;
        } // let flen = this.flen;


        var timeDiff = curr.time - last.time;
        var timtStr = timeDiff.toString(); // let v1 = last.pointerName + this.gapChar.repeat(flen - last.pointerName.length);
        // let v2 = curr.pointerName + this.gapChar.repeat(flen - curr.pointerName.length);
        // let v3 = this.gapChar.repeat(4 - timtStr.length) + timtStr; 

        var v1 = last.pointerName;
        var v2 = curr.pointerName;
        var v3 = timtStr;
        var tmpArr = ['(', v1, ')->(', v2, ')=', v3, 'ms;'];
        return tmpArr;
      }
      /**
       * 输出当前任务的分析数据
       */

    }, {
      key: "report",
      value: function report() {
        if (this.options.enablePointer === false) {
          return;
        }

        logger.log(this.reportString());
      }
    }, {
      key: "reportString",
      value: function reportString() {
        var reportText = this._analisys();

        this.pointsList = [];
        var title = "".concat(this.taskName);
        return "".concat(title, " report\uFF1A").concat(reportText);
      }
    }, {
      key: "_timeFormat",
      value: function _timeFormat() {
        var date = new Date();
        var m = this.zeroFix(date.getMonth() + 1, 2);
        var d = this.zeroFix(date.getDate(), 2);
        return "".concat(m, "-").concat(d, " ").concat(date.getHours(), ":").concat(date.getSeconds(), ":").concat(date.getMinutes(), ".").concat(date.getMilliseconds());
      }
    }, {
      key: "zeroFix",
      value: function zeroFix(num, length) {
        return ('000000000' + num).slice(-length);
      }
    }]);

    return Task;
  }();
  /**
   * 
   * @param {*} taskName 
   * @returns {Task}
   */


  var pointerTask = function pointerTask(taskName, options) {
    return new Task(taskName, options);
  };

  /**
   * 关联会话，管理消息的组装，收发，格式化等
   * @author Saxongao
   */

  var MessageController =
  /*#__PURE__*/
  function (_IMController) {
    _inherits(MessageController, _IMController);

    /**
     * @constructor
     * @param {SDK} tim - SDK 实例
     */
    function MessageController(tim) {
      var _this;

      _classCallCheck(this, MessageController);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(MessageController).call(this, tim));

      _this._initializeMembers();

      _this._initializeListener();

      _this._initialzeHandlers();

      _this._IAmReady();

      return _this;
    }
    /**
     * 控制器准备就绪时，调用此方法
     */


    _createClass(MessageController, [{
      key: "_IAmReady",
      value: function _IAmReady() {
        this.triggerReady();
      }
      /**
       * 初始化成员变量
       */

    }, {
      key: "_initializeMembers",
      value: function _initializeMembers() {
        this.messagesList = new MessagesList({
          tim: this.tim
        });
        this.currentMessageKey = {};
      }
      /**
       * 初始化 handlers
       * @memberof MessageController
       */

    }, {
      key: "_initialzeHandlers",
      value: function _initialzeHandlers() {
        this.readReportHandler = new ReadReportHandler(this.tim);
        this.getMessageHandler = new GetMessageHandler({
          messageController: this,
          tim: this.tim
        });
      }
    }, {
      key: "reset",
      value: function reset() {
        this.messagesList = null;
        this.messagesList = new MessagesList({
          tim: this.tim
        });
        this.currentMessageKey = {}; // 重置 getMessageHandler

        this.getMessageHandler.reset();
      }
      /**
       * 设置事件监听
       */

    }, {
      key: "_initializeListener",
      value: function _initializeListener() {
        var innerEmitter = this.tim.innerEmitter;
        innerEmitter.on(TIM_INNER_EVENT.NOTICE_LONGPOLL_NEW_C2C_NOTICE, this._onReceiveC2CMessage, this);
        innerEmitter.on(TIM_INNER_EVENT.SYNC_MESSAGE_C2C_PROCESSING, this._onReceiveC2CMessage, this);
        innerEmitter.on(TIM_INNER_EVENT.SYNC_MESSAGE_C2C_FINISHED, this._onReceiveC2CMessage, this);
        innerEmitter.on(TIM_INNER_EVENT.NOTICE_LONGPOLL_NEW_GROUP_MESSAGES, this._onReceiveGroupMessage, this);
        innerEmitter.on(TIM_INNER_EVENT.NOTICE_LONGPOLL_NEW_GROUP_TIPS, this._onReceiveGroupTips, this);
        innerEmitter.on(TIM_INNER_EVENT.NOTICE_LONGPOLL_NEW_GROUP_NOTICE, this._onReceiveSystemNotice, this);
      }
      /**
       * 发送一个消息实例
       * @param {Message} message - 消息实例
       * @returns {Promise}
       */

    }, {
      key: "sendMessageInstance",
      value: function sendMessageInstance(message) {
        // 设置打点，注意：打点功能受到 tim.options.enablePointer 参数控制
        var pointer = pointerTask("MessageController.sendMessageInstance(), ".concat(message.ID), this.tim.options);
        logger.time(label.SEND_MESSAGE + message.ID);
        var _this$tim = this.tim,
            innerEmitter = _this$tim.innerEmitter,
            outerEmitter = _this$tim.outerEmitter;

        if (message.isError() === true) {
          pointer.dot('message error');
          pointer.report();
          return IMPromise.reject(message.getIMError());
        }

        if (message.isSendable() === false) {
          pointer.dot('message unsendable');
          pointer.report();
          return IMPromise.reject({
            code: ERROR_CODE.MESSAGE_FILE_URL_IS_EMPTY,
            message: ERROR_MESSAGE.MESSAGE_FILE_URL_IS_EMPTY
          });
        }

        var pack = null;
        var succesHandle = null;
        var failHandle = null;
        var uniqueMessage = this.messagesList.pushIn(message);
        pointer.dot('messagesList.pushIn');

        if (uniqueMessage) {
          // 发消息前，抛内部事件，更新/创建会话
          pointer.dot("innerEmitter ".concat(TIM_INNER_EVENT.MESSAGE_SENDING));
          innerEmitter.emit(TIM_INNER_EVENT.MESSAGE_SENDING, {
            data: {
              eventDataList: [{
                conversationID: message.conversationID,
                unreadCount: 0,
                type: message.conversationType,
                subType: message.conversationSubType,
                lastMessage: message
              }]
            }
          });
          pointer.dot("outerEmitter ".concat(TIM_INNER_EVENT.MESSAGE_SENDING));
          outerEmitter.emit(TIM_OUTER_EVENT.MESSAGE_SENDING, message);
        }

        pointer.dot("init handles ".concat(message.conversationType));

        switch (message.conversationType) {
          case CONVERSATION_TYPES.C2C:
            pack = this._createC2CMessagePack(message);
            succesHandle = this._handleOnSendC2CMessageSuccess.bind(this);
            failHandle = this._handleOnSendC2CMessageFail.bind(this);
            break;

          case CONVERSATION_TYPES.GROUP:
            pack = this._createGroupMessagePack(message);
            succesHandle = this._handleOnSendGroupMessageSuccess.bind(this);
            failHandle = this._handleOnSendGroupMessageFail.bind(this);
            break;

          default:
            pointer.dot("error ".concat(message.conversationType));
            pointer.report();
            return IMPromise.reject(new IMError({
              code: ERROR_CODE.MESSAGE_SEND_INVALID_CONVERSATION_TYPE,
              message: ERROR_MESSAGE.MESSAGE_SEND_INVALID_CONVERSATION_TYPE
            }));
        }

        return this.tim.connectionController.request(pack).then(function (response) {
          pointer.dot('send success');
          succesHandle(message, response.data);
          averageCalculator.push(label.SEND_MESSAGE, logger.timeEnd(label.SEND_MESSAGE + message.ID));
          pointer.report();
          return new IMResponse({
            message: message
          });
        })["catch"](function (error) {
          failHandle(message, error);
          pointer.dot('send fail');
          logger.error("MessageController.sendMessageInstance() error:", error);
          pointer.report();
          return IMPromise.reject(new IMError({
            code: ERROR_CODE.MESSAGE_SEND_FAIL,
            message: ERROR_MESSAGE.MESSAGE_SEND_FAIL,
            data: {
              message: message
            }
          }));
        });
      }
      /**
       * 重发消息<br/>
       * 调用时机：消息发送失败时，调用该接口进行重发。
       * @param {Message} message - 消息实例
       * @returns {Promise}
       * @example
       * // 重发消息
       * let promise = tim.resendMessage(message); // 传入需要重发的消息实例
       * promise.then(function(imResponse) {
       *   // 重发成功
       *   console.log(imResponse.data.message);
       * }).catch(function(imError) {
       *   // 重发失败
       *   console.warn('resendMessage error:', imError);
       * });
       */

    }, {
      key: "resendMessage",
      value: function resendMessage(message) {
        if (this._isFileLikeMessage(message) === true) {
          logger.warn('MessageController.resendMessage(), file like message can not resendBy SDK.resendMessage()');
          return IMPromise.reject(new IMError({
            code: ERROR_CODE.MESSAGE_RESEND_FILE_UNSUPPORTED,
            message: ERROR_MESSAGE.MESSAGE_RESEND_FILE_UNSUPPORTED
          }));
        }

        message.isResend = true;
        message.status = TIM_STATUS.MESSAGE_STATUS.UNSEND;
        return this.sendMessageInstance(message);
      }
      /**
       * 是否为文件类消息，包含：图片、文件、语音、视频
       * @param {Message} message - 消息实例
       * @returns {Boolean}  返回true ，说明为类文件消息
       *                    返回false, 说明不是类文件消息
       */

    }, {
      key: "_isFileLikeMessage",
      value: function _isFileLikeMessage(message) {
        var _TIM_TYPES$MESSAGE$EL = MESSAGE.ELEMENT_TYPES,
            IMAGE = _TIM_TYPES$MESSAGE$EL.IMAGE,
            FILE = _TIM_TYPES$MESSAGE$EL.FILE,
            SOUND = _TIM_TYPES$MESSAGE$EL.SOUND,
            VIDEO = _TIM_TYPES$MESSAGE$EL.VIDEO;
        var fileLikeList = [IMAGE, FILE, SOUND, VIDEO];
        var element = message.elements[0];

        if (fileLikeList.indexOf(element.type) >= 0) {
          return true;
        }

        return false;
      }
      /**
       * 重发包含二进制数据的消息，包括图片消息、文件消息、语音消息
       */

    }, {
      key: "_resendBinaryTypeMessage",
      value: function _resendBinaryTypeMessage() {}
      /**
       * 发送私聊消息
       * @param {Object} options - 参数
       * @param {string} options.to - 接收方
       * @param {string} options.elements - 消息源内容文本
       * @param {string} options.conversationType - 会话类型
       * @param {string} options.conversationSubType - 会话子类型
       * @returns {Promise}
       * @example
       * // 发送文本消息
       * tim.messageController.sendC2CMessage({to:'User4Test02',elements:[{elementType:'TIMTextElem', messageContent: {text: +new Date()}}],conversationType: 'C2C'});
       * // 发送自定义消息
       * tim.messageController.sendC2CMessage({to:'User4Test02',elements:[{elementType:'TIMCustomElem', messageContent: {data: +new Date(), description: '', extension: ''}}],conversationType: 'C2C'});
       */

    }, {
      key: "sendC2CMessage",
      value: function sendC2CMessage(options) {
        var _this2 = this;

        var outerEmitter = this.tim.outerEmitter;
        options.currentUser = this.tim.context.identifier; // 把 tim 也传给 Message 因为需要换算 conversationId

        options.from = this.tim.context.identifier;
        var message = new Message(options);
        this.messagesList.pushIn(message);
        message.status = TIM_STATUS.MESSAGE_STATUS.UNSEND; // 发送脏位，设置为false

        outerEmitter.emit(TIM_OUTER_EVENT.MESSAGE_SENDING, message);

        var pack = this._createC2CMessagePack(message);

        var result = this.tim.connectionController.request(pack).then(function (response) {
          _this2._handleOnSendC2CMessageSuccess(message, response.data);
        })["catch"](function (error) {
          _this2._handleOnSendC2CMessageFail(message, error);
        });
        return result;
      }
      /**
       * 创建C2C消息包体
       * @param {MEssage} message - 消息实例
       * @returns {object}
       */

    }, {
      key: "_createC2CMessagePack",
      value: function _createC2CMessagePack(message) {
        var pack = this.createPackage({
          name: 'c2cMessage',
          action: 'create',
          param: {
            toAccount: message.to,
            msgBody: message.elements,
            msgSeq: message.sequence,
            msgRandom: message.random,
            offlinePushInfo: {
              desc: 'offline message push',
              ext: 'offline message push'
            }
          }
        });
        return pack;
      }
      /**
       * 私聊消息发送成功后触发的方法
       * @param {Message} message  - 消息实例
       * @param {responseData} responseData - 响应数据对象
       */

    }, {
      key: "_handleOnSendC2CMessageSuccess",
      value: function _handleOnSendC2CMessageSuccess(message, responseData) {
        var _this$tim2 = this.tim,
            innerEmitter = _this$tim2.innerEmitter,
            outerEmitter = _this$tim2.outerEmitter;
        message.status = TIM_STATUS.MESSAGE_STATUS.SUCCESS;
        message.time = responseData.time;
        innerEmitter.emit(TIM_INNER_EVENT.MESSAGE_C2C_SEND_SUCCESS, {
          data: {
            eventDataList: [{
              conversationID: message.conversationID,
              unreadCount: 0,
              type: message.conversationType,
              subType: message.conversationSubType,
              lastMessage: message
            }]
          }
        });
        outerEmitter.emit(TIM_OUTER_EVENT.MESSAGE_SEND_SUCCESS, message);
      }
      /**
       * 私聊消息发送失败后触发的方法
       * @param {Message} message - 消息实例
       * @param {IMError} error - 错误对象
       */

    }, {
      key: "_handleOnSendC2CMessageFail",
      value: function _handleOnSendC2CMessageFail(message, error) {
        var _this$tim3 = this.tim,
            innerEmitter = _this$tim3.innerEmitter,
            outerEmitter = _this$tim3.outerEmitter;
        message.status = TIM_STATUS.MESSAGE_STATUS.FAIL;
        innerEmitter.emit(TIM_INNER_EVENT.ERROR_DETECTED, error);
        outerEmitter.emit(TIM_OUTER_EVENT.MESSAGE_SEND_FAIL, message);
      }
      /**
       * 发送群聊消息
       * @param {Object} options - 参数
       * @param {String} options.groupID - 群
       * @param {String} options.elements - 消息源内容文本
       * @param {String} options.conversationType - 会话类型
       * @param {String} options.conversationSubType - 会话子类型
       * @returns {Promise}
       * @example
       * // 发送文本消息
       * app.messageController.sendGroupMessage({groupID:'[群ID]',elements:[{elementType:'TIMTextElem', messageContent: {text: +new Date()}}],conversationType: 'GROUP'});
       */

    }, {
      key: "sendGroupMessage",
      value: function sendGroupMessage(options) {
        var _this3 = this;

        var outerEmitter = this.tim.outerEmitter;
        options.currentUser = this.tim.context.identifier; // 把 tim 也传给 Message 因为需要换算 conversationId

        options.from = this.tim.context.identifier;
        var message = new Message(options);
        this.messagesList.pushIn(message);
        message.status = TIM_STATUS.MESSAGE_STATUS.UNSEND; // 发送脏位，设置为 UNSEND

        outerEmitter.emit(TIM_OUTER_EVENT.MESSAGE_SENDING, message);

        var pack = this._createGroupMessagePack(options.groupID, message.elements);

        var result = this.tim.connectionController.request(pack).then(function (response) {
          // 发送脏位设置为true
          _this3._handleOnSendGroupMessageSuccess(message, response.data);
        })["catch"](function (error) {
          _this3._handleOnSendGroupMessageFail(error, message);
        });
        return result;
      }
      /**
       * 创建退组消息包
       * @param {Message} message - Message 实例
       * @returns {Object}
       */

    }, {
      key: "_createGroupMessagePack",
      value: function _createGroupMessagePack(message) {
        return this.createPackage({
          name: 'groupMessage',
          action: 'create',
          param: {
            groupID: message.to,
            msgBody: message.elements,
            random: message.random,
            offlinePushInfo: {
              desc: 'offline message push',
              ext: 'offline message push'
            }
          }
        });
      }
      /**
       * 当发送群消息成功时触发
       * 注意：因为群消息的ID在发送成功并收到服务端的response后才能确认，所以在收到response后，需要重置message.ID并从message中移除再重新插入。
       * @param {Message} message - 消息对象
       * @param {Object} responseData - 服务端响应包中的 data
       */

    }, {
      key: "_handleOnSendGroupMessageSuccess",
      value: function _handleOnSendGroupMessageSuccess(message, responseData) {
        var _this$tim4 = this.tim,
            innerEmitter = _this$tim4.innerEmitter,
            outerEmitter = _this$tim4.outerEmitter; // this.messagesList.remove(message); // 把这条消息从消息列表中remove

        message.sequence = responseData.sequence; // 取得这条消息的sequence，这是服务端生成的sequence

        message.time = responseData.time; // 取得此消息的服务器时间

        message.status = TIM_STATUS.MESSAGE_STATUS.SUCCESS; // message._concactMessageID(this.tim.context.identifier); // 重新生成消息ID
        // this.messagesList.pushIn(message); // 再重新push
        // 群消息发送成功，发布一个内部事件

        innerEmitter.emit(TIM_INNER_EVENT.MESSAGE_GROUP_SEND_SUCCESS, {
          data: {
            eventDataList: [{
              conversationID: message.conversationID,
              unreadCount: 0,
              type: message.conversationType,
              subType: message.conversationSubType,
              lastMessage: message
            }]
          }
        }); // 群消息发布成功，发布外部事件

        outerEmitter.emit(TIM_OUTER_EVENT.MESSAGE_SEND_SUCCESS, message);
      }
      /**
       * 当发送群消息失败时
       * @param {Message} message - Message实例
       * @param {IMerror} error - 失败事件
       */

    }, {
      key: "_handleOnSendGroupMessageFail",
      value: function _handleOnSendGroupMessageFail(message, error) {
        var _this$tim5 = this.tim,
            innerEmitter = _this$tim5.innerEmitter,
            outerEmitter = _this$tim5.outerEmitter;
        message.status = TIM_STATUS.MESSAGE_STATUS.FAIL;
        innerEmitter.emit(TIM_INNER_EVENT.ERROR_DETECTED, error);
        outerEmitter.emit(TIM_OUTER_EVENT.MESSAGE_SEND_FAIL, message);
      }
      /**
       * 收到同步消息
       * @param {*} event
       */

      /**
       * 当收到新的私聊消息
       * @param {*} event - 失败事件
       */

    }, {
      key: "_onReceiveC2CMessage",
      value: function _onReceiveC2CMessage(event) {
        var _this$tim6 = this.tim,
            innerEmitter = _this$tim6.innerEmitter,
            outerEmitter = _this$tim6.outerEmitter;
        logger.log('MessageController._onReceiveC2CMessage(), get new messages');

        var _this$_newC2CMessageS = this._newC2CMessageStoredAndSummary(event.data, CONVERSATION_TYPES.C2C),
            eventDataList = _this$_newC2CMessageS.eventDataList,
            result = _this$_newC2CMessageS.result;

        innerEmitter.emit(TIM_INNER_EVENT.MESSAGE_C2C_INSTANT_RECEIVED, {
          data: {
            eventDataList: eventDataList,
            result: result
          },
          resource: this
        });

        if (result.length > 0) {
          outerEmitter.emit(TIM_OUTER_EVENT.MESSAGE_RECEIVED, result);
        }
      }
      /**
       * 当收到新的群组消息，入 list 汇总，发布事件
       * @param {*} event - 事件
       */

    }, {
      key: "_onReceiveGroupMessage",
      value: function _onReceiveGroupMessage(event) {
        var _this$tim7 = this.tim,
            outerEmitter = _this$tim7.outerEmitter,
            innerEmitter = _this$tim7.innerEmitter;

        var _this$_newGroupMessag = this._newGroupMessageStoredAndSummary(event.data),
            eventDataList = _this$_newGroupMessag.eventDataList,
            result = _this$_newGroupMessag.result;

        if (eventDataList.length > 0) {
          logger.log('MessageController._onReceiveGroupMessage()');
          innerEmitter.emit(TIM_INNER_EVENT.MESSAGE_GROUP_INSTANT_RECEIVED, {
            data: {
              eventDataList: eventDataList,
              result: result,
              isGroupTip: false
            }
          });
        }

        if (result.length > 0) {
          outerEmitter.emit(TIM_OUTER_EVENT.MESSAGE_RECEIVED, result);
        }
      }
      /**
       * 当收到新的群提示，入 list 汇总，发布事件
       * @param {*} event - 事件
       */

    }, {
      key: "_onReceiveGroupTips",
      value: function _onReceiveGroupTips(event) {
        var _this$tim8 = this.tim,
            outerEmitter = _this$tim8.outerEmitter,
            innerEmitter = _this$tim8.innerEmitter;
        var notifiesList = event.data;

        var _this$_newGroupTipsSt = this._newGroupTipsStoredAndSummary(notifiesList, CONVERSATION_TYPES.GROUP),
            eventDataList = _this$_newGroupTipsSt.eventDataList,
            result = _this$_newGroupTipsSt.result;

        logger.log('MessageController._onReceiveGroupTips()');
        innerEmitter.emit(TIM_INNER_EVENT.MESSAGE_GROUP_INSTANT_RECEIVED, {
          data: {
            eventDataList: eventDataList,
            result: result,
            isGroupTip: true
          }
        }); // 事件名无法区分ev3/ev4的群消息, 用isGroupTip区分

        if (result.length > 0) {
          outerEmitter.emit(TIM_OUTER_EVENT.MESSAGE_RECEIVED, result);
        }
      }
      /**
       * 当收到系统通知，包含群系统通知
       * @param {object} event - 事件
       */

    }, {
      key: "_onReceiveSystemNotice",
      value: function _onReceiveSystemNotice(event) {
        var _this$tim9 = this.tim,
            outerEmitter = _this$tim9.outerEmitter,
            innerEmitter = _this$tim9.innerEmitter;
        var _event$data = event.data,
            notifiesList = _event$data.groupSystemNotices,
            type = _event$data.type;

        var _this$_newSystemNotic = this._newSystemNoticeStoredAndSummary({
          notifiesList: notifiesList,
          type: type
        }),
            eventDataList = _this$_newSystemNotic.eventDataList,
            result = _this$_newSystemNotic.result;

        innerEmitter.emit(TIM_INNER_EVENT.MESSAGE_GROUP_SYSTEM_NOTICE_RECEIVED, {
          data: {
            eventDataList: eventDataList,
            result: result,
            type: type
          }
        });

        if (result.length > 0) {
          outerEmitter.emit(TIM_OUTER_EVENT.MESSAGE_RECEIVED, result);
        }
      }
      /**
       * C2C新通知入例与生成汇总数据
       * @param {array} notifiesList - 通知列表
       * @param {string} type - 会话类型
       * @returns {array} eventDataList
       */

    }, {
      key: "_newC2CMessageStoredAndSummary",
      value: function _newC2CMessageStoredAndSummary(notifiesList, type) {
        var message = null;
        var eventDataList = [];
        var result = [];
        var indexes = {}; // 先循环归类

        for (var i = 0, len = notifiesList.length; i < len; i++) {
          var item = notifiesList[i];
          item.currentUser = this.tim.context.identifier;
          item.conversationType = type;
          item.isSystemMessage = !!item.isSystemMessage;
          message = new Message(item);
          message.setElement(item.elements[0]);
          var uniqueMessage = this.messagesList.pushIn(message); // 全入列，如有重复，靠pushIn去重

          if (typeof indexes[message.conversationID] === 'undefined') {
            indexes[message.conversationID] = eventDataList.push({
              conversationID: message.conversationID,
              // 如果是自己发送的消息，不计未读
              unreadCount: message.flow === 'out' ? 0 : 1,
              type: message.conversationType,
              subType: message.conversationSubType,
              lastMessage: message
            }) - 1;
          } else {
            eventDataList[indexes[message.conversationID]].type = message.conversationType;
            eventDataList[indexes[message.conversationID]].subType = message.conversationSubType;
            eventDataList[indexes[message.conversationID]].lastMessage = message; // 如果是不是自己发的消息， 未读计数增加

            if (message.flow === 'in') {
              eventDataList[indexes[message.conversationID]].unreadCount++;
            }
          }

          if (uniqueMessage) {
            result.push(uniqueMessage);
          }
        }

        return {
          eventDataList: eventDataList,
          result: result
        };
      }
      /**
       * TIPS: 发现群消息和C2C消息处理逻辑不太相同，单独分出一个函数来处理入列问题，以防逻辑变得复杂
       * GROUP新通知入例与生成汇总数据
       * @param {*} notifiesList - 通知列表
       * @returns {object}
       */

    }, {
      key: "_newGroupMessageStoredAndSummary",
      value: function _newGroupMessageStoredAndSummary(notifiesList) {
        var message = null;
        var eventDataList = [];
        var indexes = {};
        var result = [];
        var type = CONVERSATION_TYPES.GROUP; // 先循环归类

        for (var i = 0, len = notifiesList.length; i < len; i++) {
          var item = notifiesList[i];
          item.currentUser = this.tim.context.identifier;
          item.conversationType = type;
          item.isSystemMessage = !!item.isSystemMessage;
          message = new Message(item);
          message.setElement(item.elements[0]); // 注意，群消息由于发送前的ID和成功后的ID并不相同，目前不能依赖 pushIn 方法的去重能力，办法是：如果poll回了自己发送的消息，则不入列

          if (message.from === this.tim.context.identifier) {
            continue;
          }

          var uniqueMessage = this.messagesList.pushIn(message); // 全入列，如有重复，靠pushIn去重

          if (uniqueMessage) {
            result.push(uniqueMessage);
          }

          if (typeof indexes[message.conversationID] === 'undefined') {
            indexes[message.conversationID] = eventDataList.push({
              conversationID: message.conversationID,
              // 如果是自己发送的消息，不计未读
              unreadCount: message.flow === 'out' ? 0 : 1,
              type: message.conversationType,
              subType: message.conversationSubType,
              lastMessage: message
            }) - 1;
          } else {
            eventDataList[indexes[message.conversationID]].type = message.conversationType;
            eventDataList[indexes[message.conversationID]].subType = message.conversationSubType;
            eventDataList[indexes[message.conversationID]].lastMessage = message; // 如果是不是自己发的消息， 未读计数增加

            if (message.flow === 'in') {
              eventDataList[indexes[message.conversationID]].unreadCount++;
            }
          }
        }

        return {
          eventDataList: eventDataList,
          result: result
        };
      }
      /**
       * 新通知入例与生成汇总数据
       * @param {array} notifiesList - 通知列表
       * @param {string} type - 会话类型
       * @returns {array} eventDataList
       */

    }, {
      key: "_newGroupTipsStoredAndSummary",
      value: function _newGroupTipsStoredAndSummary(notifiesList, type) {
        var message = null;
        var eventDataList = [];
        var result = [];
        var indexes = {}; // 先循环归类

        for (var i = 0, len = notifiesList.length; i < len; i++) {
          var item = notifiesList[i];
          item.currentUser = this.tim.context.identifier;
          item.conversationType = type;
          message = new Message(item);
          message.setElement({
            type: MESSAGE.ELEMENT_TYPES.GROUP_TIP,
            content: _objectSpread2({}, item.elements, {
              groupProfile: item.groupProfile
            })
          });
          message.isSystemMessage = false;
          var uniqueMessage = this.messagesList.pushIn(message); // 全入列，如有重复，靠pushIn去重

          if (uniqueMessage) {
            result.push(uniqueMessage);
          }

          if (typeof indexes[message.conversationID] === 'undefined') {
            indexes[message.conversationID] = eventDataList.push({
              conversationID: message.conversationID,
              // 如果是自己发送的消息，不计未读
              unreadCount: message.flow === 'out' ? 0 : 1,
              type: message.conversationType,
              subType: message.conversationSubType,
              lastMessage: message
            }) - 1;
          } else {
            eventDataList[indexes[message.conversationID]].type = message.conversationType;
            eventDataList[indexes[message.conversationID]].subType = message.conversationSubType;
            eventDataList[indexes[message.conversationID]].lastMessage = message; // 如果是不是自己发的消息， 未读计数增加

            if (message.flow === 'in') {
              eventDataList[indexes[message.conversationID]].unreadCount++;
            }
          }
        }

        return {
          eventDataList: eventDataList,
          result: result
        };
      }
      /**
       * 系统通知入列
       * @param {object} options.notifiesList - 通知列表
       * @param {string} options.type - 会话类型
       * @returns {object}
       */

    }, {
      key: "_newSystemNoticeStoredAndSummary",
      value: function _newSystemNoticeStoredAndSummary(_ref) {
        var notifiesList = _ref.notifiesList,
            type = _ref.type;
        var message = null;
        var len = notifiesList.length;
        var i = 0;
        var result = [];
        var eventData = {
          conversationID: CONVERSATION_TYPES.SYSTEM,
          unreadCount: 0,
          type: CONVERSATION_TYPES.SYSTEM,
          subType: null,
          lastMessage: null
        };

        for (i = 0; i < len; i++) {
          var item = notifiesList[i]; // 群消息已读同步的ev5不入库

          if (item.elements.operationType === GROUP_SYSTEM_NOTICE_TYPES.READED) {
            continue;
          }

          item.currentUser = this.tim.context.identifier;
          item.conversationType = CONVERSATION_TYPES.SYSTEM;
          item.conversationID = CONVERSATION_TYPES.SYSTEM; // 系统类型的会话ID只能有一个，命名固定

          message = new Message(item);
          message.setElement({
            type: MESSAGE.ELEMENT_TYPES.GROUP_SYSTEM_NOTICE,
            content: _objectSpread2({}, item.elements, {
              groupProfile: item.groupProfile
            })
          });
          message.isRead = true;
          message.isSystemMessage = true;
          var uniqueMessage = this.messagesList.pushIn(message);

          if (uniqueMessage) {
            result.push(uniqueMessage); // 实时的ev5 增加群系统通知的未读计数

            if (type === 'poll') {
              eventData.unreadCount++;
            }
          }

          eventData.subType = message.conversationSubType;
        }

        eventData.lastMessage = result[result.length - 1]; // 若遍历后 result 没有数据，则表明没有会话更新

        return {
          eventDataList: result.length > 0 ? [eventData] : [],
          result: result
        };
      }
      /**
       * 当完成消息同步时触发
       * @param {Object} event - 事件
       */

    }, {
      key: "_onSyncMessagesFinished",
      value: function _onSyncMessagesFinished(event) {
        var messageArray = event.data;
        var tmpMessage = null;
        var item = null;

        for (var i = 0; i < messageArray.length; i++) {
          item = messageArray[i];
          item.currentUser = this.tim.context.identifier;
          tmpMessage = new Message(item);
          tmpMessage.setElement(item.elements[0]);
          this.messagesList.pushIn(tmpMessage);
          tmpMessage = null;
        } // messageArray.forEach(item => {});


        logger.log('_onSyncMessagesFinished');
      }
      /**
       * 获取私聊和群的历史消息
       * @param {Object} options - 拉取历史通知时的配置参数
       * @param {String} options.conversationID - 会话ID
       * @param {Number} options.count - 一次获取的数量
       * @returns {IMPromise}
       */

    }, {
      key: "getHistoryMessages",
      value: function getHistoryMessages(options) {
        if (options.conversationID === CONVERSATION_TYPES.SYSTEM) {
          return IMPromise.resolve();
        }

        !options.count ? options.count = 15 : null;
        options.count > 20 ? options.count = 20 : null; // 暂时限制20条

        var message = this.messagesList.getLocalOldestMessageByConversationID(options.conversationID); // 拿暂存消息中最旧的一条消息对象
        // 如果最旧的这条消息对象为NULL，则定义好tim 、 sequence 的初始值。

        if (!message) {
          message = {};
          message.time = 0;
          message.sequence = 0; // 如果是C2C会话，给message 添加 to 属性

          if (options.conversationID.indexOf(CONVERSATION_TYPES.C2C) === 0) {
            message.to = options.conversationID.replace(CONVERSATION_TYPES.C2C, '');
            message.conversationType = CONVERSATION_TYPES.C2C; // 如果是GROUP会话，给message 添加 groupID 属性
          } else if (options.conversationID.indexOf(CONVERSATION_TYPES.GROUP) === 0) {
            message.to = options.conversationID.replace(CONVERSATION_TYPES.GROUP, '');
            message.conversationType = CONVERSATION_TYPES.GROUP;
          }
        }

        var peerAccount = '';

        switch (message.conversationType) {
          case CONVERSATION_TYPES.C2C:
            peerAccount = options.conversationID.replace(CONVERSATION_TYPES.C2C, ''); // this.getC2CRoamMessagesSliced({

            return this.getC2CRoamMessages({
              conversationID: options.conversationID,
              peerAccount: peerAccount,
              count: options.count,
              lastMessageTime: typeof this.currentMessageKey[options.conversationID] === 'undefined' ? 0 : message.time // 如果是第一次拉取，lastMessageTime留空
              // messageKey: ''

            });

          case CONVERSATION_TYPES.GROUP:
            return this.getGroupRoamMessages({
              conversationID: options.conversationID,
              groupID: message.to,
              count: options.count,
              sequence: message.sequence - 1 // 拉群历史消息会包含传的seq的消息，如传 seq = 1，则拉回来的消息列表中会包含 seq = 1的消息。而这条消息已经在内存中了，所以不必要再拉。

            });

          default:
            return IMPromise.resolve();
        }
      }
      /**
       * 拉取 C2C 漫游
       * @param {Object} options  -  拉取历史通知时的配置参数
       * @param {String} options.peerAccount - 对方账号
       * @param {String} options.conversationID - 会话ID
       * @param {Number} options.count  - 一次拉取的消息条数 ， 默认为15
       * @param {Number} options.lastMessageTime - 最后一条消息的时间
       * @param {String} options.messageKey - 用于断点继拉，当count大N（自测为：37）时，需要需要用到这个属性进行续拉，续拉完成后才能返回。
       * @param {Number} times - 用户继拉记数
       */

    }, {
      key: "getC2CRoamMessages",
      value: function getC2CRoamMessages(options) {
        var _this4 = this;

        var _this$tim10 = this.tim,
            connectionController = _this$tim10.connectionController,
            innerEmitter = _this$tim10.innerEmitter;
        var messageKey = typeof this.currentMessageKey[options.conversationID] !== 'undefined' ? this.currentMessageKey[options.conversationID] : '';
        var pack = this.createPackage({
          name: 'c2cMessage',
          action: 'query',
          param: {
            peerAccount: options.peerAccount,
            count: options.count || 15,
            lastMessageTime: options.lastMessageTime || 0,
            messageKey: messageKey
          }
        });
        return connectionController.request(pack).then(function (response) {
          var _response$data = response.data,
              complete = _response$data.complete,
              messageList = _response$data.messageList;

          if (complete === 1) {
            _this4.getMessageHandler.setCompleted(options.conversationID);
          }

          var messages = _this4._roamMessageStore(messageList, CONVERSATION_TYPES.C2C, options.conversationID); // 更新拉下来的历史消息的 isRead 值


          _this4.readReportHandler.updateIsRead(options.conversationID);

          _this4.currentMessageKey[options.conversationID] = response.data.messageKey;
          return messages;
        })["catch"](function (error) {
          innerEmitter.emit(TIM_INNER_EVENT.ERROR_DETECTED, error);
          return Promise.reject(error);
        });
      }
      /**
       * 分片拉取 C2C 漫游
       * @param {Object} options  -  拉取历史通知时的配置参数
       * @param {String} options.peerAccount - 对方账号
       * @param {Number} options.count  - 一次拉取的消息条数 ， 默认为15
       * @param {Number} options.lastMessageTime - 最后一条消息的时间
       * @param {String} options.messageKey - 用于断点继拉，当count大N（自测为：37）时，需要需要用到这个属性进行续拉，续拉完成后才能返回。
       */

    }, {
      key: "getC2CRoamMessagesSliced",
      value: function getC2CRoamMessagesSliced(options) {
        var connectionController = this.tim.connectionController;
        var self = this; // 递归请求

        var recurseRequest = function recurseRequest(options, resolveCallback, rejectCallback) {
          var _this5 = this;

          var messages = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
          var pack = self.createPackage({
            name: 'c2cMessage',
            action: 'query',
            param: {
              peerAccount: options.peerAccount,
              count: options.count || 15,
              lastMessageTime: options.lastMessageTime || 0,
              messageKey: options.messageKey || ''
            }
          });
          var result = connectionController.request(pack).then(function (response) {
            var messageList = response.data.messageList;

            var tempMessages = _this5._roamMessageStore(messageList, CONVERSATION_TYPES.C2C);

            messages.push.apply(messages, _toConsumableArray(tempMessages));

            if (response.data.complete === TIM_STATUS.GET_HISTORY_MESSAGE_STATUS.C2C_IS_NOT_FINISHED) {
              options.messageKey = response.data.messageKey;
              recurseRequest(options, resolveCallback, messages);
            } else if (response.data.complete === TIM_STATUS.GET_HISTORY_MESSAGE_STATUS.C2C_IS_FINISHED) {
              logger.log('getC2CRoamMessages finised...');
              resolveCallback(new IMResponse(messages));
            } else {
              rejectCallback(new IMError({
                code: ERROR_CODE.MESSAGE_UNKNOW_ROMA_LIST_END_FLAG_FIELD,
                message: ERROR_MESSAGE.MESSAGE_UNKNOW_ROMA_LIST_END_FLAG_FIELD
              }));
            }
          }).reject(function (error) {
            logger.log('getC2CRoamMessages fail...');
            rejectCallback(error);
          });
          return result;
        }; // 把递归请求包装成Promise


        var recursePromise = function recursePromise(options) {
          return new Promise(function (resolve, reject) {
            recurseRequest(options, resolve, reject, []);
          });
        };

        return recursePromise(options);
      }
      /**
       * 拉取GROUP漫游消息
       * @param {Object} options - 必填，配置参数
       * @param {String} options.groupID - 必填，群组ID
       * @param {String} options.count - 必填，群组ID
       * @param {Number} options.sequence - 选填，消息sequence
       */

    }, {
      key: "getGroupRoamMessages",
      value: function getGroupRoamMessages(options) {
        var _this6 = this;

        var _this$tim11 = this.tim,
            connectionController = _this$tim11.connectionController,
            conversationController = _this$tim11.conversationController;
        var conversationID = options.conversationID;
        var lastSequence = options.sequence >= 0 ? options.sequence : conversationController.getLocalConversationLastSequence(conversationID); // 如果会话控制器中也取不到此群的最新sequence，说明这个群还没有历史消息。

        if (lastSequence < 0) {
          return IMPromise.resolve([]);
        }

        var pack = this.createPackage({
          name: 'groupMessage',
          action: 'query',
          param: {
            groupID: options.groupID,
            count: options.count,
            sequence: lastSequence
          }
        });
        return connectionController.request(pack).then(function (response) {
          var messagesList = response.data.messagesList;
          var conversationID = "GROUP".concat(options.groupID); // 拉群历史消息，若回来的消息数量小于count，则说明群消息已经拉完。

          if (Array.isArray(messagesList) && messagesList.length < options.count) {
            _this6.getMessageHandler.setCompleted(conversationID);
          }

          var messages = _this6._roamMessageStore(messagesList, CONVERSATION_TYPES.GROUP, conversationID);

          _this6.readReportHandler.updateIsRead(conversationID);

          logger.log('getGroupRoamMessages fnished...');
          return messages;
        })["catch"](function (error) {
          _this6.tim.exceptionController.ask(error);

          logger.log('getGroupRoamMessages error...');
          return Promise.reject(error);
        });
      }
      /**
       * 漫游消息的存储，注意：群消息是升序，C2C消息是降序
       * @param {Array} messagesList - 收到的消息列表
       * @param {String} conversationType - 会话类型，可取自： TIM_TYPES.CONVERSATION_TYPES.GROUP 和 TIM_TYPES.CONVERSATION_TYPES.C2C
       * @returns {[Message]} messages - 消息数组，元素为 Message 实例
       */

    }, {
      key: "_roamMessageStore",
      value: function _roamMessageStore() {
        var messagesList = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
        var conversationType = arguments.length > 1 ? arguments[1] : undefined;
        var conversationID = arguments.length > 2 ? arguments[2] : undefined;
        var message = null;
        var messages = [];
        var index = 0;
        var indexEnd = messagesList.length;
        var elements = null;
        var isGroup = conversationType === CONVERSATION_TYPES.GROUP;

        var initIndexStartAndIndexEnd = function initIndexStartAndIndexEnd() {
          // 如果是群组消息，从数组尾标开始
          index = conversationType === CONVERSATION_TYPES.GROUP ? messagesList.length - 1 : 0; // 如果是群组消息，到数组0索引入结束

          indexEnd = conversationType === CONVERSATION_TYPES.GROUP ? 0 : messagesList.length;
        };

        var indexStep = function indexStep() {
          // 如果是群组消息，index从数组最大索引开始自减，否则是从0开始自增
          conversationType === CONVERSATION_TYPES.GROUP ? --index : ++index;
        };

        var indexCompare = function indexCompare() {
          // 如果是群组消息，继续循环的条件是 index>=indexEnd, 如果私聊消息，继续循环的条件为index<indexEnd
          return conversationType === CONVERSATION_TYPES.GROUP ? index >= indexEnd : index < indexEnd;
        }; // 拉群历史没有数据说明已经拉完


        if (isGroup && messagesList.length === 0) {
          this.getMessageHandler.setCompleted(conversationID);
        } // 抠门儿: 这样写是为了避免掉 revers 操作引起的 2 x O(n) 复杂度，牺牲掉了代码可读性，性价比可能不太高，因为也只是 2 x O(n) 和 O(n) 的区别；


        for (initIndexStartAndIndexEnd(); indexCompare(); indexStep()) {
          // 出现空消息时，不入库，且说明已经拉完历史消息
          if (messagesList[index].elements.length === 0 && messagesList[index].time === 0) {
            this.getMessageHandler.setCompleted(conversationID);
            continue;
          } // sequence 为1时，说明拉完群历史消息


          if (isGroup && messagesList[index].sequence === 1) {
            this.getMessageHandler.setCompleted(conversationID);
          }

          message = new Message(messagesList[index]);
          message.to = messagesList[index].to;
          message.isSystemMessage = !!messagesList[index].isSystemMessage;
          message.conversationType = conversationType;

          if (messagesList[index].event === MESSAGE.JSON.TYPE.GROUP.TIP) {
            elements = {
              type: MESSAGE.ELEMENT_TYPES.GROUP_TIP,
              content: _objectSpread2({}, messagesList[index].elements, {
                groupProfile: messagesList[index].groupProfile
              })
            };
          } else {
            elements = messagesList[index].elements[0];
          }

          message.setElement(elements);
          message.reInitialize(this.tim.context.identifier);
          messages.push(message);
        }

        this.messagesList.shiftIn(messages);
        initIndexStartAndIndexEnd = indexStep = indexCompare = null; // 释放掉

        return messages;
      }
      /**
       * 获取消息列表
       */

    }, {
      key: "getLocalMessageList",
      value: function getLocalMessageList(conversationID) {
        if (this.messagesList.list.has(conversationID)) {
          return _toConsumableArray(this.messagesList.list.get(conversationID).values());
        }

        return [];
      }
      /**
       * 获取会话中某条消息
       * @param {String} conversationID
       * @param {String} messageID
       */

    }, {
      key: "getLocalMessage",
      value: function getLocalMessage(conversationID, messageID) {
        var list = this.messagesList.list.get(conversationID);

        if (!list) {
          return null;
        }

        var message = list.get(messageID);

        if (!message) {
          return null;
        }

        return message;
      }
      /**
       * 消息已读上报
       * @param {Object} options - 参数配置
       * @param {String} options.conversationID - 会话 ID
       * @param {String} [options.messageID] - 消息 ID（暂时不暴露给上层）。将某消息之前的消息已读上报。<br/> 若不传该字段，则默认对会话中所有的消息已读上报。
       * @returns {object}
       * @memberof MessageController
       */

    }, {
      key: "setMessageRead",
      value: function setMessageRead(options) {
        return this.readReportHandler.setMessageRead(options);
      }
      /**
       * 获取会话的消息列表
       * @param {Object} options - 参数对象
       * @returns {object}
       * @memberof MessageController
       */

    }, {
      key: "getMessageList",
      value: function getMessageList(options) {
        return this.getMessageHandler.getMessageList(options);
      }
      /**
       * 创建文本消息，此函数返回一个消息实例，可以使用SDK.sendMessage()方法发送
       * @param {Object} options - 配置参数
       * @param {String} options.to - 消息接收方
       * @param {String} options.conversationType - 会话类型
       * @param {String} options.payload.text - 消息内容
       * @returns {Message}
       */

    }, {
      key: "createTextMessage",
      value: function createTextMessage(options) {
        options.currentUser = this.tim.context.identifier; // 发消息时，需要传入currentUser参数

        var message = new Message(options);
        var text = typeof options.payload === 'string' ? options.payload : options.payload.text;
        var element = new TextElement({
          text: text
        });
        message.setElement(element);
        return message;
      }
      /**
       * 创建自定义消息，此函数返回一个消息实例，可以使用SDK.sendMessage()方法发送
       * @param {object} options - 参数对象
       * @param {string} options.to - 消息的接收方
       * @param {string} options.conversationType - 会话类型
       * @param {Object} options.payload  - 自定义消息的结构
       * @param {string} options.payload.data - 自定义消息的数据字段
       * @param {string} options.payload.description - 自定义消息的说明字段
       * @param {string} options.payload.extension - 自定义消息的扩展字段
       * @returns {Message}
       */

    }, {
      key: "createCustomMessage",
      value: function createCustomMessage(options) {
        options.currentUser = this.tim.context.identifier; // 发消息时，需要传入currentUser参数

        var message = new Message(options);
        var element = new CustomElement({
          data: options.payload.data,
          description: options.payload.description,
          extension: options.payload.extension
        });
        message.setElement(element);
        return message;
      }
      /**
       * 创建一条图片消息
       * @param {*} options - 参数配置
       * @param {string} options.to - 消息的接收方
       * @param {string} options.conversationType - 会话类型
       * @param {HTMLFileElement} options.payload.file - HTMLFileElement对象，用于接收文件数据
       * @param {Function} options.onProgress - 获取上传进度的回调函数
       * @returns {Message}
       */

    }, {
      key: "createImageMessage",
      value: function createImageMessage(options) {
        var uploadController = this.tim.uploadController;
        options.currentUser = this.tim.context.identifier; // 发消息时，需要传入currentUser参数

        console.log(1212, JSON.parse(JSON.stringify(options)));
        var message = new Message(options);
        var element = new ImageElement({
          imageFormat: 'UNKNOWN',
          uuid: ['fake', randomInt(), randomInt()].join('-'),
          file: options.payload.file
        });
        uploadController.uploadImage({
          file: options.payload.file,
          to: options.to,
          onProgress: function onProgress(percent) {
            element.updatePercent.bind(element)(percent);

            if (typeof options.onProgress === 'function') {
              options.onProgress(percent);
            }
          }
        }).then(function (uploadResponse) {
          var imageUrl = ['https://', uploadResponse.location].join('');
          element.updateImageFormat(uploadResponse.fileType);
          element.updateImageInfoArray({
            size: uploadResponse.fileSize,
            url: imageUrl
          });
          message.triggerOperated();
        })["catch"](function (uploadErrorResponse) {
          // 上传失败， message的状态设置为FAIL
          message.status = TIM_STATUS.MESSAGE_STATUS.FAIL;
          logger.warn('MessageController.createImageMessage(), error:', uploadErrorResponse); // TODO: 需要把消息设置给IMPromise
        });
        message.setElement(element);
        return message;
      }
      /**
       * 创建一条文件消息，请注意：因为微信小程序不支持选择文件的功能，所以暂时不能支持上传上传。
       * @param {*} options - 参数参数
       * @param {string} options.to - 消息的接收方
       * @param {string} options.conversationType - 会话类型
       * @param {HTMLFileElement} options.payload.file - HTMLFileElement对象，用于接收文件数据
       * @returns {Message}
       */

    }, {
      key: "createFileMessage",
      value: function createFileMessage(options) {
        if (IN_WX_MINI_APP) {
          return IMPromise.reject({
            code: ERROR_CODE.MESSAGE_FILE_WECHAT_MINIAPP_NOT_SUPPORT,
            message: ERROR_MESSAGE.MESSAGE_FILE_WECHAT_MINIAPP_NOT_SUPPORT
          });
        }

        var uploadController = this.tim.uploadController;
        options.currentUser = this.tim.context.identifier; // 发消息时，需要传入currentUser参数

        var message = new Message(options);
        var element = new SoundElement({
          uuid: ['fake', randomInt(), randomInt()].join('-'),
          file: options.payload.file
        });
        uploadController.uploadFile({
          file: options.payload.file,
          to: options.to,
          onProgress: function onProgress(percent) {
            element.updatePercent.bind(element)(percent);

            if (typeof options.onProgress === 'function') {
              options.onProgress(percent);
            }
          }
        }).then(function (uploadResponse) {
          var fileUrl = ['https://', uploadResponse.location].join('');
          element.updateFileUrl(fileUrl);
          logger.log("MessageController.createFileMessage(), file upload success, URL: ".concat(fileUrl));
          message.triggerOperated();
        })["catch"](function (uploadErrorResponse) {
          message.status = TIM_STATUS.MESSAGE_STATUS.FAIL;

          if (uploadErrorResponse.code === ERROR_CODE.MESSAGE_FILE_SIZE_LIMIT) {
            message.setError(uploadErrorResponse.code, uploadErrorResponse.message);
          }

          logger.warn('MessageController.createFileMessage(), file upload fail, error response: ', uploadErrorResponse);
          message.triggerOperated();
        });
        message.setElement(element);
        return message;
      }
      /**
       * 创建一条音频消息，请注意：因为 Web 端目前没有提供录音接口，所以暂时不能支持。
       * @param {*} options - 参数参数
       * @param {string} options.to - 消息的接收方
       * @param {string} options.conversationType - 会话类型
       * @param {Function} options.onProgress - 获取上传进度的回调函数
       * @returns {Message}
       */

    }, {
      key: "createSoundMessage",
      value: function createSoundMessage(options) {
        var uploadController = this.tim.uploadController;
        options.currentUser = this.tim.context.identifier; // 发消息时，需要传入currentUser参数

        var message = new Message(options);
        console.log(1212, options);
        var element = new SoundElement({
          uuid: ['fake', randomInt(), randomInt()].join('-'),
          file: options.payload.file
        });
        console.log('createSoundMessage', element);
        uploadController.uploadSound({
          file: options.payload.file,
          to: options.to
        }).then(function (uploadResponse) {
          console.log('uploadsuccess', uploadResponse);
        })["catch"](function (uploadErrorResponse) {
          console.log('uploaderror', uploadErrorResponse);
        });
        message.setElement(element);
        return message;
      }
      /**
       *
       * @param {*} options - 参数配置
       * @returns {Message}
       */

    }, {
      key: "createFaceMessage",
      value: function createFaceMessage(options) {
        options.currentUser = this.tim.context.identifier; // 发消息时，需要传入currentUser参数

        var message = new Message(options);
        var text = typeof options.payload === 'string' ? options.payload : options.payload.text;
        var element = new TextElement({
          text: text
        });
        message.setElement(element);
        return message;
      }
    }]);

    return MessageController;
  }(IMController);

  /**
   * @class GroupMember
   * @description 群成员对象，用于描述群成员具有的属性，如 ID、昵称、群内身份、入群时间等。
   * @property {String} userID 群成员 ID
   * @property {String} avatar 群成员头像 URL
   * @property {String} nick 群成员昵称
   * @property {String} role 群内身份<br/>
   * - TIM.TYPES.GRP_MBR_ROLE_OWNER（群主）
   * - TIM.TYPES.GRP_MBR_ROLE_ADMIN（群管理员）
   * - TIM.TYPES.GRP_MBR_ROLE_MEMBER（群普通成员）
   * @property {Number} joinTime 入群时间
   * @property {Number} lastSendMsgTime 最后发送消息的时间
   * @property {String} nameCard 群名片
   * @property {Number} muteUntil 禁言时间，值是时间戳，单位: 秒。
   * @property {Object[]} memberCustomField 群成员自定义字段
   * @property {String} memberCustomField.key 群成员自定义字段的 Key
   * @property {String} memberCustomField.value 群成员自定义字段的 Value
   */

  var GroupMember =
  /*#__PURE__*/
  function () {
    function GroupMember(options) {
      _classCallCheck(this, GroupMember);

      this.userID = '';
      this.avatar = '';
      this.nick = '';
      this.role = '';
      this.joinTime = '';
      this.lastSendMsgTime = '';
      this.nameCard = '';
      this.muteUntil = 0;
      this.memberCustomField = [];

      this._initMember(options);
    }
    /**
     * @private
     */


    _createClass(GroupMember, [{
      key: "_initMember",
      value: function _initMember(options) {
        this.updateMember(options);
      }
      /**
       * @private
       */

    }, {
      key: "updateMember",
      value: function updateMember(member) {
        var valuesIgnore = [null, undefined, '', 0, NaN];
        deepMerge(this, member, [], valuesIgnore);
      }
      /**
       * @private
       * @param {String} role
       */

    }, {
      key: "updateRole",
      value: function updateRole(role) {
        if (['Owner', 'Admin', 'Member'].indexOf(role) < 0) {
          return;
        }

        this.role = role;
      }
      /**
       * 更新群成员自定义字段
       * @private
       * @param {Obejct[]} memberCustomField
       */

    }, {
      key: "updateMemberCustomField",
      value: function updateMemberCustomField(memberCustomField) {
        deepMerge(this.memberCustomField, memberCustomField);
      }
    }]);

    return GroupMember;
  }();

  var GroupTipsHandler =
  /*#__PURE__*/
  function () {
    function GroupTipsHandler(options) {
      _classCallCheck(this, GroupTipsHandler);

      this.tim = options.tim;
      this.groupController = options.groupController;

      this._initListeners();
    }

    _createClass(GroupTipsHandler, [{
      key: "_initListeners",
      value: function _initListeners() {
        this.tim.innerEmitter.on(TIM_INNER_EVENT.MESSAGE_GROUP_INSTANT_RECEIVED, this._onReceivedGroupTips, this);
      }
      /**
       * 收到 Event 4 的群提示消息
       * @param {Object} event
       */

    }, {
      key: "_onReceivedGroupTips",
      value: function _onReceivedGroupTips(_ref) {
        var _this = this;

        var _ref$data = _ref.data,
            groupTips = _ref$data.result,
            isGroupTip = _ref$data.isGroupTip;

        if (!isGroupTip) {
          return;
        }

        groupTips.forEach(function (groupTip) {
          switch (groupTip.elements[0].content.operationType) {
            // 有新成员进群
            case 1:
              _this._onNewMemberComeIn(groupTip);

              break;
            // 有成员退出群

            case 2:
              _this._onMemberQuit(groupTip);

              break;
            // 有成员被踢出群

            case 3:
              _this._onMemberKickedOut(groupTip);

              break;
            // 有成员被设置成管理员

            case 4:
              _this._onMemberSetAdmin(groupTip);

              break;
            // 有成员被取消管理员

            case 5:
              _this._onMemberCancelledAdmin(groupTip);

              break;
            // 群资料变更

            case 6:
              _this._onGroupProfileModified(groupTip);

              break;
            // 群成员资料变更

            case 7:
              _this._onMemberInfoModified(groupTip);

              break;

            default:
              logger.warn('GroupTipsHandler._onReceivedGroupTips Unhandled groupTips. operationType=', groupTip.elements[0].content.operationType);
              break;
          }
        });
      }
      /**
       * 有新成员进群
       * @param {Object} groupTip
       */

    }, {
      key: "_onNewMemberComeIn",
      value: function _onNewMemberComeIn(groupTip) {
        // 是否需要更新群成员列表
        var needUpdate = false;
        var groupID = groupTip.elements[0].content.groupProfile.groupID;
        var userIDList = groupTip.elements[0].content.userIDList;

        if (this.groupController.hasLocalGroupMemberMap(groupID)) {
          for (var i = 0; i < userIDList.length; i++) {
            var userID = userIDList[0];
            var member = this.groupController.getLocalGroupMemberInfo(groupID, userID);

            if (!member) {
              needUpdate = true;
              break;
            }
          }
        }

        if (needUpdate) {
          this.groupController.updateGroupMemberList({
            groupID: groupID
          });
        }
      }
      /**
       * 有成员退群
       * @param {Object} groupTip
       */

    }, {
      key: "_onMemberQuit",
      value: function _onMemberQuit(groupTip) {
        var groupID = groupTip.elements[0].content.groupProfile.groupID;

        this.groupController._deleteLocalGroupMembers(groupID, groupTip.elements[0].content.userIDList);
      }
      /**
       * 有群成员被踢出群
       * @param {Object} groupTip
       */

    }, {
      key: "_onMemberKickedOut",
      value: function _onMemberKickedOut(groupTip) {
        var groupID = groupTip.elements[0].content.groupProfile.groupID;

        this.groupController._deleteLocalGroupMembers(groupID, groupTip.elements[0].content.userIDList);
      }
      /**
       * 有群成员被设为管理员
       * @param {Object} groupTip
       */

    }, {
      key: "_onMemberSetAdmin",
      value: function _onMemberSetAdmin(groupTip) {
        var _this2 = this;

        var groupID = groupTip.elements[0].content.groupProfile.groupID;
        var userIDList = groupTip.elements[0].content.userIDList;
        userIDList.forEach(function (userID) {
          var member = _this2.groupController.getLocalGroupMemberInfo(groupID, userID);

          if (member) {
            member.updateRole(GROUP_MEMBER_ROLE_TYPES.ADMIN);
          }
        });
      }
      /**
       * 有成员被取消管理员
       * @param {Object} groupTip
       */

    }, {
      key: "_onMemberCancelledAdmin",
      value: function _onMemberCancelledAdmin(groupTip) {
        var _this3 = this;

        var groupID = groupTip.elements[0].content.groupProfile.groupID;
        var userIDList = groupTip.elements[0].content.userIDList;
        userIDList.forEach(function (userID) {
          var member = _this3.groupController.getLocalGroupMemberInfo(groupID, userID);

          if (member) {
            member.updateRole(GROUP_MEMBER_ROLE_TYPES.MEMBER);
          }
        });
      }
      /**
       * 群资料变更
       * @param {Object} groupTip
       */

    }, {
      key: "_onGroupProfileModified",
      value: function _onGroupProfileModified(groupTip) {
        var _this4 = this;

        var newInfo = groupTip.elements[0].content.newGroupProfile;
        var groupID = groupTip.elements[0].content.groupProfile.groupID;
        var group = this.groupController.getLocalGroupProfile(groupID);
        Object.keys(newInfo).forEach(function (key) {
          switch (key) {
            case 'ownerID':
              _this4._ownerChaged(group, newInfo);

              break;

            default:
              group[key] = newInfo[key];
          }
        });

        this.groupController._emitGroupUpdate(true, true);
      }
      /**
       * 群主变更
       * @param {*} groupTip
       * @param {*} newInfo
       * @memberof GroupTipsHandler
       */

    }, {
      key: "_ownerChaged",
      value: function _ownerChaged(_ref2, newInfo) {
        var groupID = _ref2.groupID;
        var group = this.groupController.getLocalGroupProfile(groupID);
        var selfID = this.tim.context.identifier; // 若新的群主是自己，则更新自己的身份

        if (selfID === newInfo.ownerID) {
          group.updateGroup({
            selfInfo: {
              role: GROUP_MEMBER_ROLE_TYPES.OWNER
            }
          });
          var self = this.groupController.getLocalGroupMemberInfo(groupID, selfID);
          var oldOwenrID = this.groupController.getLocalGroupProfile(groupID).ownerID;
          var oldOwenr = this.groupController.getLocalGroupMemberInfo(groupID, oldOwenrID);

          if (self) {
            self.updateRole(GROUP_MEMBER_ROLE_TYPES.OWNER);
          }

          if (oldOwenr) {
            oldOwenr.updateRole(GROUP_MEMBER_ROLE_TYPES.MEMBER);
          }
        }
      }
      /**
       * 群成员资料变更
       * @param {Object} groupTip
       */

    }, {
      key: "_onMemberInfoModified",
      value: function _onMemberInfoModified(groupTip) {
        var _this5 = this;

        var groupID = groupTip.elements[0].content.groupProfile.groupID;
        groupTip.elements[0].content.msgMemberInfo.forEach(function (item) {
          var member = _this5.groupController.getLocalGroupMemberInfo(groupID, item.userAccount);

          if (member) {
            // 目前只有修改 禁言时间才会下发 event4 opType 8
            if (item.shutupTime) {
              member.shutUpUntil = (Date.now() + item.shutupTime * 1000) / 1000;
            } // TODO: 自定义字段尚未处理

          }
        });
      }
    }]);

    return GroupTipsHandler;
  }();

  var GroupSystemNoticeHandler =
  /*#__PURE__*/
  function () {
    function GroupSystemNoticeHandler(options) {
      _classCallCheck(this, GroupSystemNoticeHandler);

      this.groupController = options.groupController;
      this.tim = options.tim;

      this._initLiceners();
    }

    _createClass(GroupSystemNoticeHandler, [{
      key: "_initLiceners",
      value: function _initLiceners() {
        this.tim.innerEmitter.on(TIM_INNER_EVENT.MESSAGE_GROUP_SYSTEM_NOTICE_RECEIVED, this._onReceivedGroupSystemNotice, this);
      }
      /**
       * 收到群系统通知
       * @private
       * @param {Array} groupSystemNotices 收到的群系统通知
       */

    }, {
      key: "_onReceivedGroupSystemNotice",
      value: function _onReceivedGroupSystemNotice(_ref) {
        var _this = this;

        var _ref$data = _ref.data,
            groupSystemNotices = _ref$data.result,
            type = _ref$data.type;

        if (type === 'sync') {
          return;
        }

        groupSystemNotices.forEach(function (groupSystemNotice) {
          var operationType = groupSystemNotice.elements[0].content.operationType;

          switch (operationType) {
            // 申请加群请求（只有管理员会收到）
            case 1:
              _this._onApplyGroupRequest(groupSystemNotice);

              break;
            // 申请加群被同意（只有申请人能够收到）

            case 2:
              _this._onApplyGroupRequestAgreed(groupSystemNotice);

              break;
            // 申请加群被拒绝（只有申请人能够收到）

            case 3:
              _this._onApplyGroupRequestRefused(groupSystemNotice);

              break;
            // 被管理员踢出群(只有被踢者接收到)

            case 4:
              _this._onMemberKicked(groupSystemNotice);

              break;
            // 群被解散(全员接收)

            case 5:
              _this._onGroupDismissed(groupSystemNotice);

              break;
            // 创建群(创建者接收, 不展示)

            case 6:
              break;
            // 邀请加群(被邀请者接收)。对于被邀请者，表示被邀请进群。

            case 7:
              _this._onInviteGroup(groupSystemNotice);

              break;
            // 主动退群(主动退出者接收, 不展示)

            case 8:
              _this._onQuitGroup(groupSystemNotice);

              break;
            // 设置管理员(被设置者接收)

            case 9:
              _this._onSetManager(groupSystemNotice);

              break;
            // 取消管理员(被取消者接收)

            case 10:
              _this._onDeleteManager(groupSystemNotice);

              break;
            // 群已被回收(全员接收, 不展示)

            case 11:
              break;
            // TODO: 12邀请加群(被邀请者需同意)

            case 12:
              break;
            // 群消息已读同步

            case 15:
              // TODO: 15群消息已读同步
              break;
            // 用户自定义通知(默认全员接收)

            case 255:
              _this.tim.outerEmitter.emit(TIM_OUTER_EVENT.GROUP_SYSTEM_NOTICE_RECERIVED, {
                groupSystemNotice: groupSystemNotice,
                type: GROUP_SYSTEM_NOTICE_TYPES.CUSTOM
              });

              break;

            default:
              break;
          }
        });
      }
      /**
       * @private
       * @param {Object} groupSystemNotice 收到的群通知
       * 1申请加群请求（只有管理员会收到）
       */

    }, {
      key: "_onApplyGroupRequest",
      value: function _onApplyGroupRequest(groupSystemNotice) {
        this.tim.outerEmitter.emit(TIM_OUTER_EVENT.GROUP_SYSTEM_NOTICE_RECERIVED, {
          message: groupSystemNotice,
          type: GROUP_SYSTEM_NOTICE_TYPES.JOIN_GROUP_REQUEST
        });
      }
      /**
       * 2申请加群被同意（只有申请人能够收到）
       */

    }, {
      key: "_onApplyGroupRequestAgreed",
      value: function _onApplyGroupRequestAgreed(groupSystemNotice) {
        var groupID = groupSystemNotice.elements[0].content.groupProfile.groupID;
        var hasGroup = this.groupController.hasLocalGroup(groupID);

        if (!hasGroup) {
          this.groupController.getGroupList();
        }

        this.tim.outerEmitter.emit(TIM_OUTER_EVENT.GROUP_SYSTEM_NOTICE_RECERIVED, {
          message: groupSystemNotice,
          tyep: GROUP_SYSTEM_NOTICE_TYPES.JOIN_GROUP_ACCEPT
        });
      }
      /**
       * 3申请加群被拒绝（只有申请人能够收到）
       */

    }, {
      key: "_onApplyGroupRequestRefused",
      value: function _onApplyGroupRequestRefused(groupSystemNotice) {
        this.tim.outerEmitter.emit(TIM_OUTER_EVENT.GROUP_SYSTEM_NOTICE_RECERIVED, {
          message: groupSystemNotice,
          type: GROUP_SYSTEM_NOTICE_TYPES.JOIN_GROUP_REFUSE
        });
      }
      /**
       * 4被群成员踢出群(只有被踢者接收到)
       */

    }, {
      key: "_onMemberKicked",
      value: function _onMemberKicked(groupSystemNotice) {
        var groupID = groupSystemNotice.elements[0].content.groupProfile.groupID;
        var hasGroup = this.groupController.hasLocalGroup(groupID);

        if (hasGroup) {
          this.groupController._deleteLocalGroup(groupID);

          this.tim.conversationController._deleteLocalConversation("GROUP".concat(groupID));
        }

        this.groupController._emitGroupUpdate(true, false);

        this.tim.outerEmitter.emit(TIM_OUTER_EVENT.GROUP_SYSTEM_NOTICE_RECERIVED, {
          message: groupSystemNotice,
          type: GROUP_SYSTEM_NOTICE_TYPES.KICKED_OUT
        });
      }
      /**
       * 5群被解散(全员接收)
       */

    }, {
      key: "_onGroupDismissed",
      value: function _onGroupDismissed(groupSystemNotice) {
        var groupID = groupSystemNotice.elements[0].content.groupProfile.groupID;

        this.groupController._deleteLocalGroup(groupID);

        this.tim.conversationController._deleteLocalConversation("GROUP".concat(groupID));

        this.groupController._emitGroupUpdate(true, false);

        this.tim.outerEmitter.emit(TIM_OUTER_EVENT.GROUP_SYSTEM_NOTICE_RECERIVED, {
          message: groupSystemNotice,
          type: GROUP_SYSTEM_NOTICE_TYPES.GROUP_DISMISSED
        });
      }
      /**
       * 7邀请加群(被邀请者接收)。对于被邀请者，表示被邀请进群。
       */

    }, {
      key: "_onInviteGroup",
      value: function _onInviteGroup(groupSystemNotice) {
        var groupID = groupSystemNotice.elements[0].content.groupProfile.groupID;
        var hasGroup = this.groupController.hasLocalGroup(groupID);

        if (!hasGroup) {
          this.groupController.getGroupList();
        }

        this.tim.outerEmitter.emit(TIM_OUTER_EVENT.GROUP_SYSTEM_NOTICE_RECERIVED, {
          message: groupSystemNotice,
          type: GROUP_SYSTEM_NOTICE_TYPES.INVITED_JOIN_GROUP_REQUEST
        });
      }
      /**
       * 8主动退群(主动退出者接收, 不展示)
       */

    }, {
      key: "_onQuitGroup",
      value: function _onQuitGroup(groupSystemNotice) {
        var groupID = groupSystemNotice.elements[0].content.groupProfile.groupID;
        var hasGroup = this.groupController.hasLocalGroup(groupID);

        if (hasGroup) {
          this.groupController._deleteLocalGroup(groupID);

          this.tim.conversationController._deleteLocalConversation("GROUP".concat(groupID));

          this.groupController._emitGroupUpdate(true, false);
        }

        this.tim.outerEmitter.emit(TIM_OUTER_EVENT.GROUP_SYSTEM_NOTICE_RECERIVED, {
          message: groupSystemNotice,
          type: GROUP_SYSTEM_NOTICE_TYPES.QUIT
        });
      }
      /**
       * 9设置管理员(被设置者接收)
       */

    }, {
      key: "_onSetManager",
      value: function _onSetManager(groupSystemNotice) {
        var _groupSystemNotice$el = groupSystemNotice.elements[0].content.groupProfile,
            userID = _groupSystemNotice$el.to,
            groupID = _groupSystemNotice$el.groupID;
        var member = this.groupController.getLocalGroupMemberInfo(groupID, userID);

        if (member) {
          member.updateRole(GROUP_MEMBER_ROLE_TYPES.ADMIN);
        }

        this.tim.outerEmitter.emit(TIM_OUTER_EVENT.GROUP_SYSTEM_NOTICE_RECERIVED, {
          message: groupSystemNotice,
          type: GROUP_SYSTEM_NOTICE_TYPES.SET_ADMIN
        });
      }
      /**
       * 10移除管理员(被设置者接收)
       */

    }, {
      key: "_onDeleteManager",
      value: function _onDeleteManager(groupSystemNotice) {
        var _groupSystemNotice$el2 = groupSystemNotice.elements[0].content.groupProfile,
            userID = _groupSystemNotice$el2.to,
            groupID = _groupSystemNotice$el2.groupID;
        var member = this.groupController.getLocalGroupMemberInfo(groupID, userID);

        if (member) {
          member.updateRole(GROUP_MEMBER_ROLE_TYPES.MEMBER);
        }

        this.tim.outerEmitter.emit(TIM_OUTER_EVENT.GROUP_SYSTEM_NOTICE_RECERIVED, {
          message: groupSystemNotice,
          type: GROUP_SYSTEM_NOTICE_TYPES.CANCELED_ADMIN
        });
      }
    }]);

    return GroupSystemNoticeHandler;
  }();

  /**
   * AVChatRoom 轮询逻辑
   * @author rychouwei
   */

  var AVChatRoomHandler =
  /*#__PURE__*/
  function () {
    function AVChatRoomHandler(_ref) {
      var tim = _ref.tim,
          groupController = _ref.groupController;

      _classCallCheck(this, AVChatRoomHandler);

      this.tim = tim;
      this.groupController = groupController;
      this.AVChatRoomLoop = null;
      this.key = ''; // AVChatRoom 长轮询的 Key

      this.startSeq = 1; // AVChatRoom 拉消息的起始位置，默认为 1

      this.errorCount = 0; // 出错的次数

      this.group = {}; // 当前加入的 group 资料
    }

    _createClass(AVChatRoomHandler, [{
      key: "_updateProperties",

      /**
       * 更新 Loop 的请求参数
       * @param {Object} options
       * @param {String} options.key AVChatRoom 的 Key
       * @param {Number} options.startSeq AVChatRoom 的 startSeq
       * @memberof AVChatRoomHandler
       */
      value: function _updateProperties(options) {
        var _this = this;

        Object.keys(options).forEach(function (key) {
          _this[key] = options[key];
        });
      }
      /**
       * 启动 AVChatRoom 的长轮询
       */

    }, {
      key: "start",
      value: function start() {
        var options = {
          key: this.key,
          startSeq: this.startSeq
        };

        if (this.AVChatRoomLoop !== null) {
          if (this.AVChatRoomLoop._stoped) {
            this.AVChatRoomLoop.start();
          }

          return;
        }

        var pack = this.tim.notificationController.createPackage({
          name: 'AVChatRoom',
          action: 'startLongPoll',
          param: options
        });
        this.AVChatRoomLoop = this.tim.connectionController.createRunLoop({
          pack: pack,
          before: this._updateRequestData.bind(this),
          success: this._handleSuccess.bind(this),
          fail: this._handleFailure.bind(this)
        });
        this.AVChatRoomLoop.start();
      }
      /**
       * 关掉 AVChatRoom 的轮询，但不销毁实例
       */

    }, {
      key: "stop",
      value: function stop() {
        if (this.AVChatRoomLoop !== null && !this.AVChatRoomLoop._stoped) {
          this.AVChatRoomLoop.abort();
          this.AVChatRoomLoop.stop();
          this.group = {};
        }
      }
      /**
       * 申请加入 AVChatRoom
       * @param {Object} options
       */

    }, {
      key: "applyJoinAVChatRoom",
      value: function applyJoinAVChatRoom(options) {
        this._checkBeforeJoinGroup(options);

        var isLogin = this.tim.context.a2Key && this.tim.context.tinyID; // 1. 登录状态下，直接调用普通加群接口

        if (isLogin) {
          return this._joinWithAuth(options);
        } // 2. 非登录状态下，走匿名加群接口


        return this._joinWithoutAuth(options);
      }
      /**
       * 带登录状态加群
       * @private
       * @param {*} options
       */

    }, {
      key: "_joinWithAuth",
      value: function _joinWithAuth(options) {
        var _this2 = this;

        return this.groupController.applyJoinGroup(options).then(function (imResponse) {
          _this2.tim.innerEmitter.emit(TIM_INNER_EVENT.AVCHATROOM_JOIN_SUCCESS, {
            data: options.groupID
          }); // 更新实例属性值


          _this2._updateProperties({
            key: imResponse.data.longPollingKey,
            startSeq: 1,
            group: _this2.groupController.groupMap.get(options.groupID)
          }); // 启动轮询


          _this2.start();

          return imResponse;
        });
      }
      /**
       * 不带登录状态加群
       * @private
       * @param {Object} options
       */

    }, {
      key: "_joinWithoutAuth",
      value: function _joinWithoutAuth(options) {
        var _this3 = this;

        var pack = this.groupController.createPackage({
          name: 'group',
          action: 'applyJoinAVChatRoom',
          param: options
        });
        return this.tim.connectionController.request(pack).then(function (_ref2) {
          var longPollingKey = _ref2.data.longPollingKey;
          logger.log('AVChatRoomHandler.applyJoinAVChatRoom ok. groupID:', options.groupID);

          _this3.tim.innerEmitter.emit(TIM_INNER_EVENT.AVCHATROOM_JOIN_SUCCESS, {
            data: options.groupID
          });

          _this3._updateProperties({
            key: longPollingKey,
            startSeq: 1,
            group: _this3.groupController.getLocalGroupProfile(options.groupID)
          });

          _this3.start();

          return new IMResponse({
            status: JOIN_GROUP_STATUS.SUCCESS,
            group: _this3.groupController.getLocalGroupProfile(options.groupID)
          });
        })["catch"](function (error) {
          logger.error("AVChatRoomHandler.applyJoinAVChatRoom error:".concat(error.message, ". groupID:").concat(options.groupID));
          return IMPromise.reject(error, true);
        });
      }
      /**
       * 加 AVChatRoom 之前进行检查
       * 检查是否已经在某一 AVChatRoom 中，有则停掉，同时只能进一个大群。
       */

    }, {
      key: "_checkBeforeJoinGroup",
      value: function _checkBeforeJoinGroup(options) {
        // 1. 若当前已经进了 AVChatRoom
        if (this.isJoined) {
          if (options.groupID === this.group.groupID) {
            return;
          }

          var isOwner = this.group.selfInfo.role === GROUP_MEMBER_ROLE_TYPES.OWNER; // 1.1 对于群主，进其他 AVChatRoom 前，先清空本地的 AVChatRoom。因为群主不能退出 AVChatRoom

          if (isOwner) {
            this.groupController._deleteLocalGroup(this.group.groupID);

            this.tim.conversationController._deleteLocalConversation("GROUP".concat(this.group.groupID));

            this.groupController._emitGroupUpdate(true, false);
          } else {
            // 1.2 对于普通群成员，进其他 AVChatRoom 前，先退出当前 AVChatRoom
            this.groupController.quitGroup(this.group.groupID);
          }
        } // 2. 若当前正在 longpolling，则应停掉


        var isLoopRunnig = this.AVChatRoomLoop !== null && !this.AVChatRoomLoop._stoped;

        if (isLoopRunnig) {
          this.stop();
        }
      }
      /**
       * 一次轮询完成后 更新请求体中的 key 和 startSeq
       * @param {Object} requestData
       */

    }, {
      key: "_updateRequestData",
      value: function _updateRequestData(requestData) {
        requestData.StartSeq = this.startSeq;
        requestData.Key = this.key;
      }
      /**
       * 收到新的 AVChatRoom 消息
       * @param {Object} event
       * @returns
       * @memberof AVChatRoomHandler
       */

    }, {
      key: "_handleSuccess",
      value: function _handleSuccess(event) {
        this.startSeq = event.data.nextSeq;
        this.key = event.data.key;
        Array.isArray(event.data.rspMsgList) && event.data.rspMsgList.forEach(function (item) {
          item.to = item.groupID;
        });

        if (event.data.rspMsgList && event.data.rspMsgList.length > 0) {
          this.tim.notificationController._eachEventArray(event.data.rspMsgList);
        }
      }
    }, {
      key: "_handleFailure",
      value: function _handleFailure(event) {
        if (event.error) {
          this.errorCount++;

          if (this.errorCount >= 5) {
            this.stop();
            this.errorCount = 0;
          }

          this.tim.innerEmitter.emit(TIM_INNER_EVENT.ERROR_DETECTED, event.error);
        }
      }
    }, {
      key: "isJoined",
      get: function get() {
        return !isUndefined(this.group.groupID);
      }
    }]);

    return AVChatRoomHandler;
  }();

  /**
   * 群组管理， 建群，加群，退群，群权限，群消息，群组资料，群成员
   * @class
   */

  var GroupController =
  /*#__PURE__*/
  function (_IMController) {
    _inherits(GroupController, _IMController);

    function GroupController(tim) {
      var _this;

      _classCallCheck(this, GroupController);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(GroupController).call(this, tim));
      _this.groupMap = new Map();
      _this.groupMemberListMap = new Map();
      _this.hasLocalGroupList = false;
      _this.groupNoticeHandler = new GroupSystemNoticeHandler({
        tim: tim,
        groupController: _assertThisInitialized(_this)
      });
      _this.groupTipsHandler = new GroupTipsHandler({
        tim: tim,
        groupController: _assertThisInitialized(_this)
      });
      _this.AVChatRoomHandler = new AVChatRoomHandler({
        tim: tim,
        groupController: _assertThisInitialized(_this)
      });

      _this._initListeners();

      return _this;
    }
    /**
     * @param {CreateGroupOptions} options - 参数集
     * @returns {Promise}
     * @throws {IMError}
     */


    _createClass(GroupController, [{
      key: "createGroup",
      value: function createGroup(options) {
        var _this2 = this;

        var accessTypes = ['Public', 'Private', 'ChatRoom', 'AVChatRoom']; // 不合法的群类型

        if (!accessTypes.includes(options.type)) {
          var error = new IMError({
            code: ERROR_CODE.ILLEGAL_GROUP_TYPE,
            message: ERROR_MESSAGE.ILLEGAL_GROUP_TYPE
          });
          return IMPromise.reject(error, true);
        } // 创建 AVChatRoom 时不能添加成员


        if (isAVChatRoom(options.type) && !isUndefined(options.memberList) && options.memberList.length > 0) {
          logger.warn('GroupController.createGroup 创建AVChatRoom时不能添加群成员，自动忽略该字段');
          options.memberList = undefined;
        } // Private, ChatRoom, AVChatRoom 类型群，创建时不能设置 申请加群设置(joinOption)


        if (!isPublic(options.type) && !isUndefined(options.joinOption)) {
          logger.warn('GroupController.createGroup 创建Private/ChatRoom/AVChatRoom群时不能设置字段：joinOption，自动忽略该字段');
          options.joinOption = undefined;
        }

        var pack = this.createPackage({
          name: 'group',
          action: 'create',
          param: options
        });
        logger.log('GroupController.createGroup.');
        return this.tim.connectionController.request(pack).then(function (response) {
          logger.log('GroupController.createGroup ok. groupID:', response.data.groupID); // 1.更新本地群组列表

          _this2._updateLocalGroupListAndGroupMemberList([_objectSpread2({}, options, {
            groupID: response.data.groupID
          })]); // 2.非 AVChatRoom 类型群组创建后，发送一条自定义消息


          if (options.type !== GROUP_TYPES.AVCHATROOM) {
            // data=group_create, desc=undefined, ext=rychou创建群组
            var message = _this2.tim.createCustomMessage({
              to: response.data.groupID,
              conversationType: CONVERSATION_TYPES.GROUP,
              payload: {
                data: 'group_create',
                extension: "".concat(_this2.tim.context.identifier, "\u521B\u5EFA\u7FA4\u7EC4")
              }
            });

            _this2.tim.sendMessage(message);
          } // 3. 抛事件


          _this2._emitGroupUpdate(); // 4. 返回创建的群的信息


          return _this2.getGroupProfile({
            groupID: response.data.groupID
          });
        }).then(function (imResponse) {
          // 手动设置 messageRemindType
          var groupID = imResponse.data.group.groupID;

          var group = _this2.getLocalGroupProfile(groupID);

          group.selfInfo.messageRemindType = TYPES.MSG_REMIND_ACPT_AND_NOTE;
          return imResponse;
        })["catch"](function (error) {
          logger.error('GroupController.createGroup error:', error);
          return IMPromise.reject(error, true);
        });
      }
      /**
       * 加入群组
       * @param {Object} options
       */

    }, {
      key: "joinGroup",
      value: function joinGroup(options) {
        if (options.type === GROUP_TYPES.PRIVATE) {
          var error = new IMError({
            code: ERROR_CODE.CANNOT_JOIN_PRIVATE,
            message: ERROR_MESSAGE.CANNOT_JOIN_PRIVATE
          });
          this.tim.innerEmitter.emit(TIM_INNER_EVENT.ERROR_DETECTED, error);
          return IMPromise.reject(error, true);
        }

        logger.log('GroupController.joinGroup. groupID:', options.groupID);

        if (options.type === GROUP_TYPES.AVCHATROOM) {
          return this.applyJoinAVChatRoom(options);
        }

        return this.applyJoinGroup(options);
      }
      /**
       * 退出群组。群主只能退出私有群，群主退出其他类型的群只能通过解散群组的方式。
       * 通知：主动退群(Event:5 reportType:8) 有群成员退出群组(Event:4 opType: 2)
       * Private: 退群者收到 【主动退群】
       * Public: 所有群成员（除退群者）收到 【有群成员退出群组】，退群者收到 【主动退群】
       * ChatRoom: 退群者收到 【主动退群】
       * AVChatRoom: 退群者收到 【主动退群】
       * @param {String} groupID
       */

    }, {
      key: "quitGroup",
      value: function quitGroup(groupID) {
        var _this3 = this;

        // 1. 如果是退出 AVChatRoom，要先停掉轮询，再发请求退群，否则会导致最后一次polling下发退群的event6 2
        // 判断条件是：当前进入的 AVChatRoom 的 groupID 是否与待退出的相同。
        if (this.AVChatRoomHandler.group.groupID === groupID) {
          this.AVChatRoomHandler.stop();
        }

        var pack = this.createPackage({
          name: 'group',
          action: 'quitGroup',
          param: {
            groupID: groupID
          }
        });
        logger.log('GroupController.quitGroup. groupID:', groupID);
        return this.tim.connectionController.request(pack).then(function () {
          logger.log('GroupController.quitGroup ok. groupID:', groupID); // 2. 删除本地的群组

          _this3._deleteLocalGroup(groupID); // 3. 删除对应的群组会话


          _this3.tim.conversationController._deleteLocalConversation("GROUP".concat(groupID)); // 4. 抛外部事件


          _this3._emitGroupUpdate(true, false); // 5. 返回被删除的群 ID


          return new IMResponse({
            groupID: groupID
          });
        })["catch"](function (error) {
          logger.error("GroupController.quitGroup error.  error:".concat(error, ". groupID:").concat(groupID));
          return IMPromise.reject(error, true);
        });
      }
      /**
       * 转让群组。私有/公开/聊天室都支持。AVChatRoom不支持
       * @param {Object} options
       * @param {String} options.groupID - 待转让的群组 ID
       * @param {String} options.newOwnerID - 新群主的 ID
       */

    }, {
      key: "changeGroupOwner",
      value: function changeGroupOwner(options) {
        var _this4 = this;

        // AVChatRoom不支持
        if (this.hasLocalGroup(options.groupID) && this.getLocalGroupProfile(options.groupID).type === GROUP_TYPES.AVCHATROOM) {
          return IMPromise.reject(new IMError({
            code: ERROR_CODE.CANNOT_CHANGE_OWNER_IN_AVCHATROOM,
            message: ERROR_MESSAGE.CANNOT_CHANGE_OWNER_IN_AVCHATROOM
          }), true);
        } // 不能转给自己


        if (options.newOwnerID === this.tim.loginInfo.identifier) {
          return IMPromise.reject(new IMError({
            code: ERROR_CODE.CANNOT_CHANGE_OWNER_TO_SELF,
            message: ERROR_MESSAGE.CANNOT_CHANGE_OWNER_TO_SELF
          }), true);
        }

        var pack = this.createPackage({
          name: 'group',
          action: 'changeGroupOwner',
          param: options
        });
        logger.log('GroupController.changeGroupOwner. groupID:', options.groupID);
        return this.tim.connectionController.request(pack).then(function () {
          logger.log('GroupController.changeGroupOwner ok. groupID:', options.groupID);
          var groupID = options.groupID,
              newOwnerID = options.newOwnerID; // 更新群主ID

          _this4.groupMap.get(groupID).ownerID = newOwnerID; // 更新群组成员的身份

          var groupMembers = _this4.groupMemberListMap.get(groupID);

          if (groupMembers instanceof Map) {
            var currentGroupMember = groupMembers.get(_this4.tim.loginInfo.identifier);

            if (!isUndefined(currentGroupMember)) {
              currentGroupMember.updateRole('Member');
              _this4.groupMap.get(groupID).selfInfo.role = 'Member';
            }

            var newGroupOwner = groupMembers.get(newOwnerID);

            if (!isUndefined(newGroupOwner)) {
              newGroupOwner.updateRole('Owner');
            }
          }

          _this4._emitGroupUpdate(true, false);

          return new IMResponse({
            group: _this4.groupMap.get(groupID)
          });
        })["catch"](function (error) {
          logger.error("GroupController.changeGroupOwner error:".concat(error, ". groupID:").concat(options.groupID));
          return IMPromise.reject(error, true);
        });
      }
      /**
       * 解散群组
       * 私有群不能解散群组
       * @param {String} groupID - 群组 ID
       */

    }, {
      key: "dismissGroup",
      value: function dismissGroup(groupID) {
        var _this5 = this;

        // 不能解散 Private 类型的群组
        if (this.hasLocalGroup(groupID) && this.getLocalGroupProfile(groupID).type === GROUP_TYPES.PRIVATE) {
          return IMPromise.reject(new IMError({
            code: ERROR_CODE.CANNOT_DISMISS_PRIVATE,
            message: ERROR_MESSAGE.CANNOT_DISMISS_PRIVATE
          }), true);
        }

        var pack = this.createPackage({
          name: 'group',
          action: 'destroyGroup',
          param: {
            groupID: groupID
          }
        });
        logger.log("GroupController.dismissGroup. groupID:".concat(groupID));
        return this.tim.connectionController.request(pack).then(function () {
          logger.log("GroupController.dismissGroup ok. groupID:".concat(groupID));

          _this5._deleteLocalGroup(groupID);

          _this5.tim.conversationController._deleteLocalConversation("GROUP".concat(groupID));

          _this5._emitGroupUpdate(true, false);

          return new IMResponse({
            groupID: groupID
          });
        })["catch"](function (error) {
          logger.error("GroupController.dismissGroup error:".concat(error, ". groupID:").concat(groupID));
          return IMPromise.reject(error, true);
        });
      }
      /**
       * 修改群组资料
       * @param {Object} options
       */

    }, {
      key: "updateGroupProfile",
      value: function updateGroupProfile(options) {
        var _this6 = this;

        // Private / ChatRoom / AVChatRoom 不能设置 joinOption
        if (this.hasLocalGroup(options.groupID) && !isPublic(this.getLocalGroupProfile(options.groupID).type) && !isUndefined(options.joinOption)) {
          logger.warn('GroupController.modifyGroup: Private/ChatRoom/AVChatRoom群不能设置字段：joinOption，自动忽略该字段');
          options.joinOption = undefined;
        }

        var pack = this.createPackage({
          name: 'group',
          action: 'updateGroupProfile',
          param: options
        });
        logger.log('GroupController.modifyGroup. groupID:', options.groupID);
        return this.tim.connectionController.request(pack).then(function () {
          logger.log('GroupController.modifyGroup ok. groupID:', options.groupID); // 更新保存在内存的群组信息

          if (_this6.hasLocalGroup(options.groupID)) {
            var group = _this6.groupMap.get(options.groupID);

            group.updateGroup(options);

            _this6._setLocalGroupList(_this6.groupMap);
          }

          return new IMResponse({
            group: _this6.groupMap.get(options.groupID)
          });
        })["catch"](function (error) {
          logger.log("GroupController.modifyGroup error. error:".concat(error, " groupID:").concat(options.groupID));
          return IMPromise.reject(error, true);
        });
      }
      /**
       * 设置群成员身份
       * @param {Object} options
       */

    }, {
      key: "setGroupMemberRole",
      value: function setGroupMemberRole(options) {
        var _this7 = this;

        var group = this.groupMap.get(options.groupID); // 不是群主

        if (group.selfInfo.role !== GROUP_MEMBER_ROLE_TYPES.OWNER) {
          return IMPromise.reject(new IMError({
            code: ERROR_CODE.NOT_OWNER,
            message: ERROR_MESSAGE.NOT_OWNER
          }), true);
        } // Private和AVChatRoom不能设置管理员


        if ([GROUP_TYPES.PRIVATE, GROUP_TYPES.AVCHATROOM].includes(group.type)) {
          return IMPromise.reject(new IMError({
            code: ERROR_CODE.CANNOT_SET_MEMBER_ROLE_IN_PRIVATE_AND_AVCHATROOM,
            message: ERROR_MESSAGE.CANNOT_SET_MEMBER_ROLE_IN_PRIVATE_AND_AVCHATROOM
          }), true);
        } // 非法的群成员类型


        if ([GROUP_MEMBER_ROLE_TYPES.ADMIN, GROUP_MEMBER_ROLE_TYPES.MEMBER].indexOf(options.role) < 0) {
          return IMPromise.reject(new IMError({
            code: ERROR_CODE.INVALID_MEMBER_ROLE,
            message: ERROR_MESSAGE.INVALID_MEMBER_ROLE
          }), true);
        } // 不能设置自己的群成员身份


        if (options.userID === this.tim.loginInfo.identifier) {
          return IMPromise.reject(new IMError({
            code: ERROR_CODE.CANNOT_SET_SELF_MEMBER_ROLE,
            message: ERROR_MESSAGE.CANNOT_SET_SELF_MEMBER_ROLE
          }), true);
        }

        logger.log("GroupController.setGroupMemberRole. groupID:".concat(options.groupID, ". userID: ").concat(options.userID));
        var groupID = options.groupID,
            userID = options.userID,
            role = options.role;
        return this._modifyGroupMemberInfo({
          groupID: groupID,
          userID: userID,
          role: role
        }).then(function () {
          logger.log("GroupController.setGroupMemberRole ok. groupID:".concat(options.groupID, ". userID: ").concat(options.userID)); // 更新对应成员的身份

          var groupMemberMap = _this7.groupMemberListMap.get(options.groupID);

          if (typeof groupMemberMap !== 'undefined' && typeof groupMemberMap.get(options.userID) !== 'undefined') {
            groupMemberMap.get(options.userID).updateRole(options.role);
          }

          return new IMResponse({
            group: _this7.groupMap.get(options.groupID)
          });
        })["catch"](function (error) {
          logger.error("GroupController.setGroupMemberRole error:".concat(error, ". groupID:").concat(options.groupID, ". userID:").concat(options.userID));
          return IMPromise.reject(error, true);
        });
      }
      /**
       * 设置群组成员禁言时间
       * @param {Object} options
       */

    }, {
      key: "setGroupMemberMuteTime",
      value: function setGroupMemberMuteTime(options) {
        var _this8 = this;

        logger.log("GroupController.setGroupMemberMuteTime. groupID:".concat(options.groupID, ". userID: ").concat(options.userID));
        var groupID = options.groupID,
            userID = options.userID,
            muteTime = options.muteTime;
        return this._modifyGroupMemberInfo({
          groupID: groupID,
          userID: userID,
          muteTime: muteTime
        }).then(function () {
          logger.log("GroupController.setGroupMemberMuteTime ok. groupID:".concat(options.groupID, ". userID: ").concat(options.userID));
          return _this8.updateGroupMemberList({
            groupID: groupID
          });
        }).then(function () {
          return new IMResponse({
            group: _this8.groupMap.get(options.groupID)
          });
        })["catch"](function (error) {
          logger.error("GroupController.setGroupMemberMuteTime error:".concat(error, ". groupID:").concat(options.groupID, ". userID:").concat(options.userID));
          return IMPromise.reject(error, true);
        });
      }
      /**
       * 设置群消息提示类型。只能设置自己在某个群的群消息提示类型
       * @param {Object} options
       */

    }, {
      key: "setMessageRemindType",
      value: function setMessageRemindType(options) {
        var _this9 = this;

        logger.log("GroupController.setMessageRemindType. groupID:".concat(options.groupID, ". userID: ").concat(options.userID || this.tim.loginInfo.identifier));
        var groupID = options.groupID,
            messageRemindType = options.messageRemindType;
        return this._modifyGroupMemberInfo({
          groupID: groupID,
          messageRemindType: messageRemindType,
          userID: this.tim.loginInfo.identifier
        }).then(function () {
          logger.log("GroupController.setMessageRemindType ok. groupID:".concat(options.groupID, ". userID: ").concat(options.userID || _this9.tim.loginInfo.identifier));

          var group = _this9.groupMap.get(options.groupID);

          group.selfInfo.messageRemindType = messageRemindType;
          return new IMResponse({
            group: group
          });
        })["catch"](function (error) {
          logger.error("GroupController.setMessageRemindType error:".concat(error, ". groupID:").concat(options.groupID, ". userID:").concat(options.userID || _this9.tim.loginInfo.identifier));
          return IMPromise.reject(error, true);
        });
      }
      /**
       * 设置群成员名片
       * @param {Object} options
       */

    }, {
      key: "setGroupMemberNameCard",
      value: function setGroupMemberNameCard(options) {
        var _this10 = this;

        logger.log("GroupController.setGroupMemberNameCard. groupID:".concat(options.groupID, ". userID: ").concat(options.userID || this.tim.loginInfo.identifier));
        var groupID = options.groupID,
            _options$userID = options.userID,
            userID = _options$userID === void 0 ? this.tim.loginInfo.identifier : _options$userID,
            nameCard = options.nameCard;
        return this._modifyGroupMemberInfo({
          groupID: groupID,
          userID: userID,
          nameCard: nameCard
        }).then(function () {
          logger.log("GroupController.setGroupMemberNameCard ok. groupID:".concat(options.groupID, ". userID: ").concat(options.userID || _this10.tim.loginInfo.identifier));

          var groupMemberMap = _this10.groupMemberListMap.get(groupID);

          if (typeof groupMemberMap !== 'undefined' && typeof groupMemberMap.get(userID) !== 'undefined') {
            groupMemberMap.get(userID).updateMember({
              nameCard: nameCard
            });
          } // 若是修改自身的群名片，则更新selfInfo


          if (userID === _this10.tim.loginInfo.identifier && _this10.hasLocalGroup(groupID)) {
            _this10.getLocalGroupProfile(groupID).selfInfo.nameCard = nameCard;
          }

          return new IMResponse({
            group: _this10.groupMap.get(groupID)
          });
        })["catch"](function (error) {
          logger.error("GroupController.setGroupMemberNameCard error:".concat(error, ". groupID:").concat(options.groupID, ". userID:").concat(options.userID || _this10.tim.loginInfo.identifier));
          return IMPromise.reject(error, true);
        });
      }
      /**
       * 设置群成员维度自定义字段，由于自定义字段的权限是可以自定义的，是由客户控制的，所以这个接口不做权限校验
       * @param {Object} options
       */

    }, {
      key: "setGroupMemberCustomField",
      value: function setGroupMemberCustomField(options) {
        var _this11 = this;

        logger.log("GroupController.setGroupMemberCustomField. groupID:".concat(options.groupID, ". userID: ").concat(options.userID || this.tim.loginInfo.identifier));
        var groupID = options.groupID,
            userID = options.userID,
            memberCustomField = options.memberCustomField;
        return this._modifyGroupMemberInfo({
          groupID: groupID,
          userID: userID,
          memberCustomField: memberCustomField
        }).then(function () {
          logger.log("GroupController.setGroupMemberCustomField ok. groupID:".concat(options.groupID, ". userID: ").concat(options.userID || _this11.tim.loginInfo.identifier));

          if (_this11.groupMemberListMap.has(groupID) && _this11.groupMemberListMap.get(groupID).has(userID)) {
            _this11.groupMemberListMap.get(groupID).get(userID).updateMemberCustomField(memberCustomField);
          }

          return new IMResponse({
            group: _this11.groupMap.get(groupID)
          });
        })["catch"](function (error) {
          logger.error("GroupController.setGroupMemberCustomField error:".concat(error, ". groupID:").concat(options.groupID, ". userID:").concat(options.userID || _this11.tim.loginInfo.identifier));
          return IMPromise.reject(error, true);
        });
      }
      /**
       * 获取用户加入的群组列表
       * @memberof GroupController
       */

    }, {
      key: "getGroupList",
      value: function getGroupList() {
        var _this12 = this;

        logger.log('GroupController.getGroupList');
        var options = {
          responseFilter: {
            groupBaseInfoFilter: ['Type', 'Name', 'FaceUrl', 'NextMsgSeq'],
            selfInfoFilter: ['Role', // 群内身份
            'JoinTime', // 入群时间
            'MsgFlag']
          }
        };
        var pack = this.createPackage({
          name: 'group',
          action: 'list',
          param: options
        });
        return this.tim.connectionController.request(pack).then(function (_ref) {
          var groups = _ref.data.groups;
          logger.log('GroupController.getGroupList ok'); // 1. 清空现有的群组列表中多出的部分

          _this12._groupListTreeShaking(groups); // 2. 更新群组列表


          _this12._updateLocalGroupListAndGroupMemberList(groups);

          _this12.hasLocalGroupList = true;

          if (_this12.tempConversationList) {
            // 检查是否有暂存的待更新的会话列表，有则更新对应群组的lastMessage
            _this12._handleUpdateGroupLastMessage(_this12.tempConversationList);

            _this12.tempConversationList = null;
          }

          _this12._emitGroupUpdate();

          return new IMResponse({
            groupList: _this12.getLocalGroups()
          });
        })["catch"](function (error) {
          logger.error('GroupController.getGroupList error: ', error);
          return IMPromise.reject(error, true);
        });
      }
      /**
       * 获取群成员列表
       * @param {Object} options 请求参数
       * @param {String} options.groupID 群组的 ID
       * @param {Number} [options.count=15] 需要拉取的数量。最大值：100，避免回包过大导致请求失败。若传入超过100，则只拉取前100个。
       * @param {Number} [options.offset=0] 偏移量，默认从0开始拉取
       * @returns {Promise}
       */

    }, {
      key: "getGroupMemberList",
      value: function getGroupMemberList(_ref2) {
        var _this13 = this;

        var groupID = _ref2.groupID,
            _ref2$offset = _ref2.offset,
            offset = _ref2$offset === void 0 ? 0 : _ref2$offset,
            _ref2$count = _ref2.count,
            count = _ref2$count === void 0 ? 15 : _ref2$count;
        logger.log("GroupController.getGroupMemberList groupID: ".concat(groupID, " offset: ").concat(offset, " count: ").concat(count));
        var pack = this.createPackage({
          name: 'group',
          action: 'getGroupMemberList',
          param: {
            groupID: groupID,
            offset: offset,
            limit: count > 100 ? 100 : count,
            // 超过 100 则取 100
            memberInfoFilter: ['Account', 'Role', 'JoinTime', 'LastSendMsgTime', 'NameCard', 'ShutUpUntil']
          }
        });
        var memberList = [];
        return this.connectionController.request(pack).then(function (_ref3) {
          var _ref3$data = _ref3.data,
              members = _ref3$data.members,
              memberNum = _ref3$data.memberNum;

          // 1.更新 memberNum TODO: 有群成员进退群要更新该字段值
          if (_this13.hasLocalGroup(groupID)) {
            _this13.getLocalGroupProfile(groupID).memberNum = memberNum;
          } // 2.更新群成员列表


          memberList = _this13._updateLocalGroupMemberList(groupID, members); // 3.更新群成员的 nick 和 avatar

          return _this13.tim.getUserProfile({
            userIDList: members.map(function (item) {
              return item.userID;
            })
          });
        }).then(function (_ref4) {
          var data = _ref4.data;
          var options = data.map(function (item) {
            return {
              userID: item.userID,
              nick: item.nick,
              avatar: item.avatar
            };
          });

          _this13._updateLocalGroupMemberList(groupID, options);

          logger.log("GroupController.getGroupMemberList ok.");
          return new IMResponse({
            memberList: memberList
          });
        })["catch"](function (error) {
          logger.error('GroupController.getGroupMemberList error: ', error);
          return IMPromise.reject(error);
        });
      }
      /**
       * 获取群组列表
       * @returns
       * @memberof GroupController
       */

    }, {
      key: "getLocalGroups",
      value: function getLocalGroups() {
        return _toConsumableArray(this.groupMap.values());
      }
      /**
       * 获取某个群组信息
       * @param {String} groupID
       */

    }, {
      key: "getLocalGroupProfile",
      value: function getLocalGroupProfile(groupID) {
        return this.groupMap.get(groupID);
      }
      /**
       * 判断本地 groupMap 是否有群组
       * @param {String} groupID
       */

    }, {
      key: "hasLocalGroup",
      value: function hasLocalGroup(groupID) {
        return this.groupMap.has(groupID);
      }
      /**
       * 获取本地的群成员信息
       * @param {String} groupID
       * @param {String} userID
       */

    }, {
      key: "getLocalGroupMemberInfo",
      value: function getLocalGroupMemberInfo(groupID, userID) {
        if (this.groupMemberListMap.has(groupID)) {
          return this.groupMemberListMap.get(groupID).get(userID);
        }

        return false;
      }
      /**
       * 判断本地 groupMemberListMap 是否有群成员
       * @param {String} groupID
       * @param {String} userID
       */

    }, {
      key: "hasLocalGroupMember",
      value: function hasLocalGroupMember(groupID, userID) {
        return this.groupMemberListMap.has(groupID) && this.groupMemberListMap.get(groupID).has(userID);
      }
      /**
       * 判断本地是否有某个群组的群成员列表
       * @param {String} groupID
       */

    }, {
      key: "hasLocalGroupMemberMap",
      value: function hasLocalGroupMemberMap(groupID) {
        return this.groupMemberListMap.has(groupID);
      }
      /**
       * 获取完整的群资料，这里获取的群资料和群成员资料都是完整的
       * @param {Object} options
       * @param {String} options.groupID 群组ID
       * @param {string[]} options.appDefinedDataFilterGroup 群组维度自定义字段过滤
       * @param {string[]} options.appDefinedDataFilterGroupMember 群成员未读自定义字段过滤
       * @returns
       * @memberof GroupController
       */

    }, {
      key: "getGroupProfile",
      value: function getGroupProfile(options) {
        var _this14 = this;

        logger.log('GroupController.getGroupProfile. groupID:', options.groupID);
        var groupID = options.groupID,
            groupCustomFieldFilter = options.groupCustomFieldFilter,
            memberCustomFieldFilter = options.memberCustomFieldFilter;
        var groupProfileOptions = {
          groupIDList: [groupID],
          responseFilter: {
            groupBaseInfoFilter: ['Type', 'Name', 'Introduction', 'Notification', 'FaceUrl', 'Owner_Account', 'CreateTime', 'InfoSeq', 'LastInfoTime', 'LastMsgTime', 'MemberNum', 'MaxMemberNum', 'ApplyJoinOption', 'NextMsgSeq'],
            groupCustomFieldFilter: groupCustomFieldFilter,
            memberCustomFieldFilter: memberCustomFieldFilter
          }
        }; // 1. 调用高级接口获取群资料

        return this.getGroupProfileAdvance(groupProfileOptions).then(function (_ref5) {
          var _ref5$data = _ref5.data,
              groups = _ref5$data.successGroupList,
              failureGroupList = _ref5$data.failureGroupList;
          logger.log('GroupController.getGroupProfile ok. groupID:', options.groupID);

          if (failureGroupList.length > 0) {
            return IMPromise.reject(failureGroupList[0], true);
          }

          var userIDList = []; // 2. 更新本地 groupMap 和 groupMemberListMap

          _this14._updateLocalGroupListAndGroupMemberList(groups, true); // 3. 筛选出群成员的 ID List


          if (_this14.groupMemberListMap.has(groupID)) {
            _this14.groupMemberListMap.get(groupID).forEach(function (_ref6) {
              var userID = _ref6.userID;
              userIDList.push(userID);
            });
          }

          _this14._emitGroupUpdate(); // 4. 请求获取群成员的头像和昵称


          return _this14.tim.getUserProfile({
            userIDList: userIDList,
            tagList: ['Tag_Profile_IM_Nick', 'Tag_Profile_IM_Image']
          });
        }).then(function (_ref7) {
          var data = _ref7.data;
          // 5. 更新群成员的头像和昵称
          data.forEach(function (profile) {
            var member = _this14.getLocalGroupMemberInfo(groupID, profile.userID);

            if (member) {
              member.updateMember({
                nick: profile.nick,
                avatar: profile.avatar
              });
            }
          });
          return new IMResponse({
            group: _this14.groupMap.get(groupID)
          });
        })["catch"](function (error) {
          logger.error("GroupController.getGroupProfile error.  error:".concat(error, ". groupID:").concat(options.groupID));
          return IMPromise.reject(error, true);
        });
      }
      /**
       * 添加群成员
       * 这里不做权限校验，为客户保留App管理员调用的权限
       * App管理员添加群成员: 通知: 群组有新成员加入（Event:4 opType:1，），被添加进群组（Event: 5 reportType: 7）
       * Private: 所有用户都收不到以上两个事件
       * Public: 所有群成员收到 【群组有新成员加入】，被添加的成员收到 【群组有新成员加入】和【被添加进群组】。设置Silence=1，则情况和ChatRoom相同
       * ChatRoom: 只有被添加成员收到 【被添加进群组】
       * @param {Object} options
       */

    }, {
      key: "addGroupMember",
      value: function addGroupMember(options) {
        var _this15 = this;

        var group = this.getLocalGroupProfile(options.groupID); // AVChatRoom不支持添加群成员

        if (isAVChatRoom(group.type)) {
          var error = new IMError({
            code: ERROR_CODE.CANNOT_ADD_MEMBER_IN_AVCHATROOM,
            message: ERROR_MESSAGE.CANNOT_ADD_MEMBER_IN_AVCHATROOM
          });
          return IMPromise.reject(error, true);
        }

        options.userIDList = options.userIDList.map(function (userID) {
          return {
            userID: userID
          };
        });
        var pack = this.createPackage({
          name: 'group',
          action: 'addGroupMember',
          param: options
        });
        logger.log('GroupController.addGroupMember. groupID:', options.groupID);
        return this.connectionController.request(pack).then(function (_ref8) {
          var members = _ref8.data.members;
          logger.log('GroupController.addGroupMember ok. groupID:', options.groupID);
          var successUserIDList = members.filter(function (item) {
            return item.result === 1;
          }).map(function (item) {
            return item.userID;
          });
          var failureUserIDList = members.filter(function (member) {
            return member.result === 0;
          }).map(function (item) {
            return item.userID;
          });
          var existedUserIDList = members.filter(function (member) {
            return member.result === 2;
          }).map(function (item) {
            return item.userID;
          });

          if (successUserIDList.length === 0) {
            return new IMResponse({
              successUserIDList: successUserIDList,
              failureUserIDList: failureUserIDList,
              existedUserIDList: existedUserIDList
            });
          }

          _this15.updateGroupMemberList(options);

          return new IMResponse({
            successUserIDList: successUserIDList,
            failureUserIDList: failureUserIDList,
            existedUserIDList: existedUserIDList,
            group: group
          });
        })["catch"](function (error) {
          logger.error("GroupController.addGroupMember error.  error:".concat(error, ". groupID:").concat(options.groupID));
          return IMPromise.reject(error, true);
        });
      }
      /**
       * 删除群成员
       * 通知：群中有成员被踢（Event:4 opType:3） 被踢出群（Event:5 reportType:4）
       * Private: 所有群成员都收不到通知
       * Public: 所有群成员收到【群中有成员被踢】，被踢的用户收到【被踢出群】
       * ChatRoom: 只有被踢的用户收到【被踢出群】
       * @param {Object} options
       */

    }, {
      key: "deleteGroupMember",
      value: function deleteGroupMember(options) {
        var _this16 = this;

        var group = this.groupMap.get(options.groupID);

        if (group.type === GROUP_TYPES.AVCHATROOM) {
          return IMPromise.reject(new IMError({
            code: ERROR_CODE.CANNOT_KICK_MEMBER_IN_AVCHATROOM,
            message: ERROR_MESSAGE.CANNOT_KICK_MEMBER_IN_AVCHATROOM
          }), true);
        }

        var pack = this.createPackage({
          name: 'group',
          action: 'deleteGroupMember',
          param: options
        });
        return this.connectionController.request(pack).then(function () {
          _this16._deleteLocalGroupMembers(options.groupID, options.userIDList);

          _this16._emitGroupUpdate();

          return new IMResponse({
            group: group,
            userIDList: options.userIDList
          });
        })["catch"](this._promiseCatch.bind(this));
      }
      /**
       * 通过 groupID 搜索群组
       * Private 类型的群组不允许搜索
       * @param {String} groupID
       */

    }, {
      key: "searchGroupByID",
      value: function searchGroupByID(groupID) {
        var options = {
          groupIDList: [groupID]
        };
        var pack = this.createPackage({
          name: 'group',
          action: 'searchGroupByID',
          param: options
        });
        logger.log("GroupController.searchGroupByID. groupID:".concat(groupID));
        return this.connectionController.request(pack).then(function (_ref9) {
          var groupProfile = _ref9.data.groupProfile;
          logger.log("GroupController.searchGroupByID ok. groupID:".concat(groupID));

          if (groupProfile[0].errorCode !== TIM_STATUS.REQUEST.SUCCESS) {
            throw new IMError({
              code: groupProfile[0].errorCode,
              message: groupProfile[0].errorInfo
            });
          }

          return new IMResponse({
            group: new Group(groupProfile[0])
          });
        })["catch"](function (error) {
          logger.error("GroupController.searchGroupByID ok. error:".concat(error, " groupID:").concat(groupID));
          return IMPromise.reject(error, true);
        });
      }
      /**
       * 申请加群
       * 通知：有新用户进群（Event:4 opType:1） 申请加群被同意（Event:5 reportType:2）
       * Private：不允许申请加群，只能通过群成员添加群成员的方式
       * 当申请被同意时：
       * Public: 所有群成员收到 【有新用户进群】 申请者收到 【申请加群被同意】
       * ChatRoom: 申请者收到 【申请加群被同意】
       * AVChatRoom: 申请者收到 【申请加群被同意】
       * @param {Object} options
       */

    }, {
      key: "applyJoinGroup",
      value: function applyJoinGroup(options) {
        var _this17 = this;

        var pack = this.createPackage({
          name: 'group',
          action: 'applyJoinGroup',
          param: options
        });
        return this.connectionController.request(pack).then(function (_ref10) {
          var _ref10$data = _ref10.data,
              joinedStatus = _ref10$data.joinedStatus,
              longPollingKey = _ref10$data.longPollingKey;
          logger.log('GroupController.joinGroup ok. groupID:', options.groupID);

          switch (joinedStatus) {
            case JOIN_GROUP_STATUS.WAIT_APPROVAL:
              return new IMResponse({
                status: JOIN_GROUP_STATUS.WAIT_APPROVAL
              });

            case JOIN_GROUP_STATUS.SUCCESS:
              return _this17.getGroupProfile({
                groupID: options.groupID
              }).then(function (response) {
                var result = {
                  status: JOIN_GROUP_STATUS.SUCCESS,
                  group: response.data.group
                };

                if (!isUndefined(longPollingKey)) {
                  result.longPollingKey = longPollingKey;
                }

                return new IMResponse(result);
              });

            default:
              {
                var error = new IMError({
                  code: ERROR_CODE.JOIN_GROUP_FAIL,
                  message: ERROR_MESSAGE.JOIN_GROUP_FAIL
                });
                logger.error("GroupController.joinGroup error:".concat(error, ". groupID:").concat(options.groupID));
                return IMPromise.reject(error, true);
              }
          }
        })["catch"](function (error) {
          logger.error("GroupController.joinGroup error:".concat(error, ". groupID:").concat(options.groupID));
          return IMPromise.reject(error, true);
        });
      }
      /**
       * 申请加入 AVChatRoom
       * @param {Object} options
       */

    }, {
      key: "applyJoinAVChatRoom",
      value: function applyJoinAVChatRoom(options) {
        return this.AVChatRoomHandler.applyJoinAVChatRoom(options);
      }
      /**
       * 处理加群请求
       * 通知：收到加群请求(Event:5 reportType:1)、加群被同意(Event:5 reportType:2)、加群被拒绝(Event:5 reportType:3)、有新用户进群（Event:4 opType:1）
       * Private: 私有群不允许申请加群，故该类通知
       * ChatRoom: 处理前：群主和管理员收到 【收到加群请求】，处理后：申请人收到 【加群被同意】 / 【加群被拒绝】
       * Public: 处理前：群主和管理员收到 【收到加群请求】，处理后：申请人收到 【加群被同意】和 【有新用户进群】 / 【加群被拒绝】，所有群成员收到 【有新用户进群】
       * @param {Object} options
       */

    }, {
      key: "handleGroupApplication",
      value: function handleGroupApplication(options) {
        var _this18 = this;

        var _options$message$elem = options.message.elements[0].content,
            groupID = _options$message$elem.groupProfile.groupID,
            authentication = _options$message$elem.authentication,
            messageKey = _options$message$elem.messageKey,
            applicant = _options$message$elem.operatorID;
        var pack = this.createPackage({
          name: 'group',
          action: 'handleApplyJoinGroup',
          param: _objectSpread2({}, options, {
            applicant: applicant,
            groupID: groupID,
            authentication: authentication,
            messageKey: messageKey
          })
        });
        logger.log('GroupController.handleApplication. groupID:', groupID);
        return this.connectionController.request(pack).then(function () {
          logger.log('GroupController.handleApplication ok. groupID:', groupID);
          return _this18.updateGroupMemberList({
            groupID: groupID
          });
        }).then(function (group) {
          return new IMResponse({
            group: group
          });
        })["catch"](function (error) {
          logger.error("GroupController.handleApplication error.  error:".concat(error, ". groupID:").concat(groupID));
          return IMPromise.reject(error, true);
        });
      }
      /**
       * 删除群系统通知
       * @param {Obejct} options
       * @param {Message[]} options.messageList
       * @param {Obejct[]} options.messageListToDelete 待删除的群系统消息列表
       */

    }, {
      key: "deleteGroupSystemNotice",
      value: function deleteGroupSystemNotice(options) {
        var pack = this.createPackage({
          name: 'group',
          action: 'deleteGroupSystemNotice',
          param: {
            messageListToDelete: options.messageList.map(function (message) {
              return {
                from: CONVERSATION_TYPES.SYSTEM,
                messageSeq: message.clientSequence,
                messageRandom: message.random
              };
            })
          }
        });
        return this.connectionController.request(pack).then(function () {
          return new IMResponse();
        })["catch"](this._promiseCatch.bind(this));
      } // TODO: 待确定是否需要
      // getPendencyGroup(options) {
      //   const pack = this.createPackage({
      //     name: 'group',
      //     action: 'getPendencyGroup',
      //     param: options
      //   });
      //   return this.connectionController
      //     .request(pack)
      //     .then(({ data }) => {
      //       console.log(data);
      //     })
      //     .catch(this._promiseCatch.bind.bind(this));
      // }
      // reportGroupPendency(options){
      //   const pack = this.createPackage({
      //     name: 'group',
      //     action: 'reportGroupPendency',
      //     param: options
      //   })
      //   return this.connectionController
      //     .request(pack)
      //     .then(({ data }) => {
      //       console.log(data);
      //     })
      //     .catch(this._promiseCatch.bind.bind(this));
      // }

      /**
       * 更新群成员列表。
       * 拉取远端数据，更新内存中的群成员列表
       * @param {Object} options
       * @param {String} options.groupID
       * @param {string[]} [options.memberInfoFilter=['Account', 'Role', 'JoinTime', 'LastSendMsgTime', 'NameCard', 'ShutUpUntil']] 需要更新的字段，默认更新所有字段
       * @param {String} options.appDefinedDataFilterGroupMember
       */

    }, {
      key: "updateGroupMemberList",
      value: function updateGroupMemberList(options) {
        var _this19 = this;

        var groupID = options.groupID,
            memberCustomFieldFilter = options.memberCustomFieldFilter,
            memberInfoFilter = options.memberInfoFilter;
        var groupProfileOptions = {
          groupIDList: [groupID],
          responseFilter: {
            memberInfoFilter: memberInfoFilter || ['Account', 'Role', 'JoinTime', 'LastSendMsgTime', 'NameCard', 'ShutUpUntil'],
            memberCustomFieldFilter: memberCustomFieldFilter
          }
        };
        return this.getGroupProfileAdvance(groupProfileOptions).then(function (_ref11) {
          var _ref11$data = _ref11.data,
              groups = _ref11$data.successGroupList,
              failureGroupList = _ref11$data.failureGroupList;

          if (failureGroupList.length > 0) {
            return IMPromise.reject(failureGroupList[0], true);
          }

          var userIDList = [];

          _this19._updateLocalGroupMemberList(groups[0].groupID, groups[0].members);

          _this19.groupMemberListMap.get(groupID).forEach(function (_ref12) {
            var userID = _ref12.userID;
            userIDList.push(userID);
          });

          return _this19.tim.getUserProfile({
            userIDList: userIDList,
            tagList: ['Tag_Profile_IM_Nick', 'Tag_Profile_IM_Image']
          });
        }).then(function (_ref13) {
          var data = _ref13.data;
          var members = data.map(function (_ref14) {
            var userID = _ref14.userID,
                nick = _ref14.nick,
                avatar = _ref14.avatar;
            return {
              userID: userID,
              nick: nick,
              avatar: avatar
            };
          });

          _this19._updateLocalGroupMemberList(groupID, members);

          _this19._emitGroupUpdate();

          return _this19.groupMap.get(groupID);
        });
      }
      /**
       * 通用的promise catch处理函数
       * @private
       * @param {ERROR|IMError} error
       */

    }, {
      key: "_promiseCatch",
      value: function _promiseCatch(error) {
        return IMPromise.reject(error, true);
      }
      /**
       * 获取群资料
       * @param {Object} options
       * @param {String[]} options.groupIDList - 需要拉取的群组列表，数组元素值为群组的ID
       * @param {Object} [options.responseFilter] - 包含三个过滤器：GroupBaseInfoFilter，MemberInfoFilter，AppDefinedDataFilter_Group，分别是基础信息字段过滤器，成员信息字段过滤器，群组维度的自定义字段过滤器
       * @param {String[]} [options.responseFilter.groupBaseInfoFilter] - 基础信息字段过滤器，指定需要获取的基础信息字段，详情请参阅 {@link https://cloud.tencent.com/document/product/269/1502#.E7.BE.A4.E5.9F.BA.E7.A1.80.E8.B5.84.E6.96.99 群基础资料}
       * @param {String[]} [options.responseFilter.memberInfoFilter] - 	成员信息字段过滤器，指定需要获取的成员信息字段，详情请参阅 {@link https://cloud.tencent.com/document/product/269/1502#.E7.BE.A4.E6.88.90.E5.91.98.E8.B5.84.E6.96.99 群成员资料}
       * @param {String[]} [options.responseFilter.groupCustomFieldFilter] - 群组维度的自定义字段过滤器，指定需要获取的群组维度的自定义字段，详情请参阅 {@link https://cloud.tencent.com/document/product/269/1502#.E8.87.AA.E5.AE.9A.E4.B9.89.E5.AD.97.E6.AE.B5 自定义字段}
       * @param {String[]} [options.responseFilter.memberCustomFieldFilter] - 群成员维度的自定义字段过滤器，指定需要获取的群成员维度的自定义字段，详情请参阅 {@link https://cloud.tencent.com/document/product/269/1502#.E8.87.AA.E5.AE.9A.E4.B9.89.E5.AD.97.E6.AE.B5 自定义字段}
       * @memberof GroupController
       */

    }, {
      key: "getGroupProfileAdvance",
      value: function getGroupProfileAdvance(options) {
        logger.log('GroupController.getGroupProfileAdvance. groupIDList:', options.groupIDList);
        var pack = this.createPackage({
          name: 'group',
          action: 'query',
          param: options
        });
        return this.tim.connectionController.request(pack).then(function (response) {
          logger.log('GroupController.getGroupProfileAdvance ok.');
          var groups = response.data.groups;
          var successGroupList = groups.filter(function (item) {
            return isUndefined(item.errorCode) || item.errorCode === TIM_STATUS.REQUEST.SUCCESS;
          });
          var failureGroupList = groups.filter(function (item) {
            return item.errorCode && item.errorCode !== TIM_STATUS.REQUEST.SUCCESS;
          }).map(function (item) {
            return new IMError({
              code: Number("500".concat(item.errorCode)),
              message: item.errorInfo,
              data: {
                groupID: item.groupID
              }
            });
          });
          return new IMResponse({
            successGroupList: successGroupList,
            failureGroupList: failureGroupList
          });
        })["catch"](function (error) {
          logger.error("GroupController.getGroupProfile error. groupID:".concat(options.groupID, " error:").concat(error));
          return IMPromise.reject(error, true);
        });
      }
      /**
       * 删除本地群组
       * @private
       * @param {String} groupID
       * @returns {Boolean} 是否删除成功
       */

    }, {
      key: "_deleteLocalGroup",
      value: function _deleteLocalGroup(groupID) {
        // 1.删除群
        this.groupMap["delete"](groupID); // 2.删除群成员列表

        this.groupMemberListMap["delete"](groupID); // 3.同步更新本地缓存

        this._setLocalGroupList(this.groupMap);

        return this.groupMap.has(groupID) && this.groupMemberListMap.has(groupID);
      }
      /**
       * 初始化groupList
       * 初始化SDK时从Storage中取出更新内存的 groupMap
       * @private
       * @memberof GroupController
       */

    }, {
      key: "_initGroupList",
      value: function _initGroupList() {
        var _this20 = this;

        logger.time(label.INIT_GROUP_LIST);
        logger.log('GroupController._initGroupList');
        this.hasLocalGroupList = this._hasLocalGroupList();

        if (this.hasLocalGroupList) {
          var localGroupList = this._getLocalGroups();

          localGroupList.forEach(function (groupArray) {
            _this20.groupMap.set(groupArray[0], new Group(groupArray[1]));
          });

          this._emitGroupUpdate(true, false);
        }

        this.triggerReady();
        logger.log("GroupController._initGroupList ok. initCost=".concat(logger.timeEnd(label.INIT_GROUP_LIST), "ms"));
        this.getGroupList();
      }
    }, {
      key: "_initListeners",
      value: function _initListeners() {
        var innerEmitter = this.tim.innerEmitter; // 登录态变更时触发，登录成功必触发一次

        innerEmitter.once(TIM_INNER_EVENT.CONTEXT_A2KEY_AND_TINYID_UPDATED, this._initGroupList, this);
        innerEmitter.on(TIM_INNER_EVENT.CONVERSATION_LIST_UPDATED, this._handleUpdateGroupLastMessage, this); // 收到群新消息推送， 包括普通消息和群提示消息

        innerEmitter.on(TIM_INNER_EVENT.MESSAGE_GROUP_INSTANT_RECEIVED, this._handleReceivedGroupMessage, this); // 自己或好友资料变更，需更新群成员资料

        innerEmitter.on(TIM_INNER_EVENT.PROFILE_UPDATED, this._handleProfileUpdated, this);
      }
      /**
       * 抛群组更新事件
       * @param {Boolean} outer 是否抛外部事件
       * @param {Boolean} inner 是否抛内部事件
       */

    }, {
      key: "_emitGroupUpdate",
      value: function _emitGroupUpdate() {
        var outer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
        var inner = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
        var groupList = this.getLocalGroups();
        inner && this.tim.innerEmitter.emit(TIM_INNER_EVENT.GROUP_LIST_UPDATED, groupList);
        outer && this.tim.outerEmitter.emit(TIM_OUTER_EVENT.GROUP_LIST_UPDATED, groupList);
      }
      /**
       * 收到群消息
       * @private
       * @param {Object} event
       */

    }, {
      key: "_handleReceivedGroupMessage",
      value: function _handleReceivedGroupMessage(_ref15) {
        var _this21 = this;

        var eventDataList = _ref15.data.eventDataList;

        // 1. 更新群的nextMessageSeq, lastSequence在更新会话时更新
        if (Array.isArray(eventDataList)) {
          eventDataList.forEach(function (item) {
            var groupID = item.conversationID.replace(CONVERSATION_TYPES.GROUP, '');

            if (_this21.groupMap.has(groupID)) {
              _this21.groupMap.get(groupID).nextMessageSeq = item.lastMessage.sequence + 1;
            }
          });
        }
      }
      /**
       * 收到 群提示消息 或 群系统通知
       * @private
       * @param {Object} event
       */

    }, {
      key: "_onReceivedGroupSystemNotice",
      value: function _onReceivedGroupSystemNotice(_ref16) {
        var groupTips = _ref16.data;

        this.groupNoticeHandler._onReceivedGroupNotice(groupTips);
      }
      /**
       * 更新群组的lastMessage
       * @private
       * @param {Array} conversationList
       * @memberof GroupController
       */

    }, {
      key: "_handleUpdateGroupLastMessage",
      value: function _handleUpdateGroupLastMessage(conversationList) {
        if (!this.hasLocalGroupList) {
          this.tempConversationList = conversationList; // 该字段用于处理本地 Storage 无数据，对方请求先回来导致，更新被忽略的问题。

          return;
        } // 是否有群组的 lastMessage 更新


        var hasGroupUpdated = false;

        for (var i = 0; i < conversationList.length; i++) {
          var conversation = conversationList[i];
          var isGroup = conversation.type === TYPES.CONV_GROUP;

          if (!conversation.conversationID || !isGroup) {
            continue;
          }

          var groupID = conversation.conversationID.split(/^GROUP/)[1];
          var group = this.getLocalGroupProfile(groupID);

          if (group) {
            group.lastMessage = conversation.lastMessage;
            hasGroupUpdated = true;
          }
        } // 若有更新则需要排序群组列表


        if (hasGroupUpdated) {
          // 根据最后一条消息时间戳排序群组
          this.groupMap = this._sortLocalGroupList(this.groupMap);

          this._emitGroupUpdate(true, false);
        }
      }
      /**
       * 对群组列表排序
       * @private
       * @param {Map} groupMap
       */

    }, {
      key: "_sortLocalGroupList",
      value: function _sortLocalGroupList(groupMap) {
        var tempGroups = _toConsumableArray(groupMap).filter(function (_ref17) {
          var _ref18 = _slicedToArray(_ref17, 2),
              key = _ref18[0],
              value = _ref18[1];

          return !isEmpty(value.lastMessage);
        }); // 1.筛选出有 lastMessage的群组


        tempGroups.sort(function (a, b) {
          return b[1].lastMessage.lastTime - a[1].lastMessage.lastTime;
        });
        return new Map([].concat(_toConsumableArray(tempGroups), _toConsumableArray(groupMap)));
      }
      /**
       * 获取本地缓存的groupList
       * @private
       * @returns {Array}
       * @memberof GroupController
       */

    }, {
      key: "_getLocalGroups",
      value: function _getLocalGroups() {
        return this.tim.storage.getItem('groupMap');
      }
      /**
       * 判断是否有本地缓存的groupList
       * @private
       * @returns {Boolean}
       * @memberof GroupController
       */

    }, {
      key: "_hasLocalGroupList",
      value: function _hasLocalGroupList() {
        var localGroupList = this.tim.storage.getItem('groupMap');
        return localGroupList !== null && localGroupList.length !== 0;
      }
      /**
       * 更新本地缓存
       * @private
       * @param {Object} groupMap
       * @memberof GroupController
       */

    }, {
      key: "_setLocalGroupList",
      value: function _setLocalGroupList(groupMap) {
        var tempGroupList = [];
        groupMap.forEach(function (_ref19, groupID) {
          var name = _ref19.name,
              avatar = _ref19.avatar,
              type = _ref19.type;
          tempGroupList.push([groupID, {
            groupID: groupID,
            name: name,
            avatar: avatar,
            type: type
          }]);
        });
        this.tim.storage.setItem('groupMap', tempGroupList);
      }
      /**
       * 更新groupList 和 groupMemberListMap
       * @private
       * @param {Array} groups 后端返回的group数组
       * @param {Boolean} fullUpdateGroupMemberList 是否全量更新groupMemberList
       * @memberof GroupController
       */

    }, {
      key: "_updateLocalGroupListAndGroupMemberList",
      value: function _updateLocalGroupListAndGroupMemberList(groups, fullUpdateGroupMemberList) {
        var _this22 = this;

        groups.forEach(function (group) {
          if (_this22.groupMap.has(group.groupID)) {
            _this22.groupMap.get(group.groupID).updateGroup(group);
          } else {
            _this22.groupMap.set(group.groupID, new Group(group));
          }

          _this22._updateLocalGroupMemberList(group.groupID, group.members || group.memberList, fullUpdateGroupMemberList);
        });

        this._setLocalGroupList(this.groupMap);
      }
      /**
       * 更新groupMemberList
       * @param {String} groupID
       * @param {Object[]} members 后端返回的群成员数组
       * @param {Boolean} [fullUpdate=false] 是否全量更新，若为true，则会抛弃原有的groupMemberList，根据传入的members重新创建groupMemberList
       * @memberof GroupController
       */

    }, {
      key: "_updateLocalGroupMemberList",
      value: function _updateLocalGroupMemberList(groupID, members) {
        var _this23 = this;

        var fullUpdate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

        if (!members) {
          return [];
        } // 若全量更新则重新创建groupMemberListMap


        var memberList = this.groupMemberListMap.has(groupID) && fullUpdate === false ? this.groupMemberListMap.get(groupID) : new Map();
        var result = members.map(function (member) {
          // 1. 更新selfInfo
          if (member.userID === _this23.tim.context.identifier) {
            var valuesIgnore = [null, undefined, '', 0, NaN];
            var selfInfo = {
              role: member.role,
              joinTime: member.joinTime,
              nameCard: member.nameCard
            };
            deepMerge(_this23.groupMap.get(groupID).selfInfo, selfInfo, [], valuesIgnore);
          } // 2. 更新member


          if (memberList.has(member.userID)) {
            memberList.get(member.userID).updateMember(member);
          } else {
            // 3. 本地无群成员，则新增member
            memberList.set(member.userID, new GroupMember(member));
          }

          return memberList.get(member.userID);
        });
        this.groupMemberListMap.set(groupID, memberList);
        return result;
      }
      /**
       * 批量删除内存中的群成员，
       * @param {String} groupID
       * @param {string[]} userIDList
       */

    }, {
      key: "_deleteLocalGroupMembers",
      value: function _deleteLocalGroupMembers(groupID, userIDList) {
        var groupMemberMap = this.groupMemberListMap.get(groupID);

        if (typeof groupMemberMap !== 'undefined') {
          userIDList.forEach(function (userID) {
            groupMemberMap["delete"](userID);
          });
          this.groupMap.get(groupID).memberList = _toConsumableArray(groupMemberMap.values());
        }
      }
      /**
       * 修改群成员资料接口
       * 内部使用，有几个接口是基于该接口实现的。
       * @private
       * @param {Object} options
       */

    }, {
      key: "_modifyGroupMemberInfo",
      value: function _modifyGroupMemberInfo(options) {
        var pack = this.createPackage({
          name: 'group',
          action: 'modifyGroupMemberInfo',
          param: options
        });
        return this.tim.connectionController.request(pack);
      }
      /**
       * 去除本地 groupMap 中比远端多出的group
       * 不直接清空群组列表是因为群组中维护了 lastMessage 字段，拉取远端群组列表后是没有该字段的，直接清空会导致该字段丢失
       * @param {Object[]} nextGroups
       */

    }, {
      key: "_groupListTreeShaking",
      value: function _groupListTreeShaking(nextGroups) {
        var tempGroupList = new Map(_toConsumableArray(this.groupMap));

        for (var i = 0, len = nextGroups.length; i < len; i++) {
          tempGroupList["delete"](nextGroups[i].groupID);
        } // 后端返回的群组列表不包括 已加入（正在轮询的）的AVChatRoom，故需忽略


        if (this.AVChatRoomHandler.isJoined) {
          tempGroupList["delete"](this.AVChatRoomHandler.group.groupID);
        }

        var groupsToDelete = _toConsumableArray(tempGroupList.keys());

        for (var _i = 0, _len = groupsToDelete.length; _i < _len; _i++) {
          this.groupMap["delete"](groupsToDelete[_i]);
        }
      }
      /**
       * 资料变更时更新群组中群成员的nick & avatar
       * 包括自己资料变更和好友资料变更
       */

    }, {
      key: "_handleProfileUpdated",
      value: function _handleProfileUpdated(_ref20) {
        var _this24 = this;

        var profiles = _ref20.data;

        var _loop = function _loop(i) {
          var profile = profiles[i];

          _this24.groupMemberListMap.forEach(function (groupMemberMap) {
            if (groupMemberMap.has(profile.userID)) {
              groupMemberMap.get(profile.userID).updateMember({
                nick: profile.nick,
                avatar: profile.avatar
              });
            }
          });
        };

        for (var i = 0; i < profiles.length; i++) {
          _loop(i);
        }
      }
    }, {
      key: "reset",
      value: function reset() {
        this.groupMap.clear();
        this.groupMemberListMap.clear();
        this.hasLocalGroupList = false;
        this.resetReady();
        this.tim.innerEmitter.once(TIM_INNER_EVENT.CONTEXT_A2KEY_AND_TINYID_UPDATED, this._initGroupList, this);
      }
    }]);

    return GroupController;
  }(IMController);

  /**
   * 输入一组 任意类型的参数，转化成 由 0 和 1，或其它整型数值拼接的字符串，用于扁平化条件嵌套
   * @param any
   * @example
   * // 对象、数据或其它非整数类型
   * let a = {test: 'test'};
   * let b = [1,2,3];
   * let condition = boolsToStr(a, b);
   * console.log(condition); // 输出 11
   * @example
   * // 对象、数据或其它非整数类型，其中有数据为null
   * let a = {test: 'test'};
   * let b = null;
   * let condition = boolsToStr(a, b);
   * console.log(condition); // 输出 10
   * @example
   * // 有数据为整形
   * let a = {test: 'test'};
   * let b = 9;
   * let condition = boolsToStr(a, b);
   * console.log(condition); // 输出 19
   * @example
   * // 有数据为undifiend
   * let a = {test: 'test'};
   * let condition = boolsToStr(a, b);  // b 未定义
   * console.log(condition); // 输出 10
   * // 需要分隔符
   * let a = {test: 'test'};
   * let b = null;
   * let condition = boolsToStr(a, b, ',');
   * console.log(condition); // 输出 1,1
   * @example
   * // 获取函数帮助信息
   * boolsToStr('--help'); // 输出帮助信息
   */
  var boolsToStr = function boolsToStr() {
    var tmp = [];
    var separate = getSeparator(arguments);

    for (var i = 0; i < arguments.length; i++) {
      // 如果是整数型，直接 push 到 tmp 中
      if (Number.isInteger(arguments[i])) {
        tmp.push(arguments[i]);
        continue;
      }

      tmp.push(!!arguments[i] === true ? '1' : '0'); // 如果是非 boolean 数据，使用 !! 运算做转换
    }

    return tmp.join(separate);
  };
  /**
   * 用于获取分隔符
   * @param {*} datas
   * @returns {String}
   */


  var getSeparator = function getSeparator(datas) {
    var len = datas.length;
    var data = datas[len - 1]; // 如果不是字符串，不会当做分隔符处理

    if (typeof data != 'string') {
      return '';
    } // 如果字符串的长度大于1，则不会当做分隔符处理


    if (data.length > 1) {
      return '';
    }

    var sp = datas[len - 1];
    delete datas[len - 1];
    datas.length -= len == datas.length ? 1 : 0;
    return sp; // 直接弹出最后一个分隔符
  };

  /**
   * SDK运行状态
   */

  var StatusController =
  /*#__PURE__*/
  function (_IMController) {
    _inherits(StatusController, _IMController);

    /**
     * 构造函数 
     * @param {SDK} tim 
     */
    function StatusController(tim) {
      var _this;

      _classCallCheck(this, StatusController);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(StatusController).call(this, tim));

      _this._initializeMembers();

      _this._initializeStatus();

      _this._initializeListener();

      return _this;
    }
    /**
     * 初始化成员变量
     */


    _createClass(StatusController, [{
      key: "_initializeMembers",
      value: function _initializeMembers() {
        this.normalTimeout = 300; // 在此时间内的返回，都会当成正常、良好的请求，待商榷，毫秒

        this.realtimeNoticeTimeout = 110000; // 实时消息超时时间，毫秒，服务端为2分钟，为了保险起见，这里配置为1分50秒

        this.channelMaxTimeout = 300000; // longpollingID 超时时间，毫秒，服务端配置为5分钟

        this._memoryUsed = 0; // 内存占用比率，小于1的纯小数

        this._memoryUsedThreshold = 0.9; // 警告阀值，90%

        this._onMemoryWarning = null;
      }
      /**
       * 初始化成员变量，主要是状态数组
       * @private
       */

    }, {
      key: "_initializeStatus",
      value: function _initializeStatus() {
        // 初始化账号状态
        this._initializeAccountStatus(); // 初始化消息通道状态


        this._initializeChannelStatus();
      }
      /**
       * 初始化账号状态
       */

    }, {
      key: "_initializeAccountStatus",
      value: function _initializeAccountStatus() {
        this.accountStatus = {
          lastSignInTime: 0,
          // 账号上一次在线的时间，浏览器端时间，毫秒
          status: TIM_STATUS.ACCOUNT_STATUS.SIGN_OUT // 初始化当前状态为未登录

        };
      }
      /**
       * 初始化消息通道状态
       */

    }, {
      key: "_initializeChannelStatus",
      value: function _initializeChannelStatus() {
        this.channelStatus = {
          startTime: 0,
          // 开始请求的时间
          offlineTime: 0,
          // 浏览器离线时间，不一定能拿到，比如直接合上笔记本，就无法拿到 offlineTime
          failCount: 0,
          // 请求失败计数
          lastRequestTime: 0,
          // 消息通道上一次请求成功的时间，浏览器端时间，毫秒
          lastJitterTime: 0,
          // 上一次出现波动的时间
          jitterCount: 0,
          // 出现波动的总数
          jitters: [],
          // 波动时间点记录
          status: TIM_STATUS.CHANNEL_STATUS.OFFLINE // 初始化当前状态为离线

        };
      }
      /**
       * 运行内存低容量告警
       * @param {number} level 
       * @private
       */

    }, {
      key: "_onMemoryRunningLow",
      value: function _onMemoryRunningLow(level) {
        logger.warn('memory running low : ', level);
      }
      /**
       * 获取通道当前的运行状态
       */

    }, {
      key: "getChannelStatus",
      value: function getChannelStatus() {
        // logger.log('this.channelStatus.status:', this.channelStatus.status, this.channelStatus.failCount);
        return this.channelStatus.status;
      }
      /**
       * 更新channelStatus
       * @param {Number} value 
       */

    }, {
      key: "_channelStatusJittersUpdate",
      value: function _channelStatusJittersUpdate(value) {
        var jittersLengthLimit = 5;
        this.channelStatus.jitterCount++;
        this.channelStatus.lastJitterTime = value;
        this.channelStatus.jitters.push(value);

        if (this.channelStatus.jitters.length > jittersLengthLimit) {
          this.channelStatus.jitters.pop();
        }
      }
    }, {
      key: "_initializeListener",
      value: function _initializeListener() {
        var innerEmitter = this.tim.innerEmitter;
        innerEmitter.on(TIM_INNER_EVENT.NOTICE_LONGPOLL_START, this._onChannelStart, this);
        innerEmitter.on(TIM_INNER_EVENT.NOTICE_LONGPOLL_REQUEST_ARRIVED, this._onChannelRequestSuccess, this);
        innerEmitter.on(TIM_INNER_EVENT.NOTICE_LONGPOLL_REQUEST_NOT_ARRIVED, this._onChannelFail, this); // 
      }
      /**
       * 当通道开始运作时
       */

    }, {
      key: "_onChannelStart",
      value: function _onChannelStart() {
        this.channelStatus.startTime = +new Date();
        this.channelStatus.status = TIM_STATUS.CHANNEL_STATUS.ONLINE;
      } // 获取内存占用

    }, {
      key: "_getMemoryUsed",
      value: function _getMemoryUsed() {
        var string = 'disabled';
        var memoryUsed = 0;

        if (typeof window != 'undefined' && typeof window.performance != 'undefined') {
          memoryUsed = window.performance.memory.usedJSHeapSize / window.performance.memory.jsHeapSizeLimit;
          this._memoryUsed = memoryUsed;
          string = [Math.round(this._memoryUsed * 100000) / 1000, '%'].join('');
        }

        return string;
      }
      /**
       * 当通道请求成功时
       * @fires TIM_INNER_EVENT.NOTICE_LONGPOLL_FLUCTUATION:  出现网络抖动
       */

    }, {
      key: "_onChannelRequestSuccess",
      value: function _onChannelRequestSuccess() {
        var _this$tim = this.tim,
            innerEmitter = _this$tim.innerEmitter,
            outerEmitter = _this$tim.outerEmitter;
        var newTime = Date.now();
        var lastTime = this.channelStatus.lastRequestTime > 0 ? this.channelStatus.lastRequestTime : Date.now() + 100;
        var intervalTime = newTime - lastTime; // channel 两次成功请求成功的时间间隔

        var condition = boolsToStr(intervalTime < this.realtimeNoticeTimeout, intervalTime < this.channelMaxTimeout); // logger.log('memory used: ', this._getMemoryUsed());

        this.channelStatus.status = TIM_STATUS.CHANNEL_STATUS.ONLINE;
        this.channelStatus.failCount = 0;

        switch (condition) {
          // intervalTime : < realtimeNoticeTimeout, <channelMaxTimeout；表示网络抖动，或掉线时间在 realtimeNoticeTimeout 以内
          // 注意：以 case 11 为条件，判断网络抖动的方式是不太合理的，因为在收到新消息时，channel会马上返回数据，导致 intervalTime 远小于 realtimeNoticeTimeout，而没送到新消息时，channel 会在2.5秒左右超时返回。反而会记入抖动。
          case '11':
            break;
          // intervalTime: >= realtimeNoticeTimeout, < channelMaxTimeout； 表示掉线时间在2分钟(realtimeNoticeTimeout)和5分钟(channelMaxTimeout)之间；

          case '01':
            innerEmitter.emit(TIM_INNER_EVENT.NOTICE_LONGPOLL_SOON_RECONNECT); // 重连了

            outerEmitter.emit(TIM_OUTER_EVENT.NOTICE_LONGPOLL_RECONNECT); // 重连了

            break;
          // 表示 intervalTime 大于或等于 channelMaxTimeout；此时 longpollingID 已经失效了

          case '00':
            innerEmitter.emit(TIM_INNER_EVENT.NOTICE_LONGPOLL_LONG_RECONNECT); // 掉线时间大于 channelMaxTimeout，longpollingID 失效了

            break;
        }

        this.channelStatus.lastRequestTime = newTime; // 记录下这一次请求到达的时间
      }
      /**
       * 当检测到消息通道离线时间，此方法不一定会触发，比如用户直接关闭了笔记本，或直接退出小程序。
       * @param {error} error
       */

    }, {
      key: "_onChannelFail",
      value: function _onChannelFail(error) {
        var innerEmitter = this.tim.innerEmitter;
        var thisTime = Date.now();
        this.channelStatus.status = TIM_STATUS.CHANNEL_STATUS.OFFLINE; // 如果是第一次通道失败，则取lastRequestTime，否则可以直接取 offlineTime

        var oldTime = this.channelStatus.offlineTime === 0 ? this.channelStatus.lastRequestTime : this.channelStatus.offlineTime;
        var diffience = thisTime - oldTime;
        this.channelStatus.offlineTime = thisTime;
        this.channelStatus.failCount++;
        logger.log("_onChannelFail count : ".concat(this.channelStatus.failCount, "  time diff: ").concat(diffience, ";"));

        if (this.channelStatus.failCount > 5 && diffience < 5000) {
          innerEmitter.emit(TIM_INNER_EVENT.NOTICE_LONGPOLL_DISCONNECT);
          logger.error('Detected notice channel offline, please check your network!');
        }
      }
    }]);

    return StatusController;
  }(IMController);

  function emptyFunction() {
    return null;
  }
  /**
   * Storage类，兼容Web端和WX小程序端
   * 使用方法：该实例挂载在tim实例下，可以通过this.tim.storage.getItem(key)调用。
   * @class Storage
   * @author rychouwei
   */


  var Storage =
  /*#__PURE__*/
  function () {
    function Storage(tim) {
      _classCallCheck(this, Storage);

      this.tim = tim;
      this.isWX = IN_WX_MINI_APP;
      this.storageQueue = new Map(); // 存储队列，结构为Map<string, *>

      this.checkTimes = 0;
      this.checkTimer = setInterval(this._onCheckTimer.bind(this), 1000);
      this._prefix = ''; //用于区分不同用户

      this._initListeners();

      this._errorTolerantHandle();
    }
    /**
     * 容错处理
     * 不支持localstorage的浏览器则用空函数替代
     * @memberof Storage
     */


    _createClass(Storage, [{
      key: "_errorTolerantHandle",
      value: function _errorTolerantHandle() {
        if (!this.isWX && isUndefined(window.localStorage)) {
          this.getItem = emptyFunction;
          this.setItem = emptyFunction;
          this.removeItem = emptyFunction;
          this.clear = emptyFunction;
        }
      }
    }, {
      key: "_onCheckTimer",
      value: function _onCheckTimer() {
        this.checkTimes++; // 每20s检查一次

        if (this.checkTimes % 20 == 0) {
          if (this.storageQueue.size == 0) {
            return;
          }

          this._doFlush();
        }
      } // 将存储队列的消息写入本地缓存，并清空存储队列

    }, {
      key: "_doFlush",
      value: function _doFlush() {
        try {
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            for (var _iterator = this.storageQueue[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var _step$value = _slicedToArray(_step.value, 2),
                  key = _step$value[0],
                  value = _step$value[1];

              if (this.isWX) {
                wx.setStorageSync(this._getKey(key), value);
              } else {
                localStorage.setItem(this._getKey(key), JSON.stringify(value));
              }
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                _iterator["return"]();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }

          this.storageQueue.clear();
        } catch (error) {
          logger.error('Storage._doFlush error', error);
        }
      }
    }, {
      key: "_initListeners",
      value: function _initListeners() {
        this.tim.innerEmitter.once(TIM_INNER_EVENT.CONTEXT_A2KEY_AND_TINYID_UPDATED, this._updatePrefix, this);
      }
    }, {
      key: "_updatePrefix",
      value: function _updatePrefix() {
        var _this$tim$loginInfo = this.tim.loginInfo,
            SDKAppID = _this$tim$loginInfo.SDKAppID,
            identifier = _this$tim$loginInfo.identifier;
        this._prefix = "TIM_".concat(SDKAppID, "_").concat(identifier, "_");
      }
      /**
       * 获取storage中的一条数据
       * @param {String} key
       * @returns 返回指定key的数据
       * @memberof StorageController
       */

    }, {
      key: "getItem",
      value: function getItem(key) {
        try {
          if (this.isWX) {
            return wx.getStorageSync(this._getKey(key));
          }

          return JSON.parse(localStorage.getItem(this._getKey(key)));
        } catch (error) {
          logger.error('Storage.getItem error:', error);
        }
      }
      /**
       * 设置storage中的一条数据。若key已存在，则会覆盖已有数据。
       * @param {String} key
       * @param {*} value - 任何可JSON序列化的数据
       * @memberof StorageController
       */

    }, {
      key: "setItem",
      value: function setItem(key, value) {
        this.storageQueue.set(key, value);
      }
      /**
       * 清除缓存数据
       * @memberof StorageController
       */

    }, {
      key: "clear",
      value: function clear() {
        try {
          if (this.isWX) {
            wx.clearStorageSync();
          } else {
            localStorage.clear();
          }
        } catch (error) {
          logger.error('Storage.clear error:', error);
        }
      }
      /**
       * 删除指定key的数据
       * @param {String} key
       * @memberof StorageController
       */

    }, {
      key: "removeItem",
      value: function removeItem(key) {
        try {
          if (this.isWX) {
            wx.removeStorageSync(this._getKey(key));
          } else {
            localStorage.removeItem(this._getKey(key));
          }
        } catch (error) {
          logger.error('Storage.removeItem error:', error);
        }
      }
      /**
       * 获取本地已用缓存大小。计算规则：key的占用加上value的占用
       * @param {String} [key] - 需要查询哪个key空间占用，不传则不区分key
       * @param {String} [unit] - 单位，默认为b，可选值有：b,kb,mb
       * @returns {Object} 返回查询结果对象
       * @memberof Storage
       * @example
       * const result = app.storage.getSize('conversationList')
       *
       * //返回
       * result:{ // 默认单位都是Byte
       *  size: 100, // 空间占用
       *  limitSize: 5242880, // 最大缓存空间大小
       *  leftSize: 5242780 // 剩余可用大小
       * }
       */

    }, {
      key: "getSize",
      value: function getSize(key) {
        var _this = this;

        var unit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'b';

        try {
          var result = {
            size: 0,
            limitSize: 5 * 1024 * 1024,
            unit: unit
          };
          Object.defineProperty(result, 'leftSize', {
            enumerable: true,
            get: function get() {
              return result.limitSize - result.size;
            }
          }); // 小程序环境则设置limitSize

          if (this.isWX) {
            result.limitSize = wx.getStorageInfoSync().limitSize * 1024;
          } // 单独计算某个key的占用


          if (key) {
            result.size = JSON.stringify(this.getItem(key)).length + this._getKey(key).length;
          } else {
            //计算全部占用
            if (this.isWX) {
              //计算微信小程序环境的全部占用
              var _wx$getStorageInfoSyn = wx.getStorageInfoSync(),
                  keys = _wx$getStorageInfoSyn.keys;

              keys.forEach(function (_key) {
                result.size += JSON.stringify(wx.getStorageSync(_key)).length + _this._getKey(_key).length;
              });
            } else {
              // 计算Web环境全部占用
              for (var item in localStorage) {
                if (localStorage.hasOwnProperty(item)) {
                  result.size += localStorage.getItem(item).length + item.length;
                }
              }
            }
          }

          return this._convertUnit(result);
        } catch (error) {
          logger.error('Storage.getSize error:', error);
        }
      }
      /**
       * 单位转换器
       * @private
       * @param {Object} object
       * @param {String} unit - b/kb/mb
       * @returns {Object} 转换后的对象
       * @memberof Storage
       *
       */

    }, {
      key: "_convertUnit",
      value: function _convertUnit(object) {
        var result = {};
        var unit = object.unit;
        result['unit'] = unit;

        for (var key in object) {
          if (typeof object[key] !== 'number') continue;

          if (unit.toLowerCase() === 'kb') {
            result[key] = Math.round(object[key] / 1024);
          } else if (unit.toLowerCase() === 'mb') {
            result[key] = Math.round(object[key] / 1024 / 1024);
          } else {
            result[key] = object[key];
          }
        }

        return result;
      }
      /**
       * 拼接key
       * @private
       * @param {String} key
       * @returns {String}
       * @memberof Storage
       */

    }, {
      key: "_getKey",
      value: function _getKey(key) {
        return "".concat(this._prefix).concat(key);
      }
    }, {
      key: "reset",
      value: function reset() {
        this._doFlush();

        this.checkTimes = 0;
        this._prefix = '';
        this.tim.innerEmitter.once(TIM_INNER_EVENT.CONTEXT_A2KEY_AND_TINYID_UPDATED, this._updatePrefix, this);
      }
    }]);

    return Storage;
  }();

  var eventemitter3 = createCommonjsModule(function (module) {

  var has = Object.prototype.hasOwnProperty
    , prefix = '~';

  /**
   * Constructor to create a storage for our `EE` objects.
   * An `Events` instance is a plain object whose properties are event names.
   *
   * @constructor
   * @private
   */
  function Events() {}

  //
  // We try to not inherit from `Object.prototype`. In some engines creating an
  // instance in this way is faster than calling `Object.create(null)` directly.
  // If `Object.create(null)` is not supported we prefix the event names with a
  // character to make sure that the built-in object properties are not
  // overridden or used as an attack vector.
  //
  if (Object.create) {
    Events.prototype = Object.create(null);

    //
    // This hack is needed because the `__proto__` property is still inherited in
    // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.
    //
    if (!new Events().__proto__) prefix = false;
  }

  /**
   * Representation of a single event listener.
   *
   * @param {Function} fn The listener function.
   * @param {*} context The context to invoke the listener with.
   * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
   * @constructor
   * @private
   */
  function EE(fn, context, once) {
    this.fn = fn;
    this.context = context;
    this.once = once || false;
  }

  /**
   * Add a listener for a given event.
   *
   * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
   * @param {(String|Symbol)} event The event name.
   * @param {Function} fn The listener function.
   * @param {*} context The context to invoke the listener with.
   * @param {Boolean} once Specify if the listener is a one-time listener.
   * @returns {EventEmitter}
   * @private
   */
  function addListener(emitter, event, fn, context, once) {
    if (typeof fn !== 'function') {
      throw new TypeError('The listener must be a function');
    }

    var listener = new EE(fn, context || emitter, once)
      , evt = prefix ? prefix + event : event;

    if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
    else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
    else emitter._events[evt] = [emitter._events[evt], listener];

    return emitter;
  }

  /**
   * Clear event by name.
   *
   * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
   * @param {(String|Symbol)} evt The Event name.
   * @private
   */
  function clearEvent(emitter, evt) {
    if (--emitter._eventsCount === 0) emitter._events = new Events();
    else delete emitter._events[evt];
  }

  /**
   * Minimal `EventEmitter` interface that is molded against the Node.js
   * `EventEmitter` interface.
   *
   * @constructor
   * @public
   */
  function EventEmitter() {
    this._events = new Events();
    this._eventsCount = 0;
  }

  /**
   * Return an array listing the events for which the emitter has registered
   * listeners.
   *
   * @returns {Array}
   * @public
   */
  EventEmitter.prototype.eventNames = function eventNames() {
    var names = []
      , events
      , name;

    if (this._eventsCount === 0) return names;

    for (name in (events = this._events)) {
      if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
    }

    if (Object.getOwnPropertySymbols) {
      return names.concat(Object.getOwnPropertySymbols(events));
    }

    return names;
  };

  /**
   * Return the listeners registered for a given event.
   *
   * @param {(String|Symbol)} event The event name.
   * @returns {Array} The registered listeners.
   * @public
   */
  EventEmitter.prototype.listeners = function listeners(event) {
    var evt = prefix ? prefix + event : event
      , handlers = this._events[evt];

    if (!handlers) return [];
    if (handlers.fn) return [handlers.fn];

    for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
      ee[i] = handlers[i].fn;
    }

    return ee;
  };

  /**
   * Return the number of listeners listening to a given event.
   *
   * @param {(String|Symbol)} event The event name.
   * @returns {Number} The number of listeners.
   * @public
   */
  EventEmitter.prototype.listenerCount = function listenerCount(event) {
    var evt = prefix ? prefix + event : event
      , listeners = this._events[evt];

    if (!listeners) return 0;
    if (listeners.fn) return 1;
    return listeners.length;
  };

  /**
   * Calls each of the listeners registered for a given event.
   *
   * @param {(String|Symbol)} event The event name.
   * @returns {Boolean} `true` if the event had listeners, else `false`.
   * @public
   */
  EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
    var evt = prefix ? prefix + event : event;

    if (!this._events[evt]) return false;

    var listeners = this._events[evt]
      , len = arguments.length
      , args
      , i;

    if (listeners.fn) {
      if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);

      switch (len) {
        case 1: return listeners.fn.call(listeners.context), true;
        case 2: return listeners.fn.call(listeners.context, a1), true;
        case 3: return listeners.fn.call(listeners.context, a1, a2), true;
        case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
        case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
        case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
      }

      for (i = 1, args = new Array(len -1); i < len; i++) {
        args[i - 1] = arguments[i];
      }

      listeners.fn.apply(listeners.context, args);
    } else {
      var length = listeners.length
        , j;

      for (i = 0; i < length; i++) {
        if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);

        switch (len) {
          case 1: listeners[i].fn.call(listeners[i].context); break;
          case 2: listeners[i].fn.call(listeners[i].context, a1); break;
          case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;
          case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;
          default:
            if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {
              args[j - 1] = arguments[j];
            }

            listeners[i].fn.apply(listeners[i].context, args);
        }
      }
    }

    return true;
  };

  /**
   * Add a listener for a given event.
   *
   * @param {(String|Symbol)} event The event name.
   * @param {Function} fn The listener function.
   * @param {*} [context=this] The context to invoke the listener with.
   * @returns {EventEmitter} `this`.
   * @public
   */
  EventEmitter.prototype.on = function on(event, fn, context) {
    return addListener(this, event, fn, context, false);
  };

  /**
   * Add a one-time listener for a given event.
   *
   * @param {(String|Symbol)} event The event name.
   * @param {Function} fn The listener function.
   * @param {*} [context=this] The context to invoke the listener with.
   * @returns {EventEmitter} `this`.
   * @public
   */
  EventEmitter.prototype.once = function once(event, fn, context) {
    return addListener(this, event, fn, context, true);
  };

  /**
   * Remove the listeners of a given event.
   *
   * @param {(String|Symbol)} event The event name.
   * @param {Function} fn Only remove the listeners that match this function.
   * @param {*} context Only remove the listeners that have this context.
   * @param {Boolean} once Only remove one-time listeners.
   * @returns {EventEmitter} `this`.
   * @public
   */
  EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
    var evt = prefix ? prefix + event : event;

    if (!this._events[evt]) return this;
    if (!fn) {
      clearEvent(this, evt);
      return this;
    }

    var listeners = this._events[evt];

    if (listeners.fn) {
      if (
        listeners.fn === fn &&
        (!once || listeners.once) &&
        (!context || listeners.context === context)
      ) {
        clearEvent(this, evt);
      }
    } else {
      for (var i = 0, events = [], length = listeners.length; i < length; i++) {
        if (
          listeners[i].fn !== fn ||
          (once && !listeners[i].once) ||
          (context && listeners[i].context !== context)
        ) {
          events.push(listeners[i]);
        }
      }

      //
      // Reset the array, or remove it completely if we have no more listeners.
      //
      if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
      else clearEvent(this, evt);
    }

    return this;
  };

  /**
   * Remove all listeners, or those of the specified event.
   *
   * @param {(String|Symbol)} [event] The event name.
   * @returns {EventEmitter} `this`.
   * @public
   */
  EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
    var evt;

    if (event) {
      evt = prefix ? prefix + event : event;
      if (this._events[evt]) clearEvent(this, evt);
    } else {
      this._events = new Events();
      this._eventsCount = 0;
    }

    return this;
  };

  //
  // Alias methods names because people roll like that.
  //
  EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
  EventEmitter.prototype.addListener = EventEmitter.prototype.on;

  //
  // Expose the prefix.
  //
  EventEmitter.prefixed = prefix;

  //
  // Allow `EventEmitter` to be imported as module namespace.
  //
  EventEmitter.EventEmitter = EventEmitter;

  //
  // Expose the module.
  //
  {
    module.exports = EventEmitter;
  }
  });

  var accessLayer = function accessLayer(tim) {
    return {
      create: null,
      query: {
        serverName: SERVER.NAME.WEB_IM,
        cmd: SERVER.CMD.ACCESS_LAYER,
        channel: SERVER.CHANNEL.XHR,
        protocol: PROTOCOL_TYPE.JSON,
        method: 'POST',
        queryString: {
          platform: SDK.PLATFORM,
          identifier: tim.loginInfo.identifier,
          usersig: tim.loginInfo.userSig,
          contentType: tim.loginInfo.contentType,
          apn: tim.context != null ? tim.context.apn : 1,
          websdkappid: SDK.APPID,
          v: SDK.VERSION
        },
        requestData: {}
      },
      update: null,
      "delete": null
    };
  };

  var login = function login(tim) {
    var keyMaps = {
      request: {
        tinyID: 'tinyId'
      },
      response: {
        TinyId: 'tinyID'
      }
    };
    return {
      create: null,
      query: {
        serverName: SERVER.NAME.OPEN_IM,
        cmd: SERVER.CMD.LOGIN,
        channel: SERVER.CHANNEL.XHR,
        protocol: PROTOCOL_TYPE.JSON,
        method: 'POST',
        queryString: {
          websdkappid: SDK.APPID,
          v: SDK.VERSION,
          platform: SDK.PLATFORM,
          identifier: tim.loginInfo.identifier,
          usersig: tim.loginInfo.userSig,
          sdkappid: tim.loginInfo.SDKAppID,
          accounttype: tim.loginInfo.accountType,
          contentType: tim.context != null ? tim.context.contentType : 0,
          apn: tim.context != null ? tim.context.apn : 1,
          reqtime: +new Date() / 1000
        },
        requestData: {
          state: 'Online'
        },
        keyMaps: keyMaps
      },
      update: null,
      "delete": null
    };
  };

  var logout = function logout(tim) {
    return {
      create: null,
      query: {
        serverName: SERVER.NAME.OPEN_IM,
        cmd: SERVER.CMD.LOGOUT_ALL,
        channel: SERVER.CHANNEL.XHR,
        protocol: PROTOCOL_TYPE.JSON,
        method: 'POST',
        queryString: {
          websdkappid: SDK.APPID,
          v: SDK.VERSION,
          platform: SDK.PLATFORM,
          a2: tim.context != null ? tim.context.a2Key : '',
          tinyid: tim.context != null ? tim.context.tinyID : '',
          sdkappid: tim.loginInfo != null ? tim.loginInfo.SDKAppID : 0,
          contentType: tim.context != null ? tim.context.contentType : 0,
          apn: tim.context != null ? tim.context.apn : '',
          reqtime: +new Date() / 1000
        },
        requestData: {}
      },
      update: null,
      "delete": null
    };
  };

  var longPollLogout = function longPollLogout(tim) {
    var keyMaps = {
      request: {
        longPollID: 'LongPollingId'
      }
    };
    return {
      create: null,
      query: {
        serverName: SERVER.NAME.OPEN_IM,
        cmd: SERVER.CMD.LOGOUT_LONG_POLL,
        channel: SERVER.CHANNEL.XHR,
        protocol: PROTOCOL_TYPE.JSON,
        method: 'POST',
        queryString: {
          websdkappid: SDK.APPID,
          v: SDK.VERSION,
          platform: SDK.PLATFORM,
          a2: tim.context != null ? tim.context.a2Key : '',
          tinyid: tim.context != null ? tim.context.tinyID : 0,
          sdkappid: tim.context != null ? tim.context.SDKAppID : 0,
          contentType: tim.context != null ? tim.context.contentType : 0,
          apn: tim.context != null ? tim.context.apn : 1,
          reqtime: function reqtime() {
            return Date.now();
          }
        },
        requestData: {
          longPollID: ''
        },
        keyMaps: keyMaps
      },
      update: null,
      "delete": null
    };
  };

  var commonQueryString = function commonQueryString(tim) {
    var a2, tinyid, sdkappid, contentType, apn;

    if (!isEmpty(tim.context)) {
      a2 = tim.context.a2Key;
      tinyid = tim.context.tinyID;
      sdkappid = tim.context.SDKAppID;
      contentType = tim.context.contentType;
      apn = tim.context.apn;
    } else {
      a2 = '';
      tinyid = 0;
      sdkappid = 0;
      contentType = 0;
      apn = 1;
    }

    return {
      platform: SDK.PLATFORM,
      websdkappid: SDK.APPID,
      v: SDK.VERSION,
      a2: a2,
      tinyid: tinyid,
      sdkappid: sdkappid,
      contentType: contentType,
      apn: apn,
      reqtime: function reqtime() {
        return +new Date();
      }
    };
  };

  var conf = function conf(tim) {
    var queryString = commonQueryString(tim);
    var serverName = SERVER.NAME.PROFILE;
    var channel = SERVER.CHANNEL.XHR;
    var protocol = PROTOCOL_TYPE.JSON;
    var requestMethod = 'POST';
    var tagArray = []; // contains all tags

    for (var tag in STANDARD_IM_PROFILE) {
      tagArray.push(STANDARD_IM_PROFILE[tag]);
    }

    return {
      query: {
        serverName: serverName,
        cmd: SERVER.CMD.PORTRAIT_GET,
        channel: channel,
        protocol: protocol,
        method: requestMethod,
        queryString: queryString,
        requestData: {
          fromAccount: '',
          toAccount: [],
          tagList: tagArray // 默认查询全部profile
          // tagList: [STANDARD_IM_PROFILE.NICK, STANDARD_IM_PROFILE.GENDER, STANDARD_IM_PROFILE.ALLOWTYPE, STANDARD_IM_PROFILE.AVATAR]

        }
      },
      update: {
        serverName: serverName,
        cmd: SERVER.CMD.PORTRAIT_SET,
        channel: channel,
        protocol: protocol,
        method: requestMethod,
        queryString: queryString,
        requestData: {
          fromAccount: '',
          profileItem: [{
            tag: STANDARD_IM_PROFILE.NICK,
            value: ''
          }, // - 昵称
          {
            tag: STANDARD_IM_PROFILE.GENDER,
            value: ''
          }, // - 性别
          {
            tag: STANDARD_IM_PROFILE.ALLOWTYPE,
            value: ''
          }, // - 允许加好友的类型
          {
            tag: STANDARD_IM_PROFILE.AVATAR,
            value: '' // - 头像地址

          }]
        }
      }
    };
  };

  var conf$1 = function conf(tim) {
    var queryString = {
      websdkappid: SDK.APPID,
      v: SDK.VERSION,
      platform: SDK.PLATFORM,
      a2: tim.context != null && tim.context.a2Key ? tim.context.a2Key : undefined,
      tinyid: tim.context != null && tim.context.tinyID ? tim.context.tinyID : undefined,
      sdkappid: tim.context != null ? tim.context.SDKAppID : 0,
      contentType: tim.context != null ? tim.context.contentType : 0,
      accounttype: tim.context != null ? tim.context.accountType : 0
    };
    var keyMaps = {
      request: {
        ownerID: 'Owner_Account',
        userID: 'Member_Account',
        newOwnerID: 'NewOwner_Account',
        maxMemberNum: 'MaxMemberCount',
        groupCustomField: 'AppDefinedData',
        memberCustomField: 'AppMemberDefinedData',
        groupCustomFieldFilter: 'AppDefinedDataFilter_Group',
        memberCustomFieldFilter: 'AppDefinedDataFilter_GroupMember',
        messageRemindType: 'MsgFlag',
        userIDList: 'MemberList',
        groupIDList: 'GroupIdList',
        applyMessage: 'ApplyMsg',
        muteTime: 'ShutUpTime',
        joinOption: 'ApplyJoinOption'
      },
      response: {
        GroupIdList: 'groups',
        MsgFlag: 'messageRemindType',
        AppDefinedData: 'groupCustomField',
        AppMemberDefinedData: 'memberCustomField',
        AppDefinedDataFilter_Group: 'groupCustomFieldFilter',
        AppDefinedDataFilter_GroupMember: 'memberCustomFieldFilter',
        InfoSeq: 'infoSequence',
        MemberList: 'members',
        GroupInfo: 'groups',
        ShutUpUntil: 'muteUntil',
        ApplyJoinOption: 'joinOption'
      }
    };
    return {
      create: {
        serverName: SERVER.NAME.GROUP,
        cmd: SERVER.CMD.CREATE_GROUP,
        channel: SERVER.CHANNEL.XHR,
        protocol: PROTOCOL_TYPE.JSON,
        queryString: queryString,
        requestData: {
          type: GROUP_TYPES.PRIVATE,
          name: undefined,
          groupID: undefined,
          ownerID: tim.loginInfo.identifier,
          introduction: undefined,
          notification: undefined,
          avatar: undefined,
          maxMemberNum: undefined,
          joinOption: undefined,
          memberList: undefined,
          groupCustomField: undefined
        },
        keyMaps: keyMaps
      },
      list: {
        serverName: SERVER.NAME.GROUP,
        cmd: SERVER.CMD.GET_JOINED_GROUPS,
        channel: SERVER.CHANNEL.XHR,
        protocol: PROTOCOL_TYPE.JSON,
        queryString: queryString,
        requestData: {
          userID: tim.loginInfo.identifier,
          limit: undefined,
          // 拉取多少个，不填表示拉取全部
          offset: undefined,
          // 从第多少个开始拉取
          groupType: undefined,
          // 拉取哪种群组形态，不填为拉取所有
          responseFilter: undefined
        },
        keyMaps: keyMaps
      },
      query: {
        serverName: SERVER.NAME.GROUP,
        cmd: SERVER.CMD.GET_GROUP_INFO,
        channel: SERVER.CHANNEL.XHR,
        protocol: PROTOCOL_TYPE.JSON,
        queryString: queryString,
        requestData: {
          groupIDList: undefined,
          responseFilter: undefined
        },
        keyMaps: keyMaps
      },
      getGroupMemberList: {
        serverName: SERVER.NAME.GROUP,
        cmd: SERVER.CMD.GET_GROUP_MEMBER_INFO,
        channel: SERVER.CHANNEL.XHR,
        protocol: PROTOCOL_TYPE.JSON,
        queryString: queryString,
        requestData: {
          groupID: undefined,
          limit: 0,
          offset: 0,
          memberRoleFilter: undefined,
          memberInfoFilter: undefined
        },
        keyMaps: keyMaps
      },
      quitGroup: {
        serverName: SERVER.NAME.GROUP,
        cmd: SERVER.CMD.QUIT_GROUP,
        channel: SERVER.CHANNEL.XHR,
        protocol: PROTOCOL_TYPE.JSON,
        queryString: queryString,
        requestData: {
          groupID: undefined
        }
      },
      changeGroupOwner: {
        serverName: SERVER.NAME.GROUP,
        cmd: SERVER.CMD.CHANGE_GROUP_OWNER,
        channel: SERVER.CHANNEL.XHR,
        protocol: PROTOCOL_TYPE.JSON,
        queryString: queryString,
        requestData: {
          groupID: undefined,
          newOwnerID: undefined
        },
        keyMaps: keyMaps
      },
      destroyGroup: {
        serverName: SERVER.NAME.GROUP,
        cmd: SERVER.CMD.DESTROY_GROUP,
        channel: SERVER.CHANNEL.XHR,
        protocol: PROTOCOL_TYPE.JSON,
        queryString: queryString,
        requestData: {
          groupID: undefined
        }
      },
      updateGroupProfile: {
        serverName: SERVER.NAME.GROUP,
        cmd: SERVER.CMD.MODIFY_GROUP_INFO,
        channel: SERVER.CHANNEL.XHR,
        protocol: PROTOCOL_TYPE.JSON,
        queryString: queryString,
        requestData: {
          groupID: undefined,
          name: undefined,
          introduction: undefined,
          notification: undefined,
          avatar: undefined,
          maxMemberNum: undefined,
          joinOption: undefined,
          groupCustomField: undefined
        },
        keyMaps: {
          request: _objectSpread2({}, keyMaps.request, {
            groupCustomField: 'AppDefinedData'
          }),
          response: keyMaps.response
        }
      },
      modifyGroupMemberInfo: {
        serverName: SERVER.NAME.GROUP,
        cmd: SERVER.CMD.MODIFY_GROUP_MEMBER_INFO,
        channel: SERVER.CHANNEL.XHR,
        protocol: PROTOCOL_TYPE.JSON,
        queryString: queryString,
        requestData: {
          groupID: undefined,
          userID: undefined,
          messageRemindType: undefined,
          nameCard: undefined,
          role: undefined,
          memberCustomField: undefined,
          muteTime: undefined
        },
        keyMaps: keyMaps
      },
      addGroupMember: {
        serverName: SERVER.NAME.GROUP,
        cmd: SERVER.CMD.ADD_GROUP_MEMBER,
        channel: SERVER.CHANNEL.XHR,
        protocol: PROTOCOL_TYPE.JSON,
        queryString: queryString,
        requestData: {
          groupID: undefined,
          silence: undefined,
          userIDList: undefined
        },
        keyMaps: keyMaps
      },
      deleteGroupMember: {
        serverName: SERVER.NAME.GROUP,
        cmd: SERVER.CMD.DELETE_GROUP_MEMBER,
        channel: SERVER.CHANNEL.XHR,
        protocol: PROTOCOL_TYPE.JSON,
        queryString: queryString,
        requestData: {
          groupID: undefined,
          userIDList: undefined,
          reason: undefined
        },
        keyMaps: {
          request: {
            userIDList: 'MemberToDel_Account'
          }
        }
      },
      searchGroupByID: {
        serverName: SERVER.NAME.GROUP,
        cmd: SERVER.CMD.SEARCH_GROUP_BY_ID,
        channel: SERVER.CHANNEL.XHR,
        protocol: PROTOCOL_TYPE.JSON,
        queryString: queryString,
        requestData: {
          groupIDList: undefined,
          responseFilter: {
            groupBasePublicInfoFilter: ['Type', 'Name', 'Introduction', 'Notification', 'FaceUrl', 'CreateTime', 'Owner_Account', 'LastInfoTime', 'LastMsgTime', 'NextMsgSeq', 'MemberNum', 'MaxMemberNum', 'ApplyJoinOption']
          }
        },
        keyMaps: {
          request: {
            groupIDList: 'GroupIdList'
          }
        }
      },
      applyJoinGroup: {
        serverName: SERVER.NAME.GROUP,
        cmd: SERVER.CMD.APPLY_JOIN_GROUP,
        channel: SERVER.CHANNEL.XHR,
        protocol: PROTOCOL_TYPE.JSON,
        queryString: queryString,
        requestData: {
          groupID: undefined,
          applyMessage: undefined,
          userDefinedField: undefined
        },
        keyMaps: keyMaps
      },
      applyJoinAVChatRoom: {
        serverName: SERVER.NAME.BIG_GROUP_NO_AUTH,
        cmd: SERVER.CMD.APPLY_JOIN_GROUP,
        channel: SERVER.CHANNEL.XHR,
        protocol: PROTOCOL_TYPE.JSON,
        queryString: {
          websdkappid: SDK.APPID,
          v: SDK.VERSION,
          platform: SDK.PLATFORM,
          sdkappid: tim.context != null ? tim.context.SDKAppID : 0,
          contentType: tim.context != null ? tim.context.contentType : 0,
          accounttype: tim.context != null ? tim.context.accountType : 0
        },
        requestData: {
          groupID: undefined,
          applyMessage: undefined,
          userDefinedField: undefined
        },
        keyMaps: keyMaps
      },
      handleApplyJoinGroup: {
        serverName: SERVER.NAME.GROUP,
        cmd: SERVER.CMD.HANDLE_APPLY_JOIN_GROUP,
        channel: SERVER.CHANNEL.XHR,
        protocol: PROTOCOL_TYPE.JSON,
        queryString: queryString,
        requestData: {
          groupID: undefined,
          applicant: undefined,
          handleAction: undefined,
          handleMessage: undefined,
          authentication: undefined,
          messageKey: undefined,
          userDefinedField: undefined
        },
        keyMaps: {
          request: {
            applicant: 'Applicant_Account',
            handleAction: 'HandleMsg',
            handleMessage: 'ApprovalMsg',
            messageKey: 'MsgKey'
          },
          response: {
            MsgKey: 'messageKey'
          }
        }
      },
      deleteGroupSystemNotice: {
        serverName: SERVER.NAME.OPEN_IM,
        cmd: SERVER.CMD.DELETE_GROUP_SYSTEM_MESSAGE,
        channel: SERVER.CHANNEL.XHR,
        protocol: PROTOCOL_TYPE.JSON,
        queryString: queryString,
        requestData: {
          messageListToDelete: undefined
        },
        keyMaps: {
          request: {
            messageListToDelete: 'DelMsgList',
            messageSeq: 'MsgSeq',
            messageRandom: 'MsgRandom'
          }
        }
      }
    };
  };

  var conf$2 = function conf(tim) {
    return {
      create: {},
      query: {
        serverName: SERVER.NAME.OPEN_IM,
        cmd: SERVER.CMD.GET_LONG_POLL_ID,
        channel: SERVER.CHANNEL.XHR,
        protocol: PROTOCOL_TYPE.JSON,
        queryString: {
          websdkappid: SDK.APPID,
          v: SDK.VERSION,
          platform: SDK.PLATFORM,
          a2: tim.context != null ? tim.context.a2Key : '',
          tinyid: tim.context != null ? tim.context.tinyID : 0,
          sdkappid: tim.context != null ? tim.context.SDKAppID : 0,
          contentType: tim.context != null ? tim.context.contentType : 0,
          apn: tim.context != null ? tim.context.apn : 1,
          reqtime: +new Date() / 1000
        },
        requestData: {},
        keyMaps: {
          response: {
            LongPollingId: 'longPollingID'
          }
        }
      },
      update: {},
      "delete": {}
    };
  };

  var conf$3 = function conf(tim) {
    var queryString = {
      websdkappid: SDK.APPID,
      v: SDK.VERSION,
      platform: SDK.PLATFORM,
      a2: tim.context != null ? tim.context.a2Key : '',
      tinyid: tim.context != null ? tim.context.tinyID : 0,
      sdkappid: tim.context != null ? tim.context.SDKAppID : 0,
      contentType: tim.context != null ? tim.context.contentType : 0,
      accounttype: tim.context != null ? tim.loginInfo.accountType : 0,
      apn: tim.context != null ? tim.context.apn : 1,
      reqtime: Math.ceil(+new Date() / 1000)
    };
    var keyMaps = {
      response: {
        C2cMsgArray: 'C2CMessageArray',
        GroupMsgArray: 'groupMessageArray',
        GroupTips: 'groupTips',
        C2cNotifyMsgArray: 'C2CNotifyMessageArray',
        ClientSeq: 'clientSequence',
        MsgPriority: 'messagePriority',
        NoticeSeq: 'noticeSequence',
        MsgContent: 'content',
        MsgType: 'type',
        MsgBody: 'elements',
        ToGroupId: 'to',
        Desc: 'description',
        Ext: 'extension',
        MsgFrom_AccountExtraInfo: 'messageFromAccountExtraInformation'
      }
    };
    return {
      create: {},
      query: {
        serverName: SERVER.NAME.OPEN_IM,
        cmd: SERVER.CMD.LONG_POLL,
        channel: SERVER.CHANNEL.AUTO,
        // 由ConnectionController决定用什么方式进行请求
        protocol: PROTOCOL_TYPE.JSON,
        queryString: queryString,
        requestData: {
          timeout: null,
          cookie: {
            notifySeq: 0,
            noticeSeq: 0,
            longPollingID: 0
          }
        },
        keyMaps: keyMaps
      },
      update: {},
      "delete": {}
    };
  };

  var conf$4 = function conf(tim) {
    var queryString = commonQueryString(tim);
    var serverName = SERVER.NAME.FRIEND;
    var channel = SERVER.CHANNEL.XHR;
    var protocol = PROTOCOL_TYPE.JSON;
    return {
      create: {
        serverName: serverName,
        cmd: SERVER.CMD.FRIEND_ADD,
        channel: channel,
        protocol: protocol,
        queryString: queryString,
        requestData: {
          fromAccount: '',
          addFriendItem: []
        }
      },
      get: {
        serverName: serverName,
        cmd: SERVER.CMD.GET_PENDENCY,
        channel: channel,
        protocol: protocol,
        queryString: queryString,
        requestData: {
          fromAccount: '',
          pendencyType: 'Pendency_Type_ComeIn'
        }
      },
      update: {
        serverName: serverName,
        cmd: SERVER.CMD.RESPONSE_PENDENCY,
        channel: channel,
        protocol: protocol,
        queryString: queryString,
        requestData: {
          fromAccount: '',
          responseFriendItem: []
        }
      },
      "delete": {
        serverName: serverName,
        cmd: SERVER.CMD.DELETE_PENDENCY,
        channel: channel,
        protocol: protocol,
        queryString: queryString,
        requestData: {
          fromAccount: '',
          toAccount: [],
          pendencyType: 'Pendency_Type_ComeIn'
        }
      }
    };
  };

  var conf$5 = function conf(tim) {
    var queryString = commonQueryString(tim);
    var serverName = SERVER.NAME.FRIEND;
    var channel = SERVER.CHANNEL.XHR;
    var protocol = PROTOCOL_TYPE.JSON;
    var requestMethod = 'POST';
    return {
      get: {
        serverName: serverName,
        cmd: SERVER.CMD.FRIEND_GET_ALL,
        channel: channel,
        protocol: protocol,
        method: requestMethod,
        queryString: queryString,
        requestData: {
          fromAccount: '',
          timeStamp: 0,
          startIndex: 0,
          getCount: 100,
          lastStandardSequence: 0,
          tagList: ['Tag_Profile_IM_Nick', 'Tag_SNS_IM_Remark']
        },
        keyMaps: {
          request: {},
          //请求转换Map表
          response: {} //响应转换Map表

        }
      },
      "delete": {
        serverName: serverName,
        cmd: SERVER.CMD.FRIEND_DELETE,
        channel: channel,
        protocol: protocol,
        method: requestMethod,
        queryString: queryString,
        requestData: {
          fromAccount: '',
          toAccount: [],
          deleteType: 'Delete_Type_Single'
        }
      }
    };
  };

  var conf$6 = function conf(tim) {
    var queryString = commonQueryString(tim);
    return {
      create: {
        serverName: SERVER.NAME.FRIEND,
        cmd: SERVER.CMD.ADD_BLACKLIST,
        channel: SERVER.CHANNEL.XHR,
        protocol: PROTOCOL_TYPE.JSON,
        method: 'POST',
        queryString: queryString,
        requestData: {
          fromAccount: '',
          toAccount: []
        }
      },
      get: {
        serverName: SERVER.NAME.FRIEND,
        cmd: SERVER.CMD.GET_BLACKLIST,
        channel: SERVER.CHANNEL.XHR,
        protocol: PROTOCOL_TYPE.JSON,
        method: 'POST',
        queryString: queryString,
        requestData: {
          fromAccount: '',
          startIndex: 0,
          maxLimited: 30,
          lastSequence: 0
        }
      },
      "delete": {
        serverName: SERVER.NAME.FRIEND,
        cmd: SERVER.CMD.DELETE_BLACKLIST,
        channel: SERVER.CHANNEL.XHR,
        protocol: PROTOCOL_TYPE.JSON,
        method: 'POST',
        queryString: queryString,
        requestData: {
          fromAccount: '',
          toAccount: []
        }
      },
      update: {}
    };
  };

  var c2cMessage = function c2cMessage(tim) {
    var queryString = {
      platform: SDK.PLATFORM,
      websdkappid: SDK.APPID,
      v: SDK.VERSION,
      a2: tim.context !== null ? tim.context.a2Key : '',
      tinyid: tim.context !== null ? tim.context.tinyID : 0,
      sdkappid: tim.context !== null ? tim.context.SDKAppID : 0,
      contentType: tim.context !== null ? tim.context.contentType : 0,
      apn: tim.context !== null ? tim.context.apn : 1,
      reqtime: function reqtime() {
        return +new Date();
      }
    };
    var keyMaps = {
      request: {
        fromAccount: 'From_Account',
        toAccount: 'To_Account',
        msgTimeStamp: 'MsgTimeStamp',
        msgSeq: 'MsgSeq',
        msgRandom: 'MsgRandom',
        msgBody: 'MsgBody',
        count: 'MaxCnt',
        lastMessageTime: 'LastMsgTime',
        messageKey: 'MsgKey',
        peerAccount: 'Peer_Account',
        data: 'Data',
        description: 'Desc',
        extension: 'Ext',
        type: 'MsgType',
        content: 'MsgContent',
        sizeType: 'Type',
        uuid: 'UUID',
        // url: 'URL',
        imageUrl: 'URL',
        fileUrl: 'Url',
        downloadFlag: 'Download_Flag'
      },
      response: {
        MsgContent: 'content',
        MsgTime: 'time',
        Data: 'data',
        Desc: 'description',
        Ext: 'extension',
        MsgKey: 'messageKey',
        MsgType: 'type',
        MsgBody: 'elements',
        Download_Flag: 'downloadFlag'
      }
    };
    return {
      create: {
        serverName: SERVER.NAME.OPEN_IM,
        cmd: SERVER.CMD.SEND_MESSAGE,
        channel: SERVER.CHANNEL.XHR,
        protocol: PROTOCOL_TYPE.JSON,
        method: 'POST',
        queryString: queryString,
        requestData: {
          fromAccount: tim.loginInfo.identifier,
          toAccount: '',
          msgTimeStamp: Math.ceil(+new Date() / 1000),
          msgSeq: 0,
          msgRandom: 0,
          msgBody: [] // offlinePushInfo: {
          //   pushFlag: 0,
          //   desc: '',
          //   ext: '',
          //   dndroidInfo: {
          //     sound: 'android.mp3'
          //   },
          //   apnsInfo: {
          //     sound: 'apns.mp3',
          //     badgeMode: 1
          //   }
          // }

        },
        keyMaps: keyMaps
      },
      // 消息查询，用于获取 C2C 历史消息，同步消息请使用sync-message
      query: {
        serverName: SERVER.NAME.OPEN_IM,
        cmd: SERVER.CMD.GET_C2C_ROAM_MESSAGES,
        channel: SERVER.CHANNEL.XHR,
        protocol: PROTOCOL_TYPE.JSON,
        method: 'POST',
        queryString: queryString,
        requestData: {
          peerAccount: '',
          // 对方的账号
          count: 15,
          // 一次拉取多少条历史
          lastMessageTime: 0,
          // 最后一条消息的时间, 默认0
          messageKey: '' // 用于继拉历史消息的key

        },
        keyMaps: keyMaps
      },
      update: null,
      "delete": null
    };
  };

  var groupMesage = function groupMesage(tim) {
    var queryString = {
      platform: SDK.PLATFORM,
      websdkappid: SDK.APPID,
      v: SDK.VERSION,
      a2: tim.context !== null ? tim.context.a2Key : '',
      tinyid: tim.context !== null ? tim.context.tinyID : 0,
      sdkappid: tim.context !== null ? tim.context.SDKAppID : 0,
      contentType: tim.context !== null ? tim.context.contentType : 0,
      apn: tim.context !== null ? tim.context.apn : 1,
      reqtime: function reqtime() {
        return +new Date();
      }
    };
    var keyMaps = {
      request: {
        to: 'GroupId',
        extension: 'Ext',
        data: 'Data',
        description: 'Desc',
        random: 'Random',
        sequence: 'ReqMsgSeq',
        count: 'ReqMsgNumber',
        type: 'MsgType',
        content: 'MsgContent',
        elements: 'MsgBody',
        sizeType: 'Type',
        uuid: 'UUID',
        // url: 'URL',
        imageUrl: 'URL',
        fileUrl: 'Url',
        downloadFlag: 'Download_Flag'
      },
      response: {
        // GroupId: 'to',
        Random: 'random',
        MsgTime: 'time',
        MsgSeq: 'sequence',
        ReqMsgSeq: 'sequence',
        RspMsgList: 'messagesList',
        IsPlaceMsg: 'isPlaceMessage',
        // 占位消息，用于消息撤回
        IsSystemMsg: 'isSystemMessage',
        ToGroupId: 'to',
        MsgFrom_AccountExtraInfo: 'messageFromAccountExtraInformation',
        EnumFrom_AccountType: 'fromAccountType',
        EnumTo_AccountType: 'toAccountType',
        GroupCode: 'groupCode',
        MsgFlag: 'messageRemindType',
        MsgPriority: 'messagePriority',
        MsgBody: 'elements',
        MsgType: 'type',
        MsgContent: 'content',
        IsFinished: 'complete',
        Download_Flag: 'downloadFlag'
      }
    };
    return {
      create: {
        serverName: SERVER.NAME.GROUP,
        cmd: SERVER.CMD.SEND_GROUP_MESSAGE,
        channel: SERVER.CHANNEL.XHR,
        protocol: PROTOCOL_TYPE.JSON,
        method: 'POST',
        queryString: queryString,
        requestData: {
          groupID: '',
          fromAccount: tim.loginInfo.identifier,
          random: 0,
          msgBody: [] // offlinePushInfo: {
          //   pushFlag: 0,
          //   desc: '',
          //   ext: '',
          //   dndroidInfo: {
          //     sound: 'android.mp3'
          //   },
          //   apnsInfo: {
          //     sound: 'apns.mp3',
          //     badgeMode: 1
          //   }
          // }

        },
        keyMaps: keyMaps
      },
      query: {
        serverName: SERVER.NAME.GROUP,
        cmd: SERVER.CMD.GET_GROUP_ROAM_MESSAGES,
        channel: SERVER.CHANNEL.XHR,
        protocol: PROTOCOL_TYPE.JSON,
        method: 'POST',
        queryString: queryString,
        requestData: {
          groupID: '',
          // 对方的账号
          count: 15,
          // 一次拉取多少条历史
          sequence: '' // 用于继拉群历史消息的序号

        },
        keyMaps: keyMaps
      },
      update: null,
      "delete": null
    };
  };

  var conf$7 = function conf(tim) {
    var queryString = {
      platform: SDK.PLATFORM,
      websdkappid: SDK.APPID,
      v: SDK.VERSION,
      a2: tim.context !== null ? tim.context.a2Key : '',
      tinyid: tim.context !== null ? tim.context.tinyID : 0,
      sdkappid: tim.context !== null ? tim.context.SDKAppID : 0,
      contentType: tim.context !== null ? tim.context.contentType : 0,
      apn: tim.context !== null ? tim.context.apn : 1
    };
    return {
      query: {
        serverName: SERVER.NAME.RECENT_CONTACT,
        cmd: SERVER.CMD.GET_CONVERSATION_LIST,
        channel: SERVER.CHANNEL.XHR,
        protocol: PROTOCOL_TYPE.JSON,
        method: 'POST',
        queryString: queryString,
        requestData: {
          fromAccount: tim.loginInfo.identifier,
          count: 0
        },
        keyMaps: {
          request: {},
          //请求转换Map表
          response: {
            SessionItem: 'conversations',
            ToAccount: 'groupID',
            To_Account: 'userID',
            UnreadMsgCount: 'unreadCount',
            MsgGroupReadedSeq: 'messageReadSeq' //响应转换Map表

          }
        }
      },
      "delete": {
        serverName: SERVER.NAME.RECENT_CONTACT,
        cmd: SERVER.CMD.DELETE_CONVERSATION,
        channel: SERVER.CHANNEL.XHR,
        protocol: PROTOCOL_TYPE.JSON,
        method: 'POST',
        queryString: queryString,
        requestData: {
          fromAccount: tim.loginInfo.identifier,
          toAccount: undefined,
          type: 1,
          toGroupID: undefined
        },
        keyMaps: {
          request: {
            toGroupID: 'ToGroupid'
          }
        }
      },
      setC2CMessageRead: {
        serverName: SERVER.NAME.OPEN_IM,
        cmd: SERVER.CMD.SET_C2C_MESSAGE_READ,
        channel: SERVER.CHANNEL.XHR,
        protocol: PROTOCOL_TYPE.JSON,
        method: 'POST',
        queryString: queryString,
        requestData: {
          C2CMsgReaded: undefined
        },
        keyMaps: {
          request: {
            lastMessageTime: 'LastedMsgTime'
          }
        }
      },
      setGroupMessageRead: {
        serverName: SERVER.NAME.GROUP,
        cmd: SERVER.CMD.SET_GROUP_MESSAGE_READ,
        channel: SERVER.CHANNEL.XHR,
        protocol: PROTOCOL_TYPE.JSON,
        method: 'POST',
        queryString: queryString,
        requestData: {
          groupID: undefined,
          messageReadSeq: undefined
        },
        keyMaps: {
          request: {
            messageReadSeq: 'MsgReadedSeq'
          }
        }
      }
    };
  };

  var syncMessage = function syncMessage(tim) {
    var queryString = {
      platform: SDK.PLATFORM,
      websdkappid: SDK.APPID,
      v: SDK.VERSION,
      a2: tim.context !== null ? tim.context.a2Key : '',
      tinyid: tim.context !== null ? tim.context.tinyID : 0,
      sdkappid: tim.context !== null ? tim.context.SDKAppID : 0,
      contentType: tim.context !== null ? tim.context.contentType : 0,
      apn: tim.context !== null ? tim.context.apn : 1,
      reqtime: function reqtime() {
        return [Math.ceil(+new Date()), Math.random()].join('');
      }
    };
    var keyMaps = {
      request: {
        fromAccount: 'From_Account',
        toAccount: 'To_Account',
        from: 'From_Account',
        to: 'To_Account',
        time: 'MsgTimeStamp',
        sequence: 'MsgSeq',
        random: 'MsgRandom',
        elements: 'MsgBody'
      },
      response: {
        MsgList: 'messageList',
        SyncFlag: 'syncFlag',
        To_Account: 'to',
        From_Account: 'from',
        ClientSeq: 'clientSequence',
        MsgSeq: 'sequence',
        NoticeSeq: 'noticeSequence',
        NotifySeq: 'notifySequence',
        MsgRandom: 'random',
        MsgTimeStamp: 'time',
        MsgContent: 'content',
        ToGroupId: 'groupID',
        MsgKey: 'messageKey',
        GroupTips: 'groupTips',
        MsgBody: 'elements',
        MsgType: 'type'
      }
    };
    return {
      create: null,
      query: {
        serverName: SERVER.NAME.OPEN_IM,
        cmd: SERVER.CMD.GET_MESSAGES,
        channel: SERVER.CHANNEL.XHR,
        protocol: PROTOCOL_TYPE.JSON,
        method: 'POST',
        queryString: queryString,
        requestData: {
          cookie: '',
          syncFlag: 0
        },
        keyMaps: keyMaps
      },
      update: null,
      "delete": null
    };
  };

  var AVChatRoom = function AVChatRoom(tim) {
    return {
      startLongPoll: {
        serverName: SERVER.NAME.BIG_GROUP_LONG_POLLING_NO_AUTH,
        cmd: SERVER.CMD.AVCHATROOM_LONG_POLL,
        channel: SERVER.CHANNEL.XHR,
        protocol: PROTOCOL_TYPE.JSON,
        method: 'POST',
        queryString: {
          websdkappid: SDK.APPID,
          v: SDK.VERSION,
          platform: SDK.PLATFORM,
          sdkappid: tim.loginInfo.SDKAppID,
          accounttype: '792',
          apn: tim.context != null ? tim.context.apn : 1,
          reqtime: function reqtime() {
            return +new Date();
          }
        },
        requestData: {
          USP: 1,
          startSeq: 1,
          holdTime: 90,
          key: undefined
        },
        keyMaps: {
          request: {
            USP: 'USP'
          },
          response: {
            ToGroupId: 'groupID'
          }
        }
      }
    };
  };

  var cosUpload = function cosUpload(tim) {
    var queryString = {
      platform: SDK.PLATFORM,
      websdkappid: SDK.APPID,
      v: SDK.VERSION,
      a2: tim.context !== null ? tim.context.a2Key : '',
      tinyid: tim.context !== null ? tim.context.tinyID : 0,
      sdkappid: tim.context !== null ? tim.context.SDKAppID : 0,
      contentType: tim.context !== null ? tim.context.contentType : 0,
      apn: tim.context !== null ? tim.context.apn : 1,
      reqtime: function reqtime() {
        return Date.now();
      }
    };
    var keyMaps = {
      request: {},
      response: {}
    };
    return {
      create: {
        serverName: SERVER.NAME.OPEN_IM,
        cmd: SERVER.CMD.FILE_UPLOAD,
        channel: SERVER.CHANNEL.XHR,
        protocol: PROTOCOL_TYPE.JSON,
        method: 'POST',
        queryString: queryString,
        requestData: {
          appVersion: '2.1',
          fromAccount: '',
          toAccount: '',
          sequence: 0,
          time: function time() {
            return Math.ceil(Date.now() / 1000);
          },
          random: function random() {
            return randomInt();
          },
          fileStrMd5: '',
          fileSize: '',
          serverVer: 1,
          authKey: '',
          busiId: 1,
          pkgFlag: 1,
          sliceOffset: 0,
          sliceSize: 0,
          sliceData: '',
          contentType: 'application/x-www-form-urlencoded'
        },
        keyMaps: keyMaps
      },
      update: null,
      "delete": null
    };
  };

  var cosSig = function cosSig(tim) {
    var queryString = {
      sdkappid: function sdkappid() {
        return tim.loginInfo.SDKAppID;
      },
      identifier: function identifier() {
        return tim.loginInfo.identifier;
      },
      userSig: function userSig() {
        return tim.context.userSig;
      } // --- 分隔线 ---- 
      // platform: SDK.PLATFORM,
      // v: SDK.VERSION,
      // // a2: tim.context !== null ? tim.context.a2Key : '',
      // a2: function(){
      //   return tim.context.a2Key || '';
      // },
      // // tinyid: tim.context !== null ? tim.context.tinyID : 0,
      // tinyid: function(){
      //   return tim.context.tinyID || null;
      // },
      // contentType: tim.context !== null ? tim.context.contentType : 0,
      // apn: tim.context !== null ? tim.context.apn : 1,
      // reqtime: function() {return Date.now();}

    };
    var keyMaps = {
      request: {
        userSig: 'usersig',
        subCmd: 'sub_cmd',
        cmd: 'cmd',
        duration: 'duration',
        version: 'version'
      },

      /*
      appid: xxx
      bucket_name: "xxxx"
      error_code: 0
      error_msg: ""
      expired_time: xxxx
      session_token: "xxxx"
      tmp_secret_id: "xxxx"
      tmp_secret_key: "xxxx"
      */
      response: {
        expired_time: 'expiredTime',
        bucket_name: 'bucketName',
        session_token: 'sessionToken',
        tmp_secret_id: 'secretId',
        tmp_secret_key: 'secretKey'
      }
    };
    return {
      create: null,
      query: {
        serverName: SERVER.NAME.IM_COS_SIGN,
        cmd: SERVER.CMD.COS_SIGN,
        channel: SERVER.CHANNEL.XHR,
        protocol: PROTOCOL_TYPE.JSON,
        method: 'POST',
        queryString: queryString,
        requestData: {
          cmd: 'open_im_cos_svc',
          subCmd: 'get_cos_token',
          duration: 300,
          // 不设置的话，默认只给 5 分钟
          version: 1
        },
        keyMaps: keyMaps
      },
      update: null,
      "delete": null
    };
  };

  /**
   * 此类用于生成请求包
   * @class
   */

  var PackageConfig =
  /*#__PURE__*/
  function () {
    function PackageConfig(tim) {
      _classCallCheck(this, PackageConfig);

      this.isReady = false;
      this.tim = tim;
      this.context = tim.context;

      this._initList();

      this._updateWhenCTXIsReady();
    }
    /**
     * 当tim.ctx完成初始化时，执行一下update
     */


    _createClass(PackageConfig, [{
      key: "_updateWhenCTXIsReady",
      value: function _updateWhenCTXIsReady() {
        this.tim.innerEmitter.on(TIM_INNER_EVENT.CONTEXT_UPDATED, this.update, this);
        this.tim.innerEmitter.on(TIM_INNER_EVENT.CONTEXT_RESET, this.reset, this);
      }
      /**
       * 用于更新成员和 `self.config` 配置，因为有些参数无法构造时就取得，比如 `tim.context` 参数，所以可以在`tim.context` 完成初始化后再调用此方法。
       * @param {*} event
       */

    }, {
      key: "update",
      value: function update(event) {
        var context = event.context;
        this.context = context;

        this._initList();
      }
      /***
       * 重置
       */

    }, {
      key: "reset",
      value: function reset(event) {
        this.context = event.data;

        this._initList(); // this.config = {};
        // this.config['accessLayer'] = accessLayer(this.tim);
        // this.config['login'] = login(this.tim);
        // this.config['logout'] = logout(this.tim);

      }
      /**
       * 获取接口的 packageConfig 配置
       * @param {Object} options
       * @param {String} options.name - package 名称
       * @param {String} options.action - package 操作
       * @param {Object} [options.param] - 其它的POST参数
       */

    }, {
      key: "get",
      value: function get(options) {
        var name = options.name,
            action = options.action,
            param = options.param;

        if (typeof this.config[name] === 'undefined') {
          throw new IMError({
            code: ERROR_CODE.NETWORK_PACKAGE_UNDEFINED,
            message: "".concat(ERROR_MESSAGE.NETWORK_PACKAGE_UNDEFINED, ": PackageConfig.").concat(name)
          });
        }

        if (typeof this.config[name][action] === 'undefined') {
          throw new IMError({
            code: ERROR_CODE.NETWORK_PACKAGE_UNDEFINED,
            message: "".concat(ERROR_MESSAGE.NETWORK_PACKAGE_UNDEFINED, ": PackageConfig.").concat(name, ".").concat(action)
          });
        }

        var packageOption = clone(this.config[name][action]); // 转json 方式复制一份。

        packageOption.requestData = this._initRequestData(param, packageOption);
        packageOption.encode = this._initEncoder(packageOption);
        packageOption.decode = this._initDecoder(packageOption);
        return packageOption;
      }
      /**
       * 用来配置个别packageConfig选项，因为有些配置无法在初始化时就同步加载，比如`packageConfig.longPoll.requestData.Cookie.LongPollID`，LongPollID需要API请求后才能取得，只有在取得后才能去配置
       * @param {Object} options
       * @param {String} options.key
       * @param {*} options.value
       * @example
       * let packageConfig = new PackageConfig(tim);
       * packageConfig.setPackageConfig({
       *  key: 'longPoll.qeury.requestData.Cookie.LongPollID',
       *  value: 88888888
       * })
       */

    }, {
      key: "set",
      value: function set(options) {
        var key = options.key,
            value = options.value;

        if (!!key === false) {
          return;
        }

        var keys = key.split('.');

        if (keys.length <= 0) {
          return;
        }

        var packageConfigSetter = function packageConfigSetter(packageConfig, keys, startKeyIndex, value) {
          var key = keys[startKeyIndex];

          if (_typeof(packageConfig[key]) === 'object') {
            packageConfigSetter(packageConfig[key], keys, startKeyIndex + 1, value);
          } else {
            packageConfig[key] = value;
            return;
          }
        };

        packageConfigSetter(this.config, keys, 0, value);
      }
    }, {
      key: "_initList",
      value: function _initList() {
        this.config = {};
        this.config['accessLayer'] = accessLayer(this.tim);
        this.config['login'] = login(this.tim);
        this.config['logout'] = logout(this.tim);
        this.config['longPollLogout'] = longPollLogout(this.tim);
        this.config['profile'] = conf(this.tim);
        this.config['group'] = conf$1(this.tim);
        this.config['longPollID'] = conf$2(this.tim);
        this.config['longPoll'] = conf$3(this.tim);
        this.config['applyC2C'] = conf$4(this.tim);
        this.config['friend'] = conf$5(this.tim);
        this.config['blacklist'] = conf$6(this.tim);
        this.config['c2cMessage'] = c2cMessage(this.tim);
        this.config['groupMessage'] = groupMesage(this.tim);
        this.config['conversation'] = conf$7(this.tim);
        this.config['syncMessage'] = syncMessage(this.tim);
        this.config['AVChatRoom'] = AVChatRoom(this.tim);
        this.config['cosUpload'] = cosUpload(this.tim);
        this.config['cosSig'] = cosSig(this.tim);
      }
      /**
       * 初始化 reqeustData (form-data) 参数
       * @param {Object} param - 传入的 form-data
       * @param {Object} packageOption - 默认的 form-data
       */

    }, {
      key: "_initRequestData",
      value: function _initRequestData(param, packageOption) {
        if (typeof param === 'undefined') {
          var result = convertRequestParam(packageOption.requestData, this._getRequestMap(packageOption), this.tim);
          return result;
        }

        var requestData = packageOption.requestData;
        var data = Object.create(null);

        for (var p in requestData) {
          // 如果是function 类型的成员，则执行一下，否则直接赋值。
          data[p] = typeof requestData[p] === 'function' ? requestData[p]() : requestData[p];

          if (typeof param[p] === 'undefined') {
            continue;
          }

          data[p] = param[p];
        }

        data = convertRequestParam(data, this._getRequestMap(packageOption), this.tim); // 转换请求参数的key

        return data;
      }
      /**
       * 获取接口的keyMaps.request配置
       *
       * @param {Object} packageOption
       * @returns {Object|undefined} 若对应接口有配置则返回配置，否则返回undefined
       * @memberof PackageConfig
       */

    }, {
      key: "_getRequestMap",
      value: function _getRequestMap(packageOption) {
        if (packageOption.keyMaps) {
          if (packageOption.keyMaps.request) {
            if (Object.keys(packageOption.keyMaps.request).length > 0) {
              return packageOption.keyMaps.request;
            }
          }
        }
      }
      /**
       * 初始化encode编码函数
       * @param {*} packageOption
       */

    }, {
      key: "_initEncoder",
      value: function _initEncoder(packageOption) {
        switch (packageOption.protocol) {
          case PROTOCOL_TYPE.JSON:
            return function (responseData) {
              var type = _typeof(responseData);

              if (type === 'string') {
                try {
                  return JSON.parse(responseData); //如果无法用无法转化为JSON则直接赋值给 packageOption.responseData
                } catch (error) {
                  return responseData;
                }
              }

              return responseData;
            }.bind(packageOption);

          case PROTOCOL_TYPE.PROTOBUF:
            return function (responseData) {
              return responseData;
            }.bind(packageOption);

          default:
            return function (responseData) {
              logger.warn('PackageConfig._initEncoder(), unknow response type, data: ', JSON.stringify(responseData));
              return responseData;
            }.bind(packageOption);
        }
      }
      /**
       * 初始化decode解码函数
       * @param {Object} packageOption
       * @param {Object} father
       * @return {Function} function (responseData){
       *    //...
       * }
       */

    }, {
      key: "_initDecoder",
      value: function _initDecoder(packageOption) {
        switch (packageOption.protocol) {
          case PROTOCOL_TYPE.JSON:
            return function (responseData) {
              var type = _typeof(responseData);

              if (type === 'string') {
                try {
                  return JSON.parse(responseData); //如果无法用无法转化为JSON则直接赋值给 packageOption.responseData
                } catch (error) {
                  return responseData;
                }
              }

              return responseData;
            }.bind(packageOption);

          case PROTOCOL_TYPE.PROTOBUF:
            return function (responseData) {
              return responseData;
            }.bind(packageOption);

          default:
            return function (responseData) {
              logger.warn('PackageConfig._initDecoder(), unknow response type, data: ', responseData);
              return responseData;
            }.bind(packageOption);
        }
      }
    }]);

    return PackageConfig;
  }();

  var NotificationController =
  /*#__PURE__*/
  function (_IMController) {
    _inherits(NotificationController, _IMController);

    function NotificationController(tim) {
      var _this;

      _classCallCheck(this, NotificationController);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(NotificationController).call(this, tim));

      _this._initialization();

      return _this;
    }
    /**
     * 初始化
     */


    _createClass(NotificationController, [{
      key: "_initialization",
      value: function _initialization() {
        this._syncOffset = '';
        this._syncNoticeList = []; // 暂存消息同步结果

        this._syncEventArray = []; // 暂存群系统通知同步结果

        this._syncMessagesIsRunning = false;
        this._syncMessagesFinished = false;
        this._isLongPoll = false;
        this._longPollID = 0;
        this._noticeSequence = 0;

        this._initializeListener();

        this._runLoop = null;
      }
    }, {
      key: "getLongPollID",
      value: function getLongPollID() {
        return this._longPollID;
      }
      /**
       * 控制器准备就绪时，调用此方法
       */

    }, {
      key: "_IAmReady",
      value: function _IAmReady() {
        this.triggerReady();
      }
      /**
       * 重置
       */

    }, {
      key: "reset",
      value: function reset() {
        this._noticeSequence = 0;

        this._resetSync();

        this._resetLongpoll();
      }
      /**
       * 重置 同步参数
       */

    }, {
      key: "_resetSync",
      value: function _resetSync() {
        this._syncOffset = '';
        this._syncNoticeList = [];
        this._syncEventArray = [];
        this._syncMessagesIsRunning = false;
        this._syncMessagesFinished = false;
      }
      /**
       * 重置 轮询相关参数
       */

    }, {
      key: "_resetLongpoll",
      value: function _resetLongpoll() {
        this._longPollID = 0;
        this._isLongPoll = false;
      }
      /**
       * 重新设置请求包体的中 NoticeSeq
       * @param {Object} requestData
       */

    }, {
      key: "_setNoticeSeqInRequestData",
      value: function _setNoticeSeqInRequestData(requestData) {
        requestData.Cookie.NoticeSeq = this._noticeSequence;
      }
      /**
       * 更新一下最新的 _noticeSequence
       * @param {*} noticeList
       */

    }, {
      key: "_updatenoticeSequence",
      value: function _updatenoticeSequence(noticeList) {
        if (!noticeList) {
          this._noticeSequence++;
        }

        var newNoticeSequence = noticeList[noticeList.length - 1].noticeSequence; // noticeSequence 存放的位置有差别，防万一

        if (!newNoticeSequence) {
          this._noticeSequence++;
        }

        if (typeof newNoticeSequence !== 'number') {
          this._noticeSequence++;
        }

        if (newNoticeSequence < this._noticeSequence) {
          this._noticeSequence++;
        }

        this._noticeSequence = newNoticeSequence;
      }
      /**
       * 初始化监听
       */

    }, {
      key: "_initializeListener",
      value: function _initializeListener() {
        var innerEmitter = this.tim.innerEmitter; // 当 context 更新完成时，开始同步消息

        innerEmitter.on(TIM_INNER_EVENT.CONTEXT_A2KEY_AND_TINYID_UPDATED, this._startSyncMessages, this);
        innerEmitter.on(TIM_INNER_EVENT.SYNC_MESSAGE_C2C_FINISHED, this._realTimeNotice, this); // 当消息同步完成时，开始 long poll

        innerEmitter.on(TIM_INNER_EVENT.NOTICE_LONGPOLL_GETID_SUCCESS, this._onGetLongPollIDSuccess, this);
        innerEmitter.on(TIM_INNER_EVENT.SIGN_LOGOUT_SUCCESS, this.stopLongPoll, this);
        innerEmitter.on(TIM_INNER_EVENT.NOTICE_LONGPOLL_SOON_RECONNECT, this._onChannelReconnect, this); // 当发送重连时（2 < n < 5 ，具体数值以StatusController中配置的为准）
        // innerEmitter.on(TIM_INNER_EVENT.NOTICE_LONGPOLL_LONG_RECONNECT, this._onChannelReconnect, this);

        innerEmitter.on(TIM_INNER_EVENT.NOTICE_LONGPOLL_DISCONNECT, this._onChannelDisconnected, this);
      }
      /**
       * 启动实时通知任务，首先要取得 longPollID
       */

    }, {
      key: "_realTimeNotice",
      value: function _realTimeNotice() {
        logger.log('NotificationController._realTimeNotice start...');

        this._getLongPollID();
      }
      /**
       * 获取 longPollID
       * @fires TIM_INNER_EVENT.NOTICE_LONGPOLL_GETID_SUCCESS: "getLongPollIDSuccess" - 获取轮询ID成功
       * @fires TIM_INNER_EVENT.NOTICE_LONGPOLL_GETID_FAIL: "getLongPollIDFail" - 获取轮询ID失败
       * @returns null
       */

    }, {
      key: "_getLongPollID",
      value: function _getLongPollID() {
        var _this$tim = this.tim,
            innerEmitter = _this$tim.innerEmitter,
            connectionController = _this$tim.connectionController; // 如果已经取得了long poll id 则不重复获取 。 直接发布EVENT.LONG_POLL.GET_LONG_POLL_ID.SUCCESS事件

        if (this._longPollID !== 0) {
          innerEmitter.emit(TIM_INNER_EVENT.NOTICE_LONGPOLL_GETID_SUCCESS, {
            data: this._longPollID
          });
          return;
        }

        var capsule = this.createPackage({
          name: 'longPollID',
          action: 'query'
        });
        var result = connectionController.request(capsule);
        result.then(function (response) {
          if (response.data.errorCode == TIM_STATUS.REQUEST.SUCCESS) {
            innerEmitter.emit(TIM_INNER_EVENT.NOTICE_LONGPOLL_GETID_SUCCESS, {
              data: response.data.longPollingID
            });
          } else {
            innerEmitter.emit(TIM_INNER_EVENT.NOTICE_LONGPOLL_GETID_FAIL, {
              data: response.data
            });
          }
        })["catch"](function (responseError) {
          innerEmitter.emit(TIM_INNER_EVENT.NOTICE_LONGPOLL_GETID_FAIL, responseError);
        });
      }
      /**
       * 当成功取得longPollId 时，开始轮询
       * @param {object} event - 事件对象
       */

    }, {
      key: "_onGetLongPollIDSuccess",
      value: function _onGetLongPollIDSuccess(event) {
        // self._longPollID = response.data.LongPollID;
        this.tim.packageConfig.set({
          key: 'long_poll_logout.query.requestData.longPollingID',
          value: event.data
        });
        this.tim.packageConfig.set({
          key: 'longPoll.query.requestData.cookie.longPollingID',
          value: event.data
        });
        this._longPollID = event.data;

        this._startLongPoll();

        this._IAmReady(); // 控制器准备就绪

      }
      /**
       * 开始轮询
       */

    }, {
      key: "_startLongPoll",
      value: function _startLongPoll() {
        if (this._isLongPoll === true) {
          // logger.log('realTimeMessage is running...');
          return;
        }

        logger.log('NotificationController._startLongPoll...');
        var _this$tim2 = this.tim,
            connectionController = _this$tim2.connectionController,
            innerEmitter = _this$tim2.innerEmitter;
        var pack = this.createPackage({
          name: 'longPoll',
          action: 'query'
        });
        this._isLongPoll = true;
        innerEmitter.emit(TIM_INNER_EVENT.NOTICE_LONGPOLL_START, {
          data: Date.now()
        });
        this._runLoop = connectionController.createRunLoop({
          pack: pack,
          before: this._setNoticeSeqInRequestData.bind(this),
          // 发送前回调
          success: this._onNoticeReceived.bind(this),
          // 成功回调
          fail: this._onNoticeFail.bind(this) // 失败回调

        });

        this._runLoop.start();
      }
      /**
       * 当通道重连
       */

    }, {
      key: "_onChannelReconnect",
      value: function _onChannelReconnect(event) {
        // 停掉当前的 runLoop
        this.stopLongPoll(); // 重新启动消息同步，消息同步完成后，会发布 事件，消息通道便会启动

        this.syncMessage();
      }
      /**
       * 当通道掉线
       */

    }, {
      key: "_onChannelDisconnected",
      value: function _onChannelDisconnected() {}
      /**
       * 停止轮询
       */

    }, {
      key: "stopLongPoll",
      value: function stopLongPoll() {
        logger.log('NotificationController.stopLongPoll()'); // this.tim.connectionController.stopRunLoop();

        this._runLoop.stop();

        this._longPollID = 0;
        this._isLongPoll = false;
        this.tim.innerEmitter.emit(TIM_INNER_EVENT.NOTICE_LONGPOLL_STOPPED);
        this.tim.outerEmitter.emit(TIM_OUTER_EVENT.NOTICE_LONGPOLL_STOPPED);
      }
      /**
       * 取得新的实时消息时的回调
       * @param {Object} event
       */

    }, {
      key: "_onNoticeReceived",
      value: function _onNoticeReceived(event) {
        var _this$tim3 = this.tim,
            innerEmitter = _this$tim3.innerEmitter,
            statusController = _this$tim3.statusController;
        var data = event.data; // 是否要放弃本次轮询，如果掉线了2分钟到5分钟之间，需要放弃本次轮询

        var isAbortThisTurn = !statusController.getChannelStatus(); // _onNoticeReceived 调用到了， 说明收到了服务器的 response，也说明 reqeust 成功了

        innerEmitter.emit(TIM_INNER_EVENT.NOTICE_LONGPOLL_REQUEST_ARRIVED, {
          data: Date.now()
        });

        if (data.errorCode !== TIM_STATUS.REQUEST.SUCCESS) {
          // 多实例互踢
          if (data.errorCode === ERROR_CODE.LONG_POLL_KICK_OUT) {
            innerEmitter.emit(TIM_INNER_EVENT.NOTICE_LONGPOLL_KICKED_OUT);
            logger.log('NotificationController._onNoticeReceived(), longPollingID was kicked');
            this.stopLongPoll();
            return;
          }

          logger.log("NotificationController._onNoticeReceived(), error: ".concat(data.errorCode, ", errorInfo: ").concat(data.errorInfo));
          innerEmitter.emit(TIM_INNER_EVENT.ERROR_DETECTED, {
            code: data.errorCode,
            message: data.errorInfo
          });
        }

        if (event.data.eventArray == null) {
          // 如果 eventArray 为 null 说明没有新消息
          return;
        } // 如果 isAbortThisTurn 为true 则放弃本次轮询的的结果


        if (isAbortThisTurn === true) {
          return;
        }

        this._eachEventArray(event.data.eventArray); // 消息分发

      }
    }, {
      key: "_onNoticeFail",
      value: function _onNoticeFail(event) {
        this.tim.innerEmitter.emit(TIM_INNER_EVENT.ERROR_DETECTED, event.error);
        this.tim.innerEmitter.emit(TIM_INNER_EVENT.NOTICE_LONGPOLL_REQUEST_NOT_ARRIVED, {
          data: Date.now()
        });
      }
      /**
       *
       * @param {Array} eventArray - 通知列表
       * @param {String} type sync / poll
       */

    }, {
      key: "_eachEventArray",
      value: function _eachEventArray(eventArray) {
        var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'poll';
        var pTask = pointerTask('NotificationController._eachEventArray()');
        pTask.dot('start');
        var innerEmitter = this.tim.innerEmitter;
        var eventItem = null;

        for (var i = 0, len = eventArray.length; i < len; i++) {
          eventItem = eventArray[i]; // 条件生成依据： Event类型（int） ， noticeCarrierType { 详见 NotificationController._confirmCarrierType() }

          var noticeCarrierType = this._confirmCarrierType(eventItem); // 确定一下通知中载体的类型


          pTask.dot("type ".concat(noticeCarrierType));
          var condition = boolsToStr(eventItem.event, noticeCarrierType, ',');
          pTask.dot("condition ".concat(condition));

          switch (condition) {
            // Event 9, C2CMessageArray ; 轮询收到新的 C2C 通知
            case '9,1':
              // 更新一下最新的 _noticeSequence
              this._updatenoticeSequence(eventItem.C2CMessageArray);

              innerEmitter.emit(TIM_INNER_EVENT.NOTICE_LONGPOLL_NEW_C2C_NOTICE, {
                data: eventItem.C2CMessageArray,
                type: type
              });
              pTask.dot("emit ".concat(TIM_INNER_EVENT.NOTICE_LONGPOLL_NEW_C2C_NOTICE));
              break;
            // Event 3,groupMessageArray; 轮询收到新的群消息

            case '3,2':
              this._updatenoticeSequence(eventItem.groupMessageArray);

              innerEmitter.emit(TIM_INNER_EVENT.NOTICE_LONGPOLL_NEW_GROUP_MESSAGES, {
                data: eventItem.groupMessageArray
              });
              pTask.dot("emit ".concat(TIM_INNER_EVENT.NOTICE_LONGPOLL_NEW_GROUP_MESSAGES));
              break;
            // Event 4, groupTips; 轮询收到新的群提示

            case '4,3':
              this._updatenoticeSequence(eventItem.groupTips);

              innerEmitter.emit(TIM_INNER_EVENT.NOTICE_LONGPOLL_NEW_GROUP_TIPS, {
                data: eventItem.groupTips
              });
              pTask.dot("emit ".concat(TIM_INNER_EVENT.NOTICE_LONGPOLL_NEW_GROUP_TIPS));
              break;
            // Event 5, groupTips; 轮询收到新的[群系统]通知

            case '5,3':
              this._updatenoticeSequence(eventItem.groupTips);

              innerEmitter.emit(TIM_INNER_EVENT.NOTICE_LONGPOLL_NEW_GROUP_NOTICE, {
                data: {
                  groupSystemNotices: eventItem.groupTips,
                  type: type
                }
              });
              pTask.dot("emit ".concat(TIM_INNER_EVENT.NOTICE_LONGPOLL_NEW_GROUP_NOTICE));
              break;
            // Event 7, C2CMessageArray; 轮询收到好友系统消息

            case '7,7':
              this._updatenoticeSequence(eventItem.friendListMod);

              innerEmitter.emit(TIM_INNER_EVENT.NOTICE_LONGPOLL_NEW_FRIEND_MESSAGES, {
                data: eventItem.friendListMod
              });
              pTask.dot("emit ".concat(TIM_INNER_EVENT.NOTICE_LONGPOLL_NEW_FRIEND_MESSAGES));
              break;

            case '8,6':
              this._updatenoticeSequence(eventItem.profileModify);

              innerEmitter.emit(TIM_INNER_EVENT.NOTICE_LONGPOLL_PROFILE_MODIFIED, {
                data: eventItem.profileModify
              });
              pTask.dot("emit ".concat(TIM_INNER_EVENT.NOTICE_LONGPOLL_PROFILE_MODIFIED));
              break;
            // Event 10 , C2CNotifyMessageArray; 轮询收到C2C事件

            case '10,5':
              // 包含多终端互踢 ， 消息已读通知
              this._updatenoticeSequence(eventItem.C2CNotifyMessageArray); // 判断是否为多终端互踢


              if (this._isKickedoutNotice(eventItem.C2CNotifyMessageArray)) {
                innerEmitter.emit(TIM_INNER_EVENT.NOTICE_LONGPOLL_MUTIPLE_DEVICE_KICKED_OUT);
                return;
              } // TODO: 消息已读通知尚未处理


              logger.warn("NotificationController._eachEventArray() get Event condition : ".concat(condition, ", only increase noticeSequence"));
              break;
            // AVChatRoom 的 Event 3 的结构体有点区别（没有 groupMessageArray）
            // 3,0 AVChatRoom 的分发逻辑

            case '3,0':
              innerEmitter.emit(TIM_INNER_EVENT.NOTICE_LONGPOLL_NEW_GROUP_MESSAGES, {
                data: [eventItem]
              });
              pTask.dot("emit ".concat(TIM_INNER_EVENT.NOTICE_LONGPOLL_NEW_GROUP_MESSAGES));
              break;
            // AVChatRoom Event 6, groupTips; AVChatRoom 的[群提示]消息
            // 6,0 AVChatRoom 的分发逻辑

            case '6,0':
              innerEmitter.emit(TIM_INNER_EVENT.NOTICE_LONGPOLL_NEW_GROUP_TIPS, {
                data: [eventItem]
              });
              pTask.dot("emit ".concat(TIM_INNER_EVENT.NOTICE_LONGPOLL_NEW_GROUP_TIPS));
              break;
            // TODO: 需要覆盖所有的 Event + noticeCarrierType
            // 以上 condition 都不符合，说明出错了，发布错误事件；

            default:
              this._updatenoticeSequence(); // noticeSequence 自增一下，避免重复拉取


              innerEmitter.emit(TIM_INNER_EVENT.ERROR_DETECTED, {
                code: ERROR_CODE.NOTICE_RUNLOOP_UNEXPECTED_CONDITION,
                message: "".concat(ERROR_MESSAGE.NOTICE_RUNLOOP_UNEXPECTED_CONDITION, " : ").concat(condition, ", data: ").concat(JSON.stringify(eventItem))
              });
              pTask.dot("".concat(TIM_INNER_EVENT.ERROR_DETECTED, ":").concat(ERROR_CODE.NOTICE_RUNLOOP_UNEXPECTED_CONDITION));
          }

          pTask.report();
        }
      }
      /**
       * 判断是哪种内容载体
       * @param {Object} eventItem - 通知内容载体
       * @returns {Number} 参考 carrierTypes，如果返回0，说明没找到消息载体
       */

    }, {
      key: "_confirmCarrierType",
      value: function _confirmCarrierType(eventItem) {
        var carrierTypes = {
          C2CMessageArray: 1,
          groupMessageArray: 2,
          groupTips: 3,
          messageList: 4,
          C2CNotifyMessageArray: 5,
          profileModify: 6,
          friendListMod: 7
        };
        var carrierName = ''; // 匹配出消息载体名称。

        for (var index in eventItem) {
          // logger.log('_confirmCarrierType', index);
          if (carrierTypes.hasOwnProperty(index)) {
            carrierName = index;
            break;
          }
        } // 如果 carrierName 是空的， 说明没找到消息的载体


        if (carrierName === '') {
          return 0;
        }

        return carrierTypes.hasOwnProperty(carrierName) ? carrierTypes[carrierName] : 0;
      }
      /**
       * 判断是否为多终端互踢的通知
       * @param {object} C2CNotifyMessageArray - 通知数据
       * @returns {boolean}
       */

    }, {
      key: "_isKickedoutNotice",
      value: function _isKickedoutNotice(C2CNotifyMessageArray) {
        var noticeData = C2CNotifyMessageArray[0];

        if (noticeData.hasOwnProperty('kickoutMsgNotify')) {
          return true;
        }

        return false;
      }
      /**
       * 启动同步消息通知消息功能
       * @param {Object} event - 事件
       */

    }, {
      key: "_startSyncMessages",
      value: function _startSyncMessages(event) {
        if (this._syncMessagesFinished === true) return; // 如果已经完成同步，不需要两次执行
        // 当 a2key 和 tinyID 都就绪了，就开始同步

        this.syncMessage();
      }
      /**
       * 开始同步通知（C2C未读消息?）
       * @param {String} cookie 用于续拉， 不需要传入。
       * @returns null
       * @throws {IMError}
       */

    }, {
      key: "syncMessage",
      value: function syncMessage() {
        var _this2 = this;

        var cookie = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
        var syncFlag = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        // TODO: 函数太长了，分解优化一下。
        var _this$tim4 = this.tim,
            connectionController = _this$tim4.connectionController,
            innerEmitter = _this$tim4.innerEmitter;
        this._syncMessagesIsRunning = true;
        var pack = this.createPackage({
          name: 'syncMessage',
          action: 'query',
          param: {
            cookie: cookie,
            syncFlag: syncFlag
          }
        });
        connectionController.request(pack).then(function (response) {
          var data = response.data;
          var condition = boolsToStr(data.cookie, data.syncFlag);

          switch (condition) {
            case '00': // 同步任务开启时，没拿到 _syncOffset 触发异常事件

            case '01':
              // 同步任务进行期间，没拿到 _syncOffset 触发异常事件
              innerEmitter.emit(TIM_INNER_EVENT.ERROR_DETECTED, {
                code: ERROR_CODE.NOTICE_RUNLOOP_OFFSET_LOST,
                message: ERROR_MESSAGE.NOTICE_RUNLOOP_OFFSET_LOST
              });
              break;
            // 同步刚开启，记录下 _syncOffset 后继也许可以用于继传，此时已经取得了第一个分片

            case '10':
              if (data.eventArray) {
                _this2._eachEventArray(data.eventArray, 'sync');
              }

              _this2._syncNoticeList = _this2._syncNoticeList.concat(data.messageList); // 当有消息时才抛事件

              innerEmitter.emit(TIM_INNER_EVENT.SYNC_MESSAGE_C2C_PROCESSING, {
                data: data.messageList
              });
              _this2._syncOffset = data.cookie;

              _this2.syncMessage(data.cookie, data.syncFlag);

              break;
            // 同步进行中，持续接取分片

            case '11':
              if (data.eventArray) {
                _this2._eachEventArray(data.eventArray, 'sync');
              }

              _this2._syncNoticeList = _this2._syncNoticeList.concat(data.messageList);
              innerEmitter.emit(TIM_INNER_EVENT.SYNC_MESSAGE_C2C_PROCESSING, {
                data: data.messageList
              });
              _this2._syncOffset = data.cookie;

              _this2.syncMessage(data.cookie, data.syncFlag);

              break;
            // 同步任务结束, 取得最后一个分片

            case '12':
              if (data.eventArray) {
                _this2._eachEventArray(data.eventArray, 'sync');
              }

              _this2._syncNoticeList = _this2._syncNoticeList.concat(data.messageList); // 当有消息时才抛事件

              innerEmitter.emit(TIM_INNER_EVENT.SYNC_MESSAGE_C2C_FINISHED, {
                data: data.messageList
              });
              _this2._syncOffset = data.cookie;
              _this2._syncNoticeList = []; // 置空

              _this2._syncMessagesIsRunning = false;
              _this2._syncMessagesFinished = true;
              break;
          }
        })["catch"](function (error) {
          _this2._syncMessagesIsRunning = false;
          logger.error('NotificationController.syncMessage() failed, error:', JSON.stringify(error));
        });
      }
    }]);

    return NotificationController;
  }(IMController);

  /**
   * 用于文件上传控制
   * @author saxongao
   */

  var UploadController =
  /*#__PURE__*/
  function (_IMController) {
    _inherits(UploadController, _IMController);

    function UploadController(tim) {
      var _this;

      _classCallCheck(this, UploadController);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(UploadController).call(this, tim)); // 0.登录前，SDK需要registerPlugin
      // 1.先监听事件，登录成功 context 更新后才能初始化

      _this._initializeListener();

      return _this;
    }
    /**
     * 初始化基本参数
     * @param {*} options - 配置参数
     */


    _createClass(UploadController, [{
      key: "_initializeMembers",
      value: function _initializeMembers(options) {
        this.expiredTimeLimit = 300; // 签名的超时时间，单位为秒

        this.appid = options.appid || '';
        this.bucketName = options.bucketName || '';
        this.expiredTimeOut = options.expiredTimeOut || this.expiredTimeLimit; // 超时计时，单位为秒

        this.region = 'ap-shanghai';
        this.cos = null;
        this.cosOptions = {
          secretId: options.secretId,
          secretKey: options.secretKey,
          sessionToken: options.sessionToken,
          expiredTime: options.expiredTime
        };

        this._initUploaderMethod();
      }
      /**
       * coskey过期计时器，COS key过期时并没有自动去取，所以还得自己动手
       */

    }, {
      key: "_expiredTimer",
      value: function _expiredTimer() {
        var _this2 = this;

        var checkRate = 10; // 检测频率 单位为秒

        var timeSecond = 0;
        var seed = setInterval(function () {
          timeSecond = Math.ceil(Date.now() / 1000);

          if (timeSecond >= _this2.cosOptions.expiredTime - 2 * checkRate) {
            _this2._isReady = false;

            _this2._getAuthorizationKey();

            clearInterval(seed);
          }
        }, checkRate * 1000);
      }
      /**
       * 配置事件订阅
       */

    }, {
      key: "_initializeListener",
      value: function _initializeListener() {
        this.tim.innerEmitter.on(TIM_INNER_EVENT.CONTEXT_A2KEY_AND_TINYID_UPDATED, this._initialization, this);
      }
      /**
       * 初始化: 初始化成员、获取COS KEY ， 初始化上传方法
       */

    }, {
      key: "_initialization",
      value: function _initialization() {
        // 1.通过tim.getPlugin 获取 cos sdk 类 ,如果获取不到，则不进行初始化
        this._initCOSSDKPlugin();

        if (this.COSSDK) {
          // 2.获取到cos sdk 继续进行初始化， cos sdk 挂载到 this
          this._initializeMembers({});

          this._getAuthorizationKey();
        } else {
          logger.warn('UploadController 没有检测到上传插件，文件上传功能将无法使用');
        }
      }
      /**
       * 获取COS签名的接口
       */

    }, {
      key: "_getAuthorizationKey",
      value: function _getAuthorizationKey() {
        var _this3 = this;

        var requestTime = Math.ceil(Date.now() / 1000);
        var pack = this.createPackage({
          name: 'cosSig',
          action: 'query',
          param: {
            duration: this.expiredTimeLimit
          }
        });
        this.tim.connectionController.request(pack).then(function (response) {
          // logger.log('_getUploadToken', requestTime);
          response.data.expiredTimeOut = response.data.expiredTime - requestTime;
          logger.log("UploadController._getAuthorizationKey timeout=".concat(response.data.expiredTimeOut, "s"));

          _this3._initializeMembers(response.data); // 设置基本配置


          _this3._expiredTimer();

          _this3._initUploaderMethod();
        })["catch"](function (error) {
          logger.warn(error);
        });
      }
      /**
       * 初始化COS SDK
       */

    }, {
      key: "_initCOSSDKPlugin",
      value: function _initCOSSDKPlugin() {
        var sdkName = IN_WX_MINI_APP ? 'cos-wx-sdk' : 'cos-js-sdk';
        this.COSSDK = this.tim.getPlugin(sdkName);
      }
      /**
       * 初始化上传方法
       */

    }, {
      key: "_initUploaderMethod",
      value: function _initUploaderMethod() {
        var _this4 = this;

        if (!this.appid) {
          return;
        }

        if (IN_WX_MINI_APP) {
          this.cos = new this.COSSDK({
            ForcePathStyle: true,
            getAuthorization: this._getAuthorization.bind(this)
          });
        } else {
          this.cos = new this.COSSDK({
            getAuthorization: this._getAuthorization.bind(this)
          });
        }

        if (IN_WX_MINI_APP) {
          this._cosUploadMethod = function (options, callback) {
            _this4.cos.postObject(options, callback);
          };
        } else {
          this._cosUploadMethod = function (options, callback) {
            _this4.cos.uploadFiles(options, callback); // this.cos.putObject(options, callback); // 这函数按说明调不了 ...

          };
        }

        this._IAmReady(); // 控制器 ready

      }
      /**
       *
       * @param {*} options - COS SDK 需要的options参数，暂时不知道有什么用， 但一定要有，否则不能正常callback
       * @param {*} callback - COS SDK 会使用这个callback来获取
       */

    }, {
      key: "_getAuthorization",
      value: function _getAuthorization(options, callback) {
        callback({
          TmpSecretId: this.cosOptions.secretId,
          TmpSecretKey: this.cosOptions.secretKey,
          XCosSecurityToken: this.cosOptions.sessionToken,
          ExpiredTime: this.cosOptions.expiredTime // SDK 在 ExpiredTime 时间前，不会再次调用 getAuthorization

        });
      }
    }, {
      key: "_IAmReady",
      value: function _IAmReady() {
        this.triggerReady();
      }
      /**
       * 上传图片类型WX
       * @param {object} options - 配置参数
       * @param {HTMLInputElement} options.file - 在web端运行时，为Input<type=file> 的 DOM 对象。
       * @param {Object} options.file - 在微信小程序运行时，为包含了上传文件信息的对象，可以通过 `wx.chooseImage()` 方法来获取此对象
       * @returns {Promise}
       * @example
       * // WEB端
       * html:
       * ```html
       * <input type='file' id='uploadInput'/>
       * ```
       * javascript:
       * ```javascript
       * this.tim.uploadContrller.uploadImage({
       *  file: document.querySelector('input#uploadInput')
       * })
       * ```
       *
       * // 微信小程序
       * ```javascript
       * wx.chooseImage(function(res){
       *
       * });
       * ```
       */

    }, {
      key: "uploadImage",
      value: function uploadImage(options) {
        if (!options.file) {
          return IMPromise.reject(new IMError({
            code: ERROR_CODE.MESSAGE_IMAGE_SELECT_FILE_FIRST,
            message: ERROR_MESSAGE.MESSAGE_IMAGE_SELECT_FILE_FIRST
          }));
        } // 判断图片类型


        var typeCheck = this._checkImageType(options.file);

        if (typeCheck !== true) {
          return typeCheck;
        } // 判断文件MIME ， 以防鱼目混珠，待实现


        var MIMECheck = this._checkImageMime(options.file);

        if (MIMECheck !== true) {
          return MIMECheck;
        } // 判断文件大小


        var sizeCheck = this._checkImageSize(options.file);

        if (sizeCheck !== true) {
          return sizeCheck;
        } // TODO: 图片压缩（优图，与cos有合作）


        return this.upload(options);
      }
      /**
       * 检测图片类型，目前仅通过后缀名检测，后期需要升级为MIME检测
       * @param {*} file - 文件对象
       * @returns {IMPromise}
       */

    }, {
      key: "_checkImageType",
      value: function _checkImageType(file) {
        var fileType = '';

        if (IN_WX_MINI_APP) {
          fileType = file.tempFiles[0].path.slice(file.tempFiles[0].path.lastIndexOf('.') + 1);
        } else {
          fileType = file.files[0].name.slice(file.files[0].name.lastIndexOf('.') + 1);
        }

        if (UPLOAD_IMAGE_TYPES_LIMIT.indexOf(fileType) >= 0) {
          return true;
        }

        return IMPromise.reject(new IMError({
          coe: ERROR_CODE.MESSAGE_IMAGE_TYPES_LIMIT,
          message: ERROR_MESSAGE.MESSAGE_IMAGE_TYPES_LIMIT
        }));
      }
      /**
       * 检测图片的mime，防止改后缀后进行鱼目混珠
       * @param {*} file - 文件对象
       * @returns {boolean}
       */

    }, {
      key: "_checkImageMime",
      value: function _checkImageMime(file) {
        // TODO: 检测图片的mime，防止改后缀后进行鱼目混珠, 待实现，注：此方法需要浏览器支持blob对象，小程序不支持
        // 如果是小程序环境，直接返回true ， 因为小程序不支持blob
        if (IN_WX_MINI_APP) {
          return true;
        }

        return true;
      }
      /**
       * 检测文件大小
       * @param {*} file - 文件对象
       * @returns {boolean}
       */

    }, {
      key: "_checkImageSize",
      value: function _checkImageSize(file) {
        var fileSize = 0;

        if (IN_WX_MINI_APP) {
          fileSize = file.tempFiles[0].size;
        } else {
          fileSize = file.files[0].size;
        }

        if (fileSize < UPLOAD_IMAGE_SIZE_LIMIT) {
          return true;
        }

        return IMPromise.reject(new IMError({
          coe: ERROR_CODE.MESSAGE_IMAGE_SIZE_LIMIT,
          message: "".concat(ERROR_MESSAGE.MESSAGE_IMAGE_SIZE_LIMIT, ": ").concat(UPLOAD_IMAGE_SIZE_LIMIT, " bytes")
        }));
      }
      /**
       * 上传文件类型
       * @param {object} options - 配置参数
       * @returns {IMPromise}
       */

    }, {
      key: "uploadFile",
      value: function uploadFile(options) {
        var imError = null;

        if (!options.file) {
          imError = new IMError({
            code: ERROR_CODE.MESSAGE_FILE_SELECT_FILE_FIRST,
            message: ERROR_MESSAGE.MESSAGE_FILE_SELECT_FILE_FIRST
          });
          return IMPromise.reject(imError);
        } // 检测文件大小 不能大于 UPLOAD_FILE_SIZE_LIMIT 的限制


        if (options.file.files[0].size > UPLOAD_FILE_SIZE_LIMIT) {
          // if (options.file.files[0].size>10) { // 测试代码 用于触发文件大小判断
          imError = new IMError({
            code: ERROR_CODE.MESSAGE_FILE_SIZE_LIMIT,
            message: "".concat(ERROR_MESSAGE.MESSAGE_FILE_SIZE_LIMIT, ": ").concat(UPLOAD_FILE_SIZE_LIMIT, " bytes")
          });
          return IMPromise.reject(imError);
        }

        return this.upload(options);
      }
      /**
       * 上传视频类型
       * @param {object} options - 配置参数
       * @returns {IMPromise}
       */

    }, {
      key: "uploadVideo",
      value: function uploadVideo(options) {
        if (!options.file) {
          return IMPromise.reject();
        }

        return this.upload(options);
      }
      /**
       * 上传音频类型
       * @param {object} options - 配置参数
       * @returns {IMPromise}
       */

    }, {
      key: "uploadSound",
      value: function uploadSound(options) {
        if (!options.file) {
          return IMPromise.reject(new IMError({
            code: ERROR_CODE.MESSAGE_SOUND_UPLOAD_FAIL,
            message: ERROR_MESSAGE.MESSAGE_SOUND_UPLOAD_FAIL
          }));
        }

        if (options.file.fileSize > UPLOAD_FILE_SIZE_LIMIT) {
          return IMPromise.reject(new IMError({
            code: ERROR_CODE.MESSAGE_FILE_SIZE_LIMIT,
            message: "".concat(ERROR_MESSAGE.MESSAGE_FILE_SIZE_LIMIT, ": ").concat(UPLOAD_FILE_SIZE_LIMIT, " bytes")
          }));
        }

        logger.log('uploadsound', options);
        return this.upload(options);
      }
      /**
       * 上传
       * @param {File} options - 上传参数配置
       * @returns {Promise}
       */

    }, {
      key: "upload",
      value: function upload(options) {
        var _this5 = this;

        logger.time(label.UPLOAD);
        var file = IN_WX_MINI_APP ? options.file : options.file.files[0];

        this._iniFileObjectMembersForWXMiniApp(file);

        return new Promise(function (revolve, reject) {
          var cosUploadOptions = IN_WX_MINI_APP ? _this5._createCosOptionsWXMiniApp(options) // 小程序配置
          : _this5._createCosOptionsWeb(options); // web 配置

          var self = _this5;

          _this5._cosUploadMethod(cosUploadOptions, function (error, data) {
            var result = Object.create(null);

            if (data) {
              // 检测上传错误
              if (_this5._isUploadError(data, error)) {
                // if (data.files[0].error!==null) {
                reject(data.files[0].error);
                logger.warn("UploadController.upload failed, network error:".concat(data.files[0].error.error));
                return;
              }

              result['fileName'] = file.name;
              result['fileSize'] = file.size;
              result['fileType'] = file.type.slice(file.type.indexOf('/') + 1).toUpperCase();

              if (IN_WX_MINI_APP) {
                // 小程序 SDK 返回值中，不带 files
                result['location'] = data.Location;
              } else {
                result['location'] = data.files[0].data.Location;
              }

              var time = logger.timeEnd(label.UPLOAD);

              var size = self._formatFileSize(file.size);

              var speed = self._formatSpeed(file.size * 1000 / time);

              logger.log("UploadController.upload success name=".concat(file.name, ",size=").concat(size, ",time=").concat(time, "ms,speed=").concat(speed));
              revolve(result);
              return;
            }

            logger.warn("UploadController.upload failed, error:".concat(error));
            reject(error);
          });
        });
      }
      /**
       * 检测上传是否成功
       * @param {object} data - 反馈数据
       * @param {object} error - 反馈错误
       * @returns {boolean}
       */

    }, {
      key: "_isUploadError",
      value: function _isUploadError(data, error) {
        if (IN_WX_MINI_APP) {
          return error ? true : false;
        }

        if (data.files[0].error !== null) {
          return true;
        }

        return false;
      }
    }, {
      key: "_formatFileSize",
      value: function _formatFileSize(size) {
        if (size < 1024) {
          // <1KB
          return size + 'B';
        }

        if (size < 1048576) {
          // 1KB <= size < 1MB
          return Math.floor(size / 1024) + 'KB';
        } // >= 1MB


        return Math.floor(size / 1048576) + 'MB';
      } // B/s转为KB/s或MB/s

    }, {
      key: "_formatSpeed",
      value: function _formatSpeed(speed) {
        if (speed <= 1048576) {
          var _temp = speed / 1024;

          return _temp.toFixed(1) + 'KB/s';
        }

        var temp = speed / 1048576;
        return temp.toFixed(1) + 'MB/s';
      }
      /**
       * 为小程序环境完善一下File实例的成员，方便统一处理
       */

    }, {
      key: "_iniFileObjectMembersForWXMiniApp",
      value: function _iniFileObjectMembersForWXMiniApp(file) {
        if (!IN_WX_MINI_APP) {
          return;
        }

        console.log('change', file);

        if (!file.name) {
          if (file.tempFilePaths) {
            file.name = file.tempFilePaths[0].slice(file.tempFilePaths[0].lastIndexOf('/') + 1);
          } else if (file.tempFilePath) {
            file.name = file.tempFilePath.slice(file.tempFilePath.lastIndexOf('/') + 1);
            file.tempFilePaths = [file.tempFilePath];
          }
        }

        if (file.tempFiles) {
          file.size = file.tempFiles[0].size;
        } else {
          file.size = file.fileSize;
        }

        file.type = file.name.slice(file.name.lastIndexOf('.') + 1).toUpperCase();
      }
      /**
       * 创建WEB COS上传配置
       * @param {object} options - 配置参数
       * @returns {object}
       */

    }, {
      key: "_createCosOptionsWeb",
      value: function _createCosOptionsWeb(options) {
        var from = this.tim.context.identifier;
        return {
          files: [{
            Bucket: "".concat(this.bucketName, "-").concat(this.appid),
            Region: this.region,
            Key: "imfiles/".concat(from, "/").concat(options.to, "-").concat(randomInt(9999999), "-").concat(options.file.files[0].name),
            Body: options.file.files[0]
          }],
          SliceSize: 1024 * 1024,
          onProgress: function onProgress(info) {
            if (typeof options.onProgress === 'function') {
              try {
                options.onProgress(info.percent);
              } catch (userError) {
                logger.warn('onProgress callback error:');
                logger.error(userError);
              }
            }
          },
          onFileFinish: function onFileFinish(err, data, options) {// logger.log(options.Key + ' cos upload ' + (err ? 'fail' : 'success'));
          }
        };
      }
      /**
       * 创建微信小程序 COS 上传配置
       * @param {object} options - 配置参数
       * @returns {object}
       */

    }, {
      key: "_createCosOptionsWXMiniApp",
      value: function _createCosOptionsWXMiniApp(options) {
        var from = this.tim.context.identifier;
        return {
          Bucket: "".concat(this.bucketName, "-").concat(this.appid),
          Region: this.region,
          Key: "imfiles/".concat(from, "/").concat(options.to, "-").concat(options.file.name),
          FilePath: options.file.tempFiles[0].path,
          onProgress: function onProgress(info) {
            logger.log(JSON.stringify(info));

            if (typeof options.onProgress === 'function') {
              try {
                options.onProgress(info.percent);
              } catch (userError) {
                logger.warn('onProgress callback error:');
                logger.error(userError);
              }
            }
          }
        };
      }
    }]);

    return UploadController;
  }(IMController);

  /**
   * 去重、合并消息列表 <br/>
   * 调用时机：消息收发、获取消息列表时。
   * @param {Message[]} head 排在头部的消息列表，合并后 head 中消息会排在 tail 之前
   * @param {Message[]} tail 排在尾部的消息列表，合并后 tail 中消息会排在 head 之后
   * @returns {Message[]} 合并后的消息列表
   */
  function mergeMessageList(head, tail) {
    var messageMap = new Map();
    var tempMessageList = [].concat(_toConsumableArray(head), _toConsumableArray(tail));

    for (var i = 0; i < tempMessageList.length; i++) {
      var message = tempMessageList[i];
      messageMap.set(message.ID, message);
    }

    return _toConsumableArray(messageMap.values());
  }

  var MTA_CONFIG={app_id:"",event_id:"",api_base:"https://pingtas.qq.com/pingd",prefix:"_mta_",version:"1.3.9",stat_share_app:!1,stat_pull_down_fresh:!1,stat_reach_bottom:!1,stat_param:!0};function getNetworkType(a){wx.getNetworkType({success:function(b){a(b.networkType);}});}
  function getSystemInfo(){var a=wx.getSystemInfoSync();return {adt:encodeURIComponent(a.model),scl:a.pixelRatio,scr:a.windowWidth+"x"+a.windowHeight,lg:a.language,fl:a.version,jv:encodeURIComponent(a.system),tz:encodeURIComponent(a.platform)}}function getUID(){try{return wx.getStorageSync(MTA_CONFIG.prefix+"auid")}catch(a){}}function setUID(){try{var a=getRandom();wx.setStorageSync(MTA_CONFIG.prefix+"auid",a);return a}catch(b){}}
  function getSID(){try{return wx.getStorageSync(MTA_CONFIG.prefix+"ssid")}catch(a){}}function setSID(){try{var a="s"+getRandom();wx.setStorageSync(MTA_CONFIG.prefix+"ssid",a);return a}catch(b){}}function getRandom(a){for(var b=[0,1,2,3,4,5,6,7,8,9],c=10;1<c;c--){var d=Math.floor(10*Math.random()),f=b[d];b[d]=b[c-1];b[c-1]=f;}for(c=d=0;5>c;c++)d=10*d+b[c];return (a||"")+(d+""+ +new Date)}
  function getPagePath(){try{var a=getCurrentPages(),b="/";0<a.length&&(b=a.pop().__route__);return b}catch(c){console.log("get current page path error:"+c);}}function getMainInfo(){var a={dm:"wechat.apps.xx",url:encodeURIComponent(getPagePath()+getQuery(MTA.Data.pageQuery)),pvi:"",si:"",ty:0};a.pvi=function(){var b=getUID();b||(b=setUID(),a.ty=1);return b}();a.si=function(){var a=getSID();a||(a=setSID());return a}();return a}
  function getBasicInfo(){var a=getSystemInfo();getNetworkType(function(a){try{wx.setStorageSync(MTA_CONFIG.prefix+"ntdata",a);}catch(c){}});a.ct=wx.getStorageSync(MTA_CONFIG.prefix+"ntdata")||"4g";return a}function getExtentInfo(){var a=MTA.Data.userInfo;var b=[],c;for(c in a)a.hasOwnProperty(c)&&b.push(c+"="+a[c]);a=b.join(";");return {r2:MTA_CONFIG.app_id,r4:"wx",ext:"v="+MTA_CONFIG.version+(null!==a&&""!==a?";ui="+encodeURIComponent(a):"")}}
  function getQuery(a){if(!MTA_CONFIG.stat_param||!a)return "";a=ignoreParams(a);var b=[],c;for(c in a)b.push(c+"="+a[c]);return 0<b.length?"?"+b.join("&"):""}function ignoreParams(a){if(1>MTA_CONFIG.ignore_params.length)return a;var b={},c;for(c in a)0<=MTA_CONFIG.ignore_params.indexOf(c)||(b[c]=a[c]);return b}
  function initOnload(){var a=Page;Page=function(b){var c=b.onLoad;b.onLoad=function(a){c&&c.call(this,a);MTA.Data.lastPageQuery=MTA.Data.pageQuery;MTA.Data.pageQuery=a;MTA.Data.lastPageUrl=MTA.Data.pageUrl;MTA.Data.pageUrl=getPagePath();MTA.Data.show=!1;MTA.Page.init();};a(b);};}
  var MTA={App:{init:function(a){"appID"in a&&(MTA_CONFIG.app_id=a.appID);"eventID"in a&&(MTA_CONFIG.event_id=a.eventID);"statShareApp"in a&&(MTA_CONFIG.stat_share_app=a.statShareApp);"statPullDownFresh"in a&&(MTA_CONFIG.stat_pull_down_fresh=a.statPullDownFresh);"statReachBottom"in a&&(MTA_CONFIG.stat_reach_bottom=a.statReachBottom);"ignoreParams"in a&&(MTA_CONFIG.ignore_params=a.ignoreParams);"statParam"in a&&(MTA_CONFIG.stat_param=a.statParam);setSID();try{"lauchOpts"in a&&(MTA.Data.lanchInfo=a.lauchOpts,
    MTA.Data.lanchInfo.landing=1);}catch(b){}"autoReport"in a&&a.autoReport&&initOnload();}},Page:{init:function(){var a=getCurrentPages()[getCurrentPages().length-1];a.onShow&&!function(){var b=a.onShow;a.onShow=function(){if(!0===MTA.Data.show){var a=MTA.Data.lastPageQuery;MTA.Data.lastPageQuery=MTA.Data.pageQuery;MTA.Data.pageQuery=a;MTA.Data.lastPageUrl=MTA.Data.pageUrl;MTA.Data.pageUrl=getPagePath();}MTA.Data.show=!0;MTA.Page.stat();b.apply(this,arguments);};}();MTA_CONFIG.stat_pull_down_fresh&&a.onPullDownRefresh&&
  !function(){var b=a.onPullDownRefresh;a.onPullDownRefresh=function(){MTA.Event.stat(MTA_CONFIG.prefix+"pulldownfresh",{url:a.__route__});b.apply(this,arguments);};}();MTA_CONFIG.stat_reach_bottom&&a.onReachBottom&&!function(){var b=a.onReachBottom;a.onReachBottom=function(){MTA.Event.stat(MTA_CONFIG.prefix+"reachbottom",{url:a.__route__});b.apply(this,arguments);};}();MTA_CONFIG.stat_share_app&&a.onShareAppMessage&&!function(){var b=a.onShareAppMessage;a.onShareAppMessage=function(){MTA.Event.stat(MTA_CONFIG.prefix+
    "shareapp",{url:a.__route__});return b.apply(this,arguments)};}();},multiStat:function(a,b){if(1==b)MTA.Page.stat(a),!0;else{var c=getCurrentPages()[getCurrentPages().length-1];c.onShow&&!function(){var b=c.onShow;c.onShow=function(){MTA.Page.stat(a);b.call(this,arguments);};}();}},stat:function(a){if(""!=MTA_CONFIG.app_id){var b=[],c=getExtentInfo();a&&(c.r2=a);a=[getMainInfo(),c,getBasicInfo()];if(MTA.Data.lanchInfo){a.push({ht:MTA.Data.lanchInfo.scene});MTA.Data.pageQuery&&MTA.Data.pageQuery._mta_ref_id&&
  a.push({rarg:MTA.Data.pageQuery._mta_ref_id});try{1==MTA.Data.lanchInfo.landing&&(c.ext+=";lp=1",MTA.Data.lanchInfo.landing=0);}catch(e){}}a.push({rdm:"/",rurl:0>=MTA.Data.lastPageUrl.length?MTA.Data.pageUrl+getQuery(MTA.Data.lastPageQuery):encodeURIComponent(MTA.Data.lastPageUrl+getQuery(MTA.Data.lastPageQuery))});a.push({rand:+new Date});c=0;for(var d=a.length;c<d;c++)for(var f in a[c])a[c].hasOwnProperty(f)&&b.push(f+"="+("undefined"==typeof a[c][f]?"":a[c][f]));wx.request({url:MTA_CONFIG.api_base+
  "?"+b.join("&").toLowerCase()});}}},Event:{stat:function(a,b){if(""!=MTA_CONFIG.event_id){var c=[],d=getMainInfo(),f=getExtentInfo();d.dm="wxapps.click";d.url=a;f.r2=MTA_CONFIG.event_id;var e="undefined"===typeof b?{}:b;var k=[],g;for(g in e)e.hasOwnProperty(g)&&k.push(encodeURIComponent(g)+"="+encodeURIComponent(e[g]));e=k.join(";");f.r5=e;e=0;d=[d,f,getBasicInfo(),{rand:+new Date}];for(f=d.length;e<f;e++)for(var h in d[e])d[e].hasOwnProperty(h)&&c.push(h+"="+("undefined"==typeof d[e][h]?"":d[e][h]));
    wx.request({url:MTA_CONFIG.api_base+"?"+c.join("&").toLowerCase()});}}},Data:{userInfo:null,lanchInfo:null,pageQuery:null,lastPageQuery:null,pageUrl:"",lastPageUrl:"",show:!1}};var mtaWechatAnalysis=MTA;

  /**
   * 封装 MTA SDK，兼容 Web 和 小程序
   * {@link https://mta.qq.com/docs/h5.html MTA Web接入}
   * {@link https://mta.qq.com/docs/wechat_mini_program.html MTA 小程序接入}
   * @class MTA
   * @author rychouwei
   */

  var MTA$1 =
  /*#__PURE__*/
  function () {
    function MTA() {
      _classCallCheck(this, MTA);

      this.cache = []; // 缓存队列。Web端的MTA是异步加载的，若 MTA 没加载完成，触发了 report，则先进入缓存队列。下次 report 时再上报。

      this.MtaWX = null;

      this._init();
    }
    /**
     * 手动上报事件，具体配置参考
     * {@link https://mta.qq.com/h5/visitor/ctr_custom_param_config?custom_id=246778&app_id=500690998 Web}
     * {@link https://mta.qq.com/wechat_mini/custom/ctr_custom_param_config?app_id=500690995&custom_id=246775 小程序}
     * @param {String} name
     * @param {Object} param
     * @memberof MTA
     * @example
     * tim.mta.report('sendmessage', { send: true })
     */


    _createClass(MTA, [{
      key: "report",
      value: function report(name, param) {
        var _this = this;

        try {
          // Web
          if (IN_BROWSER) {
            if (window.MtaH5) {
              window.MtaH5.clickStat(name, param); // 上报缓存队列的事件

              this.cache.forEach(function (_ref) {
                var name = _ref.name,
                    param = _ref.param;
                window.MtaH5.clickStat(name, param);

                _this.cache.shift();
              });
            } else {
              // 将事件缓存
              this.cache.push({
                name: name,
                param: param
              });
            }
          } else if (IN_WX_MINI_APP) {
            // 小程序
            if (this.MtaWX) {
              this.MtaWX.Event.stat(name, param); // 上报缓存队列的事件

              this.cache.forEach(function (_ref2) {
                var name = _ref2.name,
                    param = _ref2.param;

                _this.MtaWX.stat(name, param);

                _this.cache.shift();
              });
            } else {
              // 将事件缓存
              this.cache.push({
                name: name,
                param: param
              });
            }
          }
        } catch (error) {} // 拦截错误即可，不做处理

      }
      /**
       * 统计上报，统计PV等数据
       * @memberof MTA
       */

    }, {
      key: "stat",
      value: function stat() {
        try {
          if (IN_BROWSER && window.MtaH5) {
            window.MtaH5.pgv();
          } else if (IN_WX_MINI_APP && this.MtaWX) {
            this.MtaWX.Page.stat();
          }
        } catch (error) {} // 拦截错误即可，不做处理

      }
      /**
       * 初始化
       * @private
       * @memberof MTA
       */

    }, {
      key: "_init",
      value: function _init() {
        try {
          if (IN_BROWSER) {
            window._mtac = {
              autoReport: 0
            };
            var mta = document.createElement('script');
            var proto = getPageProtocol();
            mta.src = "".concat(proto, "//pingjs.qq.com/h5/stats.js?v2.0.4");
            mta.setAttribute('name', 'MTAH5');
            mta.setAttribute('sid', '500690998');
            mta.setAttribute('cid', '500691017');
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(mta, s);
          } else if (IN_WX_MINI_APP) {
            this.MtaWX = mtaWechatAnalysis;
            this.MtaWX.App.init({
              appID: '500690995',
              eventID: '500691014',
              // 高级功能-自定义事件统计ID，配置开通后在初始化处填写
              autoReport: false,
              statParam: true
            });
          }
        } catch (error) {}
      }
    }]);

    return MTA;
  }();

  /**
   * 上报控制器，基于 MTA
   * @class ReporterController
   * @extends {IMController}
   * @author rychouwei
   */

  var ReporterController =
  /*#__PURE__*/
  function (_IMController) {
    _inherits(ReporterController, _IMController);

    function ReporterController(tim) {
      var _this;

      _classCallCheck(this, ReporterController);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(ReporterController).call(this, tim));
      _this.tim = tim;
      _this.MTA = new MTA$1();

      _this._initListener();

      return _this;
    }

    _createClass(ReporterController, [{
      key: "_initListener",
      value: function _initListener() {
        var _this2 = this;

        var innerEmitter = this.tim.innerEmitter;

        this._sendMessageSuccessRateReport();

        this._loginSuccessRateReport();

        innerEmitter.on(TIM_INNER_EVENT.SDK_READY, function () {
          // 统计 SDK appID
          _this2.MTA.report('sdkappid', {
            value: _this2.tim.context.SDKAppID
          }); // 统计版本号


          _this2.MTA.report('version', {
            value: TIM.VERSION
          }); // 统计 PV


          _this2.MTA.stat();
        });
      }
      /**
       * 发消息成功率统计上报
       * @private
       * @memberof ReporterController
       */

    }, {
      key: "_sendMessageSuccessRateReport",
      value: function _sendMessageSuccessRateReport() {
        var _this3 = this;

        var innerEmitter = this.tim.innerEmitter;
        innerEmitter.on(TIM_INNER_EVENT.MESSAGE_SENDING, function () {
          _this3.MTA.report('sendmessage', {
            send: 1
          });
        });
        innerEmitter.on(TIM_INNER_EVENT.MESSAGE_C2C_SEND_SUCCESS, function () {
          _this3.MTA.report('sendmessage', {
            success: 1
          });
        });
        innerEmitter.on(TIM_INNER_EVENT.MESSAGE_C2C_SEND_FAIL, function () {
          _this3.MTA.report('sendmessage', {
            fail: 1
          });
        });
        innerEmitter.on(TIM_INNER_EVENT.MESSAGE_GROUP_SEND_SUCCESS, function () {
          _this3.MTA.report('sendmessage', {
            success: 1
          });
        });
        innerEmitter.on(TIM_INNER_EVENT.MESSAGE_GROUP_SEND_FAIL, function () {
          _this3.MTA.report('sendmessage', {
            fail: 1
          });
        });
      }
      /**
       * 登录成功率统计上报
       * @private
       * @memberof ReporterController
       */

    }, {
      key: "_loginSuccessRateReport",
      value: function _loginSuccessRateReport() {
        var _this4 = this;

        var innerEmitter = this.tim.innerEmitter;
        innerEmitter.on(TIM_INNER_EVENT.SIGN_LOGIN, function () {
          _this4.MTA.report('login', {
            login: 1
          });
        });
        innerEmitter.on(TIM_INNER_EVENT.SIGN_LOGIN_SUCCESS, function () {
          _this4.MTA.report('login', {
            success: 1
          });
        });
        innerEmitter.on(TIM_INNER_EVENT.SIGN_LOGIN_FAIL, function () {
          _this4.MTA.report('login', {
            fail: 1
          });
        });
      }
    }]);

    return ReporterController;
  }(IMController);

  var SDK$1 =
  /*#__PURE__*/
  function () {
    //@param { String } [options.clipboardListenrElement] - 剪切板监听对象，用来支持图片粘贴功能，如不填写，默认监听 body 元素
    //@tutorial 01-quick-start

    /**
     * ### 即时通信 IM SDK 基本概念：
     * | 基本概念 | 说明 |
     * | :--- | :---- |
     * | Message（消息） | IM SDK 中 [Message](https://imsdk-1252463788.file.myqcloud.com/IM_DOC/Web/Message.html) 表示要发送给对方的内容，消息包括若干属性，例如自己是否为发送者，发送人帐号以及消息产生时间等。 |
     * | Conversation（会话） | IM SDK 中 [Conversation](https://imsdk-1252463788.file.myqcloud.com/IM_DOC/Web/Conversation.html) 分为两种：<li> C2C（Client to Client）会话，表示单聊情况，自己与对方建立的对话。</li><li> GROUP（群）会话，表示群聊情况下群内成员组成的会话。 |
     * | Profile（资料） | IM SDK 中 [Profile](https://imsdk-1252463788.file.myqcloud.com/IM_DOC/Web/Profile.html) 描述个人的常用基本信息，例如昵称、性别、个性签名以及头像地址等。 |
     * | Group（群组） | IM SDK 中 [Group](https://imsdk-1252463788.file.myqcloud.com/IM_DOC/Web/Group.html) 表示一个支持多人聊天的通信系统，支持私有群、公开群、聊天室以及音视频聊天室。 |
     * | GroupMember（群成员） | IM SDK 中 [GroupMember](https://imsdk-1252463788.file.myqcloud.com/IM_DOC/Web/GroupMember.html) 描述群内成员的常用基本信息，例如 ID、昵称、群内身份以及入群时间等。 |
     * | 群提示消息 | 当有用户被邀请加入群组或被移出群组等事件发生时，群内会产生提示消息，接入侧可以根据实际需求展示给群组用户或忽略。<br/>群提示消息有多种类型，详细描述请参见  [Message.GroupTipPayload](https://imsdk-1252463788.file.myqcloud.com/IM_DOC/Web/Message.html#.GroupTipPayload)。  |
     * | 群系统通知消息 | 当有用户申请加群等事件发生时，管理员会收到申请加群等系统消息。管理员同意或拒绝加群申请，IM SDK 会通过群系统通知消息将申请加群等相应消息发送给接入侧，由接入侧展示给用户。<br/>群系统通知消息有多种类型，详细描述请参见 [Message.GroupSystemNoticePayload](https://imsdk-1252463788.file.myqcloud.com/IM_DOC/Web/Message.html#.GroupSystemNoticePayload)。  |
     * | 消息上屏 | 用户单击发送后，事先输入的文字或选择的图片等信息显示在用户电脑屏幕或手机屏幕上的过程。 |<br/>
     *
     * ### 支持的平台：<br/>
     * - IM SDK 支持 IE 9+、Chrome、微信、手机QQ、QQ 浏览器、FireFox、Opera 和 Safari。
     *
     * ### Web项目集成 SDK
     * | 集成方式 | 示例 |
     * | :--- | :---- |
     * | NPM 集成 | // IM Web SDK<br/>npm install tim-js-sdk --save<br/>// 发送图片、文件等消息需要的 COS SDK<br/>npm install cos-js-sdk-v5 --save<br/> |
     * | Script 集成 | 在您的项目中使用 script 标签引入 SDK，并初始化<br/>IM Web SDK 下载地址：[IM Web SDK](https://github.com/tencentyun/TIMSDK/tree/master/H5)<br/>腾讯云 COS JS SDK 源码下载地址：[腾讯云 COS JS SDK](https://github.com/tencentyun/cos-js-sdk-v5)|
     *
     * ### 微信小程序项目集成 SDK
     * | 集成方式 | 示例 |
     * | :--- | :---- |
     * | NPM 集成 | // IM 小程序 SDK<br/>npm install tim-wx-sdk --save<br/>// 发送图片、文件等消息需要的 COS SDK<br/>npm install cos-wx-sdk-v5 --save<br/> |
     * @constructs
     * @param { Object } options - 应用配置
     * @param { Number } options.SDKAppID - 云通信应用的 `SDKAppID`
     * @example
     * import TIM from 'tim-js-sdk';
     * // import TIM from 'tim-wx-sdk'; // 微信小程序环境请取消本行注释，并注释掉 import TIM from 'tim-js-sdk';
     * import COS from 'cos-js-sdk-v5';
     * // import COS from 'cos-wx-sdk-v5'; // 微信小程序环境请取消本行注释，并注释掉 import COS from 'cos-js-sdk-v5';
     *
     * // 创建 SDK 实例，TIM.create() 方法对于同一个 SDKAppID 只会返回同一份实例
     * let options = {
     *   SDKAppID: 0 // 接入时需要将0替换为您的即时通信应用的 SDKAppID
     * };
     * let tim = TIM.create(options); // SDK 实例通常用 tim 表示
     * // 设置 SDK 日志输出级别为 release 级别，详细分级请参见 setLogLevel 接口的说明
     * tim.setLogLevel(1);
     *
     * // 将腾讯云对象存储服务 SDK （以下简称 COS SDK）注册为插件，IM SDK 发送文件、图片等消息时，需要用到腾讯云的[ COS 服务]{@link https://cloud.tencent.com/document/product/436/6268}
     * // HTML5 环境，注册 COS SDK
     * tim.registerPlugin({'cos-js-sdk': COS});
     *
     * // 微信小程序环境，注册 COS SDK
     * //tim.registerPlugin({'cos-wx-sdk': COS}); // 微信小程序环境请取消本行注释，并注释掉 tim.registerPlugin({'cos-js-sdk': COS});
     *
     * // 监听事件，如：
     * tim.on(TIM.EVENT.SDK_READY, function(event) {
     *   // 收到离线消息和会话列表同步完毕通知，接入侧可以调用 sendMessage 等需要鉴权的接口
     *   // event.name - TIM.EVENT.SDK_READY
     * });
     *
     * tim.on(TIM.EVENT.MESSAGE_RECEIVED, function(event) {
     *   // 收到推送的新消息，可通过遍历 event.data 获取消息列表数据并渲染到页面
     *   // event.name - TIM.EVENT.MESSAGE_RECEIVED
     *   // event.data - 存储 Message 对象的数组 - [Message]
     * });
     *
     * tim.on(TIM.EVENT.CONVERSATION_LIST_UPDATED, function(event) {
     *   // 收到会话列表更新通知，可通过遍历 event.data 获取会话列表数据并渲染到页面
     *   // event.name - TIM.EVENT.CONVERSATION_LIST_UPDATED
     *   // event.data - 存储 Conversation 对象的数组 - [Conversation]
     * });
     *
     * tim.on(TIM.EVENT.GROUP_LIST_UPDATED, function(event) {
     *   // 收到群组列表更新通知，可通过遍历 event.data 获取群组列表数据并渲染到页面
     *   // event.name - TIM.EVENT.GROUP_LIST_UPDATED
     *   // event.data - 存储 Group 对象的数组 - [Group]
     * });
     *
     * tim.on(TIM.EVENT.GROUP_SYSTEM_NOTICE_RECERIVED, function(event) {
     *   // 收到新的群系统通知
     *   // event.name - TIM.EVENT.GROUP_SYSTEM_NOTICE_RECERIVED
     *   // event.data.type - 群系统通知的类型，详情请参见 GroupSystemNoticePayload 的 <a href="https://imsdk-1252463788.file.myqcloud.com/IM_DOC/Web/Message.html#.GroupSystemNoticePayload"> operationType 枚举值说明</a>
     *   // event.data.message - Message 对象，可将 event.data.message.content 渲染到到页面
     * });
     *
     * tim.on(TIM.EVENT.PROFILE_UPDATED, function(event) {
     *   // 收到自己或好友的资料变更通知
     *   // event.name - TIM.EVENT.PROFILE_UPDATED
     *   // event.data - 存储 Profile 对象的数组 - [Profile]
     * });
     *
     * tim.on(TIM.EVENT.BLACKLIST_UPDATED, function(event) {
     *   // 收到黑名单列表更新通知
     *   // event.name - TIM.EVENT.BLACKLIST_UPDATED
     *   // event.data - 存储 userID 的数组 - [userID]
     * });
     *
     * tim.on(TIM.EVENT.ERROR, function(event) {
     *   // 收到 SDK 发生错误通知，可以获取错误码和错误信息
     *   // event.name - TIM.EVENT.ERROR
     *   // event.data.code - 错误码
     *   // event.data.message - 错误信息
     * });
     *
     * tim.on(TIM.EVENT.SDK_NOT_READY, function(event) {
     *   // 收到 SDK 进入 not ready 状态通知，此时 SDK 无法正常工作
     *   // event.name - TIM.EVENT.SDK_NOT_READY
     * });
     *
     * tim.on(TIM.EVENT.KICKED_OUT, function(event) {
     *   // 收到被踢下线通知
     *   // event.name - TIM.EVENT.KICKED_OUT
     *   // event.data.type - 被踢下线的原因，例如 TIM.TYPES.KICKED_OUT_MULT_ACCOUNT 多账号登录被踢
     * });
     *
     * // 开始登录
     * tim.login({userID: 'your userID', userSig: 'your userSig'});
     */
    function SDK(options) {
      _classCallCheck(this, SDK);

      ReadyStatus.mixin(this);
      this.setLogLevel(0);
      logger.warn("SDK inWxMiniApp:".concat(IN_WX_MINI_APP, ", SDKAppID:").concat(options.SDKAppID));
      logger.warn("UserAgent:".concat(USER_AGENT));

      this._initOptions(options); // 初始化实例配置


      this._initMemberVariables(); // 初始化成员变量


      this._initControllers(); // 加载控制器


      this._initListener();
    } //   ______   __            __                  __
    //  /      \ |  \          |  \                |  \
    // |  $$$$$$\| $$  ______  | $$____    ______  | $$
    // | $$ __\$$| $$ /      \ | $$    \  |      \ | $$
    // | $$|    \| $$|  $$$$$$\| $$$$$$$\  \$$$$$$\| $$
    // | $$ \$$$$| $$| $$  | $$| $$  | $$ /      $$| $$
    // | $$__| $$| $$| $$__/ $$| $$__/ $$|  $$$$$$$| $$
    //  \$$    $$| $$ \$$    $$| $$    $$ \$$    $$| $$
    //   \$$$$$$  \$$  \$$$$$$  \$$$$$$$   \$$$$$$$ \$$
    //
    //  Global 登录、登出、事件监听

    /**
     * @description 使用 用户ID(userID) 和 签名串(userSig) 登录即时通信 IM，登录流程有若干个异步执行的步骤，使用返回的 Promise 对象处理登录成功或失败。<br/>
     * >注意：默认情况下，不支持多实例登录，即如果此帐号已在其他页面登录，若继续在当前页面登录成功，有可能会将其他页面踢下线。用户被踢下线时会触发事件`KICKED_OUT`，用户可在监听到事件后做相应处理。<br/>
     * 如需支持多实例登录（允许在多个网页中同时登录同一帐号），请到 [即时通信 IM 控制台](https://console.cloud.tencent.com/avc)，找到相应 SDKAppID，【应用配置】 > 【功能配置】> 【Web端实例同时在线】配置实例个数。配置将在50分钟内生效。
     * @param {Object} options - 登录配置
     * @param {String} options.userID 用户 ID
     * @param {String} options.userSig 用户登录即时通信 IM 的密码，其本质是对 UserID 等信息加密后得到的密文。<br/>具体生成方法请参见{@link https://cloud.tencent.com/document/product/269/32688 生成 UserSig}。
     * @returns {Promise}
     * @example
     * let promise = tim.login({userID: 'your userID', userSig: 'your userSig'});
     * promise.then(function(imResponse) {
     *   console.log(imResponse.data); // 登录成功
     * }).catch(function(imError) {
     *   console.warn('login error:', imError); // 登录失败的相关信息
     * });
     */


    _createClass(SDK, [{
      key: "login",
      value: function login(options) {
        logger.time(label.SDK_READY); // 对外接口描述及参数用userID或userIDList，sdk内部仍然用identifier。identifier和userID所指相同，即用户的唯一标识

        this.loginInfo.identifier = options.identifier || options.userID;
        this.loginInfo.userSig = options.userSig;
        return this.signController.login(this.loginInfo);
      }
      /**
       * @description 登出即时通信 IM，通常在切换帐号的时候调用，清除登录态以及内存中的所有数据。<br/>
       * >注意：在多实例被踢时（同一设备，多个页面登录同一账号），SDK 内部会执行登出流程，再抛出 [KICKED_OUT ](https://imsdk-1252463788.file.myqcloud.com/IM_DOC/Web/module-EVENT.html#.KICKED_OUT)事件。接入侧可在事件触发时，跳转到登录页面。
       * @returns {Promise}
       * @example
       * let promise = tim.logout();
       * promise.then(function(imResponse) {
       *   console.log(imResponse.data); // 登出成功
       * }).catch(function(imError) {
       *   console.warn('logout error:', imError);
       * });
       */

    }, {
      key: "logout",
      value: function logout() {
        var result = this.signController.logout();
        this.resetSDK();
        return result;
      }
      /**
       * @description 监听事件。
       * @param {String} eventName
       *        事件名称。所有的事件名称都存放在 `TIM.EVENT` 变量中，如需要查看可以使用 `console.log(TIM.EVENT)` 把所有的事件显示出来。{@link module:EVENT 事件列表}
       * @param {Function} handler
       *        处理事件的方法，当事件触发时，会调用此handler进行处理。
       * @param {*} [context] 期望 handler 执行时的上下文
       * @example
       * let onMessageReceived = function(event) {
       *   // 收到推送的新消息，可通过遍历 event.data 获取消息列表数据并渲染到页面
       *   // event.name - TIM.EVENT.MESSAGE_RECEIVED
       *   // event.data - 存储 Message 对象的数组 - [Message]
       * };
       * tim.on(TIM.EVENT.MESSAGE_RECEIVED, onMessageReceived);
       */

    }, {
      key: "on",
      value: function on(eventName, handler, context) {
        logger.debug('on', "eventName:".concat(eventName));
        this.outerEmitter.on(eventName, handler, context || this);
      }
      /**
       * @description 事件监听函数只执行一次。
       * @param {String} eventName
       *        事件名称。所有的事件名称都存放在 `TIM.EVENT` 变量中，如需要查看可以使用 `console.log(TIM.EVENT)` 把所有的事件显示出来。{@link module:EVENT 事件列表}
       * @param {Function} handler
       *        处理事件的方法，当事件触发时，会调用此handler进行处理。
       * @param {*} [context] 期望 handler 执行时的上下文
       * @private
       */

    }, {
      key: "once",
      value: function once(eventName, handler, context) {
        logger.debug('once', "eventName:".concat(eventName));
        this.outerEmitter.once(eventName, handler, context || this);
      }
      /**
       * @description 取消监听事件。
       * @param {String} eventName
       *        事件名称。所有的事件名称都存放在 `TIM.EVENT` 变量中，如需要查看可以使用 `console.log(TIM.EVENT)` 把所有的事件显示出来。{@link module:EVENT 事件列表}
       * @param {Function} handler
       *        处理事件的方法，当事件触发时，会调用此handler进行处理。
       * @param {*} [context] 期望 handler 执行时的上下文
       * @param {Boolean} [once]
       * @example
       * let onMessageReceived = function(event) {
       *   // 收到推送的新消息，可通过遍历 event.data 获取消息列表数据并渲染到页面
       *   // event.name - TIM.EVENT.MESSAGE_RECEIVED
       *   // event.data - 存储 Message 对象的数组 - [Message]
       * };
       * tim.off(TIM.EVENT.MESSAGE_RECEIVED, onMessageReceived);
       */

    }, {
      key: "off",
      value: function off(eventName, handler, context, once) {
        logger.debug('off', "eventName:".concat(eventName));
        this.outerEmitter.off(eventName, handler, context, once);
      }
      /**
       * @description 注册插件。<br>
       * 插件是一种遵循一定规范的应用程序接口编写出来的程序。在即时通信 IM SDK，发送图片、文件消息需要先将图片、文件上传到腾讯云对象存储，发送文本消息则不用，<br/>
       * 且在 HTML5 和小程序环境，上传图片、文件需要用到不同的文件上传 SDK 。因此我们将此功能设计成插件机制，方便您根据实际需要做定制化开发。
       * @param {Object} optoins 插件配置
       * @param {String} optoins.key 插件名称，目前支持的插件名称有：
       * - cos-wx-sdk 腾讯云对象存储{@link https://cloud.tencent.com/document/product/436/31953 小程序上传SDK}
       * - cos-js-sdk 腾讯云对象存储{@link https://cloud.tencent.com/document/product/436/11459 JavaScript上传SDK}，适用于HTML5环境
       * @param {Class} optoins.value 插件类
       * @example
       * // 微信小程序环境
       * import COS from 'cos-wx-sdk-v5';
       * tim.registerPlugin({'cos-wx-sdk': COS}); // 在 login 前调用，以支持文件上传腾讯云对象存储
       * tim.login({userID: 'your userID', userSig: 'your userSig'});
       *
       * @example
       * // HTML5 环境
       * import COS from 'cos-js-sdk-v5';
       * tim.registerPlugin({'cos-js-sdk': COS}); // 在 login 前调用，以支持文件上传腾讯云对象存储
       * tim.login({userID: 'your userID', userSig: 'your userSig'});
       */

    }, {
      key: "registerPlugin",
      value: function registerPlugin(optoins) {
        var _this = this;

        if (!this.plugins) {
          this.plugins = {};
        }

        Object.keys(optoins).forEach(function (item) {
          _this.plugins[item] = optoins[item];
        });
      }
      /**
       * 获取插件类。
       * @param {*} name
       * @private
       */

    }, {
      key: "getPlugin",
      value: function getPlugin(name) {
        return this.plugins[name] || undefined;
      }
      /**
       * 去重、合并消息列表 <br/>
       * 调用时机：消息收发、获取消息列表时。
       * @param {Message[]} head 排在头部的消息列表，合并后 head 中消息会排在 tail 之前
       * @param {Message[]} tail 排在尾部的消息列表，合并后 tail 中消息会排在 head 之后
       * @returns {Message[]} 合并后的消息列表
       * @example
       * let currentMessageList = []; // 当前会话的消息列表
       * // 1. 获取到消息列表时。将获取到的消息列表放在第一个参数，当前消息列表放第二个参数。
       * tim.getMessageList({conversationID: 'C2CTest'})
       * .then(imResponse=>{
       *  let currentMessageList = tim.mergeMessageList(imResponse.data.messageList, currentMessageList)
       * })
       * // 2. 消息收发时。将当前消息列表放第一个参数，收发的消息放第二个参数
       * // 2.1 发送消息时。event.data 值是单条消息对象
       * tim.on(TIM.EVENT.MESSAGE_SENDING, event => {
       *  let currentMessageList = tim.mergeMessageList(currentMessageList, [event.data])
       * })
       * // 2.2收到消息时。event.data 值是多条消息对象数组
       * tim.on(TIM.EVENT.MESSAGE_RECEIVED, event => {
       *  let currentMessageList = tim.mergeMessageList(currentMessageList, event.data)
       * })
       * @private
       */

    }, {
      key: "mergeMessageList",
      value: function mergeMessageList$1(head, tail) {
        return mergeMessageList(head, tail);
      }
      /**
       * @description 设置日志级别，低于 level 的日志将不会输出。
       * @param {Number} level - 日志级别
       * - 0 普通级别，日志量较多，接入时建议使用
       * - 1 release级别，SDK 输出关键信息，生产环境时建议使用
       * - 2 告警级别，SDK 只输出告警和错误级别的日志
       * - 3 错误级别，SDK 只输出错误级别的日志
       * - 4 无日志级别，SDK 将不打印任何日志
       * @example
       * tim.setLogLevel(1);
       */

    }, {
      key: "setLogLevel",
      value: function setLogLevel(level) {
        logger.setLevel(level);
      }
      /**
       * @description 获取sdk缓存的日志信息。
       * @returns sdk缓存的最近的1000条日志，类型为数组
       * @example
       * let ret = tim.getLog();
       * console.log(ret); // 可将日志列表转成长字符串上报
       * @private
       */

    }, {
      key: "getLog",
      value: function getLog() {
        return logger.getLog();
      }
      /**
       * 保存sdk缓存的日志信息到本地文件，文件名字格式：TIM-年-月-日-SDKAppID-userID.txt
       * > 不支持微信小程序和移动端浏览器环境
       * @example
       * tim.downloadLog();
       * @private
       */

    }, {
      key: "downloadLog",
      value: function downloadLog() {
        var link = document.createElement('a');
        var date = new Date();
        var blob = new Blob(this.getLog());
        link.download = 'TIM-' + date.getFullYear() + '-' + (date.getMonth() + 1) + '-' + date.getDate() + '-' + this.loginInfo.SDKAppID + '-' + this.context.identifier + '.txt';
        link.href = URL.createObjectURL(blob);
        link.click();
        URL.revokeObjectURL(blob);
      }
      /**
       * @private
       * @description 销毁 SDK 实例，管理多实例时用
       * @example
       * tim.destroy();
       */

    }, {
      key: "destroy",
      value: function destroy() {
        this.logout();
        this.outerEmitter.emit(TIM_OUTER_EVENT.SDK_DESTROY, {
          SDKAppID: this.loginInfo.SDKAppID
        }); // TODO: 解绑所有事件
      }
      /**
       * @typedef Promise
       * @property {function} then - 正常回调，参数为： {@link IMResponse}
       * @property {function} catch - 异常回调，参数为： {@link IMError}
       */

      /**
       * @typedef IMResponse
       * @property {String} code - 返回码, 值为0
       * @property {*} data - API 相关数据
       */

      /**
       * @typedef IMError
       * @description 错误对象
       * @property {String} code - 错误码
       * @property {String} message - 错误信息
       * @property {Object} stack - 错误堆栈信息
       */

      /**
       * @typedef IMEvent
       * @description 事件对象类型，在监听函数响应时返回
       * @property {String} name - 事件名称
       * @property {*} data - 事件数据
       */
      //  __       __
      // |  \     /  \
      // | $$\   /  $$  ______    _______   _______   ______    ______    ______
      // | $$$\ /  $$$ /      \  /       \ /       \ |      \  /      \  /      \
      // | $$$$\  $$$$|  $$$$$$\|  $$$$$$$|  $$$$$$$  \$$$$$$\|  $$$$$$\|  $$$$$$\
      // | $$\$$ $$ $$| $$    $$ \$$    \  \$$    \  /      $$| $$  | $$| $$    $$
      // | $$ \$$$| $$| $$$$$$$$ _\$$$$$$\ _\$$$$$$\|  $$$$$$$| $$__| $$| $$$$$$$$
      // | $$  \$ | $$ \$$     \|       $$|       $$ \$$    $$ \$$    $$ \$$     \
      //  \$$      \$$  \$$$$$$$ \$$$$$$$  \$$$$$$$   \$$$$$$$ _\$$$$$$$  \$$$$$$$
      //                                                      |  \__| $$
      //                                                       \$$    $$
      //                                                        \$$$$$$
      // Message 发送消息，同步消息

      /**
       * 创建文本消息的接口，此接口返回一个消息实例，可以在需要发送文本消息时调用 [发送消息](https://imsdk-1252463788.file.myqcloud.com/IM_DOC/Web/SDK.html#sendMessage) 接口发送消息。
       * @param {Object} options
       * @param {String} options.to - 消息接收方的 userID 或 groupID
       * @param {String} options.conversationType - 会话类型，取值`TIM.TYPES.CONV_C2C`（端到端会话） 或 `TIM.TYPES.CONV_GROUP`（群组会话）
       * @param {Object} options.payload - 消息内容的容器
       * @param {String} options.payload.text - 消息文本内容
       * @returns {Message} 消息实例
       * @example
       * // 发送文本消息，Web 端与小程序端相同
       * // 1. 创建消息实例，接口返回的实例可以上屏
       * let message = tim.createTextMessage({
       *   to: 'user1',
       *   conversationType: TIM.TYPES.CONV_C2C,
       *   payload: {
       *     text: 'Hello world!'
       *   }
       * });
       * // 2. 发送消息
       * let promise = tim.sendMessage(message);
       * promise.then(function(imResponse) {
       *   // 发送成功
       *   console.log(imResponse);
       * }).catch(function(imError) {
       *   // 发送失败
       *   console.warn('sendMessage error:', imError);
       * });
       */

    }, {
      key: "createTextMessage",
      value: function createTextMessage(options) {
        return this.messageController.createTextMessage(options);
      }
      /**
       * 创建图片消息的接口，此接口返回一个消息实例，可以在需要发送图片消息时调用 [发送消息](https://imsdk-1252463788.file.myqcloud.com/IM_DOC/Web/SDK.html#sendMessage) 接口发送消息。
       * @param {Object} options
       * @param {String} options.to - 消息接收方的 userID 或 groupID
       * @param {String} options.conversationType - 会话类型，取值`TIM.TYPES.CONV_C2C`（端到端会话） 或 `TIM.TYPES.CONV_GROUP`（群组会话）
       * @param {Object} options.payload
       * @param {HTMLInputElement|Object} options.payload.file 用于选择图片的 DOM 节点（Web）或者微信小程序 `wx.chooseImage` 接口的 `success` 回调参数。SDK 会读取其中的数据并上传图片。
       * @param {Function} options.onProgress - 获取上传进度的回调函数
       * @returns {Message} 消息实例
       * @example
       * // Web 端发送图片消息
       * // 1. 创建消息实例，接口返回的实例可以上屏
       * let message = tim.createImageMessage({
       *   to: 'user1',
       *   conversationType: TIM.TYPES.CONV_C2C,
       *   payload: {
       *     file: document.getElementById('imagePicker'),
       *   },
       *   onProgress: function(event) { console.log('file uploading:', event) }
       * });
       * // 2. 发送消息
       * let promise = tim.sendMessage(message);
       * promise.then(function(imResponse) {
       *   // 发送成功
       *   console.log(imResponse);
       * }).catch(function(imError) {
       *   // 发送失败
       *   console.warn('sendMessage error:', imError);
       * });
       * @example
       * // 小程序端发送图片
       * // 1. 选择图片
       * wx.chooseImage({
       *   sourceType: ['album'], // 从相册选择
       *   count: 1, // 只选一张，目前 SDK 不支持一次发送多张图片
       *   success: function (res) {
       *     // 2. 创建消息实例，接口返回的实例可以上屏
       *     let message = tim.createImageMessage({
       *       to: 'user1',
       *       conversationType: TIM.TYPES.CONV_C2C,
       *       payload: { file: res },
       *       onProgress: function(event) { console.log('file uploading:', event) }
       *     });
       *     // 3. 发送图片
       *     let promise = tim.sendMessage(message);
       *     promise.then(function(imResponse) {
       *       // 发送成功
       *       console.log(imResponse);
       *     }).catch(function(imError) {
       *       // 发送失败
       *       console.warn('sendMessage error:', imError);
       *     });
       *   }
       * })
       */

    }, {
      key: "createImageMessage",
      value: function createImageMessage(options) {
        return this.messageController.createImageMessage(options);
      }
      /**
       * 创建文件消息的接口，此接口返回一个消息实例，可以在需要发送文件消息时调用 [发送消息](https://imsdk-1252463788.file.myqcloud.com/IM_DOC/Web/SDK.html#sendMessage) 接口发送消息。
       * > 注意：微信小程序目前不支持选择文件的功能，故该接口暂不支持微信小程序端。
       * @param {Object} options
       * @param {String} options.to - 消息接收方的 userID 或 groupID
       * @param {String} options.conversationType - 会话类型，取值`TIM.TYPES.CONV_C2C`（端到端会话） 或 `TIM.TYPES.CONV_GROUP`（群组会话）
       * @param {Object} options.payload
       * @param {HTMLInputElement} options.payload.file 用于选择文件的 DOM 节点，SDK 会读取其中的数据并上传文件。
       * @param {Function} options.onProgress - 获取上传进度的回调函数
       * @returns {Message} 消息实例
       * @example
       * // 发送文件消息
       * // 1. 创建文件消息实例，接口返回的实例可以上屏
       * let message = createFileMessage({
       *   to: 'user1',
       *   conversationType: TIM.TYPES.CONV_C2C,
       *   payload: {
       *     file: document.getElementById('filePicker'),
       *   },
       *   onProgress: function(event) { console.log('file uploading:', event) }
       * });
       * // 2. 发送消息
       * let promise = tim.sendMessage(message);
       * promise.then(function(imResponse) {
       *   // 发送成功
       *   console.log(imResponse);
       * }).catch(function(imError) {
       *   // 发送失败
       *   console.warn('sendMessage error:', imError);
       * });
       */

    }, {
      key: "createFileMessage",
      value: function createFileMessage(options) {
        if (IN_WX_MINI_APP) {
          return IMPromise.reject({
            code: ERROR_CODE.MESSAGE_FILE_WECHAT_MINIAPP_NOT_SUPPORT,
            message: ERROR_MESSAGE.MESSAGE_FILE_WECHAT_MINIAPP_NOT_SUPPORT
          });
        }

        return this.messageController.createFileMessage(options);
      }
      /**
       * @description 创建自定义消息实例的接口，此接口返回一个消息实例，可以在需要发送自定义消息时调用 [发送消息](https://imsdk-1252463788.file.myqcloud.com/IM_DOC/Web/SDK.html#sendMessage) 接口发送消息。
       * 当 SDK 提供的能力不能满足您的需求时，可以使用自定义消息进行个性化定制，例如投骰子功能。
       * @private
       * @param {Object} options
       * @param {String} options.to 消息接收方的 userID 或 groupID
       * @param {String} options.conversationType 会话类型，取值`TIM.TYPES.CONV_C2C`(端到端会话) 或 `TIM.TYPES.CONV_GROUP`(群组会话)
       * @param {Object} options.payload
       * @param {String} options.payload.faceCode 表情编码
       * @returns {Message} 消息实例
       * @example
       * // 发送表情消息，Web端与小程序端相同。
       * // 1. 创建消息实例，接口返回的实例可以上屏
       * let message = tim.createFaceMessage({
       *   to: 'user1',
       *   conversationType: TIM.TYPES.CONV_C2C,
       *   payload: { faceCode: 'tt00@2x' }
       * });
       * // 2. 发送消息
       * let promise = tim.sendMessage(message);
       * promise.then(function(imResponse) {
       *   // 发送成功
       *   console.log(imResponse);
       * }).catch(function(imError) {
       *   // 发送失败
       *   console.warn('sendMessage error:', imError);
       * });
       */

    }, {
      key: "createFaceMessage",
      value: function createFaceMessage(options) {
        return this.messageController.createFaceMessage(options);
      }
      /**
       * @description 创建自定义消息实例的接口，此接口返回一个消息实例，可以在需要发送自定义消息时调用 [发送消息](https://imsdk-1252463788.file.myqcloud.com/IM_DOC/Web/SDK.html#sendMessage) 接口发送消息。
       * 当 SDK 提供的能力不能满足您的需求时，可以使用自定义消息进行个性化定制，例如投骰子功能。
       * @param {Object} options
       * @param {String} options.to - 消息接收方的 userID 或 groupID
       * @param {String} options.conversationType - 会话类型，取值`TIM.TYPES.CONV_C2C`(端到端会话) 或 `TIM.TYPES.CONV_GROUP`(群组会话)
       * @param {Object} options.payload
       * @param {String} options.payload.data - 自定义消息的数据字段
       * @param {String} options.payload.description - 自定义消息的说明字段
       * @param {String} options.payload.extension - 自定义消息的扩展字段
       * @returns {Message} 消息实例
       * @example
       * // 示例：利用自定义消息实现投骰子功能
       * // 1. 定义随机函数
       * function random(min, max) {
       *   return Math.floor(Math.random() * (max - min + 1) + min);
       * }
       * // 2. 创建消息实例，接口返回的实例可以上屏
       * let message = tim.createCustomMessage({
       *   to: 'user1',
       *   conversationType: TIM.TYPES.CONV_C2C,
       *   payload: {
       *     data: 'dice', // 用于标识该消息是骰子类型消息
       *     description: String(random(1,6)), // 获取骰子点数
       *     extension: ''
       *   }
       * });
       * // 3. 发送消息
       * let promise = tim.sendMessage(message);
       * promise.then(function(imResponse) {
       *   // 发送成功
       *   console.log(imResponse);
       * }).catch(function(imError) {
       *   // 发送失败
       *   console.warn('sendMessage error:', imError);
       * });
       */

    }, {
      key: "createCustomMessage",
      value: function createCustomMessage(options) {
        return this.messageController.createCustomMessage(options);
      }
    }, {
      key: "createSoundMessage",
      value: function createSoundMessage(options) {
        return this.messageController.createSoundMessage(options);
      }
      /**
       * 发送消息的接口，需先调用下列的创建消息实例的接口获取消息实例后，再调用该接口发送消息实例。
       * - [创建文本消息](https://imsdk-1252463788.file.myqcloud.com/IM_DOC/Web/SDK.html#createTextMessage)
       * - [创建图片消息](https://imsdk-1252463788.file.myqcloud.com/IM_DOC/Web/SDK.html#createImageMessage)
       * - [创建文件消息](https://imsdk-1252463788.file.myqcloud.com/IM_DOC/Web/SDK.html#createFileMessage)
       * - [创建自定义消息](https://imsdk-1252463788.file.myqcloud.com/IM_DOC/Web/SDK.html#createCustomMessage)
       * @param {Message} message - 消息实例
       * @return {Promise}
       */

    }, {
      key: "sendMessage",
      value: function sendMessage(message) {
        var _this2 = this;

        if (!(message instanceof Message)) {
          return IMPromise.reject(new IMError({
            code: ERROR_CODE.MESSAGE_SEND_NEED_MESSAGE_INSTANCE,
            message: ERROR_MESSAGE.MESSAGE_SEND_NEED_MESSAGE_INSTANCE
          }));
        }

        var result = new Promise(function (resolve, reject) {
          // 注册一个 afterOperated 回调，消息在处理完成时，会触发此回调，处理完成包含两种结果：成功与失败
          message.afterOperated(function (msg) {
            _this2.messageController.sendMessageInstance(msg).then(function (successResponse) {
              resolve(successResponse);
            })["catch"](function (errorResponse) {
              reject(errorResponse);
            });
          });
        });
        return result;
      }
      /**
       * 重发消息的接口，当消息发送失败时，调用该接口进行重发。
       * > 注意：目前暂不支持图片和文件消息重发。
       * @param {Message} message 待重发的消息实例
       * @returns {Promise}
       * @example
       * // 重发消息
       * let promise = tim.resendMessage(message); // 传入需要重发的消息实例
       * promise.then(function(imResponse) {
       *   // 重发成功
       *   console.log(imResponse.data.message);
       * }).catch(function(imError) {
       *   // 重发失败
       *   console.warn('resendMessage error:', imError);
       * });
       */

    }, {
      key: "resendMessage",
      value: function resendMessage(message) {
        return this.messageController.resendMessage(message); // message.isResend = true;
        // message.status = TIM_STATUS.MESSAGE_STATUS.UNSEND;
        // return this.messageController.sendMessageInstance(message);
      }
      /**
       * 分页拉取指定会话的消息列表的接口，当用户进入会话首次渲染消息列表或者用户“下拉查看更多消息”时，需调用该接口。
       * @see Message
       * @param {Object} options
       * @param {String} options.conversationID 会话 ID
       * @param {String} options.nextReqMessageID 用于分页续拉的消息 ID。第一次拉取时该字段可不填，每次调用该接口会返回该字段，续拉时将返回字段填入即可。
       * @param {Number} [options.count=15] 需要拉取的消息数量，最大值为15
       * @return {Promise}
       * @example
       * // 打开某个会话时，第一次拉取消息列表
       * let promise = tim.getMessageList({conversationID: 'C2Ctest', count: 15});
       * promise.then(function(imResponse) {
       *   const messageList = imResponse.data.messageList; // 消息列表。
       *   const nextReqMessageID = imResponse.data.nextReqMessageID; // 用于续拉，分页续拉时需传入该字段。
       *   const isCompleted = imResponse.data.isCompleted; // 表示是否已经拉完所有消息。
       * });
       * @example
       * // 下拉查看更多消息
       * let promise = tim.getMessageList({conversationID: 'C2Ctest', nextReqMessageID, count: 15});
       * promise.then(function(imResponse) {
       *   const messageList = imResponse.data.messageList; // 消息列表。
       *   const nextReqMessageID = imResponse.data.nextReqMessageID; // 用于续拉，分页续拉时需传入该字段。
       *   const isCompleted = imResponse.data.isCompleted; // 表示是否已经拉完所有消息。
       * });
       */

    }, {
      key: "getMessageList",
      value: function getMessageList(options) {
        return this.messageController.getMessageList(options);
      }
      /**
       * 将某会话下的未读消息状态设置为已读，置为已读的消息不会计入到未读统计，当打开会话或切换会话时调用该接口。如果在打开/切换会话时，不调用该接口，则对应的消息会一直是未读的状态。
       * @param {Object} options
       * @param {String} options.conversationID 会话 ID
       * @example
       * // 将某会话下所有未读消息已读上报
       * tim.setMessageRead({conversationID: 'C2Cexample'});
       */

    }, {
      key: "setMessageRead",
      value: function setMessageRead(options) {
        return this.messageController.setMessageRead(options);
      }
      /**
       * 上传图片
       * @param {Object} options
       * @param {HTMLInputElement | Object} options.file - 在web端运行时，file 为 HTMLInputElement 对象；在微信小程序运行时，为包含了上传文件信息的对象，可以通过 `wx.chooseImage()` 方法来获取此对象。
       * @return {Promise}
       * @private
       * @example
       * // Web 端
       * html:
       * <input type='file' id='uploadInput'/>
       *
       * javascript:
       * // 建议在选择图片后触发
       * tim.uploadImage({
       *  file: document.querySelector('input#uploadInput')
       * })
       *  .then((successResponse)=>{
       *      // 上传成功
       *  })
       *  .catch((errorResponse)=>{
       *    // 上传失败
       *    console.log(errorResponse.error.code, errorResponse.error.message);
       *  })
       *
       * // 微信小程序
       * wx.chooseImage({
       *  success(res) {
       *    tim.uploadImage({
       *      file: res
       *    })
       *    .then((successResponse)=>{
       *      // 上传成功
       *    })
       *    .catch((errorResponse)=>{
       *      // 上传失败
       *      console.log(errorResponse.error.code, errorResponse.error.message);
       *    })
       *  }
       * });
       */

    }, {
      key: "uploadImage",
      value: function uploadImage(options) {} // 没有独立的bucket 暂不能支持
      // return this.uploadController.uploadImage(options);
      //   ______                                                                          __      __
      //  /      \                                                                        |  \    |  \
      // |  $$$$$$\  ______   _______  __     __   ______    ______    _______   ______  _| $$_    \$$  ______   _______
      // | $$   \$$ /      \ |       \|  \   /  \ /      \  /      \  /       \ |      \|   $$ \  |  \ /      \ |       \
      // | $$      |  $$$$$$\| $$$$$$$\\$$\ /  $$|  $$$$$$\|  $$$$$$\|  $$$$$$$  \$$$$$$\\$$$$$$  | $$|  $$$$$$\| $$$$$$$\
      // | $$   __ | $$  | $$| $$  | $$ \$$\  $$ | $$    $$| $$   \$$ \$$    \  /      $$ | $$ __ | $$| $$  | $$| $$  | $$
      // | $$__/  \| $$__/ $$| $$  | $$  \$$ $$  | $$$$$$$$| $$       _\$$$$$$\|  $$$$$$$ | $$|  \| $$| $$__/ $$| $$  | $$
      //  \$$    $$ \$$    $$| $$  | $$   \$$$    \$$     \| $$      |       $$ \$$    $$  \$$  $$| $$ \$$    $$| $$  | $$
      //   \$$$$$$   \$$$$$$  \$$   \$$    \$      \$$$$$$$ \$$       \$$$$$$$   \$$$$$$$   \$$$$  \$$  \$$$$$$  \$$   \$$
      //
      // Conversation

      /**
       * 获取会话列表的接口，该接口拉取最近的100条会话，当需要刷新会话列表时调用该接口。
       * @see Conversation
       * @returns {Promise}
       * @example
       * // 拉取会话列表
       * let promise = tim.getConversationList();
       * promise.then(function(imResponse) {
       *   const conversationList = imResponse.data.conversationList; // 会话列表，用该列表覆盖原有的会话列表。
       * }).catch(function(imError) {
       *   console.warn('getConversationList error:', imError); // 获取会话列表失败的相关信息
       * });
       */

    }, {
      key: "getConversationList",
      value: function getConversationList() {
        return this.conversationController.getConversationList();
      }
      /**
       * 获取会话资料的接口，当单机会话列表中的某个会话时，调用该接口获取会话的详细信息。
       * @param {String} conversationID 会话 ID
       * @see {@link SDK.Conversation 会话结构描述}
       * @returns {Promise}
       * @example
       * let promise = tim.getConversationProfile(conversationID);
       * promise.then(function(imResponse) {
       *   // 获取成功
       *   console.log(imResponse.data.conversation); // 会话资料
       * }).catch(function(imError) {
       *   console.warn('getConversationProfile error:', imError); // 获取会话资料失败的相关信息
       * });
       */

    }, {
      key: "getConversationProfile",
      value: function getConversationProfile(conversationID) {
        return this.conversationController.getConversationProfile(conversationID);
      }
      /**
       * 根据会话 ID 删除会话的接口。
       * @param {String} conversationID - 会话ID
       * @see {@link SDK.Conversation 会话结构描述}
       * @returns {Promise}
       * @example
       * let promise = tim.deleteConversation('C2CExample');
       * promise.then(function(imResponse) {
       *   //删除成功。
       *   const { conversationID } = imResponse.data;// 被删除的会话 ID。
       * }).catch(function(imError) {
       *   console.warn('deleteConversation error:', imError); // 删除会话失败的相关信息
       * });
       */

    }, {
      key: "deleteConversation",
      value: function deleteConversation(conversationID) {
        return this.conversationController.deleteConversation(conversationID);
      } //  __    __
      // |  \  |  \
      // | $$  | $$  _______   ______    ______
      // | $$  | $$ /       \ /      \  /      \
      // | $$  | $$|  $$$$$$$|  $$$$$$\|  $$$$$$\
      // | $$  | $$ \$$    \ | $$    $$| $$   \$$
      // | $$__/ $$ _\$$$$$$\| $$$$$$$$| $$
      //  \$$    $$|       $$ \$$     \| $$
      //   \$$$$$$  \$$$$$$$   \$$$$$$$ \$$
      //
      // User

      /**
       * 好友未决已读上报
       * @param {Object} options
       * @returns {Promise}
       * @private
       */

    }, {
      key: "getPendencyReport",
      value: function getPendencyReport(options) {
        return new Promise();
      }
      /**
       * @description 获取个人资料
       * @see {@link SDK.Profile 资料结构描述}
       * @returns {Promise}
       * @example
       * let promise = tim.getMyProfile();
       * promise.then(function(imResponse) {
       *   console.log(imResponse.data); // 个人资料 - Profile 实例
       * }).catch(function(imError) {
       *   console.warn('getMyProfile error:', imError); // 获取个人资料失败的相关信息
       * });
       */

    }, {
      key: "getMyProfile",
      value: function getMyProfile() {
        return this.userController.getMyProfile();
      }
      /**
       * @description 获取其他用户资料
       * >注意：每次拉取的用户数不超过100，避免因回包数据量太大导致回包失败。如果传入的数组长度大于100，则只取前100个用户进行查询，其余丢弃。
       * @param {Object} options - 搜索参数
       * @param {Array.<String>} options.userIDList - 用户的账号列表，类型为数组
       * @returns {Promise}
       * @example
       * let promise = tim.getUserProfile({
       *   userIDList: ['user1', 'user2'] // 请注意：即使只拉取一个用户的资料，也需要用数组类型，例如：userIDList: ['user1']
       * });
       * promise.then(function(imResponse) {
       *   console.log(imResponse.data); // 存储用户资料的数组 - [Profile]
       * }).catch(function(imError) {
       *   console.warn('getUserProfile error:', imError); // 获取其他用户资料失败的相关信息
       * });
       *
       */

    }, {
      key: "getUserProfile",
      value: function getUserProfile(options) {
        return this.userController.getUserProfile(options);
      }
      /**
       * @description 更新个人资料
       * @param {Object} options - 资料参数
       * @param { String } options.nick - 昵称
       * @param { String } options.avatar - 头像地址
       * @param { String } options.gender - 性别：
       * - TIM.TYPES.GENDER_UNKNOWN（未设置性别）
       * - TIM.TYPES.GENDER_FEMALE（女）
       * - TIM.TYPES.GENDER_MALE（男）
       * @param { String } options.selfSignature 个性签名
       * @param { String } options.allowType - 当被加人加好友时：
       * - TIM.TYPES.ALLOW_TYPE_ALLOW_ANY（允许直接加为好友）
       * - TIM.TYPES.ALLOW_TYPE_NEED_CONFIRM（需要验证）
       * - TIM.TYPES.ALLOW_TYPE_DENY_ANY（拒绝）
       * @param { Number } options.birthday 生日 推荐用法：20000101
       * @param { String } options.location 所在地 推荐用法：App 本地定义一套数字到地名的映射关系 后台实际保存的是4个 uint32_t 类型的数字：
       *    其中第一个 uint32_t 表示国家；
       *    第二个 uint32_t 用于表示省份；
       *    第三个 uint32_t 用于表示城市；
       *    第四个 uint32_t 用于表示区县
       * @param { Number } options.language 语言
       * @param { Number } options.messageSettings 消息设置 0：接收消息，1：不接收消息
       * @param { String } options.adminForbidType 管理员禁止加好友标识：
       * - TIM.TYPES.FORBID_TYPE_NONE（默认值，允许加好友）
       * - TIM.TYPES.FORBID_TYPE_SEND_OUT（禁止该用户发起加好友请求）
       * @param { Number } options.level 等级 建议拆分以保存多种角色的等级信息
       * @param { Number } options.role 角色 建议拆分以保存多种角色信息
       * @returns {Promise}
       * @example
       * let promise = tim.updateMyProfile({
       *   nick: '我的昵称',
       *   avatar: 'http(s)://url/to/image.jpg',
       *   gender: TIM.TYPES.GENDER_MALE,
       *   selfSignature: '我的个性签名',
       *   allowType: TIM.TYPES.ALLOW_TYPE_ALLOW_ANY
       * });
       * promise.then(function(imResponse) {
       *   console.log(imResponse.data); // 更新资料成功
       * }).catch(function(imError) {
       *   console.warn('updateMyProfile error:', imError); // 更新资料失败的相关信息
       * });
       *
       */

    }, {
      key: "updateMyProfile",
      value: function updateMyProfile(options) {
        return this.userController.updateMyProfile(options);
      }
      /**
       * 申请添加好友，
       * @description [详细的参数信息]{@link https://cloud.tencent.com/document/product/269/1643#.E8.AF.B7.E6.B1.82.E5.8C.85.E5.AD.97.E6.AE.B5.E8.AF.B4.E6.98.8E}
       * @param {Object} options - 添加好友的参数配置
       * @param {Array} options.addFriendItem - 必填，添加好友的对象结构
       * @param {String} options.addFriendItem.toAccount - 必填，需要添加的好友userID
       * @param {String} options.addFriendItem.remark - 选填，备注信息
       * @param {String} options.addFriendItem.groupName - 选填，分组名称
       * @param {String} options.addFriendItem.addSource - 选填，好友来源
       * @param {String} options.addFriendItem.addWording - 选填，附言信息
       * @param {String} options.addType - 选填，加好友方式，单向加好友："Add_Type_Single"; 双向加好友:"Add_Type_Both"，默认为"Add_Type_Both"
       * @param {String} options.forceAddFlags - 选填，管理员强制加好友标记：1 表示强制加好友；0 表示常规加好友方式
       * @fires TIM_EVENT.APPLY.ADD_FRIEND.SUCCESS
       * @fires TIM_EVENT.APPLY.ADD_FRIEND.FAIL
       * @returns {Promise}
       * @throws {IMError}
       * @private
       */

    }, {
      key: "applyAddFriend",
      value: function applyAddFriend(options) {
        return this.userController.applyAddFriend(options);
      }
      /**
       *  拉取未决的好友申请
       * @fires TIM_EVENT.APPLY.GET.PENDENCY.SUCCESS: 'applyGetPendencySuccess'
       * @fires TIM_EVENT.APPLY.GET.PENDENCY.FAIL: 'applyGetPendencyFail'
       * @param {Object} options
       * @param {String} [options.pendencyType='Pendency_Type_ComeIn'] - Pendency_Type_ComeIn: 别人发给我的; Pendency_Type_SendOut: 我发给别人的
       * @param {Number} [options.startTime=0] - 好友申请的起始时间
       * @param {Number} [options.maxLimited=30] - 分页大小，如果取值为30 则表示客户端要求服务器端每页最多返回30个好友申请
       * @param {Number} [options.lastSequence=0] - 好友申请数据的版本号，用户每收到或删除一条好友申请，服务器端就自增一次好友申请数据版本号，一般传0，表示拉取最新的数据
       * @returns {Promise}
       * @private
       */

    }, {
      key: "getPendency",
      value: function getPendency(options) {
        return this.userController.getPendency(options);
      }
      /**
       *  删除好友申请
       * @param {Object} options
       * @param {String[]} options.toAccount - 用户账号或昵称
       * @param {String} [options.pendencyType='Pendency_Type_ComeIn'] - Pendency_Type_ComeIn: 别人发给我的; Pendency_Type_SendOut: 我发给别人的
       * @returns {Promise}
       * @private
       */

    }, {
      key: "deletePendency",
      value: function deletePendency(options) {
        return this.userController.deletePendency(options);
      }
      /**
       *  响应好友申请
       * @param {Object} options - 请求参数
       * @param {String} options.toAccount - 目标用户名
       * @param {Number} options.action - 0（同意） / 1（同意并加为好友）/ -1 (拒绝)
       * @param {Object[]} [options.items] - 可选字段，用于批量处理好友申请。当使用该字段时则options.To_Account和options.Action失效。
       * @param {String} [options.items.toAccount] - 目标用户名
       * @param {Number} [options.items.action] - 0（同意） / 1（同意并加为好友）/ -1 (拒绝)
       * @returns {Promise}
       * @private
       */

    }, {
      key: "replyPendency",
      value: function replyPendency(options) {
        return this.userController.replyPendency(options);
      }
      /**
       * @private
       * @description 获取我的好友列表
       * @returns {Promise}
       * @example
       * let promise = tim.getFriendList();
       * promise.then(function(imResponse) {
       *   console.log(imResponse.data); // 拉取好友列表成功
       * }).catch(function(imError) {
       *   console.warn('getFriendList error:', imError); // 获取好友列表失败的相关信息
       * });
       */

    }, {
      key: "getFriendList",
      value: function getFriendList() {
        return this.userController.getFriendList();
      }
      /**
       * @description 删除好友
       * @param {Object} options - 请求参数
       * @param {Array.<String>} options.toAccount - 待删除的好友的 userID 列表，单次请求的 To_Account 数不得超过1000
       * @param {String} [options.deleteType='Delete_Type_Single'] - 删除模式，Delete_Type_Single或Delete_Type_Both，默认单向删除。详情可参见 [删除好友]{@link https://cloud.tencent.com/document/product/269/1501#.E5.88.A0.E9.99.A4.E5.A5.BD.E5.8F.8B}
       * @fires ON_DELETEFRIEND_SUCCESS,ON_DELETEFRIEND_FAIL
       * @returns {Promise}
       * @private
       */

    }, {
      key: "deleteFriend",
      value: function deleteFriend(options) {
        return this.userController.deleteFriend(options);
      }
      /**
       * @description 获取我的黑名单列表
       * @returns {Promise}
       * @example
       * let promise = tim.getBlacklist();
       * promise.then(function(imResponse) {
       *   console.log(imResponse.data); // 我的黑名单列表，结构为包含用户 userID 的数组 - [userID]
       * }).catch(function(imError) {
       *   console.warn('getBlacklist error:', imError); // 获取黑名单列表失败的相关信息
       * });
       */

    }, {
      key: "getBlacklist",
      value: function getBlacklist() {
        return this.userController.getBlacklist();
      }
      /**
       * @description 添加用户到黑名单列表。将用户加入黑名单后可以屏蔽来自 TA 的所有消息，因此该接口可以实现“屏蔽该用户消息”的功能。
       * - 如果用户 A 与用户 B 之间存在好友关系，拉黑时会解除双向好友关系。
       * - 如果用户 A 与用户 B 之间存在黑名单关系，二者之间无法发起会话。
       * - 如果用户 A 与用户 B 之间存在黑名单关系，二者之间无法发起加好友请求。
       * @param {Object} options
       * @param {Array.<String>} options.userIDList 待添加为黑名单的用户 userID 列表，单次请求的 userID 数不得超过1000
       * @returns {Promise}
       * @example
       * let promise = tim.addToBlacklist({userIDList: ['user1', 'user2']}); // 请注意：即使只添加一个用户帐号到黑名单，也需要用数组类型，例如：userIDList: ['user1']
       * promise.then(function(imResponse) {
       *   console.log(imResponse.data); // 成功添加到黑名单的账号信息，结构为包含用户 userID 的数组 - [userID]
       * }).catch(function(imError) {
       *   console.warn('addToBlacklist error:', imError); // 添加用户到黑名单列表失败的相关信息
       * });
       */

    }, {
      key: "addToBlacklist",
      value: function addToBlacklist(options) {
        return this.userController.addBlacklist(options);
      }
      /**
       * @description 将用户从黑名单中移除。移除后，可以接收来自 TA 的所有消息。
       * @param {Object} options
       * @param {Array.<String>} option.userIDList - 待从黑名单中移除的 userID 列表，单次请求的 userID 数不得超过1000
       * @returns {Promise}
       * @example
       * let promise = tim.removeFromBlacklist({userIDList: ['user1', 'user2']}); // 请注意：即使只从黑名单中移除一个用户帐号，也需要用数组类型，例如：userIDList: ['user1']
       * result.then(function(imResponse) {
       *   console.log(imResponse.data); // 从黑名单中成功移除的账号列表，结构为包含用户 userID 的数组 - [userID]
       * }).catch(function(imError) {
       *   console.warn('removeFromBlacklist error:', imError); // 将用户从黑名单中移除失败的相关信息
       * });
       */

    }, {
      key: "removeFromBlacklist",
      value: function removeFromBlacklist(options) {
        return this.userController.deleteBlacklist(options);
      } //   ______
      //  /      \
      // |  $$$$$$\  ______    ______   __    __   ______
      // | $$ __\$$ /      \  /      \ |  \  |  \ /      \
      // | $$|    \|  $$$$$$\|  $$$$$$\| $$  | $$|  $$$$$$\
      // | $$ \$$$$| $$   \$$| $$  | $$| $$  | $$| $$  | $$
      // | $$__| $$| $$      | $$__/ $$| $$__/ $$| $$__/ $$
      //  \$$    $$| $$       \$$    $$ \$$    $$| $$    $$
      //   \$$$$$$  \$$        \$$$$$$   \$$$$$$ | $$$$$$$
      //                                         | $$
      //                                         | $$
      //                                          \$$
      //
      // Group

      /**
       * 批量获取指定的群组资料 <br/>
       * @private
       * @param {Object} options
       * @param {String[]} options.groupIDList - 需要拉取的群组列表，数组元素值为群组的ID
       * @param {Object} [options.responseFilter] - 包含三个过滤器：GroupBaseInfoFilter，MemberInfoFilter，groupCustomFieldFilter，memberCustomFieldFilter。含义如下：
       * @param {String[]} [options.responseFilter.groupBaseInfoFilter] - 基础信息字段过滤器，指定需要获取的基础信息字段，详情请参阅 {@link https://cloud.tencent.com/document/product/269/1502#.E7.BE.A4.E5.9F.BA.E7.A1.80.E8.B5.84.E6.96.99 群基础资料}
       * @param {String[]} [options.responseFilter.memberInfoFilter] - 	成员信息字段过滤器，指定需要获取的成员信息字段，详情请参阅 {@link https://cloud.tencent.com/document/product/269/1502#.E7.BE.A4.E6.88.90.E5.91.98.E8.B5.84.E6.96.99 群成员资料}
       * @param {String[]} [options.responseFilter.groupCustomFieldFilter] - 群组维度的自定义字段过滤器，指定需要获取的群组维度的自定义字段，详情请参阅 {@link https://cloud.tencent.com/document/product/269/1502#.E8.87.AA.E5.AE.9A.E4.B9.89.E5.AD.97.E6.AE.B5 自定义字段}
       * @param {String[]} [options.responseFilter.memberCustomFieldFilter] - 群成员维度的自定义字段过滤器，指定需要获取的群成员维度的自定义字段，详情请参阅 {@link https://cloud.tencent.com/document/product/269/1502#.E8.87.AA.E5.AE.9A.E4.B9.89.E5.AD.97.E6.AE.B5 自定义字段}
       * @returns {Promise}
       * @example
       * // 批量获取指定的群组资料
       * let promise = tim.getGroupProfileAdvance({
       *    groupIDList: ['group1', 'group2', 'group3'],
       *    responseFilter: {
       *      groupBaseInfoFilter: ['Type', 'Name', 'Introduction', 'Notification']
       *    }
       * });
       * promise.then(function(imResponse) {
       *    console.log(imResponse.data.successGroupList); // 成功的群组信息列表。数组中元素是 Object 对象，包含了指定的相关群资料。
       *    console.log(imResponse.data.failureGroupList); // 失败的群组信息列表。数组中元素是 IMError 实例，包含了失败的描述信息。
       * }).catch(function(imError) {
       *    console.warn('getGroupProfileAdvance error:', imError);
       * })
       */

    }, {
      key: "getGroupProfileAdvance",
      value: function getGroupProfileAdvance(options) {
        return this.groupController.getGroupProfileAdvance(options);
      }
      /**
       * 需要渲染或刷新【我的群组列表】时，调用该接口获取群组列表，更多详情请参见 [Group](https://imsdk-1252463788.file.myqcloud.com/IM_DOC/Web/Group.html)。
       * @see {@link Group}
       * @returns {Promise}
       * @example
       * let promise = tim.getGroupList();
       * promise.then(function(imResponse) {
       *   console.log(imResponse.data.groupList); // 群组列表
       * }).catch(function(imError) {
       *   console.warn('getGroupList error:', imError); // 获取群组列表失败的相关信息
       * });
       */

    }, {
      key: "getGroupList",
      value: function getGroupList() {
        return this.groupController.getGroupList();
      }
      /**
       * 获取群详细资料
       * @see {@link Group}
       * @param {Object} options
       * @param {String} options.groupID 群组ID
       * @param {String[]} [options.groupCustomFieldFilter] 群组维度的自定义字段过滤器，指定需要获取的群组维度的自定义字段，详情请参阅 {@link https://cloud.tencent.com/document/product/269/1502#.E8.87.AA.E5.AE.9A.E4.B9.89.E5.AD.97.E6.AE.B5 自定义字段}
       * @param {String[]} [options.memberCustomFieldFilter] 群成员维度的自定义字段过滤器，指定需要获取的群成员维度的自定义字段，详情请参阅 {@link https://cloud.tencent.com/document/product/269/1502#.E8.87.AA.E5.AE.9A.E4.B9.89.E5.AD.97.E6.AE.B5 自定义字段}
       * @returns {Promise}
       * @example
       * let promise = tim.getGroupProfile({ groupID: 'group1', groupCustomFieldFilter: ['key1','key2'], memberCustomFieldFilter: ['key1', 'key2']});
       * promise.then(function(imResponse) {
       *   console.log(imResponse.data.group);
       * }).catch(function(imError) {
       *   console.warn('getGroupProfile error:', imError); // 获取群详细资料失败的相关信息
       * });
       */

    }, {
      key: "getGroupProfile",
      value: function getGroupProfile(options) {
        return this.groupController.getGroupProfile(options);
      }
      /**
       * 创建群组 <br/>
       * >注意：该接口创建 TIM.TYPES.GRP_AVCHATROOM（音视频聊天室） 后，需调用 {@link SDK#joinGroup 申请加群} 接口加入群组后，才能进行消息收发流程。
       * @see {@link Group}
       * @see {@link https://cloud.tencent.com/document/product/269/1502#.E7.BE.A4.E7.BB.84.E5.BD.A2.E6.80.81.E4.BB.8B.E7.BB.8D 群组形态介绍}
       * @param {Object} options - 参数集
       * @param {String} options.name - 必填，群组名称，最长30字节
       * @param {String} [options.type=TIM.TYPES.GRP_PRIVATE] - 群组类型，包括：<br/>
       * - TIM.TYPES.GRP_PRIVATE（私有群，默认）
       * - TIM.TYPES.GRP_PUBLIC（公开群）
       * - TIM.TYPES.GRP_CHATROOM（聊天室）
       * - TIM.TYPES.GRP_AVCHATROOM（音视频聊天室）
       * @param {String} [options.groupID] - 群组ID。不填该字段时，会自动为群组创建一个唯一的群 ID
       * @param {String} [options.introduction] - 群简介，最长240字节
       * @param {String} [options.notification] - 群公告，最长300字节
       * @param {String} [options.avatar] - 群头像 URL，最长100字节
       * @param {Number} [options.maxMemberNum] - 最大群成员数量，缺省时的默认值：私有群是200，公开群是2000，聊天室是10000，音视频聊天室和在线成员广播大群无限制
       * @param {String} [options.joinOption=TIM.TYPES.JOIN_OPTIONS_FREE_ACCESS] - 申请加群处理方式。
       * - TIM.TYPES.JOIN_OPTIONS_FREE_ACCESS (自由加入)
       * - TIM.TYPES.JOIN_OPTIONS_NEED_PERMISSION (需要验证)
       * - TIM.TYPES.JOIN_OPTIONS_DISABLE_APPLY (禁止加群)<br/>
       * 注意：创建 TIM.TYPES.GRP_PRIVATE, TIM.TYPES.GRP_CHATROOM, TIM.TYPES.GRP_AVCHATROOM 类型的群组不能填写该字段。私有群禁止申请加群，聊天室和音视频聊天室自由加入。
       * @param {Array.<Object>} [options.memberList] - 初始群成员列表，最多500个。创建音视频聊天室时不能添加成员
       * @param {String} options.memberList.userID - 必填，群成员的 userID
       * @param {String} [options.memberList.role] - 成员身份，可选值只有Admin，表示添加该成员并设其为管理员
       * @param {Object[]} [options.memberList.memberCustomField] - 群成员维度的自定义字段，默认情况是没有的，需要开通，详情请参阅{@link https://cloud.tencent.com/document/product/269/1502#.E8.87.AA.E5.AE.9A.E4.B9.89.E5.AD.97.E6.AE.B5 自定义字段}
       * @param {Object[]} [options.groupCustomField] - 群组维度的自定义字段，默认情况是没有的，需要开通，详情请参阅{@link https://cloud.tencent.com/document/product/269/1502#.E8.87.AA.E5.AE.9A.E4.B9.89.E5.AD.97.E6.AE.B5 群成员资料}
       * @returns {Promise}
       * @example
       * // 创建私有群
       * let promise = tim.createGroup({
       *   type: TIM.TYPES.GRP_PRIVATE,
       *   name: 'WebSDK',
       *   memberList: [{userID: 'user1'}, {userID: 'user2'}] // 如果填写了 memberList，则必须填写 userID
       * });
       * promise.then(function(imResponse) { // 创建成功
       *   console.log(imResponse.data.group); // 创建的群的资料
       * }).catch(function(imError) {
       *   console.warn('createGroup error:', imError); // 创建群组失败的相关信息
       * });
       */

    }, {
      key: "createGroup",
      value: function createGroup(options) {
        return this.groupController.createGroup(options);
      }
      /**
       * 群主可调用该接口解散群组。<br/>
       * >注意：群主不能解散私有群。
       * @see {@link Group}
       * @see {@link https://cloud.tencent.com/document/product/269/3661 群组管理}
       * @param {String} groupID 群组 ID
       * @return {Promise}
       * @example
       * let promise = tim.dismissGroup('group1');
       * promise.then(function(imResponse) { // 解散成功
       *   console.log(imResponse.data.groupID); // 被解散的群组 ID
       * }).catch(function(imError) {
       *   console.warn('dismissGroup error:', imError); // 解散群组失败的相关信息
       * });
       */

    }, {
      key: "dismissGroup",
      value: function dismissGroup(groupID) {
        return this.groupController.dismissGroup(groupID);
      }
      /**
       * 修改群组资料
       * @see {@link Group}
       * @see {@link https://cloud.tencent.com/document/product/269/3661 群组管理}
       * @param {Object} options 请求参数
       * @param {Object} options.groupID 群ID
       * @param {Object} [options.name] 群名称，最长30字节
       * @param {Object} [options.avatar] 群头像URL，最长100字节
       * @param {Object} [options.introduction] 群简介，最长240字节
       * @param {Object} [options.notification] 群公告，最长300字节
       * @param {Number} [options.maxMemberNum] 最大群成员数量，最大为6000
       * @param {String} [options.joinOption=TIM.TYPES.JOIN_OPTIONS_FREE_ACCESS] - 申请加群处理方式。
       * - TIM.TYPES.JOIN_OPTIONS_FREE_ACCESS （自由加入）
       * - TIM.TYPES.JOIN_OPTIONS_NEED_PERMISSION （需要验证）
       * - TIM.TYPES.JOIN_OPTIONS_DISABLE_APPLY （禁止加群）<br/>
       * 注意：TIM.TYPES.GRP_PRIVATE, TIM.TYPES.GRP_CHATROOM, TIM.TYPES.GRP_AVCHATROOM 类型群组的该属性不允许修改。私有群禁止申请加群，聊天室和音视频聊天室自由加入。
       * @param {Object[]} [options.groupCustomField] 群自定义字段。默认情况是没有的。开通群组维度的自定义字段详情请参见 {@link https://cloud.tencent.com/document/product/269/1502#.E8.87.AA.E5.AE.9A.E4.B9.89.E5.AD.97.E6.AE.B5 自定义字段}
       * @param {String} options.groupCustomField.key 自定义字段的 Key
       * @param {String} options.groupCustomField.value 自定义字段的 Value
       * @returns {Promise}
       * @example
       * let promise = tim.updateGroupProfile({
       *   groupID: 'group1',
       *   name: 'new name', // 修改群名称
       *   introduction: 'this is introduction.', // 修改群公告
       *   groupCustomField: [{ key: 'group_level', value: 'high'}] // 修改群组维度自定义字段
       * });
       * promise.then(function(imResponse) {
       *   console.log(imResponse.data.group) // 修改成功后的群组详细资料
       * }).catch(function(imError) {
       *   console.warn('updateGroupProfile error:', imError); // 修改群组资料失败的相关信息
       * });
       */

    }, {
      key: "updateGroupProfile",
      value: function updateGroupProfile(options) {
        return this.groupController.updateGroupProfile(options);
      }
      /**
       * 申请加群的接口，申请加入某个群组时调用。<br/>
       * >注意：
       * 1. 私有群不允许申请加群，只能通过 {@link SDK#addGroupMember 添加群成员} 方式添加
       * 2. TIM.TYPES.GRP_AVCHATROOM（音视频聊天室）有两种加群方式：<br/>
       *  2.1 正常加群，即登录加群。此时 SDK 内的所有接口都能正常调用。<br/>
       *  2.2 匿名加群，即不登录加群。此时只能收消息，其他任何需要鉴权的接口都不能调用。
       * 3. 同一用户同时只能加入一个音视频聊天室。【例如】用户已在音视频聊天室 A 中，再加入音视频聊天室 B，SDK 会先退出音视频聊天室 A，然后加入音视频聊天室 B
       * @see {@link Group}
       * @param {Object} options
       * @param {String} options.groupID
       * @param {String} options.applyMessage 附言
       * @param {String} [options.type] 要加入群组的类型，加入音视频聊天室时该字段必填。可选值：
       * - TIM.TYPES.GRP_PUBLIC（公开群）
       * - TIM.TYPES.GRP_CHATROOM （聊天室）
       * - TIM.TYPES.GRP_AVCHATROOM （音视频聊天室）
       * @returns {Promise}
       * @example
       * let promise = tim.joinGroup({ groupID: 'group1', type: TIM.TYPES.GRP_AVCHATROOM });
       * promise.then(function(imResponse) {
       *   switch (imResponse.data.status) {
       *     case TIM.TYPES.JOIN_STATUS_WAIT_APPROVAL:
       *       break; // 等待管理员同意
       *     case TIM.TYPES.JOIN_STATUS_SUCCESS: // 加群成功
       *       console.log(imResponse.data.group); // 加入的群组资料
       *       break;
       *     default:
       *       break;
       *   }
       * }).catch(function(imError){
       *   console.warn('joinGroup error:', imError); // 申请加群失败的相关信息
       * });
       */

    }, {
      key: "joinGroup",
      value: function joinGroup(options) {
        return this.groupController.joinGroup(options);
      }
      /**
       * 退出群组。<br/>
       * >注意：群主只能退出私有群，退出后该私有群无群主。
       * @see {@link Group}
       * @see {@link https://cloud.tencent.com/document/product/269/3661 群组管理}
       * @param {String} groupID - 群组 ID
       * @returns {Promise} 成功时 then 回调参数中包含退出的群组 ID
       * @example
       * let promise = tim.quitGroup('group1');
       * promise.then(function(imResponse) {
       *   console.log(imResponse.data.groupID); // 退出成功的群 ID
       * }).catch(function(imError){
       *   console.warn('quitGroup error:', imError); // 退出群组失败的相关信息
       * });
       */

    }, {
      key: "quitGroup",
      value: function quitGroup(groupID) {
        return this.groupController.quitGroup(groupID);
      }
      /**
       * 通过 groupID 搜索群组。<br/>
       * >注意：TIM.TYPES.GRP_PRIVATE 类型的群组（私有群）不能被搜索。
       * @see {@link Group}
       * @param {String} groupID 群组 ID
       * @returns {Promise}
       * @example
       * let promise = tim.searchGroupByID('group1');
       * promise.then(function(imResponse) {
       *   const group = imResponse.data.group; // 群组信息
       * }).catch(function(imError) {
       *   console.warn('searchGroupByID error:', imError); // 搜素群组失败的相关信息
       * });
       */

    }, {
      key: "searchGroupByID",
      value: function searchGroupByID(groupID) {
        return this.groupController.searchGroupByID(groupID);
      }
      /**
       * 转让群组。只有群主有权限操作。 <br/>
       * >注意：只有群主拥有转让的权限。TIM.TYPES.GRP_AVCHATROOM（音视频聊天室）类型的群组不能转让。
       * @see {@link Group}
       * @param {Object} options
       * @param {String} options.groupID - 待转让的群组 ID
       * @param {String} options.newOwnerID - 新群主的 ID
       * @returns {Promise}
       * @example
       * let promise = tim.changeGroupOwner({
       *   groupID: 'group1',
       *   newOwnerID: 'user2'
       * });
       * promise.then(function(imResponse) { // 转让成功
       *   console.log(imResponse.data.group); // 群组资料
       * }).catch(function(imError) { // 转让失败
       *   console.warn('changeGroupOwner error:', imError); // 转让群组失败的相关信息
       * });
       */

    }, {
      key: "changeGroupOwner",
      value: function changeGroupOwner(options) {
        return this.groupController.changeGroupOwner(options);
      }
      /**
       * 处理申请加群（同意或拒绝）
       * @see {@link Group}
       * @param {Object} options
       * @param {String} options.handleAction 处理结果 Agree(同意) / Reject(拒绝)
       * @param {String} [options.handleMessage] 附言
       * @param {Message} options.message 对应【群系统通知】的消息实例
       * @returns {Promise}
       * @example
       * let promise = tim.handleGroupApplication({
       *   handleAction: 'Agree',
       *   handleMessage: '欢迎欢迎',
       *   message: message // 申请加群群系统通知的消息实例
       * });
       * promise.then(function(imResponse) {
       *   console.log(imResponse.data.group); // 群组资料
       * }).catch(function(imError){
       *   console.warn('handleGroupApplication error:', imError); // 错误信息
       * });
       */

    }, {
      key: "handleGroupApplication",
      value: function handleGroupApplication(options) {
        return this.groupController.handleGroupApplication(options);
      }
      /**
       * @description 设置自己的群消息提示类型。
       * @see {@link Group}
       * @see {@link GroupMember}
       * @param {Object} options
       * @param {String} options.groupID
       * @param {String} options.messageRemindType 群消息提示类型。详细如下：
       * - TIM.TYPES.MSG_REMIND_ACPT_AND_NOTE（SDK 接收消息并通知接入侧(抛出 {@link  module:EVENT.MESSAGE_RECEIVED 收到消息事件})，接入侧做提示）
       * - TIM.TYPES.MSG_REMIND_ACPT_NOT_NOTE（SDK 接收消息并通知接入侧(抛出 {@link  module:EVENT.MESSAGE_RECEIVED 收到消息事件})，接入侧不做提示）
       * - TIM.TYPES.MSG_REMIND_DISCARD（SDK 拒收消息）
       * @returns {Promise}
       * @example
       * let promise = tim.setMessageRemindType({ groupID: 'group1', messageRemindType: TIM.TYPES.MSG_REMIND_DISCARD }); // 拒收消息
       * promise.then(function(imResponse) {
       *   console.log(imResponse.data.group); // 设置后的群资料。
       * }).catch(function(imError) {
       *   console.warn('setMessageRemindType error:', imError);
       * });
       */

    }, {
      key: "setMessageRemindType",
      value: function setMessageRemindType(options) {
        return this.groupController.setMessageRemindType(options);
      }
      /**
       * @description 获取群成员列表
       * @see {@link GroupMember}
       * @param {Object} options 请求参数
       * @param {String} options.groupID 群组的 ID
       * @param {Number} [options.count=15] 需要拉取的数量。最大值：100，避免回包过大导致请求失败。若传入超过100，则只拉取前100个。
       * @param {Number} [options.offset=0] 偏移量，默认从0开始拉取
       * @returns {Promise}
       * @example
       * let promise = tim.getGroupMemberList({ groupID: 'group1', count: 30, offset:0 }); // 从0开始拉取30个群成员
       * promise.then(function(imResponse) {
       *   console.log(imResponse.data.memberList); // 群成员列表
       * }).catch(function(imError) {
       *   console.warn('getGroupMemberList error:', imError);
       * });
       */

    }, {
      key: "getGroupMemberList",
      value: function getGroupMemberList(options) {
        return this.groupController.getGroupMemberList(options);
      }
      /**
       * 添加群成员。详细规则如下：
       * - TIM.TYPES.GRP_PRIVATE（私有群）：任何群成员都可邀请他人加群，且无需被邀请人同意，直接将其拉入群组中。
       * - TIM.TYPES.GRP_PUBLIC（公开群）/ TIM.TYPES.GRP_CHATROOM（聊天室）：只有 App 管理员可以邀请他人入群，且无需被邀请人同意，直接将其拉入群组中。
       * - TIM.TYPES.GRP_AVCHATROOM（音视频聊天室）：不允许任何人邀请他人入群（包括 App 管理员）。
       * @see {@link Group}
       * @see {@link GroupMember}
       * @see {@link https://cloud.tencent.com/document/product/269/1502#.E7.BE.A4.E6.88.90.E5.91.98.E6.93.8D.E4.BD.9C.E5.B7.AE.E5.BC.82 群成员操作差异}
       * @param {Object} options
       * @param {String} options.groupID
       * @param {String[]} options.userIDList 待添加的群成员 ID 数组。单次最多添加500个成员
       * @returns {Promise}
       * @example
       * let promise = tim.addGroupMember({groupID: 'group1', userIDList: ['user1','user2','user3']});
       * promise.then(function(imResponse) {
       *   console.log(imResponse.data.successUserIDList); // 添加成功的群成员 userIDList
       *   console.log(imResponse.data.failureUserIDList); // 添加失败的群成员 userIDList
       *   console.log(imResponse.data.existedUserIDList); // 已在群中的群成员 userIDList
       *   console.log(imResponse.data.group); // 添加后的群组信息
       * }).catch(function(imError) {
       *   console.warn('addGroupMember error:', imError); // 错误信息
       * });
       */

    }, {
      key: "addGroupMember",
      value: function addGroupMember(options) {
        return this.groupController.addGroupMember(options);
      }
      /**
       * 删除群成员。群主可移除群成员。
       * @see {@link Group}
       * @see {@link GroupMember}
       * @param {Object} options
       * @param {String} options.groupID 群ID
       * @param {String[]} options.userIDList 待删除的群成员的 ID 列表
       * @param {String} [options.reason] 踢人的原因
       * @returns {Promise}
       * @example
       * let promise = tim.deleteGroupMember({groupID: 'group1', userIDList:['user1'], reason: '你违规了，我要踢你！'});
       * promise.then(function(imResponse) {
       *   console.log(imResponse.data.group); // 删除后的群组信息
       *   console.log(imResponse.data.userIDList); // 被删除的群成员的 userID 列表
       * }).catch(function(imError) {
       *   console.warn('deleteGroupMember error:', imError); // 错误信息
       * });
       */

    }, {
      key: "deleteGroupMember",
      value: function deleteGroupMember(options) {
        return this.groupController.deleteGroupMember(options);
      }
      /**
       * 设置群成员的禁言时间，可以禁言群成员，也可取消禁言。TIM.TYPES.GRP_PRIVATE 类型的群组（即私有群）不能禁言。<br/>
       * >注意：只有群主和管理员拥有该操作权限：
       * - 群主可以禁言/取消禁言管理员和普通群成员。
       * - 管理员可以禁言/取消禁言普通群成员。
       * @see {@link Group}
       * @see {@link GroupMember}
       * @see {@link https://cloud.tencent.com/document/product/269/1502#.E6.B6.88.E6.81.AF.E7.AE.A1.E7.90.86.E5.B7.AE.E5.BC.82 群组消息管理差异}
       * @param {Object} options
       * @param {String} options.groupID
       * @param {String} options.userID
       * @param {Number} options.muteTime 禁言时长，单位秒。如设为1000，则表示从现在起禁言该用户1000秒；设为0，则表示取消禁言。
       * @return {Promise}
       * @example
       * let promise = tim.setGroupMemberMuteTime({
       *   groupID: 'group1',
       *   userID: 'user1',
       *   muteTime: 600 // 禁言10分钟；设为0，则表示取消禁言
       * });
       * promise.then(function(imResponse) {
       *   console.log(imResponse.data.group); // 修改后的群资料
       * }).catch(function(imError) {
       *   console.warn('setGroupMemberMuteTime error:', imError); // 禁言失败的相关信息
       * });
       */

    }, {
      key: "setGroupMemberMuteTime",
      value: function setGroupMemberMuteTime(options) {
        return this.groupController.setGroupMemberMuteTime(options);
      }
      /**
       * 修改群成员角色。只有群主拥有操作的权限。
       * @see {@link Group}
       * @see {@link GroupMember}
       * @param {Object} options
       * @param {String} options.groupID
       * @param {String} options.userID
       * @param {String} options.role 可选值：TIM.TYPES.GRP_MBR_ROLE_ADMIN（群管理员） 或 TIM.TYPES.GRP_MBR_ROLE_MEMBER（群普通成员）
       * @returns {Promise}
       * @example
       * let promise = tim.setGroupMemberRole({
       *   groupID: 'group1',
       *   userID: 'user1',
       *   role: TIM.TYPES.GRP_MBR_ROLE_ADMIN // 将群 ID: group1 中的用户：user1 设为管理员
       * });
       * promise.then(function(imResponse) {
       *   console.log(imResponse.data.group); // 修改后的群资料
       * }).catch(function(imError) {
       *   console.warn('setGroupMemberRole error:', imError); // 错误信息
       * });
       */

    }, {
      key: "setGroupMemberRole",
      value: function setGroupMemberRole(options) {
        return this.groupController.setGroupMemberRole(options);
      }
      /**
       * 设置群成员名片。<br/>
       * - 群主：可设置所有群成员的名片。
       * - 管理员：可设置自身和其他普通群成员的群名片。
       * - 普通群成员：只能设置自身群名片。
       * @see {@link Group}
       * @see {@link GroupMember}
       * @param {Object} options
       * @param {String} options.groupID
       * @param {String} [options.userID] 可选，默认修改自身的群名片
       * @param {String} options.nameCard
       * @returns {Promise}
       * @example
       * let promise = tim.setGroupMemberNameCard({ groupID: 'group1', userID: 'user1', nameCard: '用户名片' });
       * promise.then(function(imResponse) {
       *   console.log(imResponse.data.group); // 设置后的群资料
       * }).catch(function(imError) {
       *   console.warn('setGroupMemberNameCard error:', imError); // 设置群成员名片失败的相关信息
       * });
       */

    }, {
      key: "setGroupMemberNameCard",
      value: function setGroupMemberNameCard(options) {
        return this.groupController.setGroupMemberNameCard(options);
      }
      /**
       * @description 设置群成员自定义字段。<br/>
       * >注意：普通群成员只能设置自己的自定义字段。
       * @see {@link Group}
       * @see {@link GroupMember}
       * @param {Object} options
       * @param {String} options.groupID
       * @param {String} [options.userID] 可选，默认修改自身的群名片
       * @param {Object[]} options.memberCustomField
       * @param {String} options.memberCustomField.key 自定义字段的 Key
       * @param {String} options.memberCustomField.value 自定义字段的 Value
       * @example
       * let promise = setMemberCustomField({ groupID: 'group1', memberCustomField: [{key: 'group_member_test', value: 'test'}]});
       * promise.then(function(imResponse) {
       *   console.log(imResponse.data.group); // 设置后的群资料
       * }).catch(function(imError) {
       *   console.warn('setMemberCustomField error:', imError); // 设置群成员自定义字段失败的相关信息
       * });
       */

    }, {
      key: "setGroupMemberCustomField",
      value: function setGroupMemberCustomField(options) {
        return this.groupController.setGroupMemberCustomField(options);
      }
      /**
       * 删除群系统通知
       * 调用时机：需要删除群系统通知时。
       * @private
       * @param {Obejct} options
       * @param {Message[]} options.messageList 待删除的消息列表
       * @returns {Promise}
       * @example
       * let promise = tim.deleteGroupSystemNotice({messageList: [message]});
       * promise.then(function(imResponse) {
       *   // 删除成功
       * }).catch(function(imError) {
       *   console.warn('deleteGroupSystemNotice error:', imError); // 删除群系统通知失败的相关信息
       * });
       */

    }, {
      key: "deleteGroupSystemNotice",
      value: function deleteGroupSystemNotice(options) {
        return this.groupController.deleteGroupSystemNotice(options);
      } //
      //  _______             __                       __
      // |       \           |  \                     |  \
      // | $$$$$$$\  ______   \$$ __     __  ______  _| $$_     ______
      // | $$__/ $$ /      \ |  \|  \   /  \|      \|   $$ \   /      \
      // | $$    $$|  $$$$$$\| $$ \$$\ /  $$ \$$$$$$\\$$$$$$  |  $$$$$$\
      // | $$$$$$$ | $$   \$$| $$  \$$\  $$ /      $$ | $$ __ | $$    $$
      // | $$      | $$      | $$   \$$ $$ |  $$$$$$$ | $$|  \| $$$$$$$$
      // | $$      | $$      | $$    \$$$   \$$    $$  \$$  $$ \$$     \
      //  \$$       \$$       \$$     \$     \$$$$$$$   \$$$$   \$$$$$$$
      //

      /**
       * 初始化TIM配置
       * @private
       * @param {Object} options
       */

    }, {
      key: "_initOptions",
      value: function _initOptions(options) {
        // 插件map
        this.plugins = {};
        this.loginInfo = {
          SDKAppID: options.SDKAppID || null,
          accountType: randomInt(),
          identifier: null,
          userSig: null
        }; // 以下参数不对外提供，仅由开发测试使用

        var RUNLOOP_TYPES$1 = RUNLOOP_TYPES;
        this.options = {
          runLoopNetType: options.runLoopNetType || RUNLOOP_TYPES$1.XHR,
          // 暂时默认xhr，ws调通后应该默认ws
          enablePointer: options.enablePointer || false // 默认不允许打点，因为打点的log接入侧无需关心

        };
      }
      /**
       * 初始化成员变量
       * @private
       */

    }, {
      key: "_initMemberVariables",
      value: function _initMemberVariables() {
        this.context = null;
        this.innerEmitter = new eventemitter3();
        this.outerEmitter = new eventemitter3();
        IMPromise.hookEmitter(this.outerEmitter);
        this.packageConfig = new PackageConfig(this);
        this.storage = new Storage(this); // 规范事件响应函数的参数

        this.outerEmitter._emit = this.outerEmitter.emit;

        this.outerEmitter.emit = function (eventName, eventData) {
          var _eventName = arguments[0];
          var args = [_eventName, {
            name: arguments[0],
            data: arguments[1]
          }];
          logger.debug("emit ".concat(_eventName), args[1]);

          this.outerEmitter._emit.apply(this.outerEmitter, args);
        }.bind(this);
      }
      /**
       *  加载相关控制台，并挂到TIM的实例上
       * @private
       */

    }, {
      key: "_initControllers",
      value: function _initControllers() {
        this.exceptionController = new ExceptionController(this); // this.commandController = new CommandController(this); // 暂时没用，先注释掉

        this.connectionController = new ConnectionController(this);
        this.contextController = new ContextController(this);
        this.signController = new SignController(this); // 加载登录控制器

        this.messageController = new MessageController(this);
        this.conversationController = new ConversationController(this);
        this.userController = new UserController(this);
        this.groupController = new GroupController(this);
        this.notificationController = new NotificationController(this);
        this.statusController = new StatusController(this);
        this.uploadController = new UploadController(this); // 最后初始化 reporterController

        this.reporterController = new ReporterController(this); // this.eventController = new EventController(this); // 加载事件控制台， 注意，EventContrller构造函数运行后， 将自动注册事件监听,所以有需要放在最后一个载入，以免注册了未实例化的controller成员函数

        this._initReadyListener();
      }
      /**
       * 给SDK配置基本的监听事件
       * @private
       */

    }, {
      key: "_initListener",
      value: function _initListener() {
        // 当长时间掉线重连时
        this.innerEmitter.on(TIM_INNER_EVENT.NOTICE_LONGPOLL_LONG_RECONNECT, this._onNoticeChannelReconnectedAfterLongTime, this);
      }
      /**
       * 初始化 Ready 监听器
       * @private
       */

    }, {
      key: "_initReadyListener",
      value: function _initReadyListener() {
        var _this3 = this;

        var readyList = this.readyList;

        for (var i = 0, length = readyList.length; i < length; i++) {
          this[readyList[i]].ready(function () {
            return _this3._readyHandle();
          });
        }
      }
      /**
       * 当消息通道长时间掉线后重新连上时
       * @private
       */

    }, {
      key: "_onNoticeChannelReconnectedAfterLongTime",
      value: function _onNoticeChannelReconnectedAfterLongTime(event) {
        logger.log('reconnect after long time...', event); // 停止当前longPolling

        this.notificationController.stopLongPoll(); // 重置sdk数据

        this.resetSDK(); // this.resetSDK();
        // 重新登录、同步消息、启动轮询（注：当前逻辑下，登录成功后会按顺序触发同步、取通道ID、启动通道的过程）

        this.login(this.loginInfo);
      }
      /**
       * reset SDK 内部的数据
       * @private
       */

    }, {
      key: "resetSDK",
      value: function resetSDK() {
        var _this4 = this;

        // 1. 重置各个 控制器
        var initList = this.initList;
        initList.forEach(function (controller) {
          if (_this4[controller].reset) {
            _this4[controller].reset();
          }
        }); // 2. 重置 storage

        this.storage.reset(); // 3. 重置 averageCalculato

        averageCalculator.reset(); // 4. 重置 ready 状态

        this.resetReady(); // 5. 注册 ready 状态监听器

        this._initReadyListener(); // 6. 抛事件


        this.outerEmitter.emit(TIM_OUTER_EVENT.SDK_NOT_READY);
      }
      /**
       * SDK 初始化时 isReady 为false
       * 在关键 Controller 模块注册 ready 回调，都触发ready 后才可以正常调用sdk api
       * 1. 每个关键模块的ready回调都是同一个handle
       * 2. 当 handle 执行时循环关键模块的 ready 状态
       * 3. 有一例false 退出循环
       * 4. 全部都是true 时 sdk _isReady为true
       * @private
       */

    }, {
      key: "_readyHandle",
      value: function _readyHandle() {
        var readyList = this.readyList,
            result = true;

        for (var i = 0, length = readyList.length; i < length; i++) {
          if (!this[readyList[i]].isReady) {
            result = false;
            break;
          }
        }

        if (result) {
          logger.warn("SDK is ready. cost=".concat(logger.timeEnd(label.SDK_READY), "ms"));
          this.triggerReady();
          this.innerEmitter.emit(TIM_INNER_EVENT.SDK_READY);
          this.outerEmitter.emit(TIM_OUTER_EVENT.SDK_READY);
        }
      }
    }]);

    return SDK;
  }(); // conversationController 是最后一个ready 的控制器，因此把它做为SDK ready的标记


  SDK$1.prototype.readyList = ['conversationController'];
  SDK$1.prototype.initList = ['exceptionController', // 'commandController',
  'connectionController', 'signController', 'contextController', 'messageController', 'conversationController', 'userController', 'groupController', 'notificationController'];

  // 不需要 SDK ready 校验的 API 列表
  var APINoNeedSDKReady = {
    login: 'login',
    on: 'on',
    off: 'off',
    ready: 'ready',
    setLogLevel: 'setLogLevel',
    joinGroup: 'joinGroup',
    // 加大群时不需要登录
    registerPlugin: 'registerPlugin'
  };

  /**
   * 调用 API 前的 SDK ready 校验
   * @param {Boolean} sdkReadyState
   * @param {String} APIName
   * @returns
   */

  function validateReady(sdkReadyState, APIName, sdk) {
    if (sdkReadyState || typeof APINoNeedSDKReady[APIName] !== 'undefined') {
      return true;
    }

    sdk.innerEmitter.emit(TIM_INNER_EVENT.ERROR_DETECTED, new IMError({
      code: ERROR_CODE.SDK_IS_NOT_READY,
      message: "".concat(ERROR_MESSAGE.SDK_IS_NOT_READY, " ").concat(APIName)
    }));
  }

  // 临时文件，用于替换 TIM.js
  var sdkList = {};
  /**
   * @description TIM 是 IM Web SDK 的命名空间，提供了创建 SDK 实例的静态方法 create() ，以及事件常量 {@link module:EVENT EVENT}，类型常量 {@link module:TYPES TYPES}
   * @namespace TIM
    */

  var TIM = {};
  /**
   * @description 即时通信 IM Web SDK 的工厂函数，用于生成 SDK 实例。<br/>
   * 接入前，您需要在 [云通信控制台]{@link https://console.cloud.tencent.com/avc} 中创建一个云通信应用，并取得 `SDKAppID`。<br/>
   * 如果想快速体验通即时通信 IM 的 Demo，请参考文档：[《一分钟跑通 Demo》]{@link https://cloud.tencent.com/document/product/269/36838}
   * @memberof TIM
   * @param {Object} options 配置
   * @param {Number} options.SDKAppID - 云通信应用的 `SDKAppID`
   * @example
   * let options = {
   *   SDKAppID: 0 // 接入时需要将0替换为您的云通信应用的 SDKAppID
   * };
   * let tim = TIM.create(options); // SDK 实例通常用 tim 表示
   * @returns {Object} SDK 实例
   */

  TIM.create = function (options) {
    if (options.SDKAppID && sdkList[options.SDKAppID]) {
      return sdkList[options.SDKAppID];
    }

    logger.log('TIM.create');
    var sdk = new SDK$1(options);
    sdk.on(TIM_OUTER_EVENT.SDK_DESTROY, function (event) {
      // sdk销毁需要移除 sdkList 相应的实例
      sdkList[event.data.SDKAppID] = null;
      delete sdkList[event.data.SDKAppID];
    }); // 将配置里指定的 SDK API 挂载到无原型对象上。

    var obj = assemblySDK(sdk);
    sdkList[options.SDKAppID] = obj;
    logger.log('TIM.create ok');
    return obj;
  };
  /**
   *
   * @param {*} sdk
   * @private
   */


  function assemblySDK(sdk) {
    var obj = Object.create(null);
    Object.keys(APIList).forEach(function (key) {
      // 配置里的方法在 SDK 里没有找到
      if (!sdk[key]) {
        return;
      }

      var name = APIList[key];
      var validateMiddleware = new Middleware();

      obj[name] = function () {
        var args = Array.from(arguments); // console.log(args);
        // 参数验证中间件

        validateMiddleware.use(function (options, next) {
          if (validateReady(sdk.isReady(), key, sdk)) {
            // sdk ready 校验
            return next();
          }
        }).use(function (options, next) {
          if (validateParams(options, APIValidateConfig[key], name) === true) {
            return next();
          }
        }).use(function (options, next) {
          return sdk[key].apply(sdk, options);
        });
        return validateMiddleware.run(args); // 异步返回promise ，同步返回response object
      };
    });
    return obj;
  } // 挂载常量配置
  // TIM.CONFIG = TIM_CONFIG;


  TIM.TYPES = TYPES; // TIM.ERROR = TIM_ERROR;

  TIM.EVENT = TIM_OUTER_EVENT;
  TIM.VERSION = version;
  logger.log("TIM.VERSION: ".concat(TIM.VERSION)); // 挂载模型

  return TIM;

}));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__("DuR2")))

/***/ }),

/***/ "PzxK":
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has = __webpack_require__("D2L2");
var toObject = __webpack_require__("sB3e");
var IE_PROTO = __webpack_require__("ax3d")('IE_PROTO');
var ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto : null;
};


/***/ }),

/***/ "QRG4":
/***/ (function(module, exports, __webpack_require__) {

// 7.1.15 ToLength
var toInteger = __webpack_require__("UuGF");
var min = Math.min;
module.exports = function (it) {
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};


/***/ }),

/***/ "R4wc":
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.1 Object.assign(target, source)
var $export = __webpack_require__("kM2E");

$export($export.S + $export.F, 'Object', { assign: __webpack_require__("To3L") });


/***/ }),

/***/ "R9M2":
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};


/***/ }),

/***/ "RPLV":
/***/ (function(module, exports, __webpack_require__) {

var document = __webpack_require__("7KvD").document;
module.exports = document && document.documentElement;


/***/ }),

/***/ "RY/4":
/***/ (function(module, exports, __webpack_require__) {

// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = __webpack_require__("R9M2");
var TAG = __webpack_require__("dSzd")('toStringTag');
// ES3 wrong here
var ARG = cof(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (e) { /* empty */ }
};

module.exports = function (it) {
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
    // builtinTag case
    : ARG ? cof(O)
    // ES3 arguments fallback
    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};


/***/ }),

/***/ "S82l":
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};


/***/ }),

/***/ "SfB7":
/***/ (function(module, exports, __webpack_require__) {

module.exports = !__webpack_require__("+E39") && !__webpack_require__("S82l")(function () {
  return Object.defineProperty(__webpack_require__("ON07")('div'), 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),

/***/ "TcQ7":
/***/ (function(module, exports, __webpack_require__) {

// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = __webpack_require__("MU5D");
var defined = __webpack_require__("52gC");
module.exports = function (it) {
  return IObject(defined(it));
};


/***/ }),

/***/ "To3L":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 19.1.2.1 Object.assign(target, source, ...)
var DESCRIPTORS = __webpack_require__("+E39");
var getKeys = __webpack_require__("lktj");
var gOPS = __webpack_require__("1kS7");
var pIE = __webpack_require__("NpIQ");
var toObject = __webpack_require__("sB3e");
var IObject = __webpack_require__("MU5D");
var $assign = Object.assign;

// should work with symbols and should have deterministic property order (V8 bug)
module.exports = !$assign || __webpack_require__("S82l")(function () {
  var A = {};
  var B = {};
  // eslint-disable-next-line no-undef
  var S = Symbol();
  var K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function (k) { B[k] = k; });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source) { // eslint-disable-line no-unused-vars
  var T = toObject(target);
  var aLen = arguments.length;
  var index = 1;
  var getSymbols = gOPS.f;
  var isEnum = pIE.f;
  while (aLen > index) {
    var S = IObject(arguments[index++]);
    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
    var length = keys.length;
    var j = 0;
    var key;
    while (length > j) {
      key = keys[j++];
      if (!DESCRIPTORS || isEnum.call(S, key)) T[key] = S[key];
    }
  } return T;
} : $assign;


/***/ }),

/***/ "UuGF":
/***/ (function(module, exports) {

// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;
module.exports = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};


/***/ }),

/***/ "V3tA":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("R4wc");
module.exports = __webpack_require__("FeBl").Object.assign;


/***/ }),

/***/ "X8DO":
/***/ (function(module, exports) {

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};


/***/ }),

/***/ "Yobk":
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject = __webpack_require__("77Pl");
var dPs = __webpack_require__("qio6");
var enumBugKeys = __webpack_require__("xnc9");
var IE_PROTO = __webpack_require__("ax3d")('IE_PROTO');
var Empty = function () { /* empty */ };
var PROTOTYPE = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = __webpack_require__("ON07")('iframe');
  var i = enumBugKeys.length;
  var lt = '<';
  var gt = '>';
  var iframeDocument;
  iframe.style.display = 'none';
  __webpack_require__("RPLV").appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty();
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};


/***/ }),

/***/ "ax3d":
/***/ (function(module, exports, __webpack_require__) {

var shared = __webpack_require__("e8AB")('keys');
var uid = __webpack_require__("3Eo+");
module.exports = function (key) {
  return shared[key] || (shared[key] = uid(key));
};


/***/ }),

/***/ "c/Tr":
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__("5zde"), __esModule: true };

/***/ }),

/***/ "dSzd":
/***/ (function(module, exports, __webpack_require__) {

var store = __webpack_require__("e8AB")('wks');
var uid = __webpack_require__("3Eo+");
var Symbol = __webpack_require__("7KvD").Symbol;
var USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function (name) {
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;


/***/ }),

/***/ "dY0y":
/***/ (function(module, exports, __webpack_require__) {

var ITERATOR = __webpack_require__("dSzd")('iterator');
var SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR]();
  riter['return'] = function () { SAFE_CLOSING = true; };
  // eslint-disable-next-line no-throw-literal
  Array.from(riter, function () { throw 2; });
} catch (e) { /* empty */ }

module.exports = function (exec, skipClosing) {
  if (!skipClosing && !SAFE_CLOSING) return false;
  var safe = false;
  try {
    var arr = [7];
    var iter = arr[ITERATOR]();
    iter.next = function () { return { done: safe = true }; };
    arr[ITERATOR] = function () { return iter; };
    exec(arr);
  } catch (e) { /* empty */ }
  return safe;
};


/***/ }),

/***/ "e6n0":
/***/ (function(module, exports, __webpack_require__) {

var def = __webpack_require__("evD5").f;
var has = __webpack_require__("D2L2");
var TAG = __webpack_require__("dSzd")('toStringTag');

module.exports = function (it, tag, stat) {
  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
};


/***/ }),

/***/ "e8AB":
/***/ (function(module, exports, __webpack_require__) {

var core = __webpack_require__("FeBl");
var global = __webpack_require__("7KvD");
var SHARED = '__core-js_shared__';
var store = global[SHARED] || (global[SHARED] = {});

(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: core.version,
  mode: __webpack_require__("O4g8") ? 'pure' : 'global',
  copyright: '© 2019 Denis Pushkarev (zloirock.ru)'
});


/***/ }),

/***/ "evD5":
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__("77Pl");
var IE8_DOM_DEFINE = __webpack_require__("SfB7");
var toPrimitive = __webpack_require__("MmMw");
var dP = Object.defineProperty;

exports.f = __webpack_require__("+E39") ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};


/***/ }),

/***/ "fBQ2":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $defineProperty = __webpack_require__("evD5");
var createDesc = __webpack_require__("X8DO");

module.exports = function (object, index, value) {
  if (index in object) $defineProperty.f(object, index, createDesc(0, value));
  else object[index] = value;
};


/***/ }),

/***/ "fkB2":
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__("UuGF");
var max = Math.max;
var min = Math.min;
module.exports = function (index, length) {
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};


/***/ }),

/***/ "h1dT":
/***/ (function(module, exports, __webpack_require__) {

!function(e,t){ true?module.exports=t():"function"==typeof define&&define.amd?define([],t):"object"==typeof exports?exports.COS=t():e.COS=t()}(this,function(){return function(e){function t(r){if(n[r])return n[r].exports;var o=n[r]={i:r,l:!1,exports:{}};return e[r].call(o.exports,o,o.exports,t),o.l=!0,o.exports}var n={};return t.m=e,t.c=n,t.i=function(e){return e},t.d=function(e,n,r){t.o(e,n)||Object.defineProperty(e,n,{configurable:!1,enumerable:!0,get:r})},t.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(n,"a",n),n},t.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},t.p="D:\\github\\cos-wx-sdk-v5\\demo\\lib",t(t.s=4)}([function(e,t,n){"use strict";function r(e){return encodeURIComponent(e).replace(/!/g,"%21").replace(/'/g,"%27").replace(/\(/g,"%28").replace(/\)/g,"%29").replace(/\*/g,"%2A")}function o(e){return u(e,function(e){return"object"==typeof e?o(e):e})}function i(e,t){return c(t,function(n,r){e[r]=t[r]}),e}function a(e){return e instanceof Array}function s(e,t){for(var n=!1,r=0;r<e.length;r++)if(t===e[r]){n=!0;break}return n}function c(e,t){for(var n in e)e.hasOwnProperty(n)&&t(e[n],n)}function u(e,t){var n=a(e)?[]:{};for(var r in e)e.hasOwnProperty(r)&&(n[r]=t(e[r],r));return n}function l(e,t){var n=a(e),r=n?[]:{};for(var o in e)e.hasOwnProperty(o)&&t(e[o],o)&&(n?r.push(e[o]):r[o]=e[o]);return r}var d=n(8),f=n(6),h=n(10),p=n(7),m=n(5),g=m.btoa,y=function(e){e=e||{};var t=e.SecretId,n=e.SecretKey,i=(e.method||e.Method||"get").toLowerCase(),a=o(e.Query||e.params||{}),s=o(e.Headers||e.headers||{}),c=e.Pathname||"/"+(e.Key||"");if(!t)return console.error("missing param SecretId");if(!n)return console.error("missing param SecretKey");var u=function(e){var t=[];for(var n in e)e.hasOwnProperty(n)&&t.push(n);return t.sort(function(e,t){return e=e.toLowerCase(),t=t.toLowerCase(),e===t?0:e>t?1:-1})},l=function(e){var t,n,o,i=[],a=u(e);for(t=0;t<a.length;t++)n=a[t],o=void 0===e[n]||null===e[n]?"":""+e[n],n=n.toLowerCase(),n=r(n),o=r(o)||"",i.push(n+"="+o);return i.join("&")},d=Math.round(_(e.SystemClockOffset)/1e3)-1,h=d,p=e.Expires||e.expires;h+=void 0===p?900:1*p||0;var m=t,g=d+";"+h,y=d+";"+h,C=u(s).join(";").toLowerCase(),v=u(a).join(";").toLowerCase(),x=f.HmacSHA1(y,n).toString(),k=[i,c,l(a),l(s),""].join("\n"),S=["sha1",g,f.SHA1(k).toString(),""].join("\n");return["q-sign-algorithm=sha1","q-ak="+m,"q-sign-time="+g,"q-key-time="+y,"q-header-list="+C,"q-url-param-list="+v,"q-signature="+f.HmacSHA1(S,x).toString()].join("&")},C=function(){},v=function(e){var t={};for(var n in e)e.hasOwnProperty(n)&&void 0!==e[n]&&null!==e[n]&&(t[n]=e[n]);return t},x=function(e,t){var n,r=new FileReader;FileReader.prototype.readAsBinaryString?(n=FileReader.prototype.readAsBinaryString,r.onload=function(){t(this.result)}):FileReader.prototype.readAsArrayBuffer?n=function(e){var n="",r=new FileReader;r.onload=function(e){for(var o=new Uint8Array(r.result),i=o.byteLength,a=0;a<i;a++)n+=String.fromCharCode(o[a]);t(n)},r.readAsArrayBuffer(e)}:console.error("FileReader not support readAsBinaryString"),n.call(r,e)},k=function(e,t){x(e,function(e){var n=d(e,!0);t(null,n)})},S=function(e){var t,n,r,o="";for(t=0,n=e.length/2;t<n;t++)r=parseInt(e[2*t]+e[2*t+1],16),o+=String.fromCharCode(r);return g(o)},A=function(){var e=function(){return(65536*(1+Math.random())|0).toString(16).substring(1)};return e()+e()+"-"+e()+"-"+e()+"-"+e()+"-"+e()+e()+e()},b=function(e,t){var n=t.Bucket,r=t.Region,o=t.Key;if(e.indexOf("Bucket")>-1||"deleteMultipleObject"===e||"multipartList"===e||"listObjectVersions"===e){if(!n)return"Bucket";if(!r)return"Region"}else if(e.indexOf("Object")>-1||e.indexOf("multipart")>-1||"sliceUploadFile"===e||"abortUploadTask"===e){if(!n)return"Bucket";if(!r)return"Region";if(!o)return"Key"}return!1},R=function(e,t){if(t=i({},t),"getAuth"!==e&&"getV4Auth"!==e&&"getObjectUrl"!==e){var n=t.Headers||{};if(t&&"object"==typeof t){!function(){for(var e in t)t.hasOwnProperty(e)&&e.indexOf("x-cos-")>-1&&(n[e]=t[e])}();var r={"x-cos-mfa":"MFA","Content-MD5":"ContentMD5","Content-Length":"ContentLength","Content-Type":"ContentType",Expect:"Expect",Expires:"Expires","Cache-Control":"CacheControl","Content-Disposition":"ContentDisposition","Content-Encoding":"ContentEncoding",Range:"Range","If-Modified-Since":"IfModifiedSince","If-Unmodified-Since":"IfUnmodifiedSince","If-Match":"IfMatch","If-None-Match":"IfNoneMatch","x-cos-copy-source":"CopySource","x-cos-copy-source-Range":"CopySourceRange","x-cos-metadata-directive":"MetadataDirective","x-cos-copy-source-If-Modified-Since":"CopySourceIfModifiedSince","x-cos-copy-source-If-Unmodified-Since":"CopySourceIfUnmodifiedSince","x-cos-copy-source-If-Match":"CopySourceIfMatch","x-cos-copy-source-If-None-Match":"CopySourceIfNoneMatch","x-cos-acl":"ACL","x-cos-grant-read":"GrantRead","x-cos-grant-write":"GrantWrite","x-cos-grant-full-control":"GrantFullControl","x-cos-grant-read-acp":"GrantReadAcp","x-cos-grant-write-acp":"GrantWriteAcp","x-cos-storage-class":"StorageClass","x-cos-server-side-encryption-customer-algorithm":"SSECustomerAlgorithm","x-cos-server-side-encryption-customer-key":"SSECustomerKey","x-cos-server-side-encryption-customer-key-MD5":"SSECustomerKeyMD5","x-cos-server-side-encryption":"ServerSideEncryption","x-cos-server-side-encryption-cos-kms-key-id":"SSEKMSKeyId","x-cos-server-side-encryption-context":"SSEContext"};N.each(r,function(e,r){void 0!==t[e]&&(n[r]=t[e])}),t.Headers=v(n)}}return t},T=function(e,t){return function(n,r){"function"==typeof n&&(r=n,n={}),n=R(e,n);var o=function(e){return e&&e.headers&&(e.headers["x-cos-version-id"]&&(e.VersionId=e.headers["x-cos-version-id"]),e.headers["x-cos-delete-marker"]&&(e.DeleteMarker=e.headers["x-cos-delete-marker"])),e},i=function(e,t){r&&r(o(e),o(t))};if("getService"!==e&&"abortUploadTask"!==e){var a;if(a=b(e,n))return void i({error:"missing param "+a});if(n.Region){if(n.Region.indexOf("cos.")>-1)return void i({error:'param Region should not be start with "cos."'});if(!/^([a-z\d-]+)$/.test(n.Region))return void i({error:"Region format error."});this.options.CompatibilityMode||-1!==n.Region.indexOf("-")||"yfb"===n.Region||"default"===n.Region||console.warn("warning: param Region format error, find help here: https://cloud.tencent.com/document/product/436/6224")}if(n.Bucket){if(!/^([a-z\d-]+)-(\d+)$/.test(n.Bucket))if(n.AppId)n.Bucket=n.Bucket+"-"+n.AppId;else{if(!this.options.AppId)return void i({error:'Bucket should format as "test-1250000000".'});n.Bucket=n.Bucket+"-"+this.options.AppId}n.AppId&&(console.warn('warning: AppId has been deprecated, Please put it at the end of parameter Bucket(E.g Bucket:"test-1250000000" ).'),delete n.AppId)}}var s=t.call(this,n,i);if("getAuth"===e||"getObjectUrl"===e)return s}},w=function(e,t){function n(){if(o=0,t&&"function"==typeof t){r=Date.now();var n,i=Math.max(0,Math.round((s-a)/((r-c)/1e3)*100)/100);n=0===s&&0===e?1:Math.round(s/e*100)/100||0,c=r,a=s;try{t({loaded:s,total:e,speed:i,percent:n})}catch(e){}}}var r,o,i=this,a=0,s=0,c=Date.now();return function(t,r){if(t&&(s=t.loaded,e=t.total),r)clearTimeout(o),n();else{if(o)return;o=setTimeout(n,i.options.ProgressInterval)}}},E=function(e,t,n){var r;if("string"==typeof t.Body&&(t.Body=new Blob([t.Body],{type:"text/plain"})),!t.Body||!(t.Body instanceof Blob||"[object File]"===t.Body.toString()||"[object Blob]"===t.Body.toString()))return void n({error:"params body format error, Only allow File|Blob|String."});r=t.Body.size,t.ContentLength=r,n(null,r)},_=function(e){return Date.now()+(e||0)},N={noop:C,formatParams:R,apiWrapper:T,xml2json:h,json2xml:p,md5:d,clearKey:v,getFileMd5:k,binaryBase64:S,extend:i,isArray:a,isInArray:s,each:c,map:u,filter:l,clone:o,uuid:A,camSafeUrlEncode:r,throttleOnProgress:w,getFileSize:E,getSkewTime:_,getAuth:y,isBrowser:!0};N.fileSlice=function(e,t,n){return e.slice?e.slice(t,n):e.mozSlice?e.mozSlice(t,n):e.webkitSlice?e.webkitSlice(t,n):void 0},N.getFileUUID=function(e,t){return e.name&&e.size&&e.lastModifiedDate&&t?N.md5([e.name,e.size,e.lastModifiedDate,t].join("::")):null},N.getBodyMd5=function(e,t,n){n=n||C,e&&"string"==typeof t?n(N.md5(t,!0)):n()},e.exports=N},function(e,t){function n(e,t){for(var n in e)t[n]=e[n]}function r(e,t){function r(){}var o=e.prototype;if(Object.create){var i=Object.create(t.prototype);o.__proto__=i}o instanceof t||(r.prototype=t.prototype,r=new r,n(o,r),e.prototype=o=r),o.constructor!=e&&("function"!=typeof e&&console.error("unknow Class:"+e),o.constructor=e)}function o(e,t){if(t instanceof Error)var n=t;else n=this,Error.call(this,oe[e]),this.message=oe[e],Error.captureStackTrace&&Error.captureStackTrace(this,o);return n.code=e,t&&(this.message=this.message+": "+t),n}function i(){}function a(e,t){this._node=e,this._refresh=t,s(this)}function s(e){var t=e._node._inc||e._node.ownerDocument._inc;if(e._inc!=t){var r=e._refresh(e._node);K(e,"length",r.length),n(r,e),e._inc=t}}function c(){}function u(e,t){for(var n=e.length;n--;)if(e[n]===t)return n}function l(e,t,n,r){if(r?t[u(t,r)]=n:t[t.length++]=n,e){n.ownerElement=e;var o=e.ownerDocument;o&&(r&&C(o,e,r),y(o,e,n))}}function d(e,t,n){var r=u(t,n);if(!(r>=0))throw o(ae,new Error(e.tagName+"@"+n));for(var i=t.length-1;r<i;)t[r]=t[++r];if(t.length=i,e){var a=e.ownerDocument;a&&(C(a,e,n),n.ownerElement=null)}}function f(e){if(this._features={},e)for(var t in e)this._features=e[t]}function h(){}function p(e){return"<"==e&&"&lt;"||">"==e&&"&gt;"||"&"==e&&"&amp;"||'"'==e&&"&quot;"||"&#"+e.charCodeAt()+";"}function m(e,t){if(t(e))return!0;if(e=e.firstChild)do{if(m(e,t))return!0}while(e=e.nextSibling)}function g(){}function y(e,t,n){e&&e._inc++,"http://www.w3.org/2000/xmlns/"==n.namespaceURI&&(t._nsMap[n.prefix?n.localName:""]=n.value)}function C(e,t,n,r){e&&e._inc++,"http://www.w3.org/2000/xmlns/"==n.namespaceURI&&delete t._nsMap[n.prefix?n.localName:""]}function v(e,t,n){if(e&&e._inc){e._inc++;var r=t.childNodes;if(n)r[r.length++]=n;else{for(var o=t.firstChild,i=0;o;)r[i++]=o,o=o.nextSibling;r.length=i}}}function x(e,t){var n=t.previousSibling,r=t.nextSibling;return n?n.nextSibling=r:e.firstChild=r,r?r.previousSibling=n:e.lastChild=n,v(e.ownerDocument,e),t}function k(e,t,n){var r=t.parentNode;if(r&&r.removeChild(t),t.nodeType===te){var o=t.firstChild;if(null==o)return t;var i=t.lastChild}else o=i=t;var a=n?n.previousSibling:e.lastChild;o.previousSibling=a,i.nextSibling=n,a?a.nextSibling=o:e.firstChild=o,null==n?e.lastChild=i:n.previousSibling=i;do{o.parentNode=e}while(o!==i&&(o=o.nextSibling));return v(e.ownerDocument||e,e),t.nodeType==te&&(t.firstChild=t.lastChild=null),t}function S(e,t){var n=t.parentNode;if(n){var r=e.lastChild;n.removeChild(t);var r=e.lastChild}var r=e.lastChild;return t.parentNode=e,t.previousSibling=r,t.nextSibling=null,r?r.nextSibling=t:e.firstChild=t,e.lastChild=t,v(e.ownerDocument,e,t),t}function A(){this._nsMap={}}function b(){}function R(){}function T(){}function w(){}function E(){}function _(){}function N(){}function B(){}function D(){}function O(){}function P(){}function I(){}function M(e,t){var n=[],r=9==this.nodeType?this.documentElement:this,o=r.prefix,i=r.namespaceURI;if(i&&null==o){var o=r.lookupPrefix(i);if(null==o)var a=[{namespace:i,prefix:null}]}return F(this,n,e,t,a),n.join("")}function L(e,t,n){var r=e.prefix||"",o=e.namespaceURI;if(!r&&!o)return!1;if("xml"===r&&"http://www.w3.org/XML/1998/namespace"===o||"http://www.w3.org/2000/xmlns/"==o)return!1;for(var i=n.length;i--;){var a=n[i];if(a.prefix==r)return a.namespace!=o}return!0}function F(e,t,n,r,o){if(r){if(!(e=r(e)))return;if("string"==typeof e)return void t.push(e)}switch(e.nodeType){case q:o||(o=[]);var i=(o.length,e.attributes),a=i.length,s=e.firstChild,c=e.tagName;n=z===e.namespaceURI||n,t.push("<",c);for(var u=0;u<a;u++){var l=i.item(u);"xmlns"==l.prefix?o.push({prefix:l.localName,namespace:l.value}):"xmlns"==l.nodeName&&o.push({prefix:"",namespace:l.value})}for(var u=0;u<a;u++){var l=i.item(u);if(L(l,n,o)){var d=l.prefix||"",f=l.namespaceURI,h=d?" xmlns:"+d:" xmlns";t.push(h,'="',f,'"'),o.push({prefix:d,namespace:f})}F(l,t,n,r,o)}if(L(e,n,o)){var d=e.prefix||"",f=e.namespaceURI,h=d?" xmlns:"+d:" xmlns";t.push(h,'="',f,'"'),o.push({prefix:d,namespace:f})}if(s||n&&!/^(?:meta|link|img|br|hr|input)$/i.test(c)){if(t.push(">"),n&&/^script$/i.test(c))for(;s;)s.data?t.push(s.data):F(s,t,n,r,o),s=s.nextSibling;else for(;s;)F(s,t,n,r,o),s=s.nextSibling;t.push("</",c,">")}else t.push("/>");return;case J:case te:for(var s=e.firstChild;s;)F(s,t,n,r,o),s=s.nextSibling;return;case V:return t.push(" ",e.name,'="',e.value.replace(/[<&"]/g,p),'"');case X:return t.push(e.data.replace(/[<&]/g,p));case $:return t.push("<![CDATA[",e.data,"]]>");case Y:return t.push("\x3c!--",e.data,"--\x3e");case ee:var m=e.publicId,g=e.systemId;if(t.push("<!DOCTYPE ",e.name),m)t.push(' PUBLIC "',m),g&&"."!=g&&t.push('" "',g),t.push('">');else if(g&&"."!=g)t.push(' SYSTEM "',g,'">');else{var y=e.internalSubset;y&&t.push(" [",y,"]"),t.push(">")}return;case Z:return t.push("<?",e.target," ",e.data,"?>");case W:return t.push("&",e.nodeName,";");default:t.push("??",e.nodeName)}}function U(e,t,n){var r;switch(t.nodeType){case q:r=t.cloneNode(!1),r.ownerDocument=e;case te:break;case V:n=!0}if(r||(r=t.cloneNode(!1)),r.ownerDocument=e,r.parentNode=null,n)for(var o=t.firstChild;o;)r.appendChild(U(e,o,n)),o=o.nextSibling;return r}function j(e,t,n){var r=new t.constructor;for(var o in t){var a=t[o];"object"!=typeof a&&a!=r[o]&&(r[o]=a)}switch(t.childNodes&&(r.childNodes=new i),r.ownerDocument=e,r.nodeType){case q:var s=t.attributes,u=r.attributes=new c,l=s.length;u._ownerElement=r;for(var d=0;d<l;d++)r.setAttributeNode(j(e,s.item(d),!0));break;case V:n=!0}if(n)for(var f=t.firstChild;f;)r.appendChild(j(e,f,n)),f=f.nextSibling;return r}function K(e,t,n){e[t]=n}function H(e){switch(e.nodeType){case q:case te:var t=[];for(e=e.firstChild;e;)7!==e.nodeType&&8!==e.nodeType&&t.push(H(e)),e=e.nextSibling;return t.join("");default:return e.nodeValue}}var z="http://www.w3.org/1999/xhtml",G={},q=G.ELEMENT_NODE=1,V=G.ATTRIBUTE_NODE=2,X=G.TEXT_NODE=3,$=G.CDATA_SECTION_NODE=4,W=G.ENTITY_REFERENCE_NODE=5,Q=G.ENTITY_NODE=6,Z=G.PROCESSING_INSTRUCTION_NODE=7,Y=G.COMMENT_NODE=8,J=G.DOCUMENT_NODE=9,ee=G.DOCUMENT_TYPE_NODE=10,te=G.DOCUMENT_FRAGMENT_NODE=11,ne=G.NOTATION_NODE=12,re={},oe={},ie=(re.INDEX_SIZE_ERR=(oe[1]="Index size error",1),re.DOMSTRING_SIZE_ERR=(oe[2]="DOMString size error",2),re.HIERARCHY_REQUEST_ERR=(oe[3]="Hierarchy request error",3)),ae=(re.WRONG_DOCUMENT_ERR=(oe[4]="Wrong document",4),re.INVALID_CHARACTER_ERR=(oe[5]="Invalid character",5),re.NO_DATA_ALLOWED_ERR=(oe[6]="No data allowed",6),re.NO_MODIFICATION_ALLOWED_ERR=(oe[7]="No modification allowed",7),re.NOT_FOUND_ERR=(oe[8]="Not found",8)),se=(re.NOT_SUPPORTED_ERR=(oe[9]="Not supported",9),re.INUSE_ATTRIBUTE_ERR=(oe[10]="Attribute in use",10));re.INVALID_STATE_ERR=(oe[11]="Invalid state",11),re.SYNTAX_ERR=(oe[12]="Syntax error",12),re.INVALID_MODIFICATION_ERR=(oe[13]="Invalid modification",13),re.NAMESPACE_ERR=(oe[14]="Invalid namespace",14),re.INVALID_ACCESS_ERR=(oe[15]="Invalid access",15);o.prototype=Error.prototype,n(re,o),i.prototype={length:0,item:function(e){return this[e]||null},toString:function(e,t){for(var n=[],r=0;r<this.length;r++)F(this[r],n,e,t);return n.join("")}},a.prototype.item=function(e){return s(this),this[e]},r(a,i),c.prototype={length:0,item:i.prototype.item,getNamedItem:function(e){for(var t=this.length;t--;){var n=this[t];if(n.nodeName==e)return n}},setNamedItem:function(e){var t=e.ownerElement;if(t&&t!=this._ownerElement)throw new o(se);var n=this.getNamedItem(e.nodeName);return l(this._ownerElement,this,e,n),n},setNamedItemNS:function(e){var t,n=e.ownerElement;if(n&&n!=this._ownerElement)throw new o(se);return t=this.getNamedItemNS(e.namespaceURI,e.localName),l(this._ownerElement,this,e,t),t},removeNamedItem:function(e){var t=this.getNamedItem(e);return d(this._ownerElement,this,t),t},removeNamedItemNS:function(e,t){var n=this.getNamedItemNS(e,t);return d(this._ownerElement,this,n),n},getNamedItemNS:function(e,t){for(var n=this.length;n--;){var r=this[n];if(r.localName==t&&r.namespaceURI==e)return r}return null}},f.prototype={hasFeature:function(e,t){var n=this._features[e.toLowerCase()];return!(!n||t&&!(t in n))},createDocument:function(e,t,n){var r=new g;if(r.implementation=this,r.childNodes=new i,r.doctype=n,n&&r.appendChild(n),t){var o=r.createElementNS(e,t);r.appendChild(o)}return r},createDocumentType:function(e,t,n){var r=new _;return r.name=e,r.nodeName=e,r.publicId=t,r.systemId=n,r}},h.prototype={firstChild:null,lastChild:null,previousSibling:null,nextSibling:null,attributes:null,parentNode:null,childNodes:null,ownerDocument:null,nodeValue:null,namespaceURI:null,prefix:null,localName:null,insertBefore:function(e,t){return k(this,e,t)},replaceChild:function(e,t){this.insertBefore(e,t),t&&this.removeChild(t)},removeChild:function(e){return x(this,e)},appendChild:function(e){return this.insertBefore(e,null)},hasChildNodes:function(){return null!=this.firstChild},cloneNode:function(e){return j(this.ownerDocument||this,this,e)},normalize:function(){for(var e=this.firstChild;e;){var t=e.nextSibling;t&&t.nodeType==X&&e.nodeType==X?(this.removeChild(t),e.appendData(t.data)):(e.normalize(),e=t)}},isSupported:function(e,t){return this.ownerDocument.implementation.hasFeature(e,t)},hasAttributes:function(){return this.attributes.length>0},lookupPrefix:function(e){for(var t=this;t;){var n=t._nsMap;if(n)for(var r in n)if(n[r]==e)return r;t=t.nodeType==V?t.ownerDocument:t.parentNode}return null},lookupNamespaceURI:function(e){for(var t=this;t;){var n=t._nsMap;if(n&&e in n)return n[e];t=t.nodeType==V?t.ownerDocument:t.parentNode}return null},isDefaultNamespace:function(e){return null==this.lookupPrefix(e)}},n(G,h),n(G,h.prototype),g.prototype={nodeName:"#document",nodeType:J,doctype:null,documentElement:null,_inc:1,insertBefore:function(e,t){if(e.nodeType==te){for(var n=e.firstChild;n;){var r=n.nextSibling;this.insertBefore(n,t),n=r}return e}return null==this.documentElement&&e.nodeType==q&&(this.documentElement=e),k(this,e,t),e.ownerDocument=this,e},removeChild:function(e){return this.documentElement==e&&(this.documentElement=null),x(this,e)},importNode:function(e,t){return U(this,e,t)},getElementById:function(e){var t=null;return m(this.documentElement,function(n){if(n.nodeType==q&&n.getAttribute("id")==e)return t=n,!0}),t},createElement:function(e){var t=new A;return t.ownerDocument=this,t.nodeName=e,t.tagName=e,t.childNodes=new i,(t.attributes=new c)._ownerElement=t,t},createDocumentFragment:function(){var e=new O;return e.ownerDocument=this,e.childNodes=new i,e},createTextNode:function(e){var t=new T;return t.ownerDocument=this,t.appendData(e),t},createComment:function(e){var t=new w;return t.ownerDocument=this,t.appendData(e),t},createCDATASection:function(e){var t=new E;return t.ownerDocument=this,t.appendData(e),t},createProcessingInstruction:function(e,t){var n=new P;return n.ownerDocument=this,n.tagName=n.target=e,n.nodeValue=n.data=t,n},createAttribute:function(e){var t=new b;return t.ownerDocument=this,t.name=e,t.nodeName=e,t.localName=e,t.specified=!0,t},createEntityReference:function(e){var t=new D;return t.ownerDocument=this,t.nodeName=e,t},createElementNS:function(e,t){var n=new A,r=t.split(":"),o=n.attributes=new c;return n.childNodes=new i,n.ownerDocument=this,n.nodeName=t,n.tagName=t,n.namespaceURI=e,2==r.length?(n.prefix=r[0],n.localName=r[1]):n.localName=t,o._ownerElement=n,n},createAttributeNS:function(e,t){var n=new b,r=t.split(":");return n.ownerDocument=this,n.nodeName=t,n.name=t,n.namespaceURI=e,n.specified=!0,2==r.length?(n.prefix=r[0],n.localName=r[1]):n.localName=t,n}},r(g,h),A.prototype={nodeType:q,hasAttribute:function(e){return null!=this.getAttributeNode(e)},getAttribute:function(e){var t=this.getAttributeNode(e);return t&&t.value||""},getAttributeNode:function(e){return this.attributes.getNamedItem(e)},setAttribute:function(e,t){var n=this.ownerDocument.createAttribute(e);n.value=n.nodeValue=""+t,this.setAttributeNode(n)},removeAttribute:function(e){var t=this.getAttributeNode(e);t&&this.removeAttributeNode(t)},appendChild:function(e){return e.nodeType===te?this.insertBefore(e,null):S(this,e)},setAttributeNode:function(e){return this.attributes.setNamedItem(e)},setAttributeNodeNS:function(e){return this.attributes.setNamedItemNS(e)},removeAttributeNode:function(e){return this.attributes.removeNamedItem(e.nodeName)},removeAttributeNS:function(e,t){var n=this.getAttributeNodeNS(e,t);n&&this.removeAttributeNode(n)},hasAttributeNS:function(e,t){return null!=this.getAttributeNodeNS(e,t)},getAttributeNS:function(e,t){var n=this.getAttributeNodeNS(e,t);return n&&n.value||""},setAttributeNS:function(e,t,n){var r=this.ownerDocument.createAttributeNS(e,t);r.value=r.nodeValue=""+n,this.setAttributeNode(r)},getAttributeNodeNS:function(e,t){return this.attributes.getNamedItemNS(e,t)},getElementsByTagName:function(e){return new a(this,function(t){var n=[];return m(t,function(r){r===t||r.nodeType!=q||"*"!==e&&r.tagName!=e||n.push(r)}),n})},getElementsByTagNameNS:function(e,t){return new a(this,function(n){var r=[];return m(n,function(o){o===n||o.nodeType!==q||"*"!==e&&o.namespaceURI!==e||"*"!==t&&o.localName!=t||r.push(o)}),r})}},g.prototype.getElementsByTagName=A.prototype.getElementsByTagName,g.prototype.getElementsByTagNameNS=A.prototype.getElementsByTagNameNS,r(A,h),b.prototype.nodeType=V,r(b,h),R.prototype={data:"",substringData:function(e,t){return this.data.substring(e,e+t)},appendData:function(e){e=this.data+e,this.nodeValue=this.data=e,this.length=e.length},insertData:function(e,t){this.replaceData(e,0,t)},appendChild:function(e){throw new Error(oe[ie])},deleteData:function(e,t){this.replaceData(e,t,"")},replaceData:function(e,t,n){n=this.data.substring(0,e)+n+this.data.substring(e+t),this.nodeValue=this.data=n,this.length=n.length}},r(R,h),T.prototype={nodeName:"#text",nodeType:X,splitText:function(e){var t=this.data,n=t.substring(e);t=t.substring(0,e),this.data=this.nodeValue=t,this.length=t.length;var r=this.ownerDocument.createTextNode(n);return this.parentNode&&this.parentNode.insertBefore(r,this.nextSibling),r}},r(T,R),w.prototype={nodeName:"#comment",nodeType:Y},r(w,R),E.prototype={nodeName:"#cdata-section",nodeType:$},r(E,R),_.prototype.nodeType=ee,r(_,h),N.prototype.nodeType=ne,r(N,h),B.prototype.nodeType=Q,r(B,h),D.prototype.nodeType=W,r(D,h),O.prototype.nodeName="#document-fragment",O.prototype.nodeType=te,r(O,h),P.prototype.nodeType=Z,r(P,h),I.prototype.serializeToString=function(e,t,n){return M.call(e,t,n)},h.prototype.toString=M;try{Object.defineProperty&&(Object.defineProperty(a.prototype,"length",{get:function(){return s(this),this.$$length}}),Object.defineProperty(h.prototype,"textContent",{get:function(){return H(this)},set:function(e){switch(this.nodeType){case q:case te:for(;this.firstChild;)this.removeChild(this.firstChild);(e||String(e))&&this.appendChild(this.ownerDocument.createTextNode(e));break;default:this.data=e,this.value=e,this.nodeValue=e}}}),K=function(e,t,n){e["$$"+t]=n})}catch(e){}t.DOMImplementation=f,t.XMLSerializer=I},function(e,t){var n=function(e){var t={},n=function(e){return!t[e]&&(t[e]=[]),t[e]};e.on=function(e,t){n(e).push(t)},e.off=function(e,t){for(var r=n(e),o=r.length-1;o>=0;o--)t===r[o]&&r.splice(o,1)},e.emit=function(e,t){for(var r=n(e).map(function(e){return e}),o=0;o<r.length;o++)r[o](t)}},r=function(){n(this)};e.exports.init=n,e.exports.EventProxy=r},function(e,t,n){"use strict";var r=n(0),o=n(2),i=n(16),a=n(15),s=n(13),c={SecretId:"",SecretKey:"",XCosSecurityToken:"",FileParallelLimit:3,ChunkParallelLimit:3,ChunkSize:1048576,SliceSize:1048576,CopyChunkParallelLimit:20,CopyChunkSize:10485760,CopySliceSize:10485760,MaxPartNumber:1e4,ProgressInterval:1e3,UploadQueueSize:1e4,Domain:"",ServiceDomain:"",Protocol:"",CompatibilityMode:!1,ForcePathStyle:!1,CorrectClockSkew:!0,SystemClockOffset:0},u=function(e){this.options=r.extend(r.clone(c),e||{}),this.options.FileParallelLimit=Math.max(1,this.options.FileParallelLimit),this.options.ChunkParallelLimit=Math.max(1,this.options.ChunkParallelLimit),this.options.ChunkRetryTimes=Math.max(0,this.options.ChunkRetryTimes),this.options.ChunkSize=Math.max(1048576,this.options.ChunkSize),this.options.CopyChunkParallelLimit=Math.max(1,this.options.CopyChunkParallelLimit),this.options.CopyChunkSize=Math.max(1048576,this.options.CopyChunkSize),this.options.CopySliceSize=Math.max(0,this.options.CopySliceSize),this.options.MaxPartNumber=Math.max(1024,Math.min(1e4,this.options.MaxPartNumber)),this.options.Timeout=Math.max(0,this.options.Timeout),this.options.AppId&&console.warn('warning: AppId has been deprecated, Please put it at the end of parameter Bucket(E.g: "test-1250000000").'),o.init(this),i.init(this)};a.init(u,i),s.init(u,i),u.getAuthorization=r.getAuth,u.version="0.7.3",e.exports=u},function(e,t,n){var r=n(3);e.exports=r},function(e,t){var n=function(e){e=e||{};var t,n=e.Base64,r="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",o=function(e){for(var t={},n=0,r=e.length;n<r;n++)t[e.charAt(n)]=n;return t}(r),i=String.fromCharCode,a=function(e){if(e.length<2){var t=e.charCodeAt(0);return t<128?e:t<2048?i(192|t>>>6)+i(128|63&t):i(224|t>>>12&15)+i(128|t>>>6&63)+i(128|63&t)}var t=65536+1024*(e.charCodeAt(0)-55296)+(e.charCodeAt(1)-56320);return i(240|t>>>18&7)+i(128|t>>>12&63)+i(128|t>>>6&63)+i(128|63&t)},s=/[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g,c=function(e){return e.replace(s,a)},u=function(e){var t=[0,2,1][e.length%3],n=e.charCodeAt(0)<<16|(e.length>1?e.charCodeAt(1):0)<<8|(e.length>2?e.charCodeAt(2):0);return[r.charAt(n>>>18),r.charAt(n>>>12&63),t>=2?"=":r.charAt(n>>>6&63),t>=1?"=":r.charAt(63&n)].join("")},l=e.btoa?function(t){return e.btoa(t)}:function(e){return e.replace(/[\s\S]{1,3}/g,u)},d=t?function(e){return(e.constructor===t.constructor?e:new t(e)).toString("base64")}:function(e){return l(c(e))},f=function(e,t){return t?d(String(e)).replace(/[+\/]/g,function(e){return"+"==e?"-":"_"}).replace(/=/g,""):d(String(e))},h=function(e){return f(e,!0)},p=new RegExp(["[À-ß][-¿]","[à-ï][-¿]{2}","[ð-÷][-¿]{3}"].join("|"),"g"),m=function(e){switch(e.length){case 4:var t=(7&e.charCodeAt(0))<<18|(63&e.charCodeAt(1))<<12|(63&e.charCodeAt(2))<<6|63&e.charCodeAt(3),n=t-65536;return i(55296+(n>>>10))+i(56320+(1023&n));case 3:return i((15&e.charCodeAt(0))<<12|(63&e.charCodeAt(1))<<6|63&e.charCodeAt(2));default:return i((31&e.charCodeAt(0))<<6|63&e.charCodeAt(1))}},g=function(e){return e.replace(p,m)},y=function(e){var t=e.length,n=t%4,r=(t>0?o[e.charAt(0)]<<18:0)|(t>1?o[e.charAt(1)]<<12:0)|(t>2?o[e.charAt(2)]<<6:0)|(t>3?o[e.charAt(3)]:0),a=[i(r>>>16),i(r>>>8&255),i(255&r)];return a.length-=[0,0,2,1][n],a.join("")},C=e.atob?function(t){return e.atob(t)}:function(e){return e.replace(/[\s\S]{1,4}/g,y)},v=t?function(e){return(e.constructor===t.constructor?e:new t(e,"base64")).toString()}:function(e){return g(C(e))},x=function(e){return v(String(e).replace(/[-_]/g,function(e){return"-"==e?"+":"/"}).replace(/[^A-Za-z0-9\+\/]/g,""))};return{VERSION:"2.1.9",atob:C,btoa:l,fromBase64:x,toBase64:f,utob:c,encode:f,encodeURI:h,btou:g,decode:x,noConflict:function(){var t=e.Base64;return e.Base64=n,t}}}();e.exports=n},function(e,t){var n=n||function(e,t){var n={},r=n.lib={},o=function(){},i=r.Base={extend:function(e){o.prototype=this;var t=new o;return e&&t.mixIn(e),t.hasOwnProperty("init")||(t.init=function(){t.$super.init.apply(this,arguments)}),t.init.prototype=t,t.$super=this,t},create:function(){var e=this.extend();return e.init.apply(e,arguments),e},init:function(){},mixIn:function(e){for(var t in e)e.hasOwnProperty(t)&&(this[t]=e[t]);e.hasOwnProperty("toString")&&(this.toString=e.toString)},clone:function(){return this.init.prototype.extend(this)}},a=r.WordArray=i.extend({init:function(e,t){e=this.words=e||[],this.sigBytes=void 0!=t?t:4*e.length},toString:function(e){return(e||c).stringify(this)},concat:function(e){var t=this.words,n=e.words,r=this.sigBytes;if(e=e.sigBytes,this.clamp(),r%4)for(var o=0;o<e;o++)t[r+o>>>2]|=(n[o>>>2]>>>24-o%4*8&255)<<24-(r+o)%4*8;else if(65535<n.length)for(o=0;o<e;o+=4)t[r+o>>>2]=n[o>>>2];else t.push.apply(t,n);return this.sigBytes+=e,this},clamp:function(){var t=this.words,n=this.sigBytes;t[n>>>2]&=4294967295<<32-n%4*8,t.length=e.ceil(n/4)},clone:function(){var e=i.clone.call(this);return e.words=this.words.slice(0),e},random:function(t){for(var n=[],r=0;r<t;r+=4)n.push(4294967296*e.random()|0);return new a.init(n,t)}}),s=n.enc={},c=s.Hex={stringify:function(e){var t=e.words;e=e.sigBytes;for(var n=[],r=0;r<e;r++){var o=t[r>>>2]>>>24-r%4*8&255;n.push((o>>>4).toString(16)),n.push((15&o).toString(16))}return n.join("")},parse:function(e){for(var t=e.length,n=[],r=0;r<t;r+=2)n[r>>>3]|=parseInt(e.substr(r,2),16)<<24-r%8*4;return new a.init(n,t/2)}},u=s.Latin1={stringify:function(e){var t=e.words;e=e.sigBytes;for(var n=[],r=0;r<e;r++)n.push(String.fromCharCode(t[r>>>2]>>>24-r%4*8&255));return n.join("")},parse:function(e){for(var t=e.length,n=[],r=0;r<t;r++)n[r>>>2]|=(255&e.charCodeAt(r))<<24-r%4*8;return new a.init(n,t)}},l=s.Utf8={stringify:function(e){try{return decodeURIComponent(escape(u.stringify(e)))}catch(e){throw Error("Malformed UTF-8 data")}},parse:function(e){return u.parse(unescape(encodeURIComponent(e)))}},d=r.BufferedBlockAlgorithm=i.extend({reset:function(){this._data=new a.init,this._nDataBytes=0},_append:function(e){"string"==typeof e&&(e=l.parse(e)),this._data.concat(e),this._nDataBytes+=e.sigBytes},_process:function(t){var n=this._data,r=n.words,o=n.sigBytes,i=this.blockSize,s=o/(4*i),s=t?e.ceil(s):e.max((0|s)-this._minBufferSize,0);if(t=s*i,o=e.min(4*t,o),t){for(var c=0;c<t;c+=i)this._doProcessBlock(r,c);c=r.splice(0,t),n.sigBytes-=o}return new a.init(c,o)},clone:function(){var e=i.clone.call(this);return e._data=this._data.clone(),e},_minBufferSize:0});r.Hasher=d.extend({cfg:i.extend(),init:function(e){this.cfg=this.cfg.extend(e),this.reset()},reset:function(){d.reset.call(this),this._doReset()},update:function(e){return this._append(e),this._process(),this},finalize:function(e){return e&&this._append(e),this._doFinalize()},blockSize:16,_createHelper:function(e){return function(t,n){return new e.init(n).finalize(t)}},_createHmacHelper:function(e){return function(t,n){return new f.HMAC.init(e,n).finalize(t)}}});var f=n.algo={};return n}(Math);!function(){var e=n,t=e.lib,r=t.WordArray,o=t.Hasher,i=[],t=e.algo.SHA1=o.extend({_doReset:function(){this._hash=new r.init([1732584193,4023233417,2562383102,271733878,3285377520])},_doProcessBlock:function(e,t){for(var n=this._hash.words,r=n[0],o=n[1],a=n[2],s=n[3],c=n[4],u=0;80>u;u++){if(16>u)i[u]=0|e[t+u];else{var l=i[u-3]^i[u-8]^i[u-14]^i[u-16];i[u]=l<<1|l>>>31}l=(r<<5|r>>>27)+c+i[u],l=20>u?l+(1518500249+(o&a|~o&s)):40>u?l+(1859775393+(o^a^s)):60>u?l+((o&a|o&s|a&s)-1894007588):l+((o^a^s)-899497514),c=s,s=a,a=o<<30|o>>>2,o=r,r=l}n[0]=n[0]+r|0,n[1]=n[1]+o|0,n[2]=n[2]+a|0,n[3]=n[3]+s|0,n[4]=n[4]+c|0},_doFinalize:function(){var e=this._data,t=e.words,n=8*this._nDataBytes,r=8*e.sigBytes;return t[r>>>5]|=128<<24-r%32,t[14+(r+64>>>9<<4)]=Math.floor(n/4294967296),t[15+(r+64>>>9<<4)]=n,e.sigBytes=4*t.length,this._process(),this._hash},clone:function(){var e=o.clone.call(this);return e._hash=this._hash.clone(),e}});e.SHA1=o._createHelper(t),e.HmacSHA1=o._createHmacHelper(t)}(),function(){var e=n,t=e.enc.Utf8;e.algo.HMAC=e.lib.Base.extend({init:function(e,n){e=this._hasher=new e.init,"string"==typeof n&&(n=t.parse(n));var r=e.blockSize,o=4*r;n.sigBytes>o&&(n=e.finalize(n)),n.clamp();for(var i=this._oKey=n.clone(),a=this._iKey=n.clone(),s=i.words,c=a.words,u=0;u<r;u++)s[u]^=1549556828,c[u]^=909522486;i.sigBytes=a.sigBytes=o,this.reset()},reset:function(){var e=this._hasher;e.reset(),e.update(this._iKey)},update:function(e){return this._hasher.update(e),this},finalize:function(e){var t=this._hasher;return e=t.finalize(e),t.reset(),t.finalize(this._oKey.clone().concat(e))}})}(),function(){var e=n,t=e.lib,r=t.WordArray,o=e.enc;o.Base64={stringify:function(e){var t=e.words,n=e.sigBytes,r=this._map;e.clamp();for(var o=[],i=0;i<n;i+=3)for(var a=t[i>>>2]>>>24-i%4*8&255,s=t[i+1>>>2]>>>24-(i+1)%4*8&255,c=t[i+2>>>2]>>>24-(i+2)%4*8&255,u=a<<16|s<<8|c,l=0;l<4&&i+.75*l<n;l++)o.push(r.charAt(u>>>6*(3-l)&63));var d=r.charAt(64);if(d)for(;o.length%4;)o.push(d);return o.join("")},parse:function(e){var t=e.length,n=this._map,o=n.charAt(64);if(o){var i=e.indexOf(o);-1!=i&&(t=i)}for(var a=[],s=0,c=0;c<t;c++)if(c%4){var u=n.indexOf(e.charAt(c-1))<<c%4*2,l=n.indexOf(e.charAt(c))>>>6-c%4*2;a[s>>>2]|=(u|l)<<24-s%4*8,s++}return r.create(a,s)},_map:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="}}(),e.exports=n},function(e,t){function n(e){return(""+e).replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/'/g,"&apos;").replace(/"/g,"&quot;").replace(o,"")}var r=new RegExp("^([^a-zA-Z_À-ÖØ-öø-ÿͰ-ͽͿ-῿‌-‍⁰-↏Ⰰ-⿿、-퟿豈-﷏ﷰ-�])|^((x|X)(m|M)(l|L))|([^a-zA-Z_À-ÖØ-öø-ÿͰ-ͽͿ-῿‌-‍⁰-↏Ⰰ-⿿、-퟿豈-﷏ﷰ-�-.0-9·̀-ͯ‿⁀])","g"),o=/[^\x09\x0A\x0D\x20-\xFF\x85\xA0-\uD7FF\uE000-\uFDCF\uFDE0-\uFFFD]/gm,i=function(e){var t=[];if(e instanceof Object)for(var n in e)e.hasOwnProperty(n)&&t.push(n);return t},a=function(e,t){var o=function(e,n,o,i,a){var s=void 0!==t.indent?t.indent:"\t",c=t.prettyPrint?"\n"+new Array(i).join(s):"";t.removeIllegalNameCharacters&&(e=e.replace(r,"_"));var u=[c,"<",e,o||""];return n&&n.length>0?(u.push(">"),u.push(n),a&&u.push(c),u.push("</"),u.push(e),u.push(">")):u.push("/>"),u.join("")};return function e(r,a,s){var c=typeof r;switch((Array.isArray?Array.isArray(r):r instanceof Array)?c="array":r instanceof Date&&(c="date"),c){case"array":var u=[];return r.map(function(t){u.push(e(t,1,s+1))}),t.prettyPrint&&u.push("\n"),u.join("");case"date":return r.toJSON?r.toJSON():r+"";case"object":var l=[];for(var d in r)if(r[d]instanceof Array)for(var f in r[d])l.push(o(d,e(r[d][f],0,s+1),null,s+1,i(r[d][f]).length));else l.push(o(d,e(r[d],0,s+1),null,s+1));return t.prettyPrint&&l.length>0&&l.push("\n"),l.join("");case"function":return r();default:return t.escape?n(r):""+r}}(e,0,0)},s=function(e){var t=['<?xml version="1.0" encoding="UTF-8"'];return e&&t.push(' standalone="yes"'),t.push("?>"),t.join("")},c=function(e,t){if(t||(t={xmlHeader:{standalone:!0},prettyPrint:!0,indent:"  "}),"string"==typeof e)try{e=JSON.parse(e.toString())}catch(e){return!1}var n="",r="";return t&&("object"==typeof t?(t.xmlHeader&&(n=s(!!t.xmlHeader.standalone)),void 0!==t.docType&&(r="<!DOCTYPE "+t.docType+">")):n=s()),t=t||{},[n,t.prettyPrint&&r?"\n":"",r,a(e,t)].join("").replace(/\n{2,}/g,"\n").replace(/\s+$/g,"")};e.exports=c},function(e,t){var n=function(e){function t(e,t){return e<<t|e>>>32-t}function n(e,t){var n,r,o,i,a;return o=2147483648&e,i=2147483648&t,n=1073741824&e,r=1073741824&t,a=(1073741823&e)+(1073741823&t),n&r?2147483648^a^o^i:n|r?1073741824&a?3221225472^a^o^i:1073741824^a^o^i:a^o^i}function r(e,t,n){return e&t|~e&n}function o(e,t,n){return e&n|t&~n}function i(e,t,n){return e^t^n}function a(e,t,n){return t^(e|~n)}function s(e,o,i,a,s,c,u){return e=n(e,n(n(r(o,i,a),s),u)),n(t(e,c),o)}function c(e,r,i,a,s,c,u){return e=n(e,n(n(o(r,i,a),s),u)),n(t(e,c),r)}function u(e,r,o,a,s,c,u){return e=n(e,n(n(i(r,o,a),s),u)),n(t(e,c),r)}function l(e,r,o,i,s,c,u){return e=n(e,n(n(a(r,o,i),s),u)),n(t(e,c),r)}function d(e){var t,n,r="",o="";for(n=0;n<=3;n++)t=e>>>8*n&255,o="0"+t.toString(16),r+=o.substr(o.length-2,2);return r}var f,h,p,m,g,y,C,v,x,k=Array();for(e=function(e){e=e.replace(/\r\n/g,"\n");for(var t="",n=0;n<e.length;n++){var r=e.charCodeAt(n);r<128?t+=String.fromCharCode(r):r>127&&r<2048?(t+=String.fromCharCode(r>>6|192),t+=String.fromCharCode(63&r|128)):(t+=String.fromCharCode(r>>12|224),t+=String.fromCharCode(r>>6&63|128),t+=String.fromCharCode(63&r|128))}return t}(e),k=function(e){for(var t,n=e.length,r=n+8,o=(r-r%64)/64,i=16*(o+1),a=Array(i-1),s=0,c=0;c<n;)t=(c-c%4)/4,s=c%4*8,a[t]=a[t]|e.charCodeAt(c)<<s,c++;return t=(c-c%4)/4,s=c%4*8,a[t]=a[t]|128<<s,a[i-2]=n<<3,a[i-1]=n>>>29,a}(e),y=1732584193,C=4023233417,v=2562383102,x=271733878,f=0;f<k.length;f+=16)h=y,p=C,m=v,g=x,y=s(y,C,v,x,k[f+0],7,3614090360),x=s(x,y,C,v,k[f+1],12,3905402710),v=s(v,x,y,C,k[f+2],17,606105819),C=s(C,v,x,y,k[f+3],22,3250441966),y=s(y,C,v,x,k[f+4],7,4118548399),x=s(x,y,C,v,k[f+5],12,1200080426),v=s(v,x,y,C,k[f+6],17,2821735955),C=s(C,v,x,y,k[f+7],22,4249261313),y=s(y,C,v,x,k[f+8],7,1770035416),x=s(x,y,C,v,k[f+9],12,2336552879),v=s(v,x,y,C,k[f+10],17,4294925233),C=s(C,v,x,y,k[f+11],22,2304563134),y=s(y,C,v,x,k[f+12],7,1804603682),x=s(x,y,C,v,k[f+13],12,4254626195),v=s(v,x,y,C,k[f+14],17,2792965006),C=s(C,v,x,y,k[f+15],22,1236535329),y=c(y,C,v,x,k[f+1],5,4129170786),x=c(x,y,C,v,k[f+6],9,3225465664),v=c(v,x,y,C,k[f+11],14,643717713),C=c(C,v,x,y,k[f+0],20,3921069994),y=c(y,C,v,x,k[f+5],5,3593408605),x=c(x,y,C,v,k[f+10],9,38016083),v=c(v,x,y,C,k[f+15],14,3634488961),C=c(C,v,x,y,k[f+4],20,3889429448),y=c(y,C,v,x,k[f+9],5,568446438),x=c(x,y,C,v,k[f+14],9,3275163606),v=c(v,x,y,C,k[f+3],14,4107603335),C=c(C,v,x,y,k[f+8],20,1163531501),y=c(y,C,v,x,k[f+13],5,2850285829),x=c(x,y,C,v,k[f+2],9,4243563512),v=c(v,x,y,C,k[f+7],14,1735328473),C=c(C,v,x,y,k[f+12],20,2368359562),y=u(y,C,v,x,k[f+5],4,4294588738),x=u(x,y,C,v,k[f+8],11,2272392833),v=u(v,x,y,C,k[f+11],16,1839030562),C=u(C,v,x,y,k[f+14],23,4259657740),y=u(y,C,v,x,k[f+1],4,2763975236),x=u(x,y,C,v,k[f+4],11,1272893353),v=u(v,x,y,C,k[f+7],16,4139469664),C=u(C,v,x,y,k[f+10],23,3200236656),y=u(y,C,v,x,k[f+13],4,681279174),x=u(x,y,C,v,k[f+0],11,3936430074),v=u(v,x,y,C,k[f+3],16,3572445317),C=u(C,v,x,y,k[f+6],23,76029189),y=u(y,C,v,x,k[f+9],4,3654602809),x=u(x,y,C,v,k[f+12],11,3873151461),v=u(v,x,y,C,k[f+15],16,530742520),C=u(C,v,x,y,k[f+2],23,3299628645),y=l(y,C,v,x,k[f+0],6,4096336452),x=l(x,y,C,v,k[f+7],10,1126891415),v=l(v,x,y,C,k[f+14],15,2878612391),C=l(C,v,x,y,k[f+5],21,4237533241),y=l(y,C,v,x,k[f+12],6,1700485571),x=l(x,y,C,v,k[f+3],10,2399980690),v=l(v,x,y,C,k[f+10],15,4293915773),C=l(C,v,x,y,k[f+1],21,2240044497),y=l(y,C,v,x,k[f+8],6,1873313359),x=l(x,y,C,v,k[f+15],10,4264355552),v=l(v,x,y,C,k[f+6],15,2734768916),C=l(C,v,x,y,k[f+13],21,1309151649),y=l(y,C,v,x,k[f+4],6,4149444226),x=l(x,y,C,v,k[f+11],10,3174756917),v=l(v,x,y,C,k[f+2],15,718787259),C=l(C,v,x,y,k[f+9],21,3951481745),y=n(y,h),C=n(C,p),v=n(v,m),x=n(x,g);return(d(y)+d(C)+d(v)+d(x)).toLowerCase()};e.exports=n},function(e,t){var n=function(e){var t,n,r,o=[],i=Object.keys(e);for(t=0;t<i.length;t++)n=i[t],r=e[n]||"",o.push(n+"="+encodeURIComponent(r));return o.join("&")},r=function(e,t){var r,o=e.filePath,i=e.headers||{},a=e.url,s=e.method,c=e.onProgress,u=function(e,n){t(e,{statusCode:n.statusCode,headers:n.header},n.data)};if(o){var l,d=a.match(/^(https?:\/\/[^\/]+\/)([^\/]*\/?)(.*)$/);e.pathStyle?(l=decodeURIComponent(d[3]||""),a=d[1]+d[2]):(l=decodeURIComponent(d[2]+d[3]||""),a=d[1]);var f={key:l,success_action_status:200,Signature:i.Authorization},h=["Cache-Control","Content-Type","Content-Disposition","Content-Encoding","Expires","x-cos-storage-class","x-cos-security-token"];for(var p in e.headers)e.headers.hasOwnProperty(p)&&(p.indexOf("x-cos-meta-")>-1||h.indexOf(p)>-1)&&(f[p]=e.headers[p]);i["x-cos-acl"]&&(f.acl=i["x-cos-acl"]),!f["Content-Type"]&&(f["Content-Type"]=""),r=wx.uploadFile({url:a,method:s,name:"file",filePath:o,formData:f,success:function(e){u(null,e)},fail:function(e){u(e.errMsg,e)}}),r.onProgressUpdate(function(e){c({loaded:e.totalBytesSent,total:e.totalBytesExpectedToSend,progress:e.progress/100})})}else{var m=e.qs&&n(e.qs)||"";m&&(a+=(a.indexOf("?")>-1?"&":"?")+m),i["Content-Length"]&&delete i["Content-Length"],wx.request({url:a,method:s,header:i,dataType:"text",data:e.body,success:function(e){u(null,e)},fail:function(e){u(e.errMsg,e)}})}return r};e.exports=r},function(e,t,n){var r=n(11).DOMParser,o=function(e){"use strict";function t(e){var t=e.localName;return null==t&&(t=e.baseName),null!=t&&""!=t||(t=e.nodeName),t}function n(e){return e.prefix}function o(e){return"string"==typeof e?e.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;").replace(/'/g,"&apos;"):e}function i(e,t,n,r){for(var o=0;o<e.length;o++){var i=e[o];if("string"==typeof i){if(i==r)break}else if(i instanceof RegExp){if(i.test(r))break}else if("function"==typeof i&&i(t,n,r))break}return o!=e.length}function a(t,n,r){switch(e.arrayAccessForm){case"property":t[n]instanceof Array?t[n+"_asArray"]=t[n]:t[n+"_asArray"]=[t[n]]}!(t[n]instanceof Array)&&e.arrayAccessFormPaths.length>0&&i(e.arrayAccessFormPaths,t,n,r)&&(t[n]=[t[n]])}function s(e){var t=e.split(/[-T:+Z]/g),n=new Date(t[0],t[1]-1,t[2]),r=t[5].split(".");if(n.setHours(t[3],t[4],r[0]),r.length>1&&n.setMilliseconds(r[1]),t[6]&&t[7]){var o=60*t[6]+Number(t[7]);o=0+("-"==(/\d\d-\d\d:\d\d$/.test(e)?"-":"+")?-1*o:o),n.setMinutes(n.getMinutes()-o-n.getTimezoneOffset())}else-1!==e.indexOf("Z",e.length-1)&&(n=new Date(Date.UTC(n.getFullYear(),n.getMonth(),n.getDate(),n.getHours(),n.getMinutes(),n.getSeconds(),n.getMilliseconds())));return n}function c(t,n,r){if(e.datetimeAccessFormPaths.length>0){var o=r.split(".#")[0];return i(e.datetimeAccessFormPaths,t,n,o)?s(t):t}return t}function u(t,n,r,o){return!(n==A.ELEMENT_NODE&&e.xmlElementsFilter.length>0)||i(e.xmlElementsFilter,t,r,o)}function l(r,o){if(r.nodeType==A.DOCUMENT_NODE){for(var i=new Object,s=r.childNodes,d=0;d<s.length;d++){var f=s.item(d);if(f.nodeType==A.ELEMENT_NODE){var h=t(f);i[h]=l(f,h)}}return i}if(r.nodeType==A.ELEMENT_NODE){var i=new Object;i.__cnt=0;for(var s=r.childNodes,d=0;d<s.length;d++){var f=s.item(d),h=t(f);if(f.nodeType!=A.COMMENT_NODE){var p=o+"."+h;u(i,f.nodeType,h,p)&&(i.__cnt++,null==i[h]?(i[h]=l(f,p),a(i,h,p)):(null!=i[h]&&(i[h]instanceof Array||(i[h]=[i[h]],a(i,h,p))),i[h][i[h].length]=l(f,p)))}}for(var m=0;m<r.attributes.length;m++){var g=r.attributes.item(m);i.__cnt++,i[e.attributePrefix+g.name]=g.value}var y=n(r);return null!=y&&""!=y&&(i.__cnt++,i.__prefix=y),null!=i["#text"]&&(i.__text=i["#text"],i.__text instanceof Array&&(i.__text=i.__text.join("\n")),e.stripWhitespaces&&(i.__text=i.__text.trim()),delete i["#text"],"property"==e.arrayAccessForm&&delete i["#text_asArray"],i.__text=c(i.__text,h,o+"."+h)),null!=i["#cdata-section"]&&(i.__cdata=i["#cdata-section"],delete i["#cdata-section"],"property"==e.arrayAccessForm&&delete i["#cdata-section_asArray"]),0==i.__cnt&&"text"==e.emptyNodeForm?i="":1==i.__cnt&&null!=i.__text?i=i.__text:1!=i.__cnt||null==i.__cdata||e.keepCData?i.__cnt>1&&null!=i.__text&&e.skipEmptyTextNodesForObj&&(e.stripWhitespaces&&""==i.__text||""==i.__text.trim())&&delete i.__text:i=i.__cdata,delete i.__cnt,!e.enableToStringFunc||null==i.__text&&null==i.__cdata||(i.toString=function(){return(null!=this.__text?this.__text:"")+(null!=this.__cdata?this.__cdata:"")}),i}if(r.nodeType==A.TEXT_NODE||r.nodeType==A.CDATA_SECTION_NODE)return r.nodeValue}function d(t,n,r,i){var a="<"+(null!=t&&null!=t.__prefix?t.__prefix+":":"")+n;if(null!=r)for(var s=0;s<r.length;s++){var c=r[s],u=t[c];e.escapeMode&&(u=o(u)),a+=" "+c.substr(e.attributePrefix.length)+"=",e.useDoubleQuotes?a+='"'+u+'"':a+="'"+u+"'"}return a+=i?"/>":">"}function f(e,t){return"</"+(null!=e.__prefix?e.__prefix+":":"")+t+">"}function h(e,t){return-1!==e.indexOf(t,e.length-t.length)}function p(t,n){return!!("property"==e.arrayAccessForm&&h(n.toString(),"_asArray")||0==n.toString().indexOf(e.attributePrefix)||0==n.toString().indexOf("__")||t[n]instanceof Function)}function m(e){var t=0;if(e instanceof Object)for(var n in e)p(e,n)||t++;return t}function g(t,n,r){return 0==e.jsonPropertiesFilter.length||""==r||i(e.jsonPropertiesFilter,t,n,r)}function y(t){var n=[];if(t instanceof Object)for(var r in t)-1==r.toString().indexOf("__")&&0==r.toString().indexOf(e.attributePrefix)&&n.push(r);return n}function C(t){var n="";return null!=t.__cdata&&(n+="<![CDATA["+t.__cdata+"]]>"),null!=t.__text&&(e.escapeMode?n+=o(t.__text):n+=t.__text),n}function v(t){var n="";return t instanceof Object?n+=C(t):null!=t&&(e.escapeMode?n+=o(t):n+=t),n}function x(e,t){return""===e?t:e+"."+t}function k(e,t,n,r){var o="";if(0==e.length)o+=d(e,t,n,!0);else for(var i=0;i<e.length;i++)o+=d(e[i],t,y(e[i]),!1),o+=S(e[i],x(r,t)),o+=f(e[i],t);return o}function S(e,t){var n="";if(m(e)>0)for(var r in e)if(!p(e,r)&&(""==t||g(e,r,x(t,r)))){var o=e[r],i=y(o);if(null==o||void 0==o)n+=d(o,r,i,!0);else if(o instanceof Object)if(o instanceof Array)n+=k(o,r,i,t);else if(o instanceof Date)n+=d(o,r,i,!1),n+=o.toISOString(),n+=f(o,r);else{var a=m(o);a>0||null!=o.__text||null!=o.__cdata?(n+=d(o,r,i,!1),n+=S(o,x(t,r)),n+=f(o,r)):n+=d(o,r,i,!0)}else n+=d(o,r,i,!1),n+=v(o),n+=f(o,r)}return n+=v(e)}e=e||{},function(){void 0===e.escapeMode&&(e.escapeMode=!0),e.attributePrefix=e.attributePrefix||"_",e.arrayAccessForm=e.arrayAccessForm||"none",e.emptyNodeForm=e.emptyNodeForm||"text",void 0===e.enableToStringFunc&&(e.enableToStringFunc=!0),e.arrayAccessFormPaths=e.arrayAccessFormPaths||[],void 0===e.skipEmptyTextNodesForObj&&(e.skipEmptyTextNodesForObj=!0),void 0===e.stripWhitespaces&&(e.stripWhitespaces=!0),e.datetimeAccessFormPaths=e.datetimeAccessFormPaths||[],void 0===e.useDoubleQuotes&&(e.useDoubleQuotes=!1),e.xmlElementsFilter=e.xmlElementsFilter||[],e.jsonPropertiesFilter=e.jsonPropertiesFilter||[],void 0===e.keepCData&&(e.keepCData=!1)}();var A={ELEMENT_NODE:1,TEXT_NODE:3,CDATA_SECTION_NODE:4,COMMENT_NODE:8,DOCUMENT_NODE:9};this.parseXmlString=function(e){if(void 0===e)return null;var t;if(r){var n=new r,o=null;try{o=n.parseFromString("INVALID","text/xml").getElementsByTagName("parsererror")[0].namespaceURI}catch(e){o=null}try{t=n.parseFromString(e,"text/xml"),null!=o&&t.getElementsByTagNameNS(o,"parsererror").length>0&&(t=null)}catch(e){t=null}}else 0==e.indexOf("<?")&&(e=e.substr(e.indexOf("?>")+2)),t=new ActiveXObject("Microsoft.XMLDOM"),t.async="false",t.loadXML(e);return t},this.asArray=function(e){return void 0===e||null==e?[]:e instanceof Array?e:[e]},this.toXmlDateTime=function(e){return e instanceof Date?e.toISOString():"number"==typeof e?new Date(e).toISOString():null},this.asDateTime=function(e){return"string"==typeof e?s(e):e},this.xml2json=function(e){return l(e)},this.xml_str2json=function(e){var t=this.parseXmlString(e);return null!=t?this.xml2json(t):null},this.json2xml_str=function(e){return S(e,"")},this.json2xml=function(e){var t=this.json2xml_str(e);return this.parseXmlString(t)},this.getVersion=function(){return"1.2.0"}},i=function(e){if(!e)return null;var t=new r,n=t.parseFromString(e,"text/xml"),i=new o,a=i.xml2json(n);return a.html&&a.getElementsByTagName("parsererror").length?null:a};e.exports=i},function(e,t,n){function r(e){this.options=e||{locator:{}}}function o(e,t,n){function r(t){var r=e[t];!r&&a&&(r=2==e.length?function(n){e(t,n)}:e),o[t]=r&&function(e){r("[xmldom "+t+"]\t"+e+s(n))}||function(){}}if(!e){if(t instanceof i)return t;e=t}var o={},a=e instanceof Function;return n=n||{},r("warning"),r("error"),r("fatalError"),o}function i(){this.cdata=!1}function a(e,t){t.lineNumber=e.lineNumber,t.columnNumber=e.columnNumber}function s(e){if(e)return"\n@"+(e.systemId||"")+"#[line:"+e.lineNumber+",col:"+e.columnNumber+"]"}function c(e,t,n){return"string"==typeof e?e.substr(t,n):e.length>=t+n||t?new java.lang.String(e,t,n)+"":e}function u(e,t){e.currentElement?e.currentElement.appendChild(t):e.doc.appendChild(t)}r.prototype.parseFromString=function(e,t){var n=this.options,r=new l,a=n.domBuilder||new i,s=n.errorHandler,c=n.locator,u=n.xmlns||{},d={lt:"<",gt:">",amp:"&",quot:'"',apos:"'"};return c&&a.setDocumentLocator(c),r.errorHandler=o(s,a,c),r.domBuilder=n.domBuilder||a,/\/x?html?$/.test(t)&&(d.nbsp=" ",d.copy="©",u[""]="http://www.w3.org/1999/xhtml"),u.xml=u.xml||"http://www.w3.org/XML/1998/namespace",e?r.parse(e,u,d):r.errorHandler.error("invalid doc source"),a.doc},i.prototype={startDocument:function(){this.doc=(new d).createDocument(null,null,null),this.locator&&(this.doc.documentURI=this.locator.systemId)},startElement:function(e,t,n,r){var o=this.doc,i=o.createElementNS(e,n||t),s=r.length;u(this,i),this.currentElement=i,this.locator&&a(this.locator,i);for(var c=0;c<s;c++){var e=r.getURI(c),l=r.getValue(c),n=r.getQName(c),d=o.createAttributeNS(e,n);this.locator&&a(r.getLocator(c),d),d.value=d.nodeValue=l,i.setAttributeNode(d)}},endElement:function(e,t,n){var r=this.currentElement;r.tagName;this.currentElement=r.parentNode},startPrefixMapping:function(e,t){},endPrefixMapping:function(e){},processingInstruction:function(e,t){var n=this.doc.createProcessingInstruction(e,t);this.locator&&a(this.locator,n),u(this,n)},ignorableWhitespace:function(e,t,n){},characters:function(e,t,n){if(e=c.apply(this,arguments)){if(this.cdata)var r=this.doc.createCDATASection(e);else var r=this.doc.createTextNode(e);this.currentElement?this.currentElement.appendChild(r):/^\s*$/.test(e)&&this.doc.appendChild(r),this.locator&&a(this.locator,r)}},skippedEntity:function(e){},endDocument:function(){this.doc.normalize()},setDocumentLocator:function(e){(this.locator=e)&&(e.lineNumber=0)},comment:function(e,t,n){e=c.apply(this,arguments);var r=this.doc.createComment(e);this.locator&&a(this.locator,r),u(this,r)},startCDATA:function(){this.cdata=!0},endCDATA:function(){this.cdata=!1},startDTD:function(e,t,n){var r=this.doc.implementation;if(r&&r.createDocumentType){var o=r.createDocumentType(e,t,n);this.locator&&a(this.locator,o),u(this,o)}},warning:function(e){console.warn("[xmldom warning]\t"+e,s(this.locator))},error:function(e){console.error("[xmldom error]\t"+e,s(this.locator))},fatalError:function(e){throw console.error("[xmldom fatalError]\t"+e,s(this.locator)),e}},"endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl".replace(/\w+/g,function(e){i.prototype[e]=function(){return null}});var l=n(12).XMLReader,d=t.DOMImplementation=n(1).DOMImplementation;t.XMLSerializer=n(1).XMLSerializer,t.DOMParser=r},function(e,t){function n(){}function r(e,t,n,r,u){function h(e){if(e>65535){e-=65536;var t=55296+(e>>10),n=56320+(1023&e);return String.fromCharCode(t,n)}return String.fromCharCode(e)}function p(e){var t=e.slice(1,-1);return t in n?n[t]:"#"===t.charAt(0)?h(parseInt(t.substr(1).replace("x","0x"))):(u.error("entity not found:"+e),e)}function m(t){if(t>A){var n=e.substring(A,t).replace(/&#?\w+;/g,p);x&&g(A),r.characters(n,0,t-A),A=t}}function g(t,n){for(;t>=C&&(n=v.exec(e));)y=n.index,C=y+n[0].length,x.lineNumber++;x.columnNumber=t-y+1}for(var y=0,C=0,v=/.*(?:\r\n?|\n)|.*$/g,x=r.locator,k=[{currentNSMap:t}],S={},A=0;;){try{var b=e.indexOf("<",A);if(b<0){if(!e.substr(A).match(/^\s*$/)){var R=r.doc,T=R.createTextNode(e.substr(A));R.appendChild(T),r.currentElement=T}return}switch(b>A&&m(b),e.charAt(b+1)){case"/":var w=e.indexOf(">",b+3),E=e.substring(b+2,w),_=k.pop();w<0?(E=e.substring(b+2).replace(/[\s<].*/,""),u.error("end tag name: "+E+" is not complete:"+_.tagName),w=b+1+E.length):E.match(/\s</)&&(E=E.replace(/[\s<].*/,""),u.error("end tag name: "+E+" maybe not complete"),w=b+1+E.length);var N=_.localNSMap,B=_.tagName==E;if(B||_.tagName&&_.tagName.toLowerCase()==E.toLowerCase()){if(r.endElement(_.uri,_.localName,E),N)for(var D in N)r.endPrefixMapping(D);B||u.fatalError("end tag name: "+E+" is not match the current start tagName:"+_.tagName)}else k.push(_);w++;break;case"?":x&&g(b),w=d(e,b,r);break;case"!":x&&g(b),w=l(e,b,r,u);break;default:x&&g(b);var O=new f,P=k[k.length-1].currentNSMap,w=i(e,b,O,P,p,u),I=O.length;if(!O.closed&&c(e,w,O.tagName,S)&&(O.closed=!0,n.nbsp||u.warning("unclosed xml attribute")),x&&I){for(var M=o(x,{}),L=0;L<I;L++){var F=O[L];g(F.offset),F.locator=o(x,{})}r.locator=M,a(O,r,P)&&k.push(O),r.locator=x}else a(O,r,P)&&k.push(O);"http://www.w3.org/1999/xhtml"!==O.uri||O.closed?w++:w=s(e,w,O.tagName,p,r)}}catch(e){u.error("element parse error: "+e),w=-1}w>A?A=w:m(Math.max(b,A)+1)}}function o(e,t){return t.lineNumber=e.lineNumber,t.columnNumber=e.columnNumber,t}function i(e,t,n,r,o,i){for(var a,s,c=++t,u=C;;){var l=e.charAt(c);switch(l){case"=":if(u===v)a=e.slice(t,c),u=k;else{if(u!==x)throw new Error("attribute equal must after attrName");u=k}break;case"'":case'"':if(u===k||u===v){if(u===v&&(i.warning('attribute value must after "="'),a=e.slice(t,c)),t=c+1,!((c=e.indexOf(l,t))>0))throw new Error("attribute value no end '"+l+"' match");s=e.slice(t,c).replace(/&#?\w+;/g,o),n.add(a,s,t-1),u=A}else{if(u!=S)throw new Error('attribute value must after "="');s=e.slice(t,c).replace(/&#?\w+;/g,o),n.add(a,s,t),i.warning('attribute "'+a+'" missed start quot('+l+")!!"),t=c+1,u=A}break;case"/":switch(u){case C:n.setTagName(e.slice(t,c));case A:case b:case R:u=R,n.closed=!0;case S:case v:case x:break;default:throw new Error("attribute invalid close char('/')")}break;case"":return i.error("unexpected end of input"),u==C&&n.setTagName(e.slice(t,c)),c;case">":switch(u){case C:n.setTagName(e.slice(t,c));case A:case b:case R:break;case S:case v:s=e.slice(t,c),"/"===s.slice(-1)&&(n.closed=!0,s=s.slice(0,-1));case x:u===x&&(s=a),u==S?(i.warning('attribute "'+s+'" missed quot(")!!'),n.add(a,s.replace(/&#?\w+;/g,o),t)):("http://www.w3.org/1999/xhtml"===r[""]&&s.match(/^(?:disabled|checked|selected)$/i)||i.warning('attribute "'+s+'" missed value!! "'+s+'" instead!!'),n.add(s,s,t));break;case k:throw new Error("attribute value missed!!")}return c;case"":l=" ";default:if(l<=" ")switch(u){case C:n.setTagName(e.slice(t,c)),u=b;break;case v:a=e.slice(t,c),u=x;break;case S:var s=e.slice(t,c).replace(/&#?\w+;/g,o);i.warning('attribute "'+s+'" missed quot(")!!'),n.add(a,s,t);case A:u=b}else switch(u){case x:n.tagName;"http://www.w3.org/1999/xhtml"===r[""]&&a.match(/^(?:disabled|checked|selected)$/i)||i.warning('attribute "'+a+'" missed value!! "'+a+'" instead2!!'),n.add(a,a,t),t=c,u=v;break;case A:i.warning('attribute space is required"'+a+'"!!');case b:u=v,t=c;break;case k:u=S,t=c;break;case R:throw new Error("elements closed character '/' and '>' must be connected to")}}c++}}function a(e,t,n){for(var r=e.tagName,o=null,i=e.length;i--;){var a=e[i],s=a.qName,c=a.value,l=s.indexOf(":");if(l>0)var d=a.prefix=s.slice(0,l),f=s.slice(l+1),h="xmlns"===d&&f;else f=s,d=null,h="xmlns"===s&&"";a.localName=f,!1!==h&&(null==o&&(o={},u(n,n={})),n[h]=o[h]=c,a.uri="http://www.w3.org/2000/xmlns/",t.startPrefixMapping(h,c))}for(var i=e.length;i--;){a=e[i];var d=a.prefix;d&&("xml"===d&&(a.uri="http://www.w3.org/XML/1998/namespace"),"xmlns"!==d&&(a.uri=n[d||""]))}var l=r.indexOf(":");l>0?(d=e.prefix=r.slice(0,l),f=e.localName=r.slice(l+1)):(d=null,f=e.localName=r);var p=e.uri=n[d||""];if(t.startElement(p,f,r,e),!e.closed)return e.currentNSMap=n,e.localNSMap=o,!0;if(t.endElement(p,f,r),o)for(d in o)t.endPrefixMapping(d)}function s(e,t,n,r,o){if(/^(?:script|textarea)$/i.test(n)){var i=e.indexOf("</"+n+">",t),a=e.substring(t+1,i);if(/[&<]/.test(a))return/^script$/i.test(n)?(o.characters(a,0,a.length),i):(a=a.replace(/&#?\w+;/g,r),o.characters(a,0,a.length),i)}return t+1}function c(e,t,n,r){var o=r[n];return null==o&&(o=e.lastIndexOf("</"+n+">"),o<t&&(o=e.lastIndexOf("</"+n)),r[n]=o),o<t}function u(e,t){for(var n in e)t[n]=e[n]}function l(e,t,n,r){switch(e.charAt(t+2)){case"-":if("-"===e.charAt(t+3)){var o=e.indexOf("--\x3e",t+4);return o>t?(n.comment(e,t+4,o-t-4),o+3):(r.error("Unclosed comment"),-1)}return-1;default:if("CDATA["==e.substr(t+3,6)){var o=e.indexOf("]]>",t+9);return n.startCDATA(),n.characters(e,t+9,o-t-9),n.endCDATA(),o+3}var i=p(e,t),a=i.length;if(a>1&&/!doctype/i.test(i[0][0])){var s=i[1][0],c=a>3&&/^public$/i.test(i[2][0])&&i[3][0],u=a>4&&i[4][0],l=i[a-1];return n.startDTD(s,c&&c.replace(/^(['"])(.*?)\1$/,"$2"),u&&u.replace(/^(['"])(.*?)\1$/,"$2")),n.endDTD(),l.index+l[0].length}}return-1}function d(e,t,n){var r=e.indexOf("?>",t);if(r){var o=e.substring(t,r).match(/^<\?(\S*)\s*([\s\S]*?)\s*$/);if(o){o[0].length;return n.processingInstruction(o[1],o[2]),r+2}return-1}return-1}function f(e){}function h(e,t){return e.__proto__=t,e}function p(e,t){var n,r=[],o=/'[^']+'|"[^"]+"|[^\s<>\/=]+=?|(\/?\s*>|<)/g;for(o.lastIndex=t,o.exec(e);n=o.exec(e);)if(r.push(n),n[1])return r}var m=/[A-Z_a-z\xC0-\xD6\xD8-\xF6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/,g=new RegExp("[\\-\\.0-9"+m.source.slice(1,-1)+"\\u00B7\\u0300-\\u036F\\u203F-\\u2040]"),y=new RegExp("^"+m.source+g.source+"*(?::"+m.source+g.source+"*)?$"),C=0,v=1,x=2,k=3,S=4,A=5,b=6,R=7;n.prototype={parse:function(e,t,n){var o=this.domBuilder;o.startDocument(),u(t,t={}),r(e,t,n,o,this.errorHandler),o.endDocument()}},f.prototype={setTagName:function(e){if(!y.test(e))throw new Error("invalid tagName:"+e);this.tagName=e},add:function(e,t,n){if(!y.test(e))throw new Error("invalid attribute:"+e);this[this.length++]={qName:e,value:t,offset:n}},length:0,getLocalName:function(e){return this[e].localName},getLocator:function(e){return this[e].locator},getQName:function(e){return this[e].qName},getURI:function(e){return this[e].uri},getValue:function(e){return this[e].value}},h({},h.prototype)instanceof h||(h=function(e,t){function n(){}n.prototype=t,n=new n;for(t in e)n[t]=e[t];return n}),t.XMLReader=n},function(e,t,n){function r(e,t){var n=e.Bucket,r=e.Region,a=e.Key,s=e.UploadId,c=e.Level||"task",l=e.AsyncLimit,d=this,f=new u;if(f.on("error",function(e){return t(e)}),f.on("get_abort_array",function(i){o.call(d,{Bucket:n,Region:r,Key:a,Headers:e.Headers,AsyncLimit:l,AbortArray:i},function(e,n){if(e)return t(e);t(null,n)})}),"bucket"===c)i.call(d,{Bucket:n,Region:r},function(e,n){if(e)return t(e);f.emit("get_abort_array",n.UploadList||[])});else if("file"===c){if(!a)return t({error:"abort_upload_task_no_key"});i.call(d,{Bucket:n,Region:r,Key:a},function(e,n){if(e)return t(e);f.emit("get_abort_array",n.UploadList||[])})}else{if("task"!==c)return t({error:"abort_unknown_level"});if(!s)return t({error:"abort_upload_task_no_id"});if(!a)return t({error:"abort_upload_task_no_key"});f.emit("get_abort_array",[{Key:a,UploadId:s}])}}function o(e,t){var n=e.Bucket,r=e.Region,o=e.Key,i=e.AbortArray,a=e.AsyncLimit||1,s=this,u=0,l=new Array(i.length);c.eachLimit(i,a,function(t,i){var a=u;if(o&&o!==t.Key)return l[a]={error:{KeyNotMatch:!0}},void i(null);var c=t.UploadId||t.UploadID;s.multipartAbort({Bucket:n,Region:r,Key:t.Key,Headers:e.Headers,UploadId:c},function(e,o){var s={Bucket:n,Region:r,Key:t.Key,UploadId:c};l[a]={error:e,task:s},i(null)}),u++},function(e){if(e)return t(e);for(var n=[],r=[],o=0,i=l.length;o<i;o++){var a=l[o];a.task&&(a.error?r.push(a.task):n.push(a.task))}return t(null,{successList:n,errorList:r})})}function i(e,t){var n=this,r=[],o={Bucket:e.Bucket,Region:e.Region,Prefix:e.Key},i=function(){n.multipartList(o,function(e,n){if(e)return t(e);r.push.apply(r,n.Upload||[]),"true"==n.IsTruncated?(o.KeyMarker=n.NextKeyMarker,o.UploadIdMarker=n.NextUploadIdMarker,i()):t(null,{UploadList:r})})};i()}function a(e,t){var n=new u,r=this,o=e.Bucket,i=e.Region,a=e.Key,d=e.CopySource,f=d.match(/^([^.]+-\d+)\.cos(v6)?\.([^.]+)\.[^\/]+\/(.+)$/);if(!f)return void t({error:"CopySource format error"});var h=f[1],p=f[3],m=decodeURIComponent(f[4]),g=void 0===e.SliceSize?r.options.CopySliceSize:e.SliceSize;g=Math.max(0,Math.min(g,5368709120));var y,C,v=e.ChunkSize||this.options.CopyChunkSize,x=this.options.CopyChunkParallelLimit,k=0;n.on("copy_slice_complete",function(e){r.multipartComplete({Bucket:o,Region:i,Key:a,UploadId:e.UploadId,Parts:e.PartList},function(e,n){if(e)return C(null,!0),t(e);C({loaded:y,total:y},!0),t(null,n)})}),n.on("get_copy_data_finish",function(e){c.eachLimit(e.PartList,x,function(t,n){var c=t.PartNumber,u=t.CopySourceRange,l=t.end-t.start,f=0;s.call(r,{Bucket:o,Region:i,Key:a,CopySource:d,UploadId:e.UploadId,PartNumber:c,CopySourceRange:u,onProgress:function(e){k+=e.loaded-f,f=e.loaded,C({loaded:k,total:y})}},function(e,r){if(e)return n(e);C({loaded:k,total:y}),k+=l-f,t.ETag=r.ETag,n(e||null,r)})},function(r){if(r)return C(null,!0),t(r);n.emit("copy_slice_complete",e)})}),n.on("get_file_size_finish",function(s){!function(){for(var t=[1,2,4,8,16,32,64,128,256,512,1024,2048,4096,5120],n=1048576,o=0;o<t.length&&(n=1024*t[o]*1024,!(y/n<=r.options.MaxPartNumber));o++);e.ChunkSize=v=Math.max(v,n);for(var i=Math.ceil(y/v),a=[],s=1;s<=i;s++){var c=(s-1)*v,u=s*v<y?s*v-1:y-1,l={PartNumber:s,start:c,end:u,CopySourceRange:"bytes="+c+"-"+u};a.push(l)}e.PartList=a}();var c;c="Replaced"===e.Headers["x-cos-metadata-directive"]?e.Headers:s,c["x-cos-storage-class"]=e.Headers["x-cos-storage-class"]||s["x-cos-storage-class"],c=l.clearKey(c),r.multipartInit({Bucket:o,Region:i,Key:a,Headers:c},function(r,o){if(r)return t(r);e.UploadId=o.UploadId,n.emit("get_copy_data_finish",e)})}),r.headObject({Bucket:h,Region:p,Key:m},function(o,i){if(o)return void t(o.statusCode&&404===o.statusCode?{ErrorStatus:m+" Not Exist"}:o);if(void 0===(y=e.FileSize=i.headers["content-length"])||!y)return void t({error:'get Content-Length error, please add "Content-Length" to CORS ExposeHeader setting.'});if(C=l.throttleOnProgress.call(r,y,e.onProgress),y<=g)e.Headers["x-cos-metadata-directive"]||(e.Headers["x-cos-metadata-directive"]="Copy"),r.putObjectCopy(e,function(e,n){if(e)return C(null,!0),t(e);C({loaded:y,total:y},!0),t(e,n)});else{var a=i.headers,s={"Cache-Control":a["cache-control"],"Content-Disposition":a["content-disposition"],"Content-Encoding":a["content-encoding"],"Content-Type":a["content-type"],Expires:a.expires,"x-cos-storage-class":a["x-cos-storage-class"]};l.each(a,function(e,t){0===t.indexOf("x-cos-meta-")&&t.length>"x-cos-meta-".length&&(s[t]=e)}),n.emit("get_file_size_finish",s)}})}function s(e,t){var n=e.TaskId,r=e.Bucket,o=e.Region,i=e.Key,a=e.CopySource,s=e.UploadId,u=1*e.PartNumber,l=e.CopySourceRange,d=this.options.ChunkRetryTimes+1,f=this;c.retry(d,function(t){f.uploadPartCopy({TaskId:n,Bucket:r,Region:o,Key:i,CopySource:a,UploadId:s,PartNumber:u,CopySourceRange:l,onProgress:e.onProgress},function(e,n){t(e||null,n)})},function(e,n){return t(e,n)})}var c=n(14),u=n(2).EventProxy,l=n(0),d={abortUploadTask:r,sliceCopyFile:a};e.exports.init=function(e,t){l.each(d,function(t,n){e.prototype[n]=l.apiWrapper(n,t)})}},function(e,t){var n=function(e,t,n,r){if(r=r||function(){},!e.length||t<=0)return r();var o=0,i=0,a=0;!function s(){if(o>=e.length)return r();for(;a<t&&i<e.length;)i+=1,a+=1,n(e[i-1],function(t){t?(r(t),r=function(){}):(o+=1,a-=1,o>=e.length?r():s())})}()},r=function(e,t,n){var r=function(o){t(function(t,i){t&&o<e?r(o+1):n(t,i)})};e<1?n():r(1)},o={eachLimit:n,retry:r};e.exports=o},function(e,t,n){"use strict";function r(e,t){"function"==typeof e&&(t=e,e={});var n=this.options.ServiceDomain,r=e.AppId||this.options.appId;n?(n=n.replace(/\{\{AppId\}\}/gi,r||"").replace(/\{\{.*?\}\}/gi,""),/^[a-zA-Z]+:\/\//.test(n)||(n="https://"+n),"/"===n.slice(-1)&&(n=n.slice(0,-1))):n="https://service.cos.myqcloud.com",ee.call(this,{Action:"name/cos:GetService",url:n+"/",method:"GET"},function(e,n){if(e)return t(e);var r=n&&n.ListAllMyBucketsResult&&n.ListAllMyBucketsResult.Buckets&&n.ListAllMyBucketsResult.Buckets.Bucket||[];r=re.isArray(r)?r:[r],t(null,{Buckets:r,statusCode:n.statusCode,headers:n.headers})})}function o(e,t){ee.call(this,{Action:"name/cos:HeadBucket",Bucket:e.Bucket,Region:e.Region,headers:e.Headers,method:"HEAD"},function(e,n){t(e,n)})}function i(e,t){var n={};n.prefix=e.Prefix||"",n.delimiter=e.Delimiter,n.marker=e.Marker,n["max-keys"]=e.MaxKeys,n["encoding-type"]=e.EncodingType,ee.call(this,{Action:"name/cos:GetBucket",ResourceKey:n.prefix,method:"GET",Bucket:e.Bucket,Region:e.Region,headers:e.Headers,qs:n},function(e,n){if(e)return t(e);var r=n.ListBucketResult||{},o=r.Contents||[],i=r.CommonPrefixes||[];o=re.isArray(o)?o:[o],i=re.isArray(i)?i:[i];var a=re.clone(r);re.extend(a,{Contents:o,CommonPrefixes:i,statusCode:n.statusCode,headers:n.headers}),t(null,a)})}function a(e,t){var n=this,r={};r["x-cos-acl"]=e.ACL,r["x-cos-grant-read"]=e.GrantRead,r["x-cos-grant-write"]=e.GrantWrite,r["x-cos-grant-read-acp"]=e.GrantReadAcp,r["x-cos-grant-write-acp"]=e.GrantWriteAcp,r["x-cos-grant-full-control"]=e.GrantFullControl,ee.call(this,{Action:"name/cos:PutBucket",method:"PUT",Bucket:e.Bucket,Region:e.Region,headers:r},function(r,o){if(r)return t(r);var i=Z({domain:n.options.Domain,bucket:e.Bucket,region:e.Region,isLocation:!0});t(null,{Location:i,statusCode:o.statusCode,headers:o.headers})})}function s(e,t){ee.call(this,{Action:"name/cos:DeleteBucket",Bucket:e.Bucket,Region:e.Region,headers:e.Headers,method:"DELETE"},function(e,n){return e&&204===e.statusCode?t(null,{statusCode:e.statusCode}):e?t(e):void t(null,{statusCode:n.statusCode,headers:n.headers})})}function c(e,t){ee.call(this,{Action:"name/cos:GetBucketACL",method:"GET",Bucket:e.Bucket,Region:e.Region,headers:e.Headers,action:"acl"},function(e,n){if(e)return t(e);var r=n.AccessControlPolicy||{},o=r.Owner||{},i=r.AccessControlList.Grant||[];i=re.isArray(i)?i:[i];var a=W(r);n.headers&&n.headers["x-cos-acl"]&&(a.ACL=n.headers["x-cos-acl"]),a=re.extend(a,{Owner:o,Grants:i,statusCode:n.statusCode,headers:n.headers}),t(null,a)})}function u(e,t){var n=e.Headers,r="";if(e.AccessControlPolicy){var o=re.clone(e.AccessControlPolicy||{}),i=o.Grants||o.Grant;i=re.isArray(i)?i:[i],delete o.Grant,delete o.Grants,o.AccessControlList={Grant:i},r=re.json2xml({AccessControlPolicy:o}),n["Content-Type"]="application/xml",n["Content-MD5"]=re.binaryBase64(re.md5(r))}re.each(n,function(e,t){0===t.indexOf("x-cos-grant-")&&(n[t]=Q(n[t]))}),ee.call(this,{Action:"name/cos:PutBucketACL",method:"PUT",Bucket:e.Bucket,Region:e.Region,headers:n,action:"acl",body:r},function(e,n){if(e)return t(e);t(null,{statusCode:n.statusCode,headers:n.headers})})}function l(e,t){ee.call(this,{Action:"name/cos:GetBucketCORS",method:"GET",Bucket:e.Bucket,Region:e.Region,headers:e.Headers,action:"cors"},function(e,n){if(e)if(404===e.statusCode&&e.error&&"NoSuchCORSConfiguration"===e.error.Code){var r={CORSRules:[],statusCode:e.statusCode};e.headers&&(r.headers=e.headers),t(null,r)}else t(e);else{var o=n.CORSConfiguration||{},i=o.CORSRules||o.CORSRule||[];i=re.clone(re.isArray(i)?i:[i]),re.each(i,function(e){re.each(["AllowedOrigin","AllowedHeader","AllowedMethod","ExposeHeader"],function(t,n){var r=t+"s",o=e[r]||e[t]||[];delete e[t],e[r]=re.isArray(o)?o:[o]})}),t(null,{CORSRules:i,statusCode:n.statusCode,headers:n.headers})}})}function d(e,t){var n=e.CORSConfiguration||{},r=n.CORSRules||e.CORSRules||[];r=re.clone(re.isArray(r)?r:[r]),re.each(r,function(e){re.each(["AllowedOrigin","AllowedHeader","AllowedMethod","ExposeHeader"],function(t,n){var r=t+"s",o=e[r]||e[t]||[];delete e[r],e[t]=re.isArray(o)?o:[o]})});var o=re.json2xml({CORSConfiguration:{CORSRule:r}}),i=e.Headers;i["Content-Type"]="application/xml",i["Content-MD5"]=re.binaryBase64(re.md5(o)),ee.call(this,{Action:"name/cos:PutBucketCORS",method:"PUT",Bucket:e.Bucket,Region:e.Region,body:o,action:"cors",headers:i},function(e,n){if(e)return t(e);t(null,{statusCode:n.statusCode,headers:n.headers})})}function f(e,t){ee.call(this,{Action:"name/cos:DeleteBucketCORS",method:"DELETE",Bucket:e.Bucket,Region:e.Region,headers:e.Headers,action:"cors"},function(e,n){return e&&204===e.statusCode?t(null,{statusCode:e.statusCode}):e?t(e):void t(null,{statusCode:n.statusCode||e.statusCode,headers:n.headers})})}function h(e,t){var n=e.Policy,r=n;try{"string"==typeof n?n=JSON.parse(r):r=JSON.stringify(n)}catch(e){t({error:"Policy format error"})}var o=e.Headers;o["Content-Type"]="application/json",o["Content-MD5"]=re.binaryBase64(re.md5(r)),ee.call(this,{Action:"name/cos:PutBucketPolicy",method:"PUT",Bucket:e.Bucket,Region:e.Region,action:"policy",body:re.isBrowser?r:n,headers:o,json:!0},function(e,n){return e&&204===e.statusCode?t(null,{statusCode:e.statusCode}):e?t(e):void t(null,{statusCode:n.statusCode,headers:n.headers})})}function p(e,t){ee.call(this,{Action:"name/cos:DeleteBucketPolicy",method:"DELETE",Bucket:e.Bucket,Region:e.Region,headers:e.Headers,action:"policy"},function(e,n){return e&&204===e.statusCode?t(null,{statusCode:e.statusCode}):e?t(e):void t(null,{statusCode:n.statusCode||e.statusCode,headers:n.headers})})}function m(e,t){ee.call(this,{Action:"name/cos:GetBucketLocation",method:"GET",Bucket:e.Bucket,Region:e.Region,headers:e.Headers,action:"location"},function(e,n){if(e)return t(e);t(null,n)})}function g(e,t){ee.call(this,{Action:"name/cos:GetBucketPolicy",method:"GET",Bucket:e.Bucket,Region:e.Region,headers:e.Headers,action:"policy",rawBody:!0},function(e,n){if(e)return t(e.statusCode&&403===e.statusCode?{ErrorStatus:"Access Denied"}:e.statusCode&&405===e.statusCode?{ErrorStatus:"Method Not Allowed"}:e.statusCode&&404===e.statusCode?{ErrorStatus:"Policy Not Found"}:e);var r={};try{r=JSON.parse(n.body)}catch(e){}t(null,{Policy:r,statusCode:n.statusCode,headers:n.headers})})}function y(e,t){ee.call(this,{Action:"name/cos:GetBucketTagging",method:"GET",Bucket:e.Bucket,Region:e.Region,headers:e.Headers,action:"tagging"},function(e,n){if(e)if(404!==e.statusCode||!e.error||"Not Found"!==e.error&&"NoSuchTagSet"!==e.error.Code)t(e);else{var r={Tags:[],statusCode:e.statusCode};e.headers&&(r.headers=e.headers),t(null,r)}else{var o=[];try{o=n.Tagging.TagSet.Tag||[]}catch(e){}o=re.clone(re.isArray(o)?o:[o]),t(null,{Tags:o,statusCode:n.statusCode,headers:n.headers})}})}function C(e,t){var n=e.Tagging||{},r=n.TagSet||n.Tags||e.Tags||[];r=re.clone(re.isArray(r)?r:[r]);var o=re.json2xml({Tagging:{TagSet:{Tag:r}}}),i=e.Headers;i["Content-Type"]="application/xml",i["Content-MD5"]=re.binaryBase64(re.md5(o)),ee.call(this,{Action:"name/cos:PutBucketTagging",method:"PUT",Bucket:e.Bucket,Region:e.Region,body:o,action:"tagging",headers:i},function(e,n){return e&&204===e.statusCode?t(null,{statusCode:e.statusCode}):e?t(e):void t(null,{statusCode:n.statusCode,headers:n.headers})})}function v(e,t){ee.call(this,{Action:"name/cos:DeleteBucketTagging",method:"DELETE",Bucket:e.Bucket,Region:e.Region,headers:e.Headers,action:"tagging"},function(e,n){return e&&204===e.statusCode?t(null,{statusCode:e.statusCode}):e?t(e):void t(null,{statusCode:n.statusCode,headers:n.headers})})}function x(e,t){var n=e.LifecycleConfiguration||{},r=n.Rules||[];r=re.clone(r);var o=re.json2xml({LifecycleConfiguration:{Rule:r}}),i=e.Headers;i["Content-Type"]="application/xml",i["Content-MD5"]=re.binaryBase64(re.md5(o)),ee.call(this,{Action:"name/cos:PutBucketLifecycle",method:"PUT",Bucket:e.Bucket,Region:e.Region,body:o,action:"lifecycle",headers:i},function(e,n){return e&&204===e.statusCode?t(null,{statusCode:e.statusCode}):e?t(e):void t(null,{statusCode:n.statusCode,headers:n.headers})})}function k(e,t){ee.call(this,{Action:"name/cos:GetBucketLifecycle",method:"GET",Bucket:e.Bucket,Region:e.Region,headers:e.Headers,action:"lifecycle"},function(e,n){if(e)if(404===e.statusCode&&e.error&&"NoSuchLifecycleConfiguration"===e.error.Code){var r={Rules:[],statusCode:e.statusCode};e.headers&&(r.headers=e.headers),t(null,r)}else t(e);else{var o=[];try{o=n.LifecycleConfiguration.Rule||[]}catch(e){}o=re.clone(re.isArray(o)?o:[o]),t(null,{Rules:o,statusCode:n.statusCode,headers:n.headers})}})}function S(e,t){ee.call(this,{Action:"name/cos:DeleteBucketLifecycle",method:"DELETE",Bucket:e.Bucket,Region:e.Region,headers:e.Headers,action:"lifecycle"},function(e,n){return e&&204===e.statusCode?t(null,{statusCode:e.statusCode}):e?t(e):void t(null,{statusCode:n.statusCode,headers:n.headers})})}function A(e,t){if(!e.VersioningConfiguration)return void t({error:"missing param VersioningConfiguration"});var n=e.VersioningConfiguration||{},r=re.json2xml({VersioningConfiguration:n}),o=e.Headers;o["Content-Type"]="application/xml",o["Content-MD5"]=re.binaryBase64(re.md5(r)),ee.call(this,{Action:"name/cos:PutBucketVersioning",method:"PUT",Bucket:e.Bucket,Region:e.Region,body:r,action:"versioning",headers:o},function(e,n){return e&&204===e.statusCode?t(null,{statusCode:e.statusCode}):e?t(e):void t(null,{statusCode:n.statusCode,headers:n.headers})})}function b(e,t){ee.call(this,{Action:"name/cos:GetBucketVersioning",method:"GET",Bucket:e.Bucket,Region:e.Region,headers:e.Headers,action:"versioning"},function(e,n){e||!n.VersioningConfiguration&&(n.VersioningConfiguration={}),t(e,n)})}function R(e,t){var n=re.clone(e.ReplicationConfiguration),r=re.json2xml({ReplicationConfiguration:n});r=r.replace(/<(\/?)Rules>/gi,"<$1Rule>"),r=r.replace(/<(\/?)Tags>/gi,"<$1Tag>");var o=e.Headers;o["Content-Type"]="application/xml",o["Content-MD5"]=re.binaryBase64(re.md5(r)),ee.call(this,{Action:"name/cos:PutBucketReplication",method:"PUT",Bucket:e.Bucket,Region:e.Region,body:r,action:"replication",headers:o},function(e,n){return e&&204===e.statusCode?t(null,{statusCode:e.statusCode}):e?t(e):void t(null,{statusCode:n.statusCode,headers:n.headers})})}function T(e,t){ee.call(this,{Action:"name/cos:GetBucketReplication",method:"GET",Bucket:e.Bucket,Region:e.Region,headers:e.Headers,action:"replication"},function(e,n){if(e)if(404!==e.statusCode||!e.error||"Not Found"!==e.error&&"ReplicationConfigurationnotFoundError"!==e.error.Code)t(e);else{var r={ReplicationConfiguration:{Rules:[]},statusCode:e.statusCode};e.headers&&(r.headers=e.headers),t(null,r)}else e||!n.ReplicationConfiguration&&(n.ReplicationConfiguration={}),n.ReplicationConfiguration.Rule&&(n.ReplicationConfiguration.Rules=n.ReplicationConfiguration.Rule,delete n.ReplicationConfiguration.Rule),t(e,n)})}function w(e,t){ee.call(this,{Action:"name/cos:DeleteBucketReplication",method:"DELETE",Bucket:e.Bucket,Region:e.Region,headers:e.Headers,action:"replication"},function(e,n){return e&&204===e.statusCode?t(null,{statusCode:e.statusCode}):e?t(e):void t(null,{statusCode:n.statusCode,headers:n.headers})})}function E(e,t){ee.call(this,{Action:"name/cos:HeadObject",method:"HEAD",Bucket:e.Bucket,Region:e.Region,Key:e.Key,VersionId:e.VersionId,headers:e.Headers},function(n,r){if(n){var o=n.statusCode;return e.Headers["If-Modified-Since"]&&o&&304===o?t(null,{NotModified:!0,statusCode:o}):t(n)}r.headers&&r.headers.etag&&(r.ETag=r.headers&&r.headers.etag),t(null,r)})}function _(e,t){var n={};n.prefix=e.Prefix||"",n.delimiter=e.Delimiter,n["key-marker"]=e.KeyMarker,n["version-id-marker"]=e.VersionIdMarker,n["max-keys"]=e.MaxKeys,n["encoding-type"]=e.EncodingType,ee.call(this,{Action:"name/cos:GetBucketObjectVersions",ResourceKey:n.prefix,method:"GET",Bucket:e.Bucket,Region:e.Region,headers:e.Headers,qs:n,action:"versions"},function(e,n){if(e)return t(e);var r=n.ListVersionsResult||{},o=r.DeleteMarker||[];o=re.isArray(o)?o:[o];var i=r.Version||[];i=re.isArray(i)?i:[i];var a=re.clone(r);delete a.DeleteMarker,delete a.Version,re.extend(a,{DeleteMarkers:o,Versions:i,statusCode:n.statusCode,headers:n.headers}),t(null,a)})}function N(e,t){var n={};n["response-content-type"]=e.ResponseContentType,n["response-content-language"]=e.ResponseContentLanguage,n["response-expires"]=e.ResponseExpires,n["response-cache-control"]=e.ResponseCacheControl,n["response-content-disposition"]=e.ResponseContentDisposition,n["response-content-encoding"]=e.ResponseContentEncoding,ee.call(this,{Action:"name/cos:GetObject",method:"GET",Bucket:e.Bucket,Region:e.Region,Key:e.Key,VersionId:e.VersionId,headers:e.Headers,qs:n,rawBody:!0},function(n,r){if(n){var o=n.statusCode;return e.Headers["If-Modified-Since"]&&o&&304===o?t(null,{NotModified:!0}):t(n)}var i={};i.Body=r.body,r.headers&&r.headers.etag&&(i.ETag=r.headers&&r.headers.etag),re.extend(i,{statusCode:r.statusCode,headers:r.headers}),t(null,i)})}function B(e,t){var n=this,r=e.ContentLength,o=re.throttleOnProgress.call(n,r,e.onProgress);re.getBodyMd5(n.options.UploadCheckContentMd5,e.Body,function(i){i&&(e.Headers["Content-MD5"]=re.binaryBase64(i)),void 0!==e.ContentLength&&(e.Headers["Content-Length"]=e.ContentLength),ee.call(n,{Action:"name/cos:PutObject",TaskId:e.TaskId,method:"PUT",Bucket:e.Bucket,Region:e.Region,Key:e.Key,headers:e.Headers,body:e.Body,onProgress:o},function(i,a){if(i)return o(null,!0),t(i);if(o({loaded:r,total:r},!0),a&&a.headers&&a.headers.etag){var s=Z({ForcePathStyle:n.options.ForcePathStyle,protocol:n.options.Protocol,domain:n.options.Domain,bucket:e.Bucket,region:e.Region,object:e.Key});return s=s.substr(s.indexOf("://")+3),t(null,{Location:s,ETag:a.headers.etag,statusCode:a.statusCode,headers:a.headers})}t(null,a)})})}function D(e,t){var n=this,r={};r["Cache-Control"]=e.CacheControl,r["Content-Disposition"]=e.ContentDisposition,r["Content-Encoding"]=e.ContentEncoding,r["Content-MD5"]=e.ContentMD5,r["Content-Length"]=e.ContentLength,r["Content-Type"]=e.ContentType,r.Expect=e.Expect,r.Expires=e.Expires,r["x-cos-acl"]=e.ACL,r["x-cos-grant-read"]=e.GrantRead,r["x-cos-grant-write"]=e.GrantWrite,r["x-cos-grant-full-control"]=e.GrantFullControl,r["x-cos-storage-class"]=e.StorageClass;var o=e.FilePath;for(var i in e)i.indexOf("x-cos-meta-")>-1&&(r[i]=e[i]);var a=re.throttleOnProgress.call(n,r["Content-Length"],e.onProgress);ee.call(this,{Action:"name/cos:PostObject",method:"POST",Bucket:e.Bucket,Region:e.Region,Key:e.Key,headers:r,filePath:o,onProgress:a},function(r,o){if(a(null,!0),r)return t(r);if(o){var i=Z({ForcePathStyle:n.options.ForcePathStyle,protocol:n.options.Protocol,domain:n.options.Domain,bucket:e.Bucket,region:e.Region,object:e.Key,isLocation:!0});return t(null,{Location:i,statusCode:o.statusCode})}t(null,o)})}function O(e,t){ee.call(this,{Action:"name/cos:DeleteObject",method:"DELETE",Bucket:e.Bucket,Region:e.Region,Key:e.Key,headers:e.Headers,VersionId:e.VersionId},function(e,n){if(e){var r=e.statusCode;return r&&204===r?t(null,{statusCode:r}):r&&404===r?t(null,{BucketNotFound:!0,statusCode:r}):t(e)}t(null,{statusCode:n.statusCode,headers:n.headers})})}function P(e,t){ee.call(this,{Action:"name/cos:GetObjectACL",method:"GET",Bucket:e.Bucket,Region:e.Region,Key:e.Key,headers:e.Headers,action:"acl"},function(e,n){if(e)return t(e);var r=n.AccessControlPolicy||{},o=r.Owner||{},i=r.AccessControlList&&r.AccessControlList.Grant||[];i=re.isArray(i)?i:[i];var a=W(r);n.headers&&n.headers["x-cos-acl"]&&(a.ACL=n.headers["x-cos-acl"]),a=re.extend(a,{Owner:o,Grants:i,statusCode:n.statusCode,headers:n.headers}),t(null,a)})}function I(e,t){var n=e.Headers,r="";if(e.AccessControlPolicy){var o=re.clone(e.AccessControlPolicy||{}),i=o.Grants||o.Grant;i=re.isArray(i)?i:[i],delete o.Grant,delete o.Grants,o.AccessControlList={Grant:i},r=re.json2xml({AccessControlPolicy:o}),n["Content-Type"]="application/xml",n["Content-MD5"]=re.binaryBase64(re.md5(r))}re.each(n,function(e,t){0===t.indexOf("x-cos-grant-")&&(n[t]=Q(n[t]))}),ee.call(this,{Action:"name/cos:PutObjectACL",method:"PUT",Bucket:e.Bucket,Region:e.Region,Key:e.Key,action:"acl",headers:n,body:r},function(e,n){if(e)return t(e);t(null,{statusCode:n.statusCode,headers:n.headers})})}function M(e,t){var n=e.Headers;n.Origin=e.Origin,n["Access-Control-Request-Method"]=e.AccessControlRequestMethod,n["Access-Control-Request-Headers"]=e.AccessControlRequestHeaders,ee.call(this,{Action:"name/cos:OptionsObject",method:"OPTIONS",Bucket:e.Bucket,Region:e.Region,Key:e.Key,headers:n},function(e,n){if(e)return e.statusCode&&403===e.statusCode?t(null,{OptionsForbidden:!0,statusCode:e.statusCode}):t(e);var r=n.headers||{};t(null,{AccessControlAllowOrigin:r["access-control-allow-origin"],AccessControlAllowMethods:r["access-control-allow-methods"],AccessControlAllowHeaders:r["access-control-allow-headers"],AccessControlExposeHeaders:r["access-control-expose-headers"],AccessControlMaxAge:r["access-control-max-age"],statusCode:n.statusCode,headers:n.headers})})}function L(e,t){var n=e.CopySource||"",r=n.match(/^([^.]+-\d+)\.cos(v6)?\.([^.]+)\.[^\/]+\/(.+)$/);if(!r)return void t({error:"CopySource format error"});var o=r[1],i=r[3],a=decodeURIComponent(r[4]);ee.call(this,{Scope:[{action:"name/cos:GetObject",bucket:o,region:i,prefix:a},{action:"name/cos:PutObject",bucket:e.Bucket,region:e.Region,prefix:e.Key}],method:"PUT",Bucket:e.Bucket,Region:e.Region,Key:e.Key,VersionId:e.VersionId,headers:e.Headers},function(e,n){if(e)return t(e);var r=re.clone(n.CopyObjectResult||{});re.extend(r,{statusCode:n.statusCode,headers:n.headers}),t(null,r)})}function F(e,t){var n=e.CopySource||"",r=n.match(/^([^.]+-\d+)\.cos(v6)?\.([^.]+)\.[^\/]+\/(.+)$/);if(!r)return void t({error:"CopySource format error"});var o=r[1],i=r[3],a=decodeURIComponent(r[4]);ee.call(this,{Scope:[{action:"name/cos:GetObject",bucket:o,region:i,prefix:a},{action:"name/cos:PutObject",bucket:e.Bucket,region:e.Region,prefix:e.Key}],method:"PUT",Bucket:e.Bucket,Region:e.Region,Key:e.Key,VersionId:e.VersionId,qs:{partNumber:e.PartNumber,uploadId:e.UploadId},headers:e.Headers},function(e,n){if(e)return t(e);var r=re.clone(n.CopyPartResult||{});re.extend(r,{statusCode:n.statusCode,headers:n.headers}),t(null,r)})}function U(e,t){var n=e.Objects||[],r=e.Quiet;n=re.isArray(n)?n:[n];var o=re.json2xml({Delete:{Object:n,Quiet:r||!1}}),i=e.Headers;i["Content-Type"]="application/xml",i["Content-MD5"]=re.binaryBase64(re.md5(o));var a=re.map(n,function(t){return{action:"name/cos:DeleteObject",bucket:e.Bucket,region:e.Region,prefix:t.Key}});ee.call(this,{Scope:a,method:"POST",Bucket:e.Bucket,Region:e.Region,body:o,action:"delete",headers:i},function(e,n){if(e)return t(e);var r=n.DeleteResult||{},o=r.Deleted||[],i=r.Error||[];o=re.isArray(o)?o:[o],i=re.isArray(i)?i:[i];var a=re.clone(r);re.extend(a,{Error:i,Deleted:o,statusCode:n.statusCode,headers:n.headers}),t(null,a)})}function j(e,t){var n=e.Headers;if(!e.RestoreRequest)return void t({error:"missing param RestoreRequest"});var r=e.RestoreRequest||{},o=re.json2xml({RestoreRequest:r});n["Content-Type"]="application/xml",n["Content-MD5"]=re.binaryBase64(re.md5(o)),ee.call(this,{Action:"name/cos:RestoreObject",method:"POST",Bucket:e.Bucket,Region:e.Region,Key:e.Key,VersionId:e.VersionId,body:o,action:"restore",headers:n},function(e,n){t(e,n)})}function K(e,t){ee.call(this,{Action:"name/cos:InitiateMultipartUpload",method:"POST",Bucket:e.Bucket,Region:e.Region,Key:e.Key,action:"uploads",headers:e.Headers},function(e,n){return e?t(e):(n=re.clone(n||{}))&&n.InitiateMultipartUploadResult?t(null,re.extend(n.InitiateMultipartUploadResult,{statusCode:n.statusCode,headers:n.headers})):void t(null,n)})}function H(e,t){var n=this;re.getFileSize("multipartUpload",e,function(){re.getBodyMd5(n.options.UploadCheckContentMd5,e.Body,function(r){r&&(e.Headers["Content-MD5"]=re.binaryBase64(r)),ee.call(n,{Action:"name/cos:UploadPart",TaskId:e.TaskId,method:"PUT",Bucket:e.Bucket,Region:e.Region,Key:e.Key,qs:{partNumber:e.PartNumber,uploadId:e.UploadId},headers:e.Headers,onProgress:e.onProgress,body:e.Body||null},function(e,n){if(e)return t(e);n.headers=n.headers||{},t(null,{ETag:n.headers.etag||"",statusCode:n.statusCode,headers:n.headers})})})})}function z(e,t){for(var n=this,r=e.UploadId,o=e.Parts,i=0,a=o.length;i<a;i++)0!==o[i].ETag.indexOf('"')&&(o[i].ETag='"'+o[i].ETag+'"');var s=re.json2xml({CompleteMultipartUpload:{Part:o}}),c=e.Headers;c["Content-Type"]="application/xml",c["Content-MD5"]=re.binaryBase64(re.md5(s)),ee.call(this,{Action:"name/cos:CompleteMultipartUpload",method:"POST",Bucket:e.Bucket,Region:e.Region,Key:e.Key,qs:{uploadId:r},body:s,headers:c},function(r,o){if(r)return t(r);var i=Z({ForcePathStyle:n.options.ForcePathStyle,protocol:n.options.Protocol,domain:n.options.Domain,bucket:e.Bucket,region:e.Region,object:e.Key,isLocation:!0}),a=o.CompleteMultipartUploadResult||{},s=re.extend(a,{Location:i,statusCode:o.statusCode,headers:o.headers});t(null,s)})}function G(e,t){var n={};n.delimiter=e.Delimiter,n["encoding-type"]=e.EncodingType,n.prefix=e.Prefix||"",n["max-uploads"]=e.MaxUploads,n["key-marker"]=e.KeyMarker,n["upload-id-marker"]=e.UploadIdMarker,n=re.clearKey(n),ee.call(this,{Action:"name/cos:ListMultipartUploads",ResourceKey:n.prefix,method:"GET",Bucket:e.Bucket,Region:e.Region,headers:e.Headers,qs:n,action:"uploads"},function(e,n){if(e)return t(e);if(n&&n.ListMultipartUploadsResult){var r=n.ListMultipartUploadsResult.Upload||[],o=n.ListMultipartUploadsResult.CommonPrefixes||[];o=re.isArray(o)?o:[o],r=re.isArray(r)?r:[r],n.ListMultipartUploadsResult.Upload=r,n.ListMultipartUploadsResult.CommonPrefixes=o}var i=re.clone(n.ListMultipartUploadsResult||{});re.extend(i,{statusCode:n.statusCode,headers:n.headers}),t(null,i)})}function q(e,t){var n={};n.uploadId=e.UploadId,n["encoding-type"]=e.EncodingType,n["max-parts"]=e.MaxParts,n["part-number-marker"]=e.PartNumberMarker,ee.call(this,{Action:"name/cos:ListParts",method:"GET",Bucket:e.Bucket,Region:e.Region,Key:e.Key,headers:e.Headers,qs:n},function(e,n){if(e)return t(e);var r=n.ListPartsResult||{},o=r.Part||[];o=re.isArray(o)?o:[o],r.Part=o;var i=re.clone(r);re.extend(i,{statusCode:n.statusCode,headers:n.headers}),t(null,i)})}function V(e,t){var n={};n.uploadId=e.UploadId,ee.call(this,{Action:"name/cos:AbortMultipartUpload",method:"DELETE",Bucket:e.Bucket,Region:e.Region,Key:e.Key,headers:e.Headers,qs:n},function(e,n){if(e)return t(e);t(null,{statusCode:n.statusCode,headers:n.headers})})}function X(e){var t=this;return re.getAuth({SecretId:e.SecretId||this.options.SecretId||"",SecretKey:e.SecretKey||this.options.SecretKey||"",Method:e.Method,Key:e.Key,Query:e.Query,Headers:e.Headers,Expires:e.Expires,SystemClockOffset:t.options.SystemClockOffset})}function $(e,t){var n=this,r=Z({ForcePathStyle:n.options.ForcePathStyle,protocol:e.Protocol||n.options.Protocol,domain:n.options.Domain,bucket:e.Bucket,region:e.Region,object:e.Key});if(void 0!==e.Sign&&!e.Sign)return t(null,{Url:r}),r;var o=Y.call(this,{Action:"PUT"===(e.Method||"").toUpperCase()?"name/cos:PutObject":"name/cos:GetObject",Bucket:e.Bucket||"",Region:e.Region||"",Method:e.Method||"get",Key:e.Key,Expires:e.Expires},function(e,n){if(t){if(e)return void t(e);var o=r;o+="?"+(n.Authorization.indexOf("q-signature")>-1?n.Authorization:"sign="+encodeURIComponent(n.Authorization)),n.XCosSecurityToken&&(o+="&x-cos-security-token="+n.XCosSecurityToken),n.ClientIP&&(o+="&clientIP="+n.ClientIP),n.ClientUA&&(o+="&clientUA="+n.ClientUA),n.Token&&(o+="&token="+n.Token),setTimeout(function(){t(null,{Url:o})})}});return o?r+"?"+o.Authorization+(o.XCosSecurityToken?"&x-cos-security-token="+o.XCosSecurityToken:""):r}function W(e){var t={GrantFullControl:[],GrantWrite:[],GrantRead:[],GrantReadAcp:[],GrantWriteAcp:[],ACL:""},n={FULL_CONTROL:"GrantFullControl",WRITE:"GrantWrite",READ:"GrantRead",READ_ACP:"GrantReadAcp",WRITE_ACP:"GrantWriteAcp"},r=e.AccessControlList.Grant;r&&(r=re.isArray(r)?r:[r]);var o={READ:0,WRITE:0,FULL_CONTROL:0};return r.length&&re.each(r,function(r){"qcs::cam::anyone:anyone"===r.Grantee.ID||"http://cam.qcloud.com/groups/global/AllUsers"===r.Grantee.URI?o[r.Permission]=1:r.Grantee.ID!==e.Owner.ID&&t[n[r.Permission]].push('id="'+r.Grantee.ID+'"')}),o.FULL_CONTROL||o.WRITE&&o.READ?t.ACL="public-read-write":o.READ?t.ACL="public-read":t.ACL="private",re.each(n,function(e){t[e]=Q(t[e].join(","))}),t}function Q(e){var t,n,r=e.split(","),o={};for(t=0;t<r.length;)n=r[t].trim(),o[n]?r.splice(t,1):(o[n]=!0,r[t]=n,t++);return r.join(",")}function Z(e){var t=e.bucket,n=t.substr(0,t.lastIndexOf("-")),r=t.substr(t.lastIndexOf("-")+1),o=e.domain,i=e.region,a=e.object;o||(o=["cn-south","cn-south-2","cn-north","cn-east","cn-southwest","sg"].indexOf(i)>-1?"{Region}.myqcloud.com":"cos.{Region}.myqcloud.com",e.ForcePathStyle||(o="{Bucket}."+o)),o=o.replace(/\{\{AppId\}\}/gi,r).replace(/\{\{Bucket\}\}/gi,n).replace(/\{\{Region\}\}/gi,i).replace(/\{\{.*?\}\}/gi,""),o=o.replace(/\{AppId\}/gi,r).replace(/\{BucketName\}/gi,n).replace(/\{Bucket\}/gi,t).replace(/\{Region\}/gi,i).replace(/\{.*?\}/gi,""),/^[a-zA-Z]+:\/\//.test(o)||(o="https://"+o),"/"===o.slice(-1)&&(o=o.slice(0,-1));var s=o;return e.ForcePathStyle&&(s+="/"+t),s+="/",a&&(s+=re.camSafeUrlEncode(a).replace(/%2F/g,"/")),e.isLocation&&(s=s.replace(/^https?:\/\//,"")),s}function Y(e,t){var n=re.clone(e.Headers);delete n["Content-Type"],delete n["Cache-Control"],re.each(n,function(e,t){""===e&&delete n[t]});var r=function(e){var n=!1,r=e.Authorization;if(r)if(r.indexOf(" ")>-1)n=!1;else if(r.indexOf("q-sign-algorithm=")>-1&&r.indexOf("q-ak=")>-1&&r.indexOf("q-sign-time=")>-1&&r.indexOf("q-key-time=")>-1&&r.indexOf("q-url-param-list=")>-1)n=!0;else try{r=atob(r),r.indexOf("a=")>-1&&r.indexOf("k=")>-1&&r.indexOf("t=")>-1&&r.indexOf("r=")>-1&&r.indexOf("b=")>-1&&(n=!0)}catch(e){}n?t&&t(null,e):t&&t("authorization error")},o=this,i=e.Bucket||"",a=e.Region||"",s="name/cos:PostObject"!==e.Action&&e.Key?e.Key:"";o.options.ForcePathStyle&&i&&(s=i+"/"+s);var c="/"+s,u={},l=e.Scope;if(!l){var d=e.Action||"",f=e.ResourceKey||e.Key||"";l=e.Scope||[{action:d,bucket:i,region:a,prefix:f}]}var h=re.md5(JSON.stringify(l));o._StsCache=o._StsCache||[],function(){var e,t;for(e=o._StsCache.length-1;e>=0;e--){t=o._StsCache[e];var n=Math.round(re.getSkewTime(o.options.SystemClockOffset)/1e3)+30;if(t.StartTime&&n<t.StartTime||n>=t.ExpiredTime)o._StsCache.splice(e,1);else if(!t.ScopeLimit||t.ScopeLimit&&t.ScopeKey===h){u=t;break}}}();var p=function(){var t=re.getAuth({SecretId:u.TmpSecretId,SecretKey:u.TmpSecretKey,Method:e.Method,Pathname:c,Query:e.Query,Headers:n,Expires:e.Expires,SystemClockOffset:o.options.SystemClockOffset}),i={Authorization:t,XCosSecurityToken:u.XCosSecurityToken||"",Token:u.Token||"",ClientIP:u.ClientIP||"",ClientUA:u.ClientUA||""};r(i)};if(u.ExpiredTime&&u.ExpiredTime-re.getSkewTime(o.options.SystemClockOffset)/1e3>60)p();else if(o.options.getAuthorization)o.options.getAuthorization.call(o,{Bucket:i,Region:a,Method:e.Method,Key:s,Pathname:c,Query:e.Query,Headers:n,Scope:l},function(e){"string"==typeof e&&(e={Authorization:e}),e.TmpSecretId&&e.TmpSecretKey&&e.XCosSecurityToken&&e.ExpiredTime?(u=e||{},u.Scope=l,u.ScopeKey=h,o._StsCache.push(u),p()):r(e)});else{if(!o.options.getSTS)return function(){var t=re.getAuth({SecretId:e.SecretId||o.options.SecretId,SecretKey:e.SecretKey||o.options.SecretKey,Method:e.Method,Pathname:c,Query:e.Query,Headers:n,Expires:e.Expires,SystemClockOffset:o.options.SystemClockOffset}),i={Authorization:t,XCosSecurityToken:o.options.XCosSecurityToken};return r(i),i}();o.options.getSTS.call(o,{Bucket:i,Region:a},function(e){u=e||{},u.Scope=l,u.ScopeKey=h,u.TmpSecretId=u.SecretId,u.TmpSecretKey=u.SecretKey,o._StsCache.push(u),p()})}return""}function J(e){var t=!1,n=!1,r=e.headers&&(e.headers.date||e.headers.Date)||"";try{var o=e.error.Code,i=e.error.Message;("RequestTimeTooSkewed"===o||"AccessDenied"===o&&"Request has expired"===i)&&(n=!0)}catch(e){}if(e)if(n&&r){var a=Date.parse(r);this.options.CorrectClockSkew&&Math.abs(re.getSkewTime(this.options.SystemClockOffset)-a)>=3e4&&(console.error("error: Local time is too skewed."),this.options.SystemClockOffset=a-Date.now(),t=!0)}else 5===Math.round(e.statusCode/100)&&(t=!0);return t}function ee(e,t){var n=this;!e.headers&&(e.headers={}),!e.qs&&(e.qs={}),e.VersionId&&(e.qs.versionId=e.VersionId),e.qs=re.clearKey(e.qs),e.headers&&(e.headers=re.clearKey(e.headers)),e.qs&&(e.qs=re.clearKey(e.qs));var r=re.clone(e.qs);e.action&&(r[e.action]="");var o=function(i){var a=n.options.SystemClockOffset;Y.call(n,{Bucket:e.Bucket||"",Region:e.Region||"",Method:e.method,Key:e.Key,Query:r,Headers:e.headers,Action:e.Action,ResourceKey:e.ResourceKey,Scope:e.Scope},function(r,s){e.AuthData=s,te.call(n,e,function(r,s){r&&i<2&&(a!==n.options.SystemClockOffset||J.call(n,r))?(e.headers&&(delete e.headers.Authorization,delete e.headers.token,delete e.headers.clientIP,delete e.headers.clientUA,delete e.headers["x-cos-security-token"]),o(i+1)):t(r,s)})})};o(0)}function te(e,t){var n=this,r=e.TaskId;if(!r||n._isRunningTask(r)){var o=e.Bucket,i=e.Region,a=e.Key,s=e.method||"GET",c=e.url,u=e.body,l=e.json,d=e.rawBody;c=c||Z({ForcePathStyle:n.options.ForcePathStyle,protocol:n.options.Protocol,domain:n.options.Domain,bucket:o,region:i,object:a}),e.action&&(c=c+"?"+e.action);var f={method:s,url:c,headers:e.headers,qs:e.qs,filePath:e.filePath,body:u,json:l};f.headers.Authorization=e.AuthData.Authorization,e.AuthData.Token&&(f.headers.token=e.AuthData.Token),e.AuthData.ClientIP&&(f.headers.clientIP=e.AuthData.ClientIP),e.AuthData.ClientUA&&(f.headers.clientUA=e.AuthData.ClientUA),e.AuthData.XCosSecurityToken&&(f.headers["x-cos-security-token"]=e.AuthData.XCosSecurityToken),f.headers&&(f.headers=re.clearKey(f.headers)),f=re.clearKey(f),e.onProgress&&"function"==typeof e.onProgress&&(f.onProgress=function(t){if(!r||n._isRunningTask(r)){var o=t?t.loaded:0;e.onProgress({loaded:o,total:t.total})}}),n.options.ForcePathStyle&&(f.pathStyle=n.options.ForcePathStyle);var h=ne(f,function(e,o,i){var a,s=function(e,i){if(r&&n.off("inner-kill-task",p),!a){a=!0;var s={};o&&o.statusCode&&(s.statusCode=o.statusCode),o&&o.headers&&(s.headers=o.headers),e?(e=re.extend(e||{},s),t(e,null)):(i=re.extend(i||{},s),t(null,i))}};if(e)return void s({error:e});var c;try{c=re.xml2json(i)||{}}catch(e){c=i||{}}var u=o.statusCode;return 2!==Math.floor(u/100)?void s({error:c.Error||c}):(d&&(c={},c.body=i),c.Error?void s({error:c.Error}):void s(null,c))}),p=function(e){e.TaskId===r&&(h&&h.abort&&h.abort(),n.off("inner-kill-task",p))};r&&n.on("inner-kill-task",p)}}var ne=n(9),re=n(0),oe={getService:r,putBucket:a,getBucket:i,headBucket:o,deleteBucket:s,getBucketAcl:c,putBucketAcl:u,getBucketCors:l,putBucketCors:d,deleteBucketCors:f,getBucketLocation:m,putBucketTagging:C,getBucketTagging:y,deleteBucketTagging:v,getBucketPolicy:g,putBucketPolicy:h,deleteBucketPolicy:p,getBucketLifecycle:k,putBucketLifecycle:x,deleteBucketLifecycle:S,putBucketVersioning:A,getBucketVersioning:b,putBucketReplication:R,getBucketReplication:T,deleteBucketReplication:w,getObject:N,headObject:E,listObjectVersions:_,putObject:B,postObject:D,deleteObject:O,getObjectAcl:P,putObjectAcl:I,optionsObject:M,putObjectCopy:L,deleteMultipleObject:U,restoreObject:j,uploadPartCopy:F,multipartInit:K,multipartUpload:H,multipartComplete:z,multipartList:G,multipartListPart:q,multipartAbort:V,getObjectUrl:$,getAuth:X};e.exports.init=function(e,t){t.transferToTaskMethod(oe,"postObject"),re.each(oe,function(t,n){e.prototype[n]=re.apiWrapper(n,t)})}},function(e,t,n){var r=n(0),o={},i=function(e,t){o[t]=e[t],e[t]=function(e,n){e.SkipTask?o[t].call(this,e,n):this._addTask(t,e,n)}},a=function(e){var t=[],n={},i=0,a=0,s=function(e){var t={id:e.id,Bucket:e.Bucket,Region:e.Region,Key:e.Key,FilePath:e.FilePath,state:e.state,loaded:e.loaded,size:e.size,speed:e.speed,percent:e.percent,hashPercent:e.hashPercent,error:e.error};return e.FilePath&&(t.FilePath=e.FilePath),t},c=function(){e.emit("list-update",{list:r.map(t,s)})},u=function(){if(t.length>e.options.UploadQueueSize){var n;for(n=0;n<t.length&&t.length>e.options.UploadQueueSize&&n<a;n++)t[n]&&"waiting"===t[n].state||(t.splice(n,1),a--)}},l=function(){if(a<t.length&&i<e.options.FileParallelLimit){var n=t[a];if("waiting"===n.state){i++,n.state="checking";var s=r.formatParams(n.api,n.params);o[n.api].call(e,s,function(t,r){e._isRunningTask(n.id)&&("checking"!==n.state&&"uploading"!==n.state||(n.state=t?"error":"success",t&&(n.error=t),i--,c(),l(e),n.callback&&n.callback(t,r),"success"===n.state&&(n.params&&(delete n.params.Body,delete n.params),delete n.callback)),u())}),c()}a++,l(e)}},d=function(t,r){var o=n[t];if(o){var a=o&&"waiting"===o.state,s=o&&("checking"===o.state||"uploading"===o.state);if("canceled"===r&&"canceled"!==o.state||"paused"===r&&a||"paused"===r&&s){if("paused"===r&&o.params.Body&&"function"==typeof o.params.Body.pipe)return void console.error("stream not support pause");o.state=r,e.emit("inner-kill-task",{TaskId:t,toState:r}),c(),s&&(i--,l(e)),"canceled"===r&&(o.params&&(delete o.params.Body,delete o.params),delete o.callback)}u()}};e._addTasks=function(t){r.each(t,function(t){e._addTask(t.api,t.params,t.callback,!0)}),c()},e._addTask=function(o,i,a,s){i=r.formatParams(o,i);var d=r.uuid();i.TaskId=d,i.TaskReady&&i.TaskReady(d);var f={params:i,callback:a,api:o,index:t.length,id:d,Bucket:i.Bucket,Region:i.Region,Key:i.Key,FilePath:i.FilePath||"",state:"waiting",loaded:0,size:0,speed:0,percent:0,hashPercent:0,error:null},h=i.onHashProgress;i.onHashProgress=function(t){e._isRunningTask(f.id)&&(f.hashPercent=t.percent,h&&h(t),c())};var p=i.onProgress;return i.onProgress=function(t){e._isRunningTask(f.id)&&("checking"===f.state&&(f.state="uploading"),f.loaded=t.loaded,f.size=t.total,f.speed=t.speed,f.percent=t.percent,p&&p(t),c())},function(){n[d]=f,t.push(f),f.size=i.FileSize,!s&&c(),l(e),u()}(),d},e._isRunningTask=function(e){var t=n[e];return!(!t||"checking"!==t.state&&"uploading"!==t.state)},e.getTaskList=function(){return r.map(t,s)},e.cancelTask=function(e){d(e,"canceled")},e.pauseTask=function(e){d(e,"paused")},e.restartTask=function(e){var t=n[e];!t||"paused"!==t.state&&"error"!==t.state||(t.state="waiting",c(),a=Math.min(a,t.index),l())}};e.exports.transferToTaskMethod=i,e.exports.init=a}])});

/***/ }),

/***/ "h65t":
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__("UuGF");
var defined = __webpack_require__("52gC");
// true  -> String#at
// false -> String#codePointAt
module.exports = function (TO_STRING) {
  return function (that, pos) {
    var s = String(defined(that));
    var i = toInteger(pos);
    var l = s.length;
    var a, b;
    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};


/***/ }),

/***/ "hJx8":
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__("evD5");
var createDesc = __webpack_require__("X8DO");
module.exports = __webpack_require__("+E39") ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};


/***/ }),

/***/ "kM2E":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("7KvD");
var core = __webpack_require__("FeBl");
var ctx = __webpack_require__("+ZMJ");
var hide = __webpack_require__("hJx8");
var has = __webpack_require__("D2L2");
var PROTOTYPE = 'prototype';

var $export = function (type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var IS_WRAP = type & $export.W;
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE];
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE];
  var key, own, out;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    if (own && has(exports, key)) continue;
    // export native or passed
    out = own ? target[key] : source[key];
    // prevent global pollution for namespaces
    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
    // bind timers to global for call from export context
    : IS_BIND && own ? ctx(out, global)
    // wrap global constructors for prevent change them in library
    : IS_WRAP && target[key] == out ? (function (C) {
      var F = function (a, b, c) {
        if (this instanceof C) {
          switch (arguments.length) {
            case 0: return new C();
            case 1: return new C(a);
            case 2: return new C(a, b);
          } return new C(a, b, c);
        } return C.apply(this, arguments);
      };
      F[PROTOTYPE] = C[PROTOTYPE];
      return F;
    // make static versions for prototype methods
    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
    if (IS_PROTO) {
      (exports.virtual || (exports.virtual = {}))[key] = out;
      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
      if (type & $export.R && expProto && !expProto[key]) hide(expProto, key, out);
    }
  }
};
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library`
module.exports = $export;


/***/ }),

/***/ "lOnJ":
/***/ (function(module, exports) {

module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};


/***/ }),

/***/ "lRgn":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return emojiUrl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return emojiMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return emojiName; });
var emojiUrl = 'http://imgcache.qq.com/open/qcloud/tim/assets/emoji/';
var emojiMap = {
  '[NO]': 'emoji_0@2x.png',
  '[OK]': 'emoji_1@2x.png',
  '[下雨]': 'emoji_2@2x.png',
  '[么么哒]': 'emoji_3@2x.png',
  '[乒乓]': 'emoji_4@2x.png',
  '[便便]': 'emoji_5@2x.png',
  '[信封]': 'emoji_6@2x.png',
  '[偷笑]': 'emoji_7@2x.png',
  '[傲慢]': 'emoji_8@2x.png',
  '[再见]': 'emoji_9@2x.png',
  '[冷汗]': 'emoji_10@2x.png',
  '[凋谢]': 'emoji_11@2x.png',
  '[刀]': 'emoji_12@2x.png',
  '[删除]': 'emoji_13@2x.png',
  '[勾引]': 'emoji_14@2x.png',
  '[发呆]': 'emoji_15@2x.png',
  '[发抖]': 'emoji_16@2x.png',
  '[可怜]': 'emoji_17@2x.png',
  '[可爱]': 'emoji_18@2x.png',
  '[右哼哼]': 'emoji_19@2x.png',
  '[右太极]': 'emoji_20@2x.png',
  '[右车头]': 'emoji_21@2x.png',
  '[吐]': 'emoji_22@2x.png',
  '[吓]': 'emoji_23@2x.png',
  '[咒骂]': 'emoji_24@2x.png',
  '[咖啡]': 'emoji_25@2x.png',
  '[啤酒]': 'emoji_26@2x.png',
  '[嘘]': 'emoji_27@2x.png',
  '[回头]': 'emoji_28@2x.png',
  '[困]': 'emoji_29@2x.png',
  '[坏笑]': 'emoji_30@2x.png',
  '[多云]': 'emoji_31@2x.png',
  '[大兵]': 'emoji_32@2x.png',
  '[大哭]': 'emoji_33@2x.png',
  '[太阳]': 'emoji_34@2x.png',
  '[奋斗]': 'emoji_35@2x.png',
  '[奶瓶]': 'emoji_36@2x.png',
  '[委屈]': 'emoji_37@2x.png',
  '[害羞]': 'emoji_38@2x.png',
  '[尴尬]': 'emoji_39@2x.png',
  '[左哼哼]': 'emoji_40@2x.png',
  '[左太极]': 'emoji_41@2x.png',
  '[左车头]': 'emoji_42@2x.png',
  '[差劲]': 'emoji_43@2x.png',
  '[弱]': 'emoji_44@2x.png',
  '[强]': 'emoji_45@2x.png',
  '[彩带]': 'emoji_46@2x.png',
  '[彩球]': 'emoji_47@2x.png',
  '[得意]': 'emoji_48@2x.png',
  '[微笑]': 'emoji_49@2x.png',
  '[心碎了]': 'emoji_50@2x.png',
  '[快哭了]': 'emoji_51@2x.png',
  '[怄火]': 'emoji_52@2x.png',
  '[怒]': 'emoji_53@2x.png',
  '[惊恐]': 'emoji_54@2x.png',
  '[惊讶]': 'emoji_55@2x.png',
  '[憨笑]': 'emoji_56@2x.png',
  '[手枪]': 'emoji_57@2x.png',
  '[打哈欠]': 'emoji_58@2x.png',
  '[抓狂]': 'emoji_59@2x.png',
  '[折磨]': 'emoji_60@2x.png',
  '[抠鼻]': 'emoji_61@2x.png',
  '[抱抱]': 'emoji_62@2x.png',
  '[抱拳]': 'emoji_63@2x.png',
  '[拳头]': 'emoji_64@2x.png',
  '[挥手]': 'emoji_65@2x.png',
  '[握手]': 'emoji_66@2x.png',
  '[撇嘴]': 'emoji_67@2x.png',
  '[擦汗]': 'emoji_68@2x.png',
  '[敲打]': 'emoji_69@2x.png',
  '[晕]': 'emoji_70@2x.png',
  '[月亮]': 'emoji_71@2x.png',
  '[棒棒糖]': 'emoji_72@2x.png',
  '[汽车]': 'emoji_73@2x.png',
  '[沙发]': 'emoji_74@2x.png',
  '[流汗]': 'emoji_75@2x.png',
  '[流泪]': 'emoji_76@2x.png',
  '[激动]': 'emoji_77@2x.png',
  '[灯泡]': 'emoji_78@2x.png',
  '[炸弹]': 'emoji_79@2x.png',
  '[熊猫]': 'emoji_80@2x.png',
  '[爆筋]': 'emoji_81@2x.png',
  '[爱你]': 'emoji_82@2x.png',
  '[爱心]': 'emoji_83@2x.png',
  '[爱情]': 'emoji_84@2x.png',
  '[猪头]': 'emoji_85@2x.png',
  '[猫咪]': 'emoji_86@2x.png',
  '[献吻]': 'emoji_87@2x.png',
  '[玫瑰]': 'emoji_88@2x.png',
  '[瓢虫]': 'emoji_89@2x.png',
  '[疑问]': 'emoji_90@2x.png',
  '[白眼]': 'emoji_91@2x.png',
  '[皮球]': 'emoji_92@2x.png',
  '[睡觉]': 'emoji_93@2x.png',
  '[磕头]': 'emoji_94@2x.png',
  '[示爱]': 'emoji_95@2x.png',
  '[礼品袋]': 'emoji_96@2x.png',
  '[礼物]': 'emoji_97@2x.png',
  '[篮球]': 'emoji_98@2x.png',
  '[米饭]': 'emoji_99@2x.png',
  '[糗大了]': 'emoji_100@2x.png',
  '[红双喜]': 'emoji_101@2x.png',
  '[红灯笼]': 'emoji_102@2x.png',
  '[纸巾]': 'emoji_103@2x.png',
  '[胜利]': 'emoji_104@2x.png',
  '[色]': 'emoji_105@2x.png',
  '[药]': 'emoji_106@2x.png',
  '[菜刀]': 'emoji_107@2x.png',
  '[蛋糕]': 'emoji_108@2x.png',
  '[蜡烛]': 'emoji_109@2x.png',
  '[街舞]': 'emoji_110@2x.png',
  '[衰]': 'emoji_111@2x.png',
  '[西瓜]': 'emoji_112@2x.png',
  '[调皮]': 'emoji_113@2x.png',
  '[象棋]': 'emoji_114@2x.png',
  '[跳绳]': 'emoji_115@2x.png',
  '[跳跳]': 'emoji_116@2x.png',
  '[车厢]': 'emoji_117@2x.png',
  '[转圈]': 'emoji_118@2x.png',
  '[鄙视]': 'emoji_119@2x.png',
  '[酷]': 'emoji_120@2x.png',
  '[钞票]': 'emoji_121@2x.png',
  '[钻戒]': 'emoji_122@2x.png',
  '[闪电]': 'emoji_123@2x.png',
  '[闭嘴]': 'emoji_124@2x.png',
  '[闹钟]': 'emoji_125@2x.png',
  '[阴险]': 'emoji_126@2x.png',
  '[难过]': 'emoji_127@2x.png',
  '[雨伞]': 'emoji_128@2x.png',
  '[青蛙]': 'emoji_129@2x.png',
  '[面条]': 'emoji_130@2x.png',
  '[鞭炮]': 'emoji_131@2x.png',
  '[风车]': 'emoji_132@2x.png',
  '[飞吻]': 'emoji_133@2x.png',
  '[飞机]': 'emoji_134@2x.png',
  '[饥饿]': 'emoji_135@2x.png',
  '[香蕉]': 'emoji_136@2x.png',
  '[骷髅]': 'emoji_137@2x.png',
  '[麦克风]': 'emoji_138@2x.png',
  '[麻将]': 'emoji_139@2x.png',
  '[鼓掌]': 'emoji_140@2x.png',
  '[龇牙]': 'emoji_141@2x.png'
};
var emojiName = ['[龇牙]', '[调皮]', '[流汗]', '[偷笑]', '[再见]', '[敲打]', '[擦汗]', '[猪头]', '[玫瑰]', '[流泪]', '[大哭]', '[嘘]', '[酷]', '[抓狂]', '[委屈]', '[便便]', '[炸弹]', '[菜刀]', '[可爱]', '[色]', '[害羞]', '[得意]', '[吐]', '[微笑]', '[怒]', '[尴尬]', '[惊恐]', '[冷汗]', '[爱心]', '[示爱]', '[白眼]', '[傲慢]', '[难过]', '[惊讶]', '[疑问]', '[困]', '[么么哒]', '[憨笑]', '[爱情]', '[衰]', '[撇嘴]', '[阴险]', '[奋斗]', '[发呆]', '[右哼哼]', '[抱抱]', '[坏笑]', '[飞吻]', '[鄙视]', '[晕]', '[大兵]', '[可怜]', '[强]', '[弱]', '[握手]', '[胜利]', '[抱拳]', '[凋谢]', '[米饭]', '[蛋糕]', '[西瓜]', '[啤酒]', '[瓢虫]', '[勾引]', '[OK]', '[爱你]', '[咖啡]', '[月亮]', '[刀]', '[发抖]', '[差劲]', '[拳头]', '[心碎了]', '[太阳]', '[礼物]', '[皮球]', '[骷髅]', '[挥手]', '[闪电]', '[饥饿]', '[困]', '[咒骂]', '[折磨]', '[抠鼻]', '[鼓掌]', '[糗大了]', '[左哼哼]', '[打哈欠]', '[快哭了]', '[吓]', '[篮球]', '[乒乓]', '[NO]', '[跳跳]', '[怄火]', '[转圈]', '[磕头]', '[回头]', '[跳绳]', '[激动]', '[街舞]', '[献吻]', '[左太极]', '[右太极]', '[闭嘴]', '[猫咪]', '[红双喜]', '[鞭炮]', '[红灯笼]', '[麻将]', '[麦克风]', '[礼品袋]', '[信封]', '[象棋]', '[彩带]', '[蜡烛]', '[爆筋]', '[棒棒糖]', '[奶瓶]', '[面条]', '[香蕉]', '[飞机]', '[左车头]', '[车厢]', '[右车头]', '[多云]', '[下雨]', '[钞票]', '[熊猫]', '[灯泡]', '[风车]', '[闹钟]', '[雨伞]', '[彩球]', '[钻戒]', '[沙发]', '[纸巾]', '[手枪]', '[青蛙]'];

/***/ }),

/***/ "lktj":
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys = __webpack_require__("Ibhu");
var enumBugKeys = __webpack_require__("xnc9");

module.exports = Object.keys || function keys(O) {
  return $keys(O, enumBugKeys);
};


/***/ }),

/***/ "msXi":
/***/ (function(module, exports, __webpack_require__) {

// call something on iterator step with safe closing on error
var anObject = __webpack_require__("77Pl");
module.exports = function (iterator, fn, value, entries) {
  try {
    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch (e) {
    var ret = iterator['return'];
    if (ret !== undefined) anObject(ret.call(iterator));
    throw e;
  }
};


/***/ }),

/***/ "n7IX":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/*eslint-disable*/
var e="undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{},t=[],r=[],n="undefined"!=typeof Uint8Array?Uint8Array:Array,i=!1;function o(){i=!0;for(var e="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",n=0,o=e.length;n<o;++n)t[n]=e[n],r[e.charCodeAt(n)]=n;r["-".charCodeAt(0)]=62,r["_".charCodeAt(0)]=63}function a(e,r,n){for(var i,o,a=[],s=r;s<n;s+=3)i=(e[s]<<16)+(e[s+1]<<8)+e[s+2],a.push(t[(o=i)>>18&63]+t[o>>12&63]+t[o>>6&63]+t[63&o]);return a.join("")}function s(e){var r;i||o();for(var n=e.length,s=n%3,h="",l=[],f=0,c=n-s;f<c;f+=16383)l.push(a(e,f,f+16383>c?c:f+16383));return 1===s?(r=e[n-1],h+=t[r>>2],h+=t[r<<4&63],h+="=="):2===s&&(r=(e[n-2]<<8)+e[n-1],h+=t[r>>10],h+=t[r>>4&63],h+=t[r<<2&63],h+="="),l.push(h),l.join("")}function h(e,t,r,n,i){var o,a,s=8*i-n-1,h=(1<<s)-1,l=h>>1,f=-7,c=r?i-1:0,u=r?-1:1,d=e[t+c];for(c+=u,o=d&(1<<-f)-1,d>>=-f,f+=s;f>0;o=256*o+e[t+c],c+=u,f-=8);for(a=o&(1<<-f)-1,o>>=-f,f+=n;f>0;a=256*a+e[t+c],c+=u,f-=8);if(0===o)o=1-l;else{if(o===h)return a?NaN:1/0*(d?-1:1);a+=Math.pow(2,n),o-=l}return(d?-1:1)*a*Math.pow(2,o-n)}function l(e,t,r,n,i,o){var a,s,h,l=8*o-i-1,f=(1<<l)-1,c=f>>1,u=23===i?Math.pow(2,-24)-Math.pow(2,-77):0,d=n?0:o-1,p=n?1:-1,_=t<0||0===t&&1/t<0?1:0;for(t=Math.abs(t),isNaN(t)||t===1/0?(s=isNaN(t)?1:0,a=f):(a=Math.floor(Math.log(t)/Math.LN2),t*(h=Math.pow(2,-a))<1&&(a--,h*=2),(t+=a+c>=1?u/h:u*Math.pow(2,1-c))*h>=2&&(a++,h/=2),a+c>=f?(s=0,a=f):a+c>=1?(s=(t*h-1)*Math.pow(2,i),a+=c):(s=t*Math.pow(2,c-1)*Math.pow(2,i),a=0));i>=8;e[r+d]=255&s,d+=p,s/=256,i-=8);for(a=a<<i|s,l+=i;l>0;e[r+d]=255&a,d+=p,a/=256,l-=8);e[r+d-p]|=128*_}var f={}.toString,c=Array.isArray||function(e){return"[object Array]"==f.call(e)};function u(){return p.TYPED_ARRAY_SUPPORT?2147483647:1073741823}function d(e,t){if(u()<t)throw new RangeError("Invalid typed array length");return p.TYPED_ARRAY_SUPPORT?(e=new Uint8Array(t)).__proto__=p.prototype:(null===e&&(e=new p(t)),e.length=t),e}function p(e,t,r){if(!(p.TYPED_ARRAY_SUPPORT||this instanceof p))return new p(e,t,r);if("number"==typeof e){if("string"==typeof t)throw new Error("If encoding is specified then the first argument must be a string");return v(this,e)}return _(this,e,t,r)}function _(e,t,r,n){if("number"==typeof t)throw new TypeError('"value" argument must not be a number');return"undefined"!=typeof ArrayBuffer&&t instanceof ArrayBuffer?function(e,t,r,n){if(t.byteLength,r<0||t.byteLength<r)throw new RangeError("'offset' is out of bounds");if(t.byteLength<r+(n||0))throw new RangeError("'length' is out of bounds");t=void 0===r&&void 0===n?new Uint8Array(t):void 0===n?new Uint8Array(t,r):new Uint8Array(t,r,n);p.TYPED_ARRAY_SUPPORT?(e=t).__proto__=p.prototype:e=w(e,t);return e}(e,t,r,n):"string"==typeof t?function(e,t,r){"string"==typeof r&&""!==r||(r="utf8");if(!p.isEncoding(r))throw new TypeError('"encoding" must be a valid string encoding');var n=0|m(t,r),i=(e=d(e,n)).write(t,r);i!==n&&(e=e.slice(0,i));return e}(e,t,r):function(e,t){if(y(t)){var r=0|b(t.length);return 0===(e=d(e,r)).length?e:(t.copy(e,0,0,r),e)}if(t){if("undefined"!=typeof ArrayBuffer&&t.buffer instanceof ArrayBuffer||"length"in t)return"number"!=typeof t.length||(n=t.length)!=n?d(e,0):w(e,t);if("Buffer"===t.type&&c(t.data))return w(e,t.data)}var n;throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.")}(e,t)}function g(e){if("number"!=typeof e)throw new TypeError('"size" argument must be a number');if(e<0)throw new RangeError('"size" argument must not be negative')}function v(e,t){if(g(t),e=d(e,t<0?0:0|b(t)),!p.TYPED_ARRAY_SUPPORT)for(var r=0;r<t;++r)e[r]=0;return e}function w(e,t){var r=t.length<0?0:0|b(t.length);e=d(e,r);for(var n=0;n<r;n+=1)e[n]=255&t[n];return e}function b(e){if(e>=u())throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x"+u().toString(16)+" bytes");return 0|e}function y(e){return!(null==e||!e._isBuffer)}function m(e,t){if(y(e))return e.length;if("undefined"!=typeof ArrayBuffer&&"function"==typeof ArrayBuffer.isView&&(ArrayBuffer.isView(e)||e instanceof ArrayBuffer))return e.byteLength;"string"!=typeof e&&(e=""+e);var r=e.length;if(0===r)return 0;for(var n=!1;;)switch(t){case"ascii":case"latin1":case"binary":return r;case"utf8":case"utf-8":case void 0:return q(e).length;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return 2*r;case"hex":return r>>>1;case"base64":return V(e).length;default:if(n)return q(e).length;t=(""+t).toLowerCase(),n=!0}}function k(e,t,r){var n=!1;if((void 0===t||t<0)&&(t=0),t>this.length)return"";if((void 0===r||r>this.length)&&(r=this.length),r<=0)return"";if((r>>>=0)<=(t>>>=0))return"";for(e||(e="utf8");;)switch(e){case"hex":return O(this,t,r);case"utf8":case"utf-8":return C(this,t,r);case"ascii":return I(this,t,r);case"latin1":case"binary":return P(this,t,r);case"base64":return M(this,t,r);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return U(this,t,r);default:if(n)throw new TypeError("Unknown encoding: "+e);e=(e+"").toLowerCase(),n=!0}}function E(e,t,r){var n=e[t];e[t]=e[r],e[r]=n}function S(e,t,r,n,i){if(0===e.length)return-1;if("string"==typeof r?(n=r,r=0):r>2147483647?r=2147483647:r<-2147483648&&(r=-2147483648),r=+r,isNaN(r)&&(r=i?0:e.length-1),r<0&&(r=e.length+r),r>=e.length){if(i)return-1;r=e.length-1}else if(r<0){if(!i)return-1;r=0}if("string"==typeof t&&(t=p.from(t,n)),y(t))return 0===t.length?-1:x(e,t,r,n,i);if("number"==typeof t)return t&=255,p.TYPED_ARRAY_SUPPORT&&"function"==typeof Uint8Array.prototype.indexOf?i?Uint8Array.prototype.indexOf.call(e,t,r):Uint8Array.prototype.lastIndexOf.call(e,t,r):x(e,[t],r,n,i);throw new TypeError("val must be string, number or Buffer")}function x(e,t,r,n,i){var o,a=1,s=e.length,h=t.length;if(void 0!==n&&("ucs2"===(n=String(n).toLowerCase())||"ucs-2"===n||"utf16le"===n||"utf-16le"===n)){if(e.length<2||t.length<2)return-1;a=2,s/=2,h/=2,r/=2}function l(e,t){return 1===a?e[t]:e.readUInt16BE(t*a)}if(i){var f=-1;for(o=r;o<s;o++)if(l(e,o)===l(t,-1===f?0:o-f)){if(-1===f&&(f=o),o-f+1===h)return f*a}else-1!==f&&(o-=o-f),f=-1}else for(r+h>s&&(r=s-h),o=r;o>=0;o--){for(var c=!0,u=0;u<h;u++)if(l(e,o+u)!==l(t,u)){c=!1;break}if(c)return o}return-1}function R(e,t,r,n){r=Number(r)||0;var i=e.length-r;n?(n=Number(n))>i&&(n=i):n=i;var o=t.length;if(o%2!=0)throw new TypeError("Invalid hex string");n>o/2&&(n=o/2);for(var a=0;a<n;++a){var s=parseInt(t.substr(2*a,2),16);if(isNaN(s))return a;e[r+a]=s}return a}function A(e,t,r,n){return G(q(t,e.length-r),e,r,n)}function B(e,t,r,n){return G(function(e){for(var t=[],r=0;r<e.length;++r)t.push(255&e.charCodeAt(r));return t}(t),e,r,n)}function z(e,t,r,n){return B(e,t,r,n)}function L(e,t,r,n){return G(V(t),e,r,n)}function T(e,t,r,n){return G(function(e,t){for(var r,n,i,o=[],a=0;a<e.length&&!((t-=2)<0);++a)r=e.charCodeAt(a),n=r>>8,i=r%256,o.push(i),o.push(n);return o}(t,e.length-r),e,r,n)}function M(e,t,r){return 0===t&&r===e.length?s(e):s(e.slice(t,r))}function C(e,t,r){r=Math.min(e.length,r);for(var n=[],i=t;i<r;){var o,a,s,h,l=e[i],f=null,c=l>239?4:l>223?3:l>191?2:1;if(i+c<=r)switch(c){case 1:l<128&&(f=l);break;case 2:128==(192&(o=e[i+1]))&&(h=(31&l)<<6|63&o)>127&&(f=h);break;case 3:o=e[i+1],a=e[i+2],128==(192&o)&&128==(192&a)&&(h=(15&l)<<12|(63&o)<<6|63&a)>2047&&(h<55296||h>57343)&&(f=h);break;case 4:o=e[i+1],a=e[i+2],s=e[i+3],128==(192&o)&&128==(192&a)&&128==(192&s)&&(h=(15&l)<<18|(63&o)<<12|(63&a)<<6|63&s)>65535&&h<1114112&&(f=h)}null===f?(f=65533,c=1):f>65535&&(f-=65536,n.push(f>>>10&1023|55296),f=56320|1023&f),n.push(f),i+=c}return function(e){var t=e.length;if(t<=D)return String.fromCharCode.apply(String,e);var r="",n=0;for(;n<t;)r+=String.fromCharCode.apply(String,e.slice(n,n+=D));return r}(n)}p.TYPED_ARRAY_SUPPORT=void 0===e.TYPED_ARRAY_SUPPORT||e.TYPED_ARRAY_SUPPORT,p.poolSize=8192,p._augment=function(e){return e.__proto__=p.prototype,e},p.from=function(e,t,r){return _(null,e,t,r)},p.TYPED_ARRAY_SUPPORT&&(p.prototype.__proto__=Uint8Array.prototype,p.__proto__=Uint8Array),p.alloc=function(e,t,r){return function(e,t,r,n){return g(t),t<=0?d(e,t):void 0!==r?"string"==typeof n?d(e,t).fill(r,n):d(e,t).fill(r):d(e,t)}(null,e,t,r)},p.allocUnsafe=function(e){return v(null,e)},p.allocUnsafeSlow=function(e){return v(null,e)},p.isBuffer=$,p.compare=function(e,t){if(!y(e)||!y(t))throw new TypeError("Arguments must be Buffers");if(e===t)return 0;for(var r=e.length,n=t.length,i=0,o=Math.min(r,n);i<o;++i)if(e[i]!==t[i]){r=e[i],n=t[i];break}return r<n?-1:n<r?1:0},p.isEncoding=function(e){switch(String(e).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"latin1":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return!0;default:return!1}},p.concat=function(e,t){if(!c(e))throw new TypeError('"list" argument must be an Array of Buffers');if(0===e.length)return p.alloc(0);var r;if(void 0===t)for(t=0,r=0;r<e.length;++r)t+=e[r].length;var n=p.allocUnsafe(t),i=0;for(r=0;r<e.length;++r){var o=e[r];if(!y(o))throw new TypeError('"list" argument must be an Array of Buffers');o.copy(n,i),i+=o.length}return n},p.byteLength=m,p.prototype._isBuffer=!0,p.prototype.swap16=function(){var e=this.length;if(e%2!=0)throw new RangeError("Buffer size must be a multiple of 16-bits");for(var t=0;t<e;t+=2)E(this,t,t+1);return this},p.prototype.swap32=function(){var e=this.length;if(e%4!=0)throw new RangeError("Buffer size must be a multiple of 32-bits");for(var t=0;t<e;t+=4)E(this,t,t+3),E(this,t+1,t+2);return this},p.prototype.swap64=function(){var e=this.length;if(e%8!=0)throw new RangeError("Buffer size must be a multiple of 64-bits");for(var t=0;t<e;t+=8)E(this,t,t+7),E(this,t+1,t+6),E(this,t+2,t+5),E(this,t+3,t+4);return this},p.prototype.toString=function(){var e=0|this.length;return 0===e?"":0===arguments.length?C(this,0,e):k.apply(this,arguments)},p.prototype.equals=function(e){if(!y(e))throw new TypeError("Argument must be a Buffer");return this===e||0===p.compare(this,e)},p.prototype.inspect=function(){var e="";return this.length>0&&(e=this.toString("hex",0,50).match(/.{2}/g).join(" "),this.length>50&&(e+=" ... ")),"<Buffer "+e+">"},p.prototype.compare=function(e,t,r,n,i){if(!y(e))throw new TypeError("Argument must be a Buffer");if(void 0===t&&(t=0),void 0===r&&(r=e?e.length:0),void 0===n&&(n=0),void 0===i&&(i=this.length),t<0||r>e.length||n<0||i>this.length)throw new RangeError("out of range index");if(n>=i&&t>=r)return 0;if(n>=i)return-1;if(t>=r)return 1;if(this===e)return 0;for(var o=(i>>>=0)-(n>>>=0),a=(r>>>=0)-(t>>>=0),s=Math.min(o,a),h=this.slice(n,i),l=e.slice(t,r),f=0;f<s;++f)if(h[f]!==l[f]){o=h[f],a=l[f];break}return o<a?-1:a<o?1:0},p.prototype.includes=function(e,t,r){return-1!==this.indexOf(e,t,r)},p.prototype.indexOf=function(e,t,r){return S(this,e,t,r,!0)},p.prototype.lastIndexOf=function(e,t,r){return S(this,e,t,r,!1)},p.prototype.write=function(e,t,r,n){if(void 0===t)n="utf8",r=this.length,t=0;else if(void 0===r&&"string"==typeof t)n=t,r=this.length,t=0;else{if(!isFinite(t))throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");t|=0,isFinite(r)?(r|=0,void 0===n&&(n="utf8")):(n=r,r=void 0)}var i=this.length-t;if((void 0===r||r>i)&&(r=i),e.length>0&&(r<0||t<0)||t>this.length)throw new RangeError("Attempt to write outside buffer bounds");n||(n="utf8");for(var o=!1;;)switch(n){case"hex":return R(this,e,t,r);case"utf8":case"utf-8":return A(this,e,t,r);case"ascii":return B(this,e,t,r);case"latin1":case"binary":return z(this,e,t,r);case"base64":return L(this,e,t,r);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return T(this,e,t,r);default:if(o)throw new TypeError("Unknown encoding: "+n);n=(""+n).toLowerCase(),o=!0}},p.prototype.toJSON=function(){return{type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}};var D=4096;function I(e,t,r){var n="";r=Math.min(e.length,r);for(var i=t;i<r;++i)n+=String.fromCharCode(127&e[i]);return n}function P(e,t,r){var n="";r=Math.min(e.length,r);for(var i=t;i<r;++i)n+=String.fromCharCode(e[i]);return n}function O(e,t,r){var n=e.length;(!t||t<0)&&(t=0),(!r||r<0||r>n)&&(r=n);for(var i="",o=t;o<r;++o)i+=X(e[o]);return i}function U(e,t,r){for(var n=e.slice(t,r),i="",o=0;o<n.length;o+=2)i+=String.fromCharCode(n[o]+256*n[o+1]);return i}function H(e,t,r){if(e%1!=0||e<0)throw new RangeError("offset is not uint");if(e+t>r)throw new RangeError("Trying to access beyond buffer length")}function F(e,t,r,n,i,o){if(!y(e))throw new TypeError('"buffer" argument must be a Buffer instance');if(t>i||t<o)throw new RangeError('"value" argument is out of bounds');if(r+n>e.length)throw new RangeError("Index out of range")}function N(e,t,r,n){t<0&&(t=65535+t+1);for(var i=0,o=Math.min(e.length-r,2);i<o;++i)e[r+i]=(t&255<<8*(n?i:1-i))>>>8*(n?i:1-i)}function Z(e,t,r,n){t<0&&(t=4294967295+t+1);for(var i=0,o=Math.min(e.length-r,4);i<o;++i)e[r+i]=t>>>8*(n?i:3-i)&255}function j(e,t,r,n,i,o){if(r+n>e.length)throw new RangeError("Index out of range");if(r<0)throw new RangeError("Index out of range")}function W(e,t,r,n,i){return i||j(e,0,r,4),l(e,t,r,n,23,4),r+4}function Y(e,t,r,n,i){return i||j(e,0,r,8),l(e,t,r,n,52,8),r+8}p.prototype.slice=function(e,t){var r,n=this.length;if((e=~~e)<0?(e+=n)<0&&(e=0):e>n&&(e=n),(t=void 0===t?n:~~t)<0?(t+=n)<0&&(t=0):t>n&&(t=n),t<e&&(t=e),p.TYPED_ARRAY_SUPPORT)(r=this.subarray(e,t)).__proto__=p.prototype;else{var i=t-e;r=new p(i,void 0);for(var o=0;o<i;++o)r[o]=this[o+e]}return r},p.prototype.readUIntLE=function(e,t,r){e|=0,t|=0,r||H(e,t,this.length);for(var n=this[e],i=1,o=0;++o<t&&(i*=256);)n+=this[e+o]*i;return n},p.prototype.readUIntBE=function(e,t,r){e|=0,t|=0,r||H(e,t,this.length);for(var n=this[e+--t],i=1;t>0&&(i*=256);)n+=this[e+--t]*i;return n},p.prototype.readUInt8=function(e,t){return t||H(e,1,this.length),this[e]},p.prototype.readUInt16LE=function(e,t){return t||H(e,2,this.length),this[e]|this[e+1]<<8},p.prototype.readUInt16BE=function(e,t){return t||H(e,2,this.length),this[e]<<8|this[e+1]},p.prototype.readUInt32LE=function(e,t){return t||H(e,4,this.length),(this[e]|this[e+1]<<8|this[e+2]<<16)+16777216*this[e+3]},p.prototype.readUInt32BE=function(e,t){return t||H(e,4,this.length),16777216*this[e]+(this[e+1]<<16|this[e+2]<<8|this[e+3])},p.prototype.readIntLE=function(e,t,r){e|=0,t|=0,r||H(e,t,this.length);for(var n=this[e],i=1,o=0;++o<t&&(i*=256);)n+=this[e+o]*i;return n>=(i*=128)&&(n-=Math.pow(2,8*t)),n},p.prototype.readIntBE=function(e,t,r){e|=0,t|=0,r||H(e,t,this.length);for(var n=t,i=1,o=this[e+--n];n>0&&(i*=256);)o+=this[e+--n]*i;return o>=(i*=128)&&(o-=Math.pow(2,8*t)),o},p.prototype.readInt8=function(e,t){return t||H(e,1,this.length),128&this[e]?-1*(255-this[e]+1):this[e]},p.prototype.readInt16LE=function(e,t){t||H(e,2,this.length);var r=this[e]|this[e+1]<<8;return 32768&r?4294901760|r:r},p.prototype.readInt16BE=function(e,t){t||H(e,2,this.length);var r=this[e+1]|this[e]<<8;return 32768&r?4294901760|r:r},p.prototype.readInt32LE=function(e,t){return t||H(e,4,this.length),this[e]|this[e+1]<<8|this[e+2]<<16|this[e+3]<<24},p.prototype.readInt32BE=function(e,t){return t||H(e,4,this.length),this[e]<<24|this[e+1]<<16|this[e+2]<<8|this[e+3]},p.prototype.readFloatLE=function(e,t){return t||H(e,4,this.length),h(this,e,!0,23,4)},p.prototype.readFloatBE=function(e,t){return t||H(e,4,this.length),h(this,e,!1,23,4)},p.prototype.readDoubleLE=function(e,t){return t||H(e,8,this.length),h(this,e,!0,52,8)},p.prototype.readDoubleBE=function(e,t){return t||H(e,8,this.length),h(this,e,!1,52,8)},p.prototype.writeUIntLE=function(e,t,r,n){(e=+e,t|=0,r|=0,n)||F(this,e,t,r,Math.pow(2,8*r)-1,0);var i=1,o=0;for(this[t]=255&e;++o<r&&(i*=256);)this[t+o]=e/i&255;return t+r},p.prototype.writeUIntBE=function(e,t,r,n){(e=+e,t|=0,r|=0,n)||F(this,e,t,r,Math.pow(2,8*r)-1,0);var i=r-1,o=1;for(this[t+i]=255&e;--i>=0&&(o*=256);)this[t+i]=e/o&255;return t+r},p.prototype.writeUInt8=function(e,t,r){return e=+e,t|=0,r||F(this,e,t,1,255,0),p.TYPED_ARRAY_SUPPORT||(e=Math.floor(e)),this[t]=255&e,t+1},p.prototype.writeUInt16LE=function(e,t,r){return e=+e,t|=0,r||F(this,e,t,2,65535,0),p.TYPED_ARRAY_SUPPORT?(this[t]=255&e,this[t+1]=e>>>8):N(this,e,t,!0),t+2},p.prototype.writeUInt16BE=function(e,t,r){return e=+e,t|=0,r||F(this,e,t,2,65535,0),p.TYPED_ARRAY_SUPPORT?(this[t]=e>>>8,this[t+1]=255&e):N(this,e,t,!1),t+2},p.prototype.writeUInt32LE=function(e,t,r){return e=+e,t|=0,r||F(this,e,t,4,4294967295,0),p.TYPED_ARRAY_SUPPORT?(this[t+3]=e>>>24,this[t+2]=e>>>16,this[t+1]=e>>>8,this[t]=255&e):Z(this,e,t,!0),t+4},p.prototype.writeUInt32BE=function(e,t,r){return e=+e,t|=0,r||F(this,e,t,4,4294967295,0),p.TYPED_ARRAY_SUPPORT?(this[t]=e>>>24,this[t+1]=e>>>16,this[t+2]=e>>>8,this[t+3]=255&e):Z(this,e,t,!1),t+4},p.prototype.writeIntLE=function(e,t,r,n){if(e=+e,t|=0,!n){var i=Math.pow(2,8*r-1);F(this,e,t,r,i-1,-i)}var o=0,a=1,s=0;for(this[t]=255&e;++o<r&&(a*=256);)e<0&&0===s&&0!==this[t+o-1]&&(s=1),this[t+o]=(e/a>>0)-s&255;return t+r},p.prototype.writeIntBE=function(e,t,r,n){if(e=+e,t|=0,!n){var i=Math.pow(2,8*r-1);F(this,e,t,r,i-1,-i)}var o=r-1,a=1,s=0;for(this[t+o]=255&e;--o>=0&&(a*=256);)e<0&&0===s&&0!==this[t+o+1]&&(s=1),this[t+o]=(e/a>>0)-s&255;return t+r},p.prototype.writeInt8=function(e,t,r){return e=+e,t|=0,r||F(this,e,t,1,127,-128),p.TYPED_ARRAY_SUPPORT||(e=Math.floor(e)),e<0&&(e=255+e+1),this[t]=255&e,t+1},p.prototype.writeInt16LE=function(e,t,r){return e=+e,t|=0,r||F(this,e,t,2,32767,-32768),p.TYPED_ARRAY_SUPPORT?(this[t]=255&e,this[t+1]=e>>>8):N(this,e,t,!0),t+2},p.prototype.writeInt16BE=function(e,t,r){return e=+e,t|=0,r||F(this,e,t,2,32767,-32768),p.TYPED_ARRAY_SUPPORT?(this[t]=e>>>8,this[t+1]=255&e):N(this,e,t,!1),t+2},p.prototype.writeInt32LE=function(e,t,r){return e=+e,t|=0,r||F(this,e,t,4,2147483647,-2147483648),p.TYPED_ARRAY_SUPPORT?(this[t]=255&e,this[t+1]=e>>>8,this[t+2]=e>>>16,this[t+3]=e>>>24):Z(this,e,t,!0),t+4},p.prototype.writeInt32BE=function(e,t,r){return e=+e,t|=0,r||F(this,e,t,4,2147483647,-2147483648),e<0&&(e=4294967295+e+1),p.TYPED_ARRAY_SUPPORT?(this[t]=e>>>24,this[t+1]=e>>>16,this[t+2]=e>>>8,this[t+3]=255&e):Z(this,e,t,!1),t+4},p.prototype.writeFloatLE=function(e,t,r){return W(this,e,t,!0,r)},p.prototype.writeFloatBE=function(e,t,r){return W(this,e,t,!1,r)},p.prototype.writeDoubleLE=function(e,t,r){return Y(this,e,t,!0,r)},p.prototype.writeDoubleBE=function(e,t,r){return Y(this,e,t,!1,r)},p.prototype.copy=function(e,t,r,n){if(r||(r=0),n||0===n||(n=this.length),t>=e.length&&(t=e.length),t||(t=0),n>0&&n<r&&(n=r),n===r)return 0;if(0===e.length||0===this.length)return 0;if(t<0)throw new RangeError("targetStart out of bounds");if(r<0||r>=this.length)throw new RangeError("sourceStart out of bounds");if(n<0)throw new RangeError("sourceEnd out of bounds");n>this.length&&(n=this.length),e.length-t<n-r&&(n=e.length-t+r);var i,o=n-r;if(this===e&&r<t&&t<n)for(i=o-1;i>=0;--i)e[i+t]=this[i+r];else if(o<1e3||!p.TYPED_ARRAY_SUPPORT)for(i=0;i<o;++i)e[i+t]=this[i+r];else Uint8Array.prototype.set.call(e,this.subarray(r,r+o),t);return o},p.prototype.fill=function(e,t,r,n){if("string"==typeof e){if("string"==typeof t?(n=t,t=0,r=this.length):"string"==typeof r&&(n=r,r=this.length),1===e.length){var i=e.charCodeAt(0);i<256&&(e=i)}if(void 0!==n&&"string"!=typeof n)throw new TypeError("encoding must be a string");if("string"==typeof n&&!p.isEncoding(n))throw new TypeError("Unknown encoding: "+n)}else"number"==typeof e&&(e&=255);if(t<0||this.length<t||this.length<r)throw new RangeError("Out of range index");if(r<=t)return this;var o;if(t>>>=0,r=void 0===r?this.length:r>>>0,e||(e=0),"number"==typeof e)for(o=t;o<r;++o)this[o]=e;else{var a=y(e)?e:q(new p(e,n).toString()),s=a.length;for(o=0;o<r-t;++o)this[o+t]=a[o%s]}return this};var K=/[^+\/0-9A-Za-z-_]/g;function X(e){return e<16?"0"+e.toString(16):e.toString(16)}function q(e,t){var r;t=t||1/0;for(var n=e.length,i=null,o=[],a=0;a<n;++a){if((r=e.charCodeAt(a))>55295&&r<57344){if(!i){if(r>56319){(t-=3)>-1&&o.push(239,191,189);continue}if(a+1===n){(t-=3)>-1&&o.push(239,191,189);continue}i=r;continue}if(r<56320){(t-=3)>-1&&o.push(239,191,189),i=r;continue}r=65536+(i-55296<<10|r-56320)}else i&&(t-=3)>-1&&o.push(239,191,189);if(i=null,r<128){if((t-=1)<0)break;o.push(r)}else if(r<2048){if((t-=2)<0)break;o.push(r>>6|192,63&r|128)}else if(r<65536){if((t-=3)<0)break;o.push(r>>12|224,r>>6&63|128,63&r|128)}else{if(!(r<1114112))throw new Error("Invalid code point");if((t-=4)<0)break;o.push(r>>18|240,r>>12&63|128,r>>6&63|128,63&r|128)}}return o}function V(e){return function(e){var t,a,s,h,l,f;i||o();var c=e.length;if(c%4>0)throw new Error("Invalid string. Length must be a multiple of 4");l="="===e[c-2]?2:"="===e[c-1]?1:0,f=new n(3*c/4-l),s=l>0?c-4:c;var u=0;for(t=0,a=0;t<s;t+=4,a+=3)h=r[e.charCodeAt(t)]<<18|r[e.charCodeAt(t+1)]<<12|r[e.charCodeAt(t+2)]<<6|r[e.charCodeAt(t+3)],f[u++]=h>>16&255,f[u++]=h>>8&255,f[u++]=255&h;return 2===l?(h=r[e.charCodeAt(t)]<<2|r[e.charCodeAt(t+1)]>>4,f[u++]=255&h):1===l&&(h=r[e.charCodeAt(t)]<<10|r[e.charCodeAt(t+1)]<<4|r[e.charCodeAt(t+2)]>>2,f[u++]=h>>8&255,f[u++]=255&h),f}(function(e){if((e=function(e){return e.trim?e.trim():e.replace(/^\s+|\s+$/g,"")}(e).replace(K,"")).length<2)return"";for(;e.length%4!=0;)e+="=";return e}(e))}function G(e,t,r,n){for(var i=0;i<n&&!(i+r>=t.length||i>=e.length);++i)t[i+r]=e[i];return i}function $(e){return null!=e&&(!!e._isBuffer||J(e)||function(e){return"function"==typeof e.readFloatLE&&"function"==typeof e.slice&&J(e.slice(0,0))}(e))}function J(e){return!!e.constructor&&"function"==typeof e.constructor.isBuffer&&e.constructor.isBuffer(e)}"undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self&&self;function Q(e,t){return e(t={exports:{}},t.exports),t.exports}var ee=Q(function(e,t){var r;e.exports=(r=r||function(e,t){var r=Object.create||function(){function e(){}return function(t){var r;return e.prototype=t,r=new e,e.prototype=null,r}}(),n={},i=n.lib={},o=i.Base={extend:function(e){var t=r(this);return e&&t.mixIn(e),t.hasOwnProperty("init")&&this.init!==t.init||(t.init=function(){t.$super.init.apply(this,arguments)}),t.init.prototype=t,t.$super=this,t},create:function(){var e=this.extend();return e.init.apply(e,arguments),e},init:function(){},mixIn:function(e){for(var t in e)e.hasOwnProperty(t)&&(this[t]=e[t]);e.hasOwnProperty("toString")&&(this.toString=e.toString)},clone:function(){return this.init.prototype.extend(this)}},a=i.WordArray=o.extend({init:function(e,t){e=this.words=e||[],this.sigBytes=null!=t?t:4*e.length},toString:function(e){return(e||h).stringify(this)},concat:function(e){var t=this.words,r=e.words,n=this.sigBytes,i=e.sigBytes;if(this.clamp(),n%4)for(var o=0;o<i;o++){var a=r[o>>>2]>>>24-o%4*8&255;t[n+o>>>2]|=a<<24-(n+o)%4*8}else for(var o=0;o<i;o+=4)t[n+o>>>2]=r[o>>>2];return this.sigBytes+=i,this},clamp:function(){var t=this.words,r=this.sigBytes;t[r>>>2]&=4294967295<<32-r%4*8,t.length=e.ceil(r/4)},clone:function(){var e=o.clone.call(this);return e.words=this.words.slice(0),e},random:function(t){for(var r,n=[],i=function(t){var t=t,r=987654321,n=4294967295;return function(){var i=((r=36969*(65535&r)+(r>>16)&n)<<16)+(t=18e3*(65535&t)+(t>>16)&n)&n;return i/=4294967296,(i+=.5)*(e.random()>.5?1:-1)}},o=0;o<t;o+=4){var s=i(4294967296*(r||e.random()));r=987654071*s(),n.push(4294967296*s()|0)}return new a.init(n,t)}}),s=n.enc={},h=s.Hex={stringify:function(e){for(var t=e.words,r=e.sigBytes,n=[],i=0;i<r;i++){var o=t[i>>>2]>>>24-i%4*8&255;n.push((o>>>4).toString(16)),n.push((15&o).toString(16))}return n.join("")},parse:function(e){for(var t=e.length,r=[],n=0;n<t;n+=2)r[n>>>3]|=parseInt(e.substr(n,2),16)<<24-n%8*4;return new a.init(r,t/2)}},l=s.Latin1={stringify:function(e){for(var t=e.words,r=e.sigBytes,n=[],i=0;i<r;i++){var o=t[i>>>2]>>>24-i%4*8&255;n.push(String.fromCharCode(o))}return n.join("")},parse:function(e){for(var t=e.length,r=[],n=0;n<t;n++)r[n>>>2]|=(255&e.charCodeAt(n))<<24-n%4*8;return new a.init(r,t)}},f=s.Utf8={stringify:function(e){try{return decodeURIComponent(escape(l.stringify(e)))}catch(e){throw new Error("Malformed UTF-8 data")}},parse:function(e){return l.parse(unescape(encodeURIComponent(e)))}},c=i.BufferedBlockAlgorithm=o.extend({reset:function(){this._data=new a.init,this._nDataBytes=0},_append:function(e){"string"==typeof e&&(e=f.parse(e)),this._data.concat(e),this._nDataBytes+=e.sigBytes},_process:function(t){var r=this._data,n=r.words,i=r.sigBytes,o=this.blockSize,s=4*o,h=i/s,l=(h=t?e.ceil(h):e.max((0|h)-this._minBufferSize,0))*o,f=e.min(4*l,i);if(l){for(var c=0;c<l;c+=o)this._doProcessBlock(n,c);var u=n.splice(0,l);r.sigBytes-=f}return new a.init(u,f)},clone:function(){var e=o.clone.call(this);return e._data=this._data.clone(),e},_minBufferSize:0}),u=(i.Hasher=c.extend({cfg:o.extend(),init:function(e){this.cfg=this.cfg.extend(e),this.reset()},reset:function(){c.reset.call(this),this._doReset()},update:function(e){return this._append(e),this._process(),this},finalize:function(e){e&&this._append(e);var t=this._doFinalize();return t},blockSize:16,_createHelper:function(e){return function(t,r){return new e.init(r).finalize(t)}},_createHmacHelper:function(e){return function(t,r){return new u.HMAC.init(e,r).finalize(t)}}}),n.algo={});return n}(Math),r)}),te=(Q(function(e,t){var r,n,i,o,a,s;e.exports=(i=(n=r=ee).lib,o=i.Base,a=i.WordArray,(s=n.x64={}).Word=o.extend({init:function(e,t){this.high=e,this.low=t}}),s.WordArray=o.extend({init:function(e,t){e=this.words=e||[],this.sigBytes=null!=t?t:8*e.length},toX32:function(){for(var e=this.words,t=e.length,r=[],n=0;n<t;n++){var i=e[n];r.push(i.high),r.push(i.low)}return a.create(r,this.sigBytes)},clone:function(){for(var e=o.clone.call(this),t=e.words=this.words.slice(0),r=t.length,n=0;n<r;n++)t[n]=t[n].clone();return e}}),r)}),Q(function(e,t){var r;e.exports=(r=ee,function(){if("function"==typeof ArrayBuffer){var e=r.lib.WordArray,t=e.init;(e.init=function(e){if(e instanceof ArrayBuffer&&(e=new Uint8Array(e)),(e instanceof Int8Array||"undefined"!=typeof Uint8ClampedArray&&e instanceof Uint8ClampedArray||e instanceof Int16Array||e instanceof Uint16Array||e instanceof Int32Array||e instanceof Uint32Array||e instanceof Float32Array||e instanceof Float64Array)&&(e=new Uint8Array(e.buffer,e.byteOffset,e.byteLength)),e instanceof Uint8Array){for(var r=e.byteLength,n=[],i=0;i<r;i++)n[i>>>2]|=e[i]<<24-i%4*8;t.call(this,n,r)}else t.apply(this,arguments)}).prototype=e}}(),r.lib.WordArray)}),Q(function(e,t){var r;e.exports=(r=ee,function(){var e=r,t=e.lib.WordArray,n=e.enc;function i(e){return e<<8&4278255360|e>>>8&16711935}n.Utf16=n.Utf16BE={stringify:function(e){for(var t=e.words,r=e.sigBytes,n=[],i=0;i<r;i+=2){var o=t[i>>>2]>>>16-i%4*8&65535;n.push(String.fromCharCode(o))}return n.join("")},parse:function(e){for(var r=e.length,n=[],i=0;i<r;i++)n[i>>>1]|=e.charCodeAt(i)<<16-i%2*16;return t.create(n,2*r)}},n.Utf16LE={stringify:function(e){for(var t=e.words,r=e.sigBytes,n=[],o=0;o<r;o+=2){var a=i(t[o>>>2]>>>16-o%4*8&65535);n.push(String.fromCharCode(a))}return n.join("")},parse:function(e){for(var r=e.length,n=[],o=0;o<r;o++)n[o>>>1]|=i(e.charCodeAt(o)<<16-o%2*16);return t.create(n,2*r)}}}(),r.enc.Utf16)}),Q(function(e,t){var r,n,i;e.exports=(i=(n=r=ee).lib.WordArray,n.enc.Base64={stringify:function(e){var t=e.words,r=e.sigBytes,n=this._map;e.clamp();for(var i=[],o=0;o<r;o+=3)for(var a=(t[o>>>2]>>>24-o%4*8&255)<<16|(t[o+1>>>2]>>>24-(o+1)%4*8&255)<<8|t[o+2>>>2]>>>24-(o+2)%4*8&255,s=0;s<4&&o+.75*s<r;s++)i.push(n.charAt(a>>>6*(3-s)&63));var h=n.charAt(64);if(h)for(;i.length%4;)i.push(h);return i.join("")},parse:function(e){var t=e.length,r=this._map,n=this._reverseMap;if(!n){n=this._reverseMap=[];for(var o=0;o<r.length;o++)n[r.charCodeAt(o)]=o}var a=r.charAt(64);if(a){var s=e.indexOf(a);-1!==s&&(t=s)}return function(e,t,r){for(var n=[],o=0,a=0;a<t;a++)if(a%4){var s=r[e.charCodeAt(a-1)]<<a%4*2,h=r[e.charCodeAt(a)]>>>6-a%4*2;n[o>>>2]|=(s|h)<<24-o%4*8,o++}return i.create(n,o)}(e,t,n)},_map:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="},r.enc.Base64)}),Q(function(e,t){var r;e.exports=(r=ee,function(e){var t=r,n=t.lib,i=n.WordArray,o=n.Hasher,a=t.algo,s=[];!function(){for(var t=0;t<64;t++)s[t]=4294967296*e.abs(e.sin(t+1))|0}();var h=a.MD5=o.extend({_doReset:function(){this._hash=new i.init([1732584193,4023233417,2562383102,271733878])},_doProcessBlock:function(e,t){for(var r=0;r<16;r++){var n=t+r,i=e[n];e[n]=16711935&(i<<8|i>>>24)|4278255360&(i<<24|i>>>8)}var o=this._hash.words,a=e[t+0],h=e[t+1],d=e[t+2],p=e[t+3],_=e[t+4],g=e[t+5],v=e[t+6],w=e[t+7],b=e[t+8],y=e[t+9],m=e[t+10],k=e[t+11],E=e[t+12],S=e[t+13],x=e[t+14],R=e[t+15],A=o[0],B=o[1],z=o[2],L=o[3];A=l(A,B,z,L,a,7,s[0]),L=l(L,A,B,z,h,12,s[1]),z=l(z,L,A,B,d,17,s[2]),B=l(B,z,L,A,p,22,s[3]),A=l(A,B,z,L,_,7,s[4]),L=l(L,A,B,z,g,12,s[5]),z=l(z,L,A,B,v,17,s[6]),B=l(B,z,L,A,w,22,s[7]),A=l(A,B,z,L,b,7,s[8]),L=l(L,A,B,z,y,12,s[9]),z=l(z,L,A,B,m,17,s[10]),B=l(B,z,L,A,k,22,s[11]),A=l(A,B,z,L,E,7,s[12]),L=l(L,A,B,z,S,12,s[13]),z=l(z,L,A,B,x,17,s[14]),A=f(A,B=l(B,z,L,A,R,22,s[15]),z,L,h,5,s[16]),L=f(L,A,B,z,v,9,s[17]),z=f(z,L,A,B,k,14,s[18]),B=f(B,z,L,A,a,20,s[19]),A=f(A,B,z,L,g,5,s[20]),L=f(L,A,B,z,m,9,s[21]),z=f(z,L,A,B,R,14,s[22]),B=f(B,z,L,A,_,20,s[23]),A=f(A,B,z,L,y,5,s[24]),L=f(L,A,B,z,x,9,s[25]),z=f(z,L,A,B,p,14,s[26]),B=f(B,z,L,A,b,20,s[27]),A=f(A,B,z,L,S,5,s[28]),L=f(L,A,B,z,d,9,s[29]),z=f(z,L,A,B,w,14,s[30]),A=c(A,B=f(B,z,L,A,E,20,s[31]),z,L,g,4,s[32]),L=c(L,A,B,z,b,11,s[33]),z=c(z,L,A,B,k,16,s[34]),B=c(B,z,L,A,x,23,s[35]),A=c(A,B,z,L,h,4,s[36]),L=c(L,A,B,z,_,11,s[37]),z=c(z,L,A,B,w,16,s[38]),B=c(B,z,L,A,m,23,s[39]),A=c(A,B,z,L,S,4,s[40]),L=c(L,A,B,z,a,11,s[41]),z=c(z,L,A,B,p,16,s[42]),B=c(B,z,L,A,v,23,s[43]),A=c(A,B,z,L,y,4,s[44]),L=c(L,A,B,z,E,11,s[45]),z=c(z,L,A,B,R,16,s[46]),A=u(A,B=c(B,z,L,A,d,23,s[47]),z,L,a,6,s[48]),L=u(L,A,B,z,w,10,s[49]),z=u(z,L,A,B,x,15,s[50]),B=u(B,z,L,A,g,21,s[51]),A=u(A,B,z,L,E,6,s[52]),L=u(L,A,B,z,p,10,s[53]),z=u(z,L,A,B,m,15,s[54]),B=u(B,z,L,A,h,21,s[55]),A=u(A,B,z,L,b,6,s[56]),L=u(L,A,B,z,R,10,s[57]),z=u(z,L,A,B,v,15,s[58]),B=u(B,z,L,A,S,21,s[59]),A=u(A,B,z,L,_,6,s[60]),L=u(L,A,B,z,k,10,s[61]),z=u(z,L,A,B,d,15,s[62]),B=u(B,z,L,A,y,21,s[63]),o[0]=o[0]+A|0,o[1]=o[1]+B|0,o[2]=o[2]+z|0,o[3]=o[3]+L|0},_doFinalize:function(){var t=this._data,r=t.words,n=8*this._nDataBytes,i=8*t.sigBytes;r[i>>>5]|=128<<24-i%32;var o=e.floor(n/4294967296),a=n;r[15+(i+64>>>9<<4)]=16711935&(o<<8|o>>>24)|4278255360&(o<<24|o>>>8),r[14+(i+64>>>9<<4)]=16711935&(a<<8|a>>>24)|4278255360&(a<<24|a>>>8),t.sigBytes=4*(r.length+1),this._process();for(var s=this._hash,h=s.words,l=0;l<4;l++){var f=h[l];h[l]=16711935&(f<<8|f>>>24)|4278255360&(f<<24|f>>>8)}return s},clone:function(){var e=o.clone.call(this);return e._hash=this._hash.clone(),e}});function l(e,t,r,n,i,o,a){var s=e+(t&r|~t&n)+i+a;return(s<<o|s>>>32-o)+t}function f(e,t,r,n,i,o,a){var s=e+(t&n|r&~n)+i+a;return(s<<o|s>>>32-o)+t}function c(e,t,r,n,i,o,a){var s=e+(t^r^n)+i+a;return(s<<o|s>>>32-o)+t}function u(e,t,r,n,i,o,a){var s=e+(r^(t|~n))+i+a;return(s<<o|s>>>32-o)+t}t.MD5=o._createHelper(h),t.HmacMD5=o._createHmacHelper(h)}(Math),r.MD5)}),Q(function(e,t){var r,n,i,o,a,s,h,l;e.exports=(i=(n=r=ee).lib,o=i.WordArray,a=i.Hasher,s=n.algo,h=[],l=s.SHA1=a.extend({_doReset:function(){this._hash=new o.init([1732584193,4023233417,2562383102,271733878,3285377520])},_doProcessBlock:function(e,t){for(var r=this._hash.words,n=r[0],i=r[1],o=r[2],a=r[3],s=r[4],l=0;l<80;l++){if(l<16)h[l]=0|e[t+l];else{var f=h[l-3]^h[l-8]^h[l-14]^h[l-16];h[l]=f<<1|f>>>31}var c=(n<<5|n>>>27)+s+h[l];c+=l<20?1518500249+(i&o|~i&a):l<40?1859775393+(i^o^a):l<60?(i&o|i&a|o&a)-1894007588:(i^o^a)-899497514,s=a,a=o,o=i<<30|i>>>2,i=n,n=c}r[0]=r[0]+n|0,r[1]=r[1]+i|0,r[2]=r[2]+o|0,r[3]=r[3]+a|0,r[4]=r[4]+s|0},_doFinalize:function(){var e=this._data,t=e.words,r=8*this._nDataBytes,n=8*e.sigBytes;return t[n>>>5]|=128<<24-n%32,t[14+(n+64>>>9<<4)]=Math.floor(r/4294967296),t[15+(n+64>>>9<<4)]=r,e.sigBytes=4*t.length,this._process(),this._hash},clone:function(){var e=a.clone.call(this);return e._hash=this._hash.clone(),e}}),n.SHA1=a._createHelper(l),n.HmacSHA1=a._createHmacHelper(l),r.SHA1)}),Q(function(e,t){var r;e.exports=(r=ee,function(e){var t=r,n=t.lib,i=n.WordArray,o=n.Hasher,a=t.algo,s=[],h=[];!function(){function t(t){for(var r=e.sqrt(t),n=2;n<=r;n++)if(!(t%n))return!1;return!0}function r(e){return 4294967296*(e-(0|e))|0}for(var n=2,i=0;i<64;)t(n)&&(i<8&&(s[i]=r(e.pow(n,.5))),h[i]=r(e.pow(n,1/3)),i++),n++}();var l=[],f=a.SHA256=o.extend({_doReset:function(){this._hash=new i.init(s.slice(0))},_doProcessBlock:function(e,t){for(var r=this._hash.words,n=r[0],i=r[1],o=r[2],a=r[3],s=r[4],f=r[5],c=r[6],u=r[7],d=0;d<64;d++){if(d<16)l[d]=0|e[t+d];else{var p=l[d-15],_=(p<<25|p>>>7)^(p<<14|p>>>18)^p>>>3,g=l[d-2],v=(g<<15|g>>>17)^(g<<13|g>>>19)^g>>>10;l[d]=_+l[d-7]+v+l[d-16]}var w=n&i^n&o^i&o,b=(n<<30|n>>>2)^(n<<19|n>>>13)^(n<<10|n>>>22),y=u+((s<<26|s>>>6)^(s<<21|s>>>11)^(s<<7|s>>>25))+(s&f^~s&c)+h[d]+l[d];u=c,c=f,f=s,s=a+y|0,a=o,o=i,i=n,n=y+(b+w)|0}r[0]=r[0]+n|0,r[1]=r[1]+i|0,r[2]=r[2]+o|0,r[3]=r[3]+a|0,r[4]=r[4]+s|0,r[5]=r[5]+f|0,r[6]=r[6]+c|0,r[7]=r[7]+u|0},_doFinalize:function(){var t=this._data,r=t.words,n=8*this._nDataBytes,i=8*t.sigBytes;return r[i>>>5]|=128<<24-i%32,r[14+(i+64>>>9<<4)]=e.floor(n/4294967296),r[15+(i+64>>>9<<4)]=n,t.sigBytes=4*r.length,this._process(),this._hash},clone:function(){var e=o.clone.call(this);return e._hash=this._hash.clone(),e}});t.SHA256=o._createHelper(f),t.HmacSHA256=o._createHmacHelper(f)}(Math),r.SHA256)}),Q(function(e,t){var r,n,i,o,a,s;e.exports=(i=(n=r=ee).lib.WordArray,o=n.algo,a=o.SHA256,s=o.SHA224=a.extend({_doReset:function(){this._hash=new i.init([3238371032,914150663,812702999,4144912697,4290775857,1750603025,1694076839,3204075428])},_doFinalize:function(){var e=a._doFinalize.call(this);return e.sigBytes-=4,e}}),n.SHA224=a._createHelper(s),n.HmacSHA224=a._createHmacHelper(s),r.SHA224)}),Q(function(e,t){var r;e.exports=(r=ee,function(){var e=r,t=e.lib.Hasher,n=e.x64,i=n.Word,o=n.WordArray,a=e.algo;function s(){return i.create.apply(i,arguments)}var h=[s(1116352408,3609767458),s(1899447441,602891725),s(3049323471,3964484399),s(3921009573,2173295548),s(961987163,4081628472),s(1508970993,3053834265),s(2453635748,2937671579),s(2870763221,3664609560),s(3624381080,2734883394),s(310598401,1164996542),s(607225278,1323610764),s(1426881987,3590304994),s(1925078388,4068182383),s(2162078206,991336113),s(2614888103,633803317),s(3248222580,3479774868),s(3835390401,2666613458),s(4022224774,944711139),s(264347078,2341262773),s(604807628,2007800933),s(770255983,1495990901),s(1249150122,1856431235),s(1555081692,3175218132),s(1996064986,2198950837),s(2554220882,3999719339),s(2821834349,766784016),s(2952996808,2566594879),s(3210313671,3203337956),s(3336571891,1034457026),s(3584528711,2466948901),s(113926993,3758326383),s(338241895,168717936),s(666307205,1188179964),s(773529912,1546045734),s(1294757372,1522805485),s(1396182291,2643833823),s(1695183700,2343527390),s(1986661051,1014477480),s(2177026350,1206759142),s(2456956037,344077627),s(2730485921,1290863460),s(2820302411,3158454273),s(3259730800,3505952657),s(3345764771,106217008),s(3516065817,3606008344),s(3600352804,1432725776),s(4094571909,1467031594),s(275423344,851169720),s(430227734,3100823752),s(506948616,1363258195),s(659060556,3750685593),s(883997877,3785050280),s(958139571,3318307427),s(1322822218,3812723403),s(1537002063,2003034995),s(1747873779,3602036899),s(1955562222,1575990012),s(2024104815,1125592928),s(2227730452,2716904306),s(2361852424,442776044),s(2428436474,593698344),s(2756734187,3733110249),s(3204031479,2999351573),s(3329325298,3815920427),s(3391569614,3928383900),s(3515267271,566280711),s(3940187606,3454069534),s(4118630271,4000239992),s(116418474,1914138554),s(174292421,2731055270),s(289380356,3203993006),s(460393269,320620315),s(685471733,587496836),s(852142971,1086792851),s(1017036298,365543100),s(1126000580,2618297676),s(1288033470,3409855158),s(1501505948,4234509866),s(1607167915,987167468),s(1816402316,1246189591)],l=[];!function(){for(var e=0;e<80;e++)l[e]=s()}();var f=a.SHA512=t.extend({_doReset:function(){this._hash=new o.init([new i.init(1779033703,4089235720),new i.init(3144134277,2227873595),new i.init(1013904242,4271175723),new i.init(2773480762,1595750129),new i.init(1359893119,2917565137),new i.init(2600822924,725511199),new i.init(528734635,4215389547),new i.init(1541459225,327033209)])},_doProcessBlock:function(e,t){for(var r=this._hash.words,n=r[0],i=r[1],o=r[2],a=r[3],s=r[4],f=r[5],c=r[6],u=r[7],d=n.high,p=n.low,_=i.high,g=i.low,v=o.high,w=o.low,b=a.high,y=a.low,m=s.high,k=s.low,E=f.high,S=f.low,x=c.high,R=c.low,A=u.high,B=u.low,z=d,L=p,T=_,M=g,C=v,D=w,I=b,P=y,O=m,U=k,H=E,F=S,N=x,Z=R,j=A,W=B,Y=0;Y<80;Y++){var K=l[Y];if(Y<16)var X=K.high=0|e[t+2*Y],q=K.low=0|e[t+2*Y+1];else{var V=l[Y-15],G=V.high,$=V.low,J=(G>>>1|$<<31)^(G>>>8|$<<24)^G>>>7,Q=($>>>1|G<<31)^($>>>8|G<<24)^($>>>7|G<<25),ee=l[Y-2],te=ee.high,re=ee.low,ne=(te>>>19|re<<13)^(te<<3|re>>>29)^te>>>6,ie=(re>>>19|te<<13)^(re<<3|te>>>29)^(re>>>6|te<<26),oe=l[Y-7],ae=oe.high,se=oe.low,he=l[Y-16],le=he.high,fe=he.low;X=(X=(X=J+ae+((q=Q+se)>>>0<Q>>>0?1:0))+ne+((q+=ie)>>>0<ie>>>0?1:0))+le+((q+=fe)>>>0<fe>>>0?1:0),K.high=X,K.low=q}var ce,ue=O&H^~O&N,de=U&F^~U&Z,pe=z&T^z&C^T&C,_e=L&M^L&D^M&D,ge=(z>>>28|L<<4)^(z<<30|L>>>2)^(z<<25|L>>>7),ve=(L>>>28|z<<4)^(L<<30|z>>>2)^(L<<25|z>>>7),we=(O>>>14|U<<18)^(O>>>18|U<<14)^(O<<23|U>>>9),be=(U>>>14|O<<18)^(U>>>18|O<<14)^(U<<23|O>>>9),ye=h[Y],me=ye.high,ke=ye.low,Ee=j+we+((ce=W+be)>>>0<W>>>0?1:0),Se=ve+_e;j=N,W=Z,N=H,Z=F,H=O,F=U,O=I+(Ee=(Ee=(Ee=Ee+ue+((ce+=de)>>>0<de>>>0?1:0))+me+((ce+=ke)>>>0<ke>>>0?1:0))+X+((ce+=q)>>>0<q>>>0?1:0))+((U=P+ce|0)>>>0<P>>>0?1:0)|0,I=C,P=D,C=T,D=M,T=z,M=L,z=Ee+(ge+pe+(Se>>>0<ve>>>0?1:0))+((L=ce+Se|0)>>>0<ce>>>0?1:0)|0}p=n.low=p+L,n.high=d+z+(p>>>0<L>>>0?1:0),g=i.low=g+M,i.high=_+T+(g>>>0<M>>>0?1:0),w=o.low=w+D,o.high=v+C+(w>>>0<D>>>0?1:0),y=a.low=y+P,a.high=b+I+(y>>>0<P>>>0?1:0),k=s.low=k+U,s.high=m+O+(k>>>0<U>>>0?1:0),S=f.low=S+F,f.high=E+H+(S>>>0<F>>>0?1:0),R=c.low=R+Z,c.high=x+N+(R>>>0<Z>>>0?1:0),B=u.low=B+W,u.high=A+j+(B>>>0<W>>>0?1:0)},_doFinalize:function(){var e=this._data,t=e.words,r=8*this._nDataBytes,n=8*e.sigBytes;return t[n>>>5]|=128<<24-n%32,t[30+(n+128>>>10<<5)]=Math.floor(r/4294967296),t[31+(n+128>>>10<<5)]=r,e.sigBytes=4*t.length,this._process(),this._hash.toX32()},clone:function(){var e=t.clone.call(this);return e._hash=this._hash.clone(),e},blockSize:32});e.SHA512=t._createHelper(f),e.HmacSHA512=t._createHmacHelper(f)}(),r.SHA512)}),Q(function(e,t){var r,n,i,o,a,s,h,l;e.exports=(i=(n=r=ee).x64,o=i.Word,a=i.WordArray,s=n.algo,h=s.SHA512,l=s.SHA384=h.extend({_doReset:function(){this._hash=new a.init([new o.init(3418070365,3238371032),new o.init(1654270250,914150663),new o.init(2438529370,812702999),new o.init(355462360,4144912697),new o.init(1731405415,4290775857),new o.init(2394180231,1750603025),new o.init(3675008525,1694076839),new o.init(1203062813,3204075428)])},_doFinalize:function(){var e=h._doFinalize.call(this);return e.sigBytes-=16,e}}),n.SHA384=h._createHelper(l),n.HmacSHA384=h._createHmacHelper(l),r.SHA384)}),Q(function(e,t){var r;e.exports=(r=ee,function(e){var t=r,n=t.lib,i=n.WordArray,o=n.Hasher,a=t.x64.Word,s=t.algo,h=[],l=[],f=[];!function(){for(var e=1,t=0,r=0;r<24;r++){h[e+5*t]=(r+1)*(r+2)/2%64;var n=(2*e+3*t)%5;e=t%5,t=n}for(e=0;e<5;e++)for(t=0;t<5;t++)l[e+5*t]=t+(2*e+3*t)%5*5;for(var i=1,o=0;o<24;o++){for(var s=0,c=0,u=0;u<7;u++){if(1&i){var d=(1<<u)-1;d<32?c^=1<<d:s^=1<<d-32}128&i?i=i<<1^113:i<<=1}f[o]=a.create(s,c)}}();var c=[];!function(){for(var e=0;e<25;e++)c[e]=a.create()}();var u=s.SHA3=o.extend({cfg:o.cfg.extend({outputLength:512}),_doReset:function(){for(var e=this._state=[],t=0;t<25;t++)e[t]=new a.init;this.blockSize=(1600-2*this.cfg.outputLength)/32},_doProcessBlock:function(e,t){for(var r=this._state,n=this.blockSize/2,i=0;i<n;i++){var o=e[t+2*i],a=e[t+2*i+1];o=16711935&(o<<8|o>>>24)|4278255360&(o<<24|o>>>8),a=16711935&(a<<8|a>>>24)|4278255360&(a<<24|a>>>8),(B=r[i]).high^=a,B.low^=o}for(var s=0;s<24;s++){for(var u=0;u<5;u++){for(var d=0,p=0,_=0;_<5;_++)d^=(B=r[u+5*_]).high,p^=B.low;var g=c[u];g.high=d,g.low=p}for(u=0;u<5;u++){var v=c[(u+4)%5],w=c[(u+1)%5],b=w.high,y=w.low;for(d=v.high^(b<<1|y>>>31),p=v.low^(y<<1|b>>>31),_=0;_<5;_++)(B=r[u+5*_]).high^=d,B.low^=p}for(var m=1;m<25;m++){var k=(B=r[m]).high,E=B.low,S=h[m];S<32?(d=k<<S|E>>>32-S,p=E<<S|k>>>32-S):(d=E<<S-32|k>>>64-S,p=k<<S-32|E>>>64-S);var x=c[l[m]];x.high=d,x.low=p}var R=c[0],A=r[0];for(R.high=A.high,R.low=A.low,u=0;u<5;u++)for(_=0;_<5;_++){var B=r[m=u+5*_],z=c[m],L=c[(u+1)%5+5*_],T=c[(u+2)%5+5*_];B.high=z.high^~L.high&T.high,B.low=z.low^~L.low&T.low}B=r[0];var M=f[s];B.high^=M.high,B.low^=M.low}},_doFinalize:function(){var t=this._data,r=t.words,n=(this._nDataBytes,8*t.sigBytes),o=32*this.blockSize;r[n>>>5]|=1<<24-n%32,r[(e.ceil((n+1)/o)*o>>>5)-1]|=128,t.sigBytes=4*r.length,this._process();for(var a=this._state,s=this.cfg.outputLength/8,h=s/8,l=[],f=0;f<h;f++){var c=a[f],u=c.high,d=c.low;u=16711935&(u<<8|u>>>24)|4278255360&(u<<24|u>>>8),d=16711935&(d<<8|d>>>24)|4278255360&(d<<24|d>>>8),l.push(d),l.push(u)}return new i.init(l,s)},clone:function(){for(var e=o.clone.call(this),t=e._state=this._state.slice(0),r=0;r<25;r++)t[r]=t[r].clone();return e}});t.SHA3=o._createHelper(u),t.HmacSHA3=o._createHmacHelper(u)}(Math),r.SHA3)}),Q(function(e,t){var r;e.exports=(r=ee,function(e){var t=r,n=t.lib,i=n.WordArray,o=n.Hasher,a=t.algo,s=i.create([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,7,4,13,1,10,6,15,3,12,0,9,5,2,14,11,8,3,10,14,4,9,15,8,1,2,7,0,6,13,11,5,12,1,9,11,10,0,8,12,4,13,3,7,15,14,5,6,2,4,0,5,9,7,12,2,10,14,1,3,8,11,6,15,13]),h=i.create([5,14,7,0,9,2,11,4,13,6,15,8,1,10,3,12,6,11,3,7,0,13,5,10,14,15,8,12,4,9,1,2,15,5,1,3,7,14,6,9,11,8,12,2,10,0,4,13,8,6,4,1,3,11,15,0,5,12,2,13,9,7,10,14,12,15,10,4,1,5,8,7,6,2,13,14,0,3,9,11]),l=i.create([11,14,15,12,5,8,7,9,11,13,14,15,6,7,9,8,7,6,8,13,11,9,7,15,7,12,15,9,11,7,13,12,11,13,6,7,14,9,13,15,14,8,13,6,5,12,7,5,11,12,14,15,14,15,9,8,9,14,5,6,8,6,5,12,9,15,5,11,6,8,13,12,5,12,13,14,11,8,5,6]),f=i.create([8,9,9,11,13,15,15,5,7,7,8,11,14,14,12,6,9,13,15,7,12,8,9,11,7,7,12,7,6,15,13,11,9,7,15,11,8,6,6,14,12,13,5,14,13,13,7,5,15,5,8,11,14,14,6,14,6,9,12,9,12,5,15,8,8,5,12,9,12,5,14,6,8,13,6,5,15,13,11,11]),c=i.create([0,1518500249,1859775393,2400959708,2840853838]),u=i.create([1352829926,1548603684,1836072691,2053994217,0]),d=a.RIPEMD160=o.extend({_doReset:function(){this._hash=i.create([1732584193,4023233417,2562383102,271733878,3285377520])},_doProcessBlock:function(e,t){for(var r=0;r<16;r++){var n=t+r,i=e[n];e[n]=16711935&(i<<8|i>>>24)|4278255360&(i<<24|i>>>8)}var o,a,d,y,m,k,E,S,x,R,A,B=this._hash.words,z=c.words,L=u.words,T=s.words,M=h.words,C=l.words,D=f.words;for(k=o=B[0],E=a=B[1],S=d=B[2],x=y=B[3],R=m=B[4],r=0;r<80;r+=1)A=o+e[t+T[r]]|0,A+=r<16?p(a,d,y)+z[0]:r<32?_(a,d,y)+z[1]:r<48?g(a,d,y)+z[2]:r<64?v(a,d,y)+z[3]:w(a,d,y)+z[4],A=(A=b(A|=0,C[r]))+m|0,o=m,m=y,y=b(d,10),d=a,a=A,A=k+e[t+M[r]]|0,A+=r<16?w(E,S,x)+L[0]:r<32?v(E,S,x)+L[1]:r<48?g(E,S,x)+L[2]:r<64?_(E,S,x)+L[3]:p(E,S,x)+L[4],A=(A=b(A|=0,D[r]))+R|0,k=R,R=x,x=b(S,10),S=E,E=A;A=B[1]+d+x|0,B[1]=B[2]+y+R|0,B[2]=B[3]+m+k|0,B[3]=B[4]+o+E|0,B[4]=B[0]+a+S|0,B[0]=A},_doFinalize:function(){var e=this._data,t=e.words,r=8*this._nDataBytes,n=8*e.sigBytes;t[n>>>5]|=128<<24-n%32,t[14+(n+64>>>9<<4)]=16711935&(r<<8|r>>>24)|4278255360&(r<<24|r>>>8),e.sigBytes=4*(t.length+1),this._process();for(var i=this._hash,o=i.words,a=0;a<5;a++){var s=o[a];o[a]=16711935&(s<<8|s>>>24)|4278255360&(s<<24|s>>>8)}return i},clone:function(){var e=o.clone.call(this);return e._hash=this._hash.clone(),e}});function p(e,t,r){return e^t^r}function _(e,t,r){return e&t|~e&r}function g(e,t,r){return(e|~t)^r}function v(e,t,r){return e&r|t&~r}function w(e,t,r){return e^(t|~r)}function b(e,t){return e<<t|e>>>32-t}t.RIPEMD160=o._createHelper(d),t.HmacRIPEMD160=o._createHmacHelper(d)}(),r.RIPEMD160)}),Q(function(e,t){var r,n,i,o,a,s;e.exports=(n=(r=ee).lib,i=n.Base,o=r.enc,a=o.Utf8,s=r.algo,void(s.HMAC=i.extend({init:function(e,t){e=this._hasher=new e.init,"string"==typeof t&&(t=a.parse(t));var r=e.blockSize,n=4*r;t.sigBytes>n&&(t=e.finalize(t)),t.clamp();for(var i=this._oKey=t.clone(),o=this._iKey=t.clone(),s=i.words,h=o.words,l=0;l<r;l++)s[l]^=1549556828,h[l]^=909522486;i.sigBytes=o.sigBytes=n,this.reset()},reset:function(){var e=this._hasher;e.reset(),e.update(this._iKey)},update:function(e){return this._hasher.update(e),this},finalize:function(e){var t=this._hasher,r=t.finalize(e);t.reset();var n=t.finalize(this._oKey.clone().concat(r));return n}})))}),Q(function(e,t){var r,n,i,o,a,s,h,l,f;e.exports=(i=(n=r=ee).lib,o=i.Base,a=i.WordArray,s=n.algo,h=s.SHA1,l=s.HMAC,f=s.PBKDF2=o.extend({cfg:o.extend({keySize:4,hasher:h,iterations:1}),init:function(e){this.cfg=this.cfg.extend(e)},compute:function(e,t){for(var r=this.cfg,n=l.create(r.hasher,e),i=a.create(),o=a.create([1]),s=i.words,h=o.words,f=r.keySize,c=r.iterations;s.length<f;){var u=n.update(t).finalize(o);n.reset();for(var d=u.words,p=d.length,_=u,g=1;g<c;g++){_=n.finalize(_),n.reset();for(var v=_.words,w=0;w<p;w++)d[w]^=v[w]}i.concat(u),h[0]++}return i.sigBytes=4*f,i}}),n.PBKDF2=function(e,t,r){return f.create(r).compute(e,t)},r.PBKDF2)}),Q(function(e,t){var r,n,i,o,a,s,h,l;e.exports=(i=(n=r=ee).lib,o=i.Base,a=i.WordArray,s=n.algo,h=s.MD5,l=s.EvpKDF=o.extend({cfg:o.extend({keySize:4,hasher:h,iterations:1}),init:function(e){this.cfg=this.cfg.extend(e)},compute:function(e,t){for(var r=this.cfg,n=r.hasher.create(),i=a.create(),o=i.words,s=r.keySize,h=r.iterations;o.length<s;){l&&n.update(l);var l=n.update(e).finalize(t);n.reset();for(var f=1;f<h;f++)l=n.finalize(l),n.reset();i.concat(l)}return i.sigBytes=4*s,i}}),n.EvpKDF=function(e,t,r){return l.create(r).compute(e,t)},r.EvpKDF)}),Q(function(e,t){var r,n,i,o,a,s,h,l,f,c,u,d,p,_,g,v,w,b,y,m,k,E,S,x;e.exports=void((r=ee).lib.Cipher||(i=r,o=i.lib,a=o.Base,s=o.WordArray,h=o.BufferedBlockAlgorithm,l=i.enc,l.Utf8,f=l.Base64,c=i.algo,u=c.EvpKDF,d=o.Cipher=h.extend({cfg:a.extend(),createEncryptor:function(e,t){return this.create(this._ENC_XFORM_MODE,e,t)},createDecryptor:function(e,t){return this.create(this._DEC_XFORM_MODE,e,t)},init:function(e,t,r){this.cfg=this.cfg.extend(r),this._xformMode=e,this._key=t,this.reset()},reset:function(){h.reset.call(this),this._doReset()},process:function(e){return this._append(e),this._process()},finalize:function(e){e&&this._append(e);var t=this._doFinalize();return t},keySize:4,ivSize:4,_ENC_XFORM_MODE:1,_DEC_XFORM_MODE:2,_createHelper:function(){function e(e){return"string"==typeof e?x:k}return function(t){return{encrypt:function(r,n,i){return e(n).encrypt(t,r,n,i)},decrypt:function(r,n,i){return e(n).decrypt(t,r,n,i)}}}}()}),o.StreamCipher=d.extend({_doFinalize:function(){var e=this._process(!0);return e},blockSize:1}),p=i.mode={},_=o.BlockCipherMode=a.extend({createEncryptor:function(e,t){return this.Encryptor.create(e,t)},createDecryptor:function(e,t){return this.Decryptor.create(e,t)},init:function(e,t){this._cipher=e,this._iv=t}}),g=p.CBC=function(){var e=_.extend();function t(e,t,r){var i=this._iv;if(i){var o=i;this._iv=n}else var o=this._prevBlock;for(var a=0;a<r;a++)e[t+a]^=o[a]}return e.Encryptor=e.extend({processBlock:function(e,r){var n=this._cipher,i=n.blockSize;t.call(this,e,r,i),n.encryptBlock(e,r),this._prevBlock=e.slice(r,r+i)}}),e.Decryptor=e.extend({processBlock:function(e,r){var n=this._cipher,i=n.blockSize,o=e.slice(r,r+i);n.decryptBlock(e,r),t.call(this,e,r,i),this._prevBlock=o}}),e}(),v=i.pad={},w=v.Pkcs7={pad:function(e,t){for(var r=4*t,n=r-e.sigBytes%r,i=n<<24|n<<16|n<<8|n,o=[],a=0;a<n;a+=4)o.push(i);var h=s.create(o,n);e.concat(h)},unpad:function(e){var t=255&e.words[e.sigBytes-1>>>2];e.sigBytes-=t}},o.BlockCipher=d.extend({cfg:d.cfg.extend({mode:g,padding:w}),reset:function(){d.reset.call(this);var e=this.cfg,t=e.iv,r=e.mode;if(this._xformMode==this._ENC_XFORM_MODE)var n=r.createEncryptor;else{var n=r.createDecryptor;this._minBufferSize=1}this._mode&&this._mode.__creator==n?this._mode.init(this,t&&t.words):(this._mode=n.call(r,this,t&&t.words),this._mode.__creator=n)},_doProcessBlock:function(e,t){this._mode.processBlock(e,t)},_doFinalize:function(){var e=this.cfg.padding;if(this._xformMode==this._ENC_XFORM_MODE){e.pad(this._data,this.blockSize);var t=this._process(!0)}else{var t=this._process(!0);e.unpad(t)}return t},blockSize:4}),b=o.CipherParams=a.extend({init:function(e){this.mixIn(e)},toString:function(e){return(e||this.formatter).stringify(this)}}),y=i.format={},m=y.OpenSSL={stringify:function(e){var t=e.ciphertext,r=e.salt;if(r)var n=s.create([1398893684,1701076831]).concat(r).concat(t);else var n=t;return n.toString(f)},parse:function(e){var t=f.parse(e),r=t.words;if(1398893684==r[0]&&1701076831==r[1]){var n=s.create(r.slice(2,4));r.splice(0,4),t.sigBytes-=16}return b.create({ciphertext:t,salt:n})}},k=o.SerializableCipher=a.extend({cfg:a.extend({format:m}),encrypt:function(e,t,r,n){n=this.cfg.extend(n);var i=e.createEncryptor(r,n),o=i.finalize(t),a=i.cfg;return b.create({ciphertext:o,key:r,iv:a.iv,algorithm:e,mode:a.mode,padding:a.padding,blockSize:e.blockSize,formatter:n.format})},decrypt:function(e,t,r,n){n=this.cfg.extend(n),t=this._parse(t,n.format);var i=e.createDecryptor(r,n).finalize(t.ciphertext);return i},_parse:function(e,t){return"string"==typeof e?t.parse(e,this):e}}),E=i.kdf={},S=E.OpenSSL={execute:function(e,t,r,n){n||(n=s.random(8));var i=u.create({keySize:t+r}).compute(e,n),o=s.create(i.words.slice(t),4*r);return i.sigBytes=4*t,b.create({key:i,iv:o,salt:n})}},x=o.PasswordBasedCipher=k.extend({cfg:k.cfg.extend({kdf:S}),encrypt:function(e,t,r,n){var i=(n=this.cfg.extend(n)).kdf.execute(r,e.keySize,e.ivSize);n.iv=i.iv;var o=k.encrypt.call(this,e,t,i.key,n);return o.mixIn(i),o},decrypt:function(e,t,r,n){n=this.cfg.extend(n),t=this._parse(t,n.format);var i=n.kdf.execute(r,e.keySize,e.ivSize,t.salt);n.iv=i.iv;var o=k.decrypt.call(this,e,t,i.key,n);return o}})))}),Q(function(e,t){var r;e.exports=((r=ee).mode.CFB=function(){var e=r.lib.BlockCipherMode.extend();function t(e,t,r,n){var i=this._iv;if(i){var o=i.slice(0);this._iv=void 0}else o=this._prevBlock;n.encryptBlock(o,0);for(var a=0;a<r;a++)e[t+a]^=o[a]}return e.Encryptor=e.extend({processBlock:function(e,r){var n=this._cipher,i=n.blockSize;t.call(this,e,r,i,n),this._prevBlock=e.slice(r,r+i)}}),e.Decryptor=e.extend({processBlock:function(e,r){var n=this._cipher,i=n.blockSize,o=e.slice(r,r+i);t.call(this,e,r,i,n),this._prevBlock=o}}),e}(),r.mode.CFB)}),Q(function(e,t){var r,n,i;e.exports=((r=ee).mode.CTR=(n=r.lib.BlockCipherMode.extend(),i=n.Encryptor=n.extend({processBlock:function(e,t){var r=this._cipher,n=r.blockSize,i=this._iv,o=this._counter;i&&(o=this._counter=i.slice(0),this._iv=void 0);var a=o.slice(0);r.encryptBlock(a,0),o[n-1]=o[n-1]+1|0;for(var s=0;s<n;s++)e[t+s]^=a[s]}}),n.Decryptor=i,n),r.mode.CTR)}),Q(function(e,t){var r;e.exports=((r=ee).mode.CTRGladman=function(){var e=r.lib.BlockCipherMode.extend();function t(e){if(255==(e>>24&255)){var t=e>>16&255,r=e>>8&255,n=255&e;255===t?(t=0,255===r?(r=0,255===n?n=0:++n):++r):++t,e=0,e+=t<<16,e+=r<<8,e+=n}else e+=1<<24;return e}var n=e.Encryptor=e.extend({processBlock:function(e,r){var n=this._cipher,i=n.blockSize,o=this._iv,a=this._counter;o&&(a=this._counter=o.slice(0),this._iv=void 0),function(e){0===(e[0]=t(e[0]))&&(e[1]=t(e[1]))}(a);var s=a.slice(0);n.encryptBlock(s,0);for(var h=0;h<i;h++)e[r+h]^=s[h]}});return e.Decryptor=n,e}(),r.mode.CTRGladman)}),Q(function(e,t){var r,n,i;e.exports=((r=ee).mode.OFB=(n=r.lib.BlockCipherMode.extend(),i=n.Encryptor=n.extend({processBlock:function(e,t){var r=this._cipher,n=r.blockSize,i=this._iv,o=this._keystream;i&&(o=this._keystream=i.slice(0),this._iv=void 0),r.encryptBlock(o,0);for(var a=0;a<n;a++)e[t+a]^=o[a]}}),n.Decryptor=i,n),r.mode.OFB)}),Q(function(e,t){var r,n;e.exports=((r=ee).mode.ECB=((n=r.lib.BlockCipherMode.extend()).Encryptor=n.extend({processBlock:function(e,t){this._cipher.encryptBlock(e,t)}}),n.Decryptor=n.extend({processBlock:function(e,t){this._cipher.decryptBlock(e,t)}}),n),r.mode.ECB)}),Q(function(e,t){var r;e.exports=((r=ee).pad.AnsiX923={pad:function(e,t){var r=e.sigBytes,n=4*t,i=n-r%n,o=r+i-1;e.clamp(),e.words[o>>>2]|=i<<24-o%4*8,e.sigBytes+=i},unpad:function(e){var t=255&e.words[e.sigBytes-1>>>2];e.sigBytes-=t}},r.pad.Ansix923)}),Q(function(e,t){var r;e.exports=((r=ee).pad.Iso10126={pad:function(e,t){var n=4*t,i=n-e.sigBytes%n;e.concat(r.lib.WordArray.random(i-1)).concat(r.lib.WordArray.create([i<<24],1))},unpad:function(e){var t=255&e.words[e.sigBytes-1>>>2];e.sigBytes-=t}},r.pad.Iso10126)}),Q(function(e,t){var r;e.exports=((r=ee).pad.Iso97971={pad:function(e,t){e.concat(r.lib.WordArray.create([2147483648],1)),r.pad.ZeroPadding.pad(e,t)},unpad:function(e){r.pad.ZeroPadding.unpad(e),e.sigBytes--}},r.pad.Iso97971)}),Q(function(e,t){var r;e.exports=((r=ee).pad.ZeroPadding={pad:function(e,t){var r=4*t;e.clamp(),e.sigBytes+=r-(e.sigBytes%r||r)},unpad:function(e){for(var t=e.words,r=e.sigBytes-1;!(t[r>>>2]>>>24-r%4*8&255);)r--;e.sigBytes=r+1}},r.pad.ZeroPadding)}),Q(function(e,t){var r;e.exports=((r=ee).pad.NoPadding={pad:function(){},unpad:function(){}},r.pad.NoPadding)}),Q(function(e,t){var r,n,i,o;e.exports=(i=(n=r=ee).lib.CipherParams,o=n.enc.Hex,n.format.Hex={stringify:function(e){return e.ciphertext.toString(o)},parse:function(e){var t=o.parse(e);return i.create({ciphertext:t})}},r.format.Hex)}),Q(function(e,t){var r;e.exports=(r=ee,function(){var e=r,t=e.lib.BlockCipher,n=e.algo,i=[],o=[],a=[],s=[],h=[],l=[],f=[],c=[],u=[],d=[];!function(){for(var e=[],t=0;t<256;t++)e[t]=t<128?t<<1:t<<1^283;var r=0,n=0;for(t=0;t<256;t++){var p=n^n<<1^n<<2^n<<3^n<<4;p=p>>>8^255&p^99,i[r]=p,o[p]=r;var _=e[r],g=e[_],v=e[g],w=257*e[p]^16843008*p;a[r]=w<<24|w>>>8,s[r]=w<<16|w>>>16,h[r]=w<<8|w>>>24,l[r]=w,w=16843009*v^65537*g^257*_^16843008*r,f[p]=w<<24|w>>>8,c[p]=w<<16|w>>>16,u[p]=w<<8|w>>>24,d[p]=w,r?(r=_^e[e[e[v^_]]],n^=e[e[n]]):r=n=1}}();var p=[0,1,2,4,8,16,32,64,128,27,54],_=n.AES=t.extend({_doReset:function(){if(!this._nRounds||this._keyPriorReset!==this._key){for(var e=this._keyPriorReset=this._key,t=e.words,r=e.sigBytes/4,n=4*((this._nRounds=r+6)+1),o=this._keySchedule=[],a=0;a<n;a++)if(a<r)o[a]=t[a];else{var s=o[a-1];a%r?r>6&&a%r==4&&(s=i[s>>>24]<<24|i[s>>>16&255]<<16|i[s>>>8&255]<<8|i[255&s]):(s=i[(s=s<<8|s>>>24)>>>24]<<24|i[s>>>16&255]<<16|i[s>>>8&255]<<8|i[255&s],s^=p[a/r|0]<<24),o[a]=o[a-r]^s}for(var h=this._invKeySchedule=[],l=0;l<n;l++)a=n-l,s=l%4?o[a]:o[a-4],h[l]=l<4||a<=4?s:f[i[s>>>24]]^c[i[s>>>16&255]]^u[i[s>>>8&255]]^d[i[255&s]]}},encryptBlock:function(e,t){this._doCryptBlock(e,t,this._keySchedule,a,s,h,l,i)},decryptBlock:function(e,t){var r=e[t+1];e[t+1]=e[t+3],e[t+3]=r,this._doCryptBlock(e,t,this._invKeySchedule,f,c,u,d,o),r=e[t+1],e[t+1]=e[t+3],e[t+3]=r},_doCryptBlock:function(e,t,r,n,i,o,a,s){for(var h=this._nRounds,l=e[t]^r[0],f=e[t+1]^r[1],c=e[t+2]^r[2],u=e[t+3]^r[3],d=4,p=1;p<h;p++){var _=n[l>>>24]^i[f>>>16&255]^o[c>>>8&255]^a[255&u]^r[d++],g=n[f>>>24]^i[c>>>16&255]^o[u>>>8&255]^a[255&l]^r[d++],v=n[c>>>24]^i[u>>>16&255]^o[l>>>8&255]^a[255&f]^r[d++],w=n[u>>>24]^i[l>>>16&255]^o[f>>>8&255]^a[255&c]^r[d++];l=_,f=g,c=v,u=w}_=(s[l>>>24]<<24|s[f>>>16&255]<<16|s[c>>>8&255]<<8|s[255&u])^r[d++],g=(s[f>>>24]<<24|s[c>>>16&255]<<16|s[u>>>8&255]<<8|s[255&l])^r[d++],v=(s[c>>>24]<<24|s[u>>>16&255]<<16|s[l>>>8&255]<<8|s[255&f])^r[d++],w=(s[u>>>24]<<24|s[l>>>16&255]<<16|s[f>>>8&255]<<8|s[255&c])^r[d++],e[t]=_,e[t+1]=g,e[t+2]=v,e[t+3]=w},keySize:8});e.AES=t._createHelper(_)}(),r.AES)}),Q(function(e,t){var r;e.exports=(r=ee,function(){var e=r,t=e.lib,n=t.WordArray,i=t.BlockCipher,o=e.algo,a=[57,49,41,33,25,17,9,1,58,50,42,34,26,18,10,2,59,51,43,35,27,19,11,3,60,52,44,36,63,55,47,39,31,23,15,7,62,54,46,38,30,22,14,6,61,53,45,37,29,21,13,5,28,20,12,4],s=[14,17,11,24,1,5,3,28,15,6,21,10,23,19,12,4,26,8,16,7,27,20,13,2,41,52,31,37,47,55,30,40,51,45,33,48,44,49,39,56,34,53,46,42,50,36,29,32],h=[1,2,4,6,8,10,12,14,15,17,19,21,23,25,27,28],l=[{0:8421888,268435456:32768,536870912:8421378,805306368:2,1073741824:512,1342177280:8421890,1610612736:8389122,1879048192:8388608,2147483648:514,2415919104:8389120,2684354560:33280,2952790016:8421376,3221225472:32770,3489660928:8388610,3758096384:0,4026531840:33282,134217728:0,402653184:8421890,671088640:33282,939524096:32768,1207959552:8421888,1476395008:512,1744830464:8421378,2013265920:2,2281701376:8389120,2550136832:33280,2818572288:8421376,3087007744:8389122,3355443200:8388610,3623878656:32770,3892314112:514,4160749568:8388608,1:32768,268435457:2,536870913:8421888,805306369:8388608,1073741825:8421378,1342177281:33280,1610612737:512,1879048193:8389122,2147483649:8421890,2415919105:8421376,2684354561:8388610,2952790017:33282,3221225473:514,3489660929:8389120,3758096385:32770,4026531841:0,134217729:8421890,402653185:8421376,671088641:8388608,939524097:512,1207959553:32768,1476395009:8388610,1744830465:2,2013265921:33282,2281701377:32770,2550136833:8389122,2818572289:514,3087007745:8421888,3355443201:8389120,3623878657:0,3892314113:33280,4160749569:8421378},{0:1074282512,16777216:16384,33554432:524288,50331648:1074266128,67108864:1073741840,83886080:1074282496,100663296:1073758208,117440512:16,134217728:540672,150994944:1073758224,167772160:1073741824,184549376:540688,201326592:524304,218103808:0,234881024:16400,251658240:1074266112,8388608:1073758208,25165824:540688,41943040:16,58720256:1073758224,75497472:1074282512,92274688:1073741824,109051904:524288,125829120:1074266128,142606336:524304,159383552:0,176160768:16384,192937984:1074266112,209715200:1073741840,226492416:540672,243269632:1074282496,260046848:16400,268435456:0,285212672:1074266128,301989888:1073758224,318767104:1074282496,335544320:1074266112,352321536:16,369098752:540688,385875968:16384,402653184:16400,419430400:524288,436207616:524304,452984832:1073741840,469762048:540672,486539264:1073758208,503316480:1073741824,520093696:1074282512,276824064:540688,293601280:524288,310378496:1074266112,327155712:16384,343932928:1073758208,360710144:1074282512,377487360:16,394264576:1073741824,411041792:1074282496,427819008:1073741840,444596224:1073758224,461373440:524304,478150656:0,494927872:16400,511705088:1074266128,528482304:540672},{0:260,1048576:0,2097152:67109120,3145728:65796,4194304:65540,5242880:67108868,6291456:67174660,7340032:67174400,8388608:67108864,9437184:67174656,10485760:65792,11534336:67174404,12582912:67109124,13631488:65536,14680064:4,15728640:256,524288:67174656,1572864:67174404,2621440:0,3670016:67109120,4718592:67108868,5767168:65536,6815744:65540,7864320:260,8912896:4,9961472:256,11010048:67174400,12058624:65796,13107200:65792,14155776:67109124,15204352:67174660,16252928:67108864,16777216:67174656,17825792:65540,18874368:65536,19922944:67109120,20971520:256,22020096:67174660,23068672:67108868,24117248:0,25165824:67109124,26214400:67108864,27262976:4,28311552:65792,29360128:67174400,30408704:260,31457280:65796,32505856:67174404,17301504:67108864,18350080:260,19398656:67174656,20447232:0,21495808:65540,22544384:67109120,23592960:256,24641536:67174404,25690112:65536,26738688:67174660,27787264:65796,28835840:67108868,29884416:67109124,30932992:67174400,31981568:4,33030144:65792},{0:2151682048,65536:2147487808,131072:4198464,196608:2151677952,262144:0,327680:4198400,393216:2147483712,458752:4194368,524288:2147483648,589824:4194304,655360:64,720896:2147487744,786432:2151678016,851968:4160,917504:4096,983040:2151682112,32768:2147487808,98304:64,163840:2151678016,229376:2147487744,294912:4198400,360448:2151682112,425984:0,491520:2151677952,557056:4096,622592:2151682048,688128:4194304,753664:4160,819200:2147483648,884736:4194368,950272:4198464,1015808:2147483712,1048576:4194368,1114112:4198400,1179648:2147483712,1245184:0,1310720:4160,1376256:2151678016,1441792:2151682048,1507328:2147487808,1572864:2151682112,1638400:2147483648,1703936:2151677952,1769472:4198464,1835008:2147487744,1900544:4194304,1966080:64,2031616:4096,1081344:2151677952,1146880:2151682112,1212416:0,1277952:4198400,1343488:4194368,1409024:2147483648,1474560:2147487808,1540096:64,1605632:2147483712,1671168:4096,1736704:2147487744,1802240:2151678016,1867776:4160,1933312:2151682048,1998848:4194304,2064384:4198464},{0:128,4096:17039360,8192:262144,12288:536870912,16384:537133184,20480:16777344,24576:553648256,28672:262272,32768:16777216,36864:537133056,40960:536871040,45056:553910400,49152:553910272,53248:0,57344:17039488,61440:553648128,2048:17039488,6144:553648256,10240:128,14336:17039360,18432:262144,22528:537133184,26624:553910272,30720:536870912,34816:537133056,38912:0,43008:553910400,47104:16777344,51200:536871040,55296:553648128,59392:16777216,63488:262272,65536:262144,69632:128,73728:536870912,77824:553648256,81920:16777344,86016:553910272,90112:537133184,94208:16777216,98304:553910400,102400:553648128,106496:17039360,110592:537133056,114688:262272,118784:536871040,122880:0,126976:17039488,67584:553648256,71680:16777216,75776:17039360,79872:537133184,83968:536870912,88064:17039488,92160:128,96256:553910272,100352:262272,104448:553910400,108544:0,112640:553648128,116736:16777344,120832:262144,124928:537133056,129024:536871040},{0:268435464,256:8192,512:270532608,768:270540808,1024:268443648,1280:2097152,1536:2097160,1792:268435456,2048:0,2304:268443656,2560:2105344,2816:8,3072:270532616,3328:2105352,3584:8200,3840:270540800,128:270532608,384:270540808,640:8,896:2097152,1152:2105352,1408:268435464,1664:268443648,1920:8200,2176:2097160,2432:8192,2688:268443656,2944:270532616,3200:0,3456:270540800,3712:2105344,3968:268435456,4096:268443648,4352:270532616,4608:270540808,4864:8200,5120:2097152,5376:268435456,5632:268435464,5888:2105344,6144:2105352,6400:0,6656:8,6912:270532608,7168:8192,7424:268443656,7680:270540800,7936:2097160,4224:8,4480:2105344,4736:2097152,4992:268435464,5248:268443648,5504:8200,5760:270540808,6016:270532608,6272:270540800,6528:270532616,6784:8192,7040:2105352,7296:2097160,7552:0,7808:268435456,8064:268443656},{0:1048576,16:33555457,32:1024,48:1049601,64:34604033,80:0,96:1,112:34603009,128:33555456,144:1048577,160:33554433,176:34604032,192:34603008,208:1025,224:1049600,240:33554432,8:34603009,24:0,40:33555457,56:34604032,72:1048576,88:33554433,104:33554432,120:1025,136:1049601,152:33555456,168:34603008,184:1048577,200:1024,216:34604033,232:1,248:1049600,256:33554432,272:1048576,288:33555457,304:34603009,320:1048577,336:33555456,352:34604032,368:1049601,384:1025,400:34604033,416:1049600,432:1,448:0,464:34603008,480:33554433,496:1024,264:1049600,280:33555457,296:34603009,312:1,328:33554432,344:1048576,360:1025,376:34604032,392:33554433,408:34603008,424:0,440:34604033,456:1049601,472:1024,488:33555456,504:1048577},{0:134219808,1:131072,2:134217728,3:32,4:131104,5:134350880,6:134350848,7:2048,8:134348800,9:134219776,10:133120,11:134348832,12:2080,13:0,14:134217760,15:133152,2147483648:2048,2147483649:134350880,2147483650:134219808,2147483651:134217728,2147483652:134348800,2147483653:133120,2147483654:133152,2147483655:32,2147483656:134217760,2147483657:2080,2147483658:131104,2147483659:134350848,2147483660:0,2147483661:134348832,2147483662:134219776,2147483663:131072,16:133152,17:134350848,18:32,19:2048,20:134219776,21:134217760,22:134348832,23:131072,24:0,25:131104,26:134348800,27:134219808,28:134350880,29:133120,30:2080,31:134217728,2147483664:131072,2147483665:2048,2147483666:134348832,2147483667:133152,2147483668:32,2147483669:134348800,2147483670:134217728,2147483671:134219808,2147483672:134350880,2147483673:134217760,2147483674:134219776,2147483675:0,2147483676:133120,2147483677:2080,2147483678:131104,2147483679:134350848}],f=[4160749569,528482304,33030144,2064384,129024,8064,504,2147483679],c=o.DES=i.extend({_doReset:function(){for(var e=this._key.words,t=[],r=0;r<56;r++){var n=a[r]-1;t[r]=e[n>>>5]>>>31-n%32&1}for(var i=this._subKeys=[],o=0;o<16;o++){var l=i[o]=[],f=h[o];for(r=0;r<24;r++)l[r/6|0]|=t[(s[r]-1+f)%28]<<31-r%6,l[4+(r/6|0)]|=t[28+(s[r+24]-1+f)%28]<<31-r%6;for(l[0]=l[0]<<1|l[0]>>>31,r=1;r<7;r++)l[r]=l[r]>>>4*(r-1)+3;l[7]=l[7]<<5|l[7]>>>27}var c=this._invSubKeys=[];for(r=0;r<16;r++)c[r]=i[15-r]},encryptBlock:function(e,t){this._doCryptBlock(e,t,this._subKeys)},decryptBlock:function(e,t){this._doCryptBlock(e,t,this._invSubKeys)},_doCryptBlock:function(e,t,r){this._lBlock=e[t],this._rBlock=e[t+1],u.call(this,4,252645135),u.call(this,16,65535),d.call(this,2,858993459),d.call(this,8,16711935),u.call(this,1,1431655765);for(var n=0;n<16;n++){for(var i=r[n],o=this._lBlock,a=this._rBlock,s=0,h=0;h<8;h++)s|=l[h][((a^i[h])&f[h])>>>0];this._lBlock=a,this._rBlock=o^s}var c=this._lBlock;this._lBlock=this._rBlock,this._rBlock=c,u.call(this,1,1431655765),d.call(this,8,16711935),d.call(this,2,858993459),u.call(this,16,65535),u.call(this,4,252645135),e[t]=this._lBlock,e[t+1]=this._rBlock},keySize:2,ivSize:2,blockSize:2});function u(e,t){var r=(this._lBlock>>>e^this._rBlock)&t;this._rBlock^=r,this._lBlock^=r<<e}function d(e,t){var r=(this._rBlock>>>e^this._lBlock)&t;this._lBlock^=r,this._rBlock^=r<<e}e.DES=i._createHelper(c);var p=o.TripleDES=i.extend({_doReset:function(){var e=this._key.words;this._des1=c.createEncryptor(n.create(e.slice(0,2))),this._des2=c.createEncryptor(n.create(e.slice(2,4))),this._des3=c.createEncryptor(n.create(e.slice(4,6)))},encryptBlock:function(e,t){this._des1.encryptBlock(e,t),this._des2.decryptBlock(e,t),this._des3.encryptBlock(e,t)},decryptBlock:function(e,t){this._des3.decryptBlock(e,t),this._des2.encryptBlock(e,t),this._des1.decryptBlock(e,t)},keySize:6,ivSize:2,blockSize:2});e.TripleDES=i._createHelper(p)}(),r.TripleDES)}),Q(function(e,t){var r;e.exports=(r=ee,function(){var e=r,t=e.lib.StreamCipher,n=e.algo,i=n.RC4=t.extend({_doReset:function(){for(var e=this._key,t=e.words,r=e.sigBytes,n=this._S=[],i=0;i<256;i++)n[i]=i;i=0;for(var o=0;i<256;i++){var a=i%r,s=t[a>>>2]>>>24-a%4*8&255;o=(o+n[i]+s)%256;var h=n[i];n[i]=n[o],n[o]=h}this._i=this._j=0},_doProcessBlock:function(e,t){e[t]^=o.call(this)},keySize:8,ivSize:0});function o(){for(var e=this._S,t=this._i,r=this._j,n=0,i=0;i<4;i++){r=(r+e[t=(t+1)%256])%256;var o=e[t];e[t]=e[r],e[r]=o,n|=e[(e[t]+e[r])%256]<<24-8*i}return this._i=t,this._j=r,n}e.RC4=t._createHelper(i);var a=n.RC4Drop=i.extend({cfg:i.cfg.extend({drop:192}),_doReset:function(){i._doReset.call(this);for(var e=this.cfg.drop;e>0;e--)o.call(this)}});e.RC4Drop=t._createHelper(a)}(),r.RC4)}),Q(function(e,t){var r;e.exports=(r=ee,function(){var e=r,t=e.lib.StreamCipher,n=e.algo,i=[],o=[],a=[],s=n.Rabbit=t.extend({_doReset:function(){for(var e=this._key.words,t=this.cfg.iv,r=0;r<4;r++)e[r]=16711935&(e[r]<<8|e[r]>>>24)|4278255360&(e[r]<<24|e[r]>>>8);var n=this._X=[e[0],e[3]<<16|e[2]>>>16,e[1],e[0]<<16|e[3]>>>16,e[2],e[1]<<16|e[0]>>>16,e[3],e[2]<<16|e[1]>>>16],i=this._C=[e[2]<<16|e[2]>>>16,4294901760&e[0]|65535&e[1],e[3]<<16|e[3]>>>16,4294901760&e[1]|65535&e[2],e[0]<<16|e[0]>>>16,4294901760&e[2]|65535&e[3],e[1]<<16|e[1]>>>16,4294901760&e[3]|65535&e[0]];for(this._b=0,r=0;r<4;r++)h.call(this);for(r=0;r<8;r++)i[r]^=n[r+4&7];if(t){var o=t.words,a=o[0],s=o[1],l=16711935&(a<<8|a>>>24)|4278255360&(a<<24|a>>>8),f=16711935&(s<<8|s>>>24)|4278255360&(s<<24|s>>>8),c=l>>>16|4294901760&f,u=f<<16|65535&l;for(i[0]^=l,i[1]^=c,i[2]^=f,i[3]^=u,i[4]^=l,i[5]^=c,i[6]^=f,i[7]^=u,r=0;r<4;r++)h.call(this)}},_doProcessBlock:function(e,t){var r=this._X;h.call(this),i[0]=r[0]^r[5]>>>16^r[3]<<16,i[1]=r[2]^r[7]>>>16^r[5]<<16,i[2]=r[4]^r[1]>>>16^r[7]<<16,i[3]=r[6]^r[3]>>>16^r[1]<<16;for(var n=0;n<4;n++)i[n]=16711935&(i[n]<<8|i[n]>>>24)|4278255360&(i[n]<<24|i[n]>>>8),e[t+n]^=i[n]},blockSize:4,ivSize:2});function h(){for(var e=this._X,t=this._C,r=0;r<8;r++)o[r]=t[r];for(t[0]=t[0]+1295307597+this._b|0,t[1]=t[1]+3545052371+(t[0]>>>0<o[0]>>>0?1:0)|0,t[2]=t[2]+886263092+(t[1]>>>0<o[1]>>>0?1:0)|0,t[3]=t[3]+1295307597+(t[2]>>>0<o[2]>>>0?1:0)|0,t[4]=t[4]+3545052371+(t[3]>>>0<o[3]>>>0?1:0)|0,t[5]=t[5]+886263092+(t[4]>>>0<o[4]>>>0?1:0)|0,t[6]=t[6]+1295307597+(t[5]>>>0<o[5]>>>0?1:0)|0,t[7]=t[7]+3545052371+(t[6]>>>0<o[6]>>>0?1:0)|0,this._b=t[7]>>>0<o[7]>>>0?1:0,r=0;r<8;r++){var n=e[r]+t[r],i=65535&n,s=n>>>16,h=((i*i>>>17)+i*s>>>15)+s*s,l=((4294901760&n)*n|0)+((65535&n)*n|0);a[r]=h^l}e[0]=a[0]+(a[7]<<16|a[7]>>>16)+(a[6]<<16|a[6]>>>16)|0,e[1]=a[1]+(a[0]<<8|a[0]>>>24)+a[7]|0,e[2]=a[2]+(a[1]<<16|a[1]>>>16)+(a[0]<<16|a[0]>>>16)|0,e[3]=a[3]+(a[2]<<8|a[2]>>>24)+a[1]|0,e[4]=a[4]+(a[3]<<16|a[3]>>>16)+(a[2]<<16|a[2]>>>16)|0,e[5]=a[5]+(a[4]<<8|a[4]>>>24)+a[3]|0,e[6]=a[6]+(a[5]<<16|a[5]>>>16)+(a[4]<<16|a[4]>>>16)|0,e[7]=a[7]+(a[6]<<8|a[6]>>>24)+a[5]|0}e.Rabbit=t._createHelper(s)}(),r.Rabbit)}),Q(function(e,t){var r;e.exports=(r=ee,function(){var e=r,t=e.lib.StreamCipher,n=e.algo,i=[],o=[],a=[],s=n.RabbitLegacy=t.extend({_doReset:function(){var e=this._key.words,t=this.cfg.iv,r=this._X=[e[0],e[3]<<16|e[2]>>>16,e[1],e[0]<<16|e[3]>>>16,e[2],e[1]<<16|e[0]>>>16,e[3],e[2]<<16|e[1]>>>16],n=this._C=[e[2]<<16|e[2]>>>16,4294901760&e[0]|65535&e[1],e[3]<<16|e[3]>>>16,4294901760&e[1]|65535&e[2],e[0]<<16|e[0]>>>16,4294901760&e[2]|65535&e[3],e[1]<<16|e[1]>>>16,4294901760&e[3]|65535&e[0]];this._b=0;for(var i=0;i<4;i++)h.call(this);for(i=0;i<8;i++)n[i]^=r[i+4&7];if(t){var o=t.words,a=o[0],s=o[1],l=16711935&(a<<8|a>>>24)|4278255360&(a<<24|a>>>8),f=16711935&(s<<8|s>>>24)|4278255360&(s<<24|s>>>8),c=l>>>16|4294901760&f,u=f<<16|65535&l;for(n[0]^=l,n[1]^=c,n[2]^=f,n[3]^=u,n[4]^=l,n[5]^=c,n[6]^=f,n[7]^=u,i=0;i<4;i++)h.call(this)}},_doProcessBlock:function(e,t){var r=this._X;h.call(this),i[0]=r[0]^r[5]>>>16^r[3]<<16,i[1]=r[2]^r[7]>>>16^r[5]<<16,i[2]=r[4]^r[1]>>>16^r[7]<<16,i[3]=r[6]^r[3]>>>16^r[1]<<16;for(var n=0;n<4;n++)i[n]=16711935&(i[n]<<8|i[n]>>>24)|4278255360&(i[n]<<24|i[n]>>>8),e[t+n]^=i[n]},blockSize:4,ivSize:2});function h(){for(var e=this._X,t=this._C,r=0;r<8;r++)o[r]=t[r];for(t[0]=t[0]+1295307597+this._b|0,t[1]=t[1]+3545052371+(t[0]>>>0<o[0]>>>0?1:0)|0,t[2]=t[2]+886263092+(t[1]>>>0<o[1]>>>0?1:0)|0,t[3]=t[3]+1295307597+(t[2]>>>0<o[2]>>>0?1:0)|0,t[4]=t[4]+3545052371+(t[3]>>>0<o[3]>>>0?1:0)|0,t[5]=t[5]+886263092+(t[4]>>>0<o[4]>>>0?1:0)|0,t[6]=t[6]+1295307597+(t[5]>>>0<o[5]>>>0?1:0)|0,t[7]=t[7]+3545052371+(t[6]>>>0<o[6]>>>0?1:0)|0,this._b=t[7]>>>0<o[7]>>>0?1:0,r=0;r<8;r++){var n=e[r]+t[r],i=65535&n,s=n>>>16,h=((i*i>>>17)+i*s>>>15)+s*s,l=((4294901760&n)*n|0)+((65535&n)*n|0);a[r]=h^l}e[0]=a[0]+(a[7]<<16|a[7]>>>16)+(a[6]<<16|a[6]>>>16)|0,e[1]=a[1]+(a[0]<<8|a[0]>>>24)+a[7]|0,e[2]=a[2]+(a[1]<<16|a[1]>>>16)+(a[0]<<16|a[0]>>>16)|0,e[3]=a[3]+(a[2]<<8|a[2]>>>24)+a[1]|0,e[4]=a[4]+(a[3]<<16|a[3]>>>16)+(a[2]<<16|a[2]>>>16)|0,e[5]=a[5]+(a[4]<<8|a[4]>>>24)+a[3]|0,e[6]=a[6]+(a[5]<<16|a[5]>>>16)+(a[4]<<16|a[4]>>>16)|0,e[7]=a[7]+(a[6]<<8|a[6]>>>24)+a[5]|0}e.RabbitLegacy=t._createHelper(s)}(),r.RabbitLegacy)}),Q(function(e,t){e.exports=ee}));function re(){throw new Error("setTimeout has not been defined")}function ne(){throw new Error("clearTimeout has not been defined")}var ie=re,oe=ne;function ae(e){if(ie===setTimeout)return setTimeout(e,0);if((ie===re||!ie)&&setTimeout)return ie=setTimeout,setTimeout(e,0);try{return ie(e,0)}catch(t){try{return ie.call(null,e,0)}catch(t){return ie.call(this,e,0)}}}"function"==typeof e.setTimeout&&(ie=setTimeout),"function"==typeof e.clearTimeout&&(oe=clearTimeout);var se,he=[],le=!1,fe=-1;function ce(){le&&se&&(le=!1,se.length?he=se.concat(he):fe=-1,he.length&&ue())}function ue(){if(!le){var e=ae(ce);le=!0;for(var t=he.length;t;){for(se=he,he=[];++fe<t;)se&&se[fe].run();fe=-1,t=he.length}se=null,le=!1,function(e){if(oe===clearTimeout)return clearTimeout(e);if((oe===ne||!oe)&&clearTimeout)return oe=clearTimeout,clearTimeout(e);try{oe(e)}catch(t){try{return oe.call(null,e)}catch(t){return oe.call(this,e)}}}(e)}}function de(e){var t=new Array(arguments.length-1);if(arguments.length>1)for(var r=1;r<arguments.length;r++)t[r-1]=arguments[r];he.push(new pe(e,t)),1!==he.length||le||ae(ue)}function pe(e,t){this.fun=e,this.array=t}pe.prototype.run=function(){this.fun.apply(null,this.array)};var _e=e.performance||{};_e.now||_e.mozNow||_e.msNow||_e.oNow||_e.webkitNow;function ge(){}function ve(){ve.init.call(this)}function we(e){return void 0===e._maxListeners?ve.defaultMaxListeners:e._maxListeners}function be(e,t,r){if(t)e.call(r);else for(var n=e.length,i=Ae(e,n),o=0;o<n;++o)i[o].call(r)}function ye(e,t,r,n){if(t)e.call(r,n);else for(var i=e.length,o=Ae(e,i),a=0;a<i;++a)o[a].call(r,n)}function me(e,t,r,n,i){if(t)e.call(r,n,i);else for(var o=e.length,a=Ae(e,o),s=0;s<o;++s)a[s].call(r,n,i)}function ke(e,t,r,n,i,o){if(t)e.call(r,n,i,o);else for(var a=e.length,s=Ae(e,a),h=0;h<a;++h)s[h].call(r,n,i,o)}function Ee(e,t,r,n){if(t)e.apply(r,n);else for(var i=e.length,o=Ae(e,i),a=0;a<i;++a)o[a].apply(r,n)}function Se(e,t,r,n){var i,o,a,s;if("function"!=typeof r)throw new TypeError('"listener" argument must be a function');if((o=e._events)?(o.newListener&&(e.emit("newListener",t,r.listener?r.listener:r),o=e._events),a=o[t]):(o=e._events=new ge,e._eventsCount=0),a){if("function"==typeof a?a=o[t]=n?[r,a]:[a,r]:n?a.unshift(r):a.push(r),!a.warned&&(i=we(e))&&i>0&&a.length>i){a.warned=!0;var h=new Error("Possible EventEmitter memory leak detected. "+a.length+" "+t+" listeners added. Use emitter.setMaxListeners() to increase limit");h.name="MaxListenersExceededWarning",h.emitter=e,h.type=t,h.count=a.length,s=h,"function"==typeof console.warn?console.warn(s):console.log(s)}}else a=o[t]=r,++e._eventsCount;return e}function xe(e,t,r){var n=!1;function i(){e.removeListener(t,i),n||(n=!0,r.apply(e,arguments))}return i.listener=r,i}function Re(e){var t=this._events;if(t){var r=t[e];if("function"==typeof r)return 1;if(r)return r.length}return 0}function Ae(e,t){for(var r=new Array(t);t--;)r[t]=e[t];return r}ge.prototype=Object.create(null),ve.EventEmitter=ve,ve.usingDomains=!1,ve.prototype.domain=void 0,ve.prototype._events=void 0,ve.prototype._maxListeners=void 0,ve.defaultMaxListeners=10,ve.init=function(){this.domain=null,ve.usingDomains&&(void 0).active&&(void 0).Domain,this._events&&this._events!==Object.getPrototypeOf(this)._events||(this._events=new ge,this._eventsCount=0),this._maxListeners=this._maxListeners||void 0},ve.prototype.setMaxListeners=function(e){if("number"!=typeof e||e<0||isNaN(e))throw new TypeError('"n" argument must be a positive number');return this._maxListeners=e,this},ve.prototype.getMaxListeners=function(){return we(this)},ve.prototype.emit=function(e){var t,r,n,i,o,a,s,h="error"===e;if(a=this._events)h=h&&null==a.error;else if(!h)return!1;if(s=this.domain,h){if(t=arguments[1],!s){if(t instanceof Error)throw t;var l=new Error('Uncaught, unspecified "error" event. ('+t+")");throw l.context=t,l}return t||(t=new Error('Uncaught, unspecified "error" event')),t.domainEmitter=this,t.domain=s,t.domainThrown=!1,s.emit("error",t),!1}if(!(r=a[e]))return!1;var f="function"==typeof r;switch(n=arguments.length){case 1:be(r,f,this);break;case 2:ye(r,f,this,arguments[1]);break;case 3:me(r,f,this,arguments[1],arguments[2]);break;case 4:ke(r,f,this,arguments[1],arguments[2],arguments[3]);break;default:for(i=new Array(n-1),o=1;o<n;o++)i[o-1]=arguments[o];Ee(r,f,this,i)}return!0},ve.prototype.addListener=function(e,t){return Se(this,e,t,!1)},ve.prototype.on=ve.prototype.addListener,ve.prototype.prependListener=function(e,t){return Se(this,e,t,!0)},ve.prototype.once=function(e,t){if("function"!=typeof t)throw new TypeError('"listener" argument must be a function');return this.on(e,xe(this,e,t)),this},ve.prototype.prependOnceListener=function(e,t){if("function"!=typeof t)throw new TypeError('"listener" argument must be a function');return this.prependListener(e,xe(this,e,t)),this},ve.prototype.removeListener=function(e,t){var r,n,i,o,a;if("function"!=typeof t)throw new TypeError('"listener" argument must be a function');if(!(n=this._events))return this;if(!(r=n[e]))return this;if(r===t||r.listener&&r.listener===t)0==--this._eventsCount?this._events=new ge:(delete n[e],n.removeListener&&this.emit("removeListener",e,r.listener||t));else if("function"!=typeof r){for(i=-1,o=r.length;o-- >0;)if(r[o]===t||r[o].listener&&r[o].listener===t){a=r[o].listener,i=o;break}if(i<0)return this;if(1===r.length){if(r[0]=void 0,0==--this._eventsCount)return this._events=new ge,this;delete n[e]}else!function(e,t){for(var r=t,n=r+1,i=e.length;n<i;r+=1,n+=1)e[r]=e[n];e.pop()}(r,i);n.removeListener&&this.emit("removeListener",e,a||t)}return this},ve.prototype.removeAllListeners=function(e){var t,r;if(!(r=this._events))return this;if(!r.removeListener)return 0===arguments.length?(this._events=new ge,this._eventsCount=0):r[e]&&(0==--this._eventsCount?this._events=new ge:delete r[e]),this;if(0===arguments.length){for(var n,i=Object.keys(r),o=0;o<i.length;++o)"removeListener"!==(n=i[o])&&this.removeAllListeners(n);return this.removeAllListeners("removeListener"),this._events=new ge,this._eventsCount=0,this}if("function"==typeof(t=r[e]))this.removeListener(e,t);else if(t)do{this.removeListener(e,t[t.length-1])}while(t[0]);return this},ve.prototype.listeners=function(e){var t,r=this._events;return r&&(t=r[e])?"function"==typeof t?[t.listener||t]:function(e){for(var t=new Array(e.length),r=0;r<t.length;++r)t[r]=e[r].listener||e[r];return t}(t):[]},ve.listenerCount=function(e,t){return"function"==typeof e.listenerCount?e.listenerCount(t):Re.call(e,t)},ve.prototype.listenerCount=Re,ve.prototype.eventNames=function(){return this._eventsCount>0?Reflect.ownKeys(this._events):[]};var Be="function"==typeof Object.create?function(e,t){e.super_=t,e.prototype=Object.create(t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}})}:function(e,t){e.super_=t;var r=function(){};r.prototype=t.prototype,e.prototype=new r,e.prototype.constructor=e},ze=/%[sdj%]/g;function Le(e){if(!Ze(e)){for(var t=[],r=0;r<arguments.length;r++)t.push(De(arguments[r]));return t.join(" ")}r=1;for(var n=arguments,i=n.length,o=String(e).replace(ze,function(e){if("%%"===e)return"%";if(r>=i)return e;switch(e){case"%s":return String(n[r++]);case"%d":return Number(n[r++]);case"%j":try{return JSON.stringify(n[r++])}catch(e){return"[Circular]"}default:return e}}),a=n[r];r<i;a=n[++r])Ne(a)||!Ye(a)?o+=" "+a:o+=" "+De(a);return o}function Te(t,r){if(je(e.process))return function(){return Te(t,r).apply(this,arguments)};var n=!1;return function(){return n||(console.error(r),n=!0),t.apply(this,arguments)}}var Me,Ce={};function De(e,t){var r={seen:[],stylize:Pe};return arguments.length>=3&&(r.depth=arguments[2]),arguments.length>=4&&(r.colors=arguments[3]),Fe(t)?r.showHidden=t:t&&function(e,t){if(!t||!Ye(t))return e;var r=Object.keys(t),n=r.length;for(;n--;)e[r[n]]=t[r[n]]}(r,t),je(r.showHidden)&&(r.showHidden=!1),je(r.depth)&&(r.depth=2),je(r.colors)&&(r.colors=!1),je(r.customInspect)&&(r.customInspect=!0),r.colors&&(r.stylize=Ie),Oe(r,e,r.depth)}function Ie(e,t){var r=De.styles[t];return r?"["+De.colors[r][0]+"m"+e+"["+De.colors[r][1]+"m":e}function Pe(e,t){return e}function Oe(e,t,r){if(e.customInspect&&t&&qe(t.inspect)&&t.inspect!==De&&(!t.constructor||t.constructor.prototype!==t)){var n=t.inspect(r,e);return Ze(n)||(n=Oe(e,n,r)),n}var i=function(e,t){if(je(t))return e.stylize("undefined","undefined");if(Ze(t)){var r="'"+JSON.stringify(t).replace(/^"|"$/g,"").replace(/'/g,"\\'").replace(/\\"/g,'"')+"'";return e.stylize(r,"string")}if(n=t,"number"==typeof n)return e.stylize(""+t,"number");var n;if(Fe(t))return e.stylize(""+t,"boolean");if(Ne(t))return e.stylize("null","null")}(e,t);if(i)return i;var o=Object.keys(t),a=function(e){var t={};return e.forEach(function(e,r){t[e]=!0}),t}(o);if(e.showHidden&&(o=Object.getOwnPropertyNames(t)),Xe(t)&&(o.indexOf("message")>=0||o.indexOf("description")>=0))return Ue(t);if(0===o.length){if(qe(t)){var s=t.name?": "+t.name:"";return e.stylize("[Function"+s+"]","special")}if(We(t))return e.stylize(RegExp.prototype.toString.call(t),"regexp");if(Ke(t))return e.stylize(Date.prototype.toString.call(t),"date");if(Xe(t))return Ue(t)}var h,l,f="",c=!1,u=["{","}"];(h=t,Array.isArray(h)&&(c=!0,u=["[","]"]),qe(t))&&(f=" [Function"+(t.name?": "+t.name:"")+"]");return We(t)&&(f=" "+RegExp.prototype.toString.call(t)),Ke(t)&&(f=" "+Date.prototype.toUTCString.call(t)),Xe(t)&&(f=" "+Ue(t)),0!==o.length||c&&0!=t.length?r<0?We(t)?e.stylize(RegExp.prototype.toString.call(t),"regexp"):e.stylize("[Object]","special"):(e.seen.push(t),l=c?function(e,t,r,n,i){for(var o=[],a=0,s=t.length;a<s;++a)Ge(t,String(a))?o.push(He(e,t,r,n,String(a),!0)):o.push("");return i.forEach(function(i){i.match(/^\d+$/)||o.push(He(e,t,r,n,i,!0))}),o}(e,t,r,a,o):o.map(function(n){return He(e,t,r,a,n,c)}),e.seen.pop(),function(e,t,r){if(e.reduce(function(e,t){return t.indexOf("\n"),e+t.replace(/\u001b\[\d\d?m/g,"").length+1},0)>60)return r[0]+(""===t?"":t+"\n ")+" "+e.join(",\n  ")+" "+r[1];return r[0]+t+" "+e.join(", ")+" "+r[1]}(l,f,u)):u[0]+f+u[1]}function Ue(e){return"["+Error.prototype.toString.call(e)+"]"}function He(e,t,r,n,i,o){var a,s,h;if((h=Object.getOwnPropertyDescriptor(t,i)||{value:t[i]}).get?s=h.set?e.stylize("[Getter/Setter]","special"):e.stylize("[Getter]","special"):h.set&&(s=e.stylize("[Setter]","special")),Ge(n,i)||(a="["+i+"]"),s||(e.seen.indexOf(h.value)<0?(s=Ne(r)?Oe(e,h.value,null):Oe(e,h.value,r-1)).indexOf("\n")>-1&&(s=o?s.split("\n").map(function(e){return"  "+e}).join("\n").substr(2):"\n"+s.split("\n").map(function(e){return"   "+e}).join("\n")):s=e.stylize("[Circular]","special")),je(a)){if(o&&i.match(/^\d+$/))return s;(a=JSON.stringify(""+i)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)?(a=a.substr(1,a.length-2),a=e.stylize(a,"name")):(a=a.replace(/'/g,"\\'").replace(/\\"/g,'"').replace(/(^"|"$)/g,"'"),a=e.stylize(a,"string"))}return a+": "+s}function Fe(e){return"boolean"==typeof e}function Ne(e){return null===e}function Ze(e){return"string"==typeof e}function je(e){return void 0===e}function We(e){return Ye(e)&&"[object RegExp]"===Ve(e)}function Ye(e){return"object"==typeof e&&null!==e}function Ke(e){return Ye(e)&&"[object Date]"===Ve(e)}function Xe(e){return Ye(e)&&("[object Error]"===Ve(e)||e instanceof Error)}function qe(e){return"function"==typeof e}function Ve(e){return Object.prototype.toString.call(e)}function Ge(e,t){return Object.prototype.hasOwnProperty.call(e,t)}function $e(){this.head=null,this.tail=null,this.length=0}De.colors={bold:[1,22],italic:[3,23],underline:[4,24],inverse:[7,27],white:[37,39],grey:[90,39],black:[30,39],blue:[34,39],cyan:[36,39],green:[32,39],magenta:[35,39],red:[31,39],yellow:[33,39]},De.styles={special:"cyan",number:"yellow",boolean:"yellow",undefined:"grey",null:"bold",string:"green",date:"magenta",regexp:"red"},$e.prototype.push=function(e){var t={data:e,next:null};this.length>0?this.tail.next=t:this.head=t,this.tail=t,++this.length},$e.prototype.unshift=function(e){var t={data:e,next:this.head};0===this.length&&(this.tail=t),this.head=t,++this.length},$e.prototype.shift=function(){if(0!==this.length){var e=this.head.data;return 1===this.length?this.head=this.tail=null:this.head=this.head.next,--this.length,e}},$e.prototype.clear=function(){this.head=this.tail=null,this.length=0},$e.prototype.join=function(e){if(0===this.length)return"";for(var t=this.head,r=""+t.data;t=t.next;)r+=e+t.data;return r},$e.prototype.concat=function(e){if(0===this.length)return p.alloc(0);if(1===this.length)return this.head.data;for(var t=p.allocUnsafe(e>>>0),r=this.head,n=0;r;)r.data.copy(t,n),n+=r.data.length,r=r.next;return t};var Je=p.isEncoding||function(e){switch(e&&e.toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":case"raw":return!0;default:return!1}};function Qe(e){switch(this.encoding=(e||"utf8").toLowerCase().replace(/[-_]/,""),function(e){if(e&&!Je(e))throw new Error("Unknown encoding: "+e)}(e),this.encoding){case"utf8":this.surrogateSize=3;break;case"ucs2":case"utf16le":this.surrogateSize=2,this.detectIncompleteChar=tt;break;case"base64":this.surrogateSize=3,this.detectIncompleteChar=rt;break;default:return void(this.write=et)}this.charBuffer=new p(6),this.charReceived=0,this.charLength=0}function et(e){return e.toString(this.encoding)}function tt(e){this.charReceived=e.length%2,this.charLength=this.charReceived?2:0}function rt(e){this.charReceived=e.length%3,this.charLength=this.charReceived?3:0}Qe.prototype.write=function(e){for(var t="";this.charLength;){var r=e.length>=this.charLength-this.charReceived?this.charLength-this.charReceived:e.length;if(e.copy(this.charBuffer,this.charReceived,0,r),this.charReceived+=r,this.charReceived<this.charLength)return"";if(e=e.slice(r,e.length),!((i=(t=this.charBuffer.slice(0,this.charLength).toString(this.encoding)).charCodeAt(t.length-1))>=55296&&i<=56319)){if(this.charReceived=this.charLength=0,0===e.length)return t;break}this.charLength+=this.surrogateSize,t=""}this.detectIncompleteChar(e);var n=e.length;this.charLength&&(e.copy(this.charBuffer,0,e.length-this.charReceived,n),n-=this.charReceived);var i;n=(t+=e.toString(this.encoding,0,n)).length-1;if((i=t.charCodeAt(n))>=55296&&i<=56319){var o=this.surrogateSize;return this.charLength+=o,this.charReceived+=o,this.charBuffer.copy(this.charBuffer,o,0,o),e.copy(this.charBuffer,0,0,o),t.substring(0,n)}return t},Qe.prototype.detectIncompleteChar=function(e){for(var t=e.length>=3?3:e.length;t>0;t--){var r=e[e.length-t];if(1==t&&r>>5==6){this.charLength=2;break}if(t<=2&&r>>4==14){this.charLength=3;break}if(t<=3&&r>>3==30){this.charLength=4;break}}this.charReceived=t},Qe.prototype.end=function(e){var t="";if(e&&e.length&&(t=this.write(e)),this.charReceived){var r=this.charReceived,n=this.charBuffer,i=this.encoding;t+=n.slice(0,r).toString(i)}return t},ot.ReadableState=it;var nt=function(e){je(Me)&&(Me=""),e=e.toUpperCase(),Ce[e]||(new RegExp("\\b"+e+"\\b","i").test(Me)?Ce[e]=function(){var t=Le.apply(null,arguments);console.error("%s %d: %s",e,0,t)}:Ce[e]=function(){});return Ce[e]}("stream");function it(e,t){e=e||{},this.objectMode=!!e.objectMode,t instanceof Ct&&(this.objectMode=this.objectMode||!!e.readableObjectMode);var r=e.highWaterMark,n=this.objectMode?16:16384;this.highWaterMark=r||0===r?r:n,this.highWaterMark=~~this.highWaterMark,this.buffer=new $e,this.length=0,this.pipes=null,this.pipesCount=0,this.flowing=null,this.ended=!1,this.endEmitted=!1,this.reading=!1,this.sync=!0,this.needReadable=!1,this.emittedReadable=!1,this.readableListening=!1,this.resumeScheduled=!1,this.defaultEncoding=e.defaultEncoding||"utf8",this.ranOut=!1,this.awaitDrain=0,this.readingMore=!1,this.decoder=null,this.encoding=null,e.encoding&&(this.decoder=new Qe(e.encoding),this.encoding=e.encoding)}function ot(e){if(!(this instanceof ot))return new ot(e);this._readableState=new it(e,this),this.readable=!0,e&&"function"==typeof e.read&&(this._read=e.read),ve.call(this)}function at(e,t,r,n,i){var o=function(e,t){var r=null;$(t)||"string"==typeof t||null==t||e.objectMode||(r=new TypeError("Invalid non-string/buffer chunk"));return r}(t,r);if(o)e.emit("error",o);else if(null===r)t.reading=!1,function(e,t){if(t.ended)return;if(t.decoder){var r=t.decoder.end();r&&r.length&&(t.buffer.push(r),t.length+=t.objectMode?1:r.length)}t.ended=!0,lt(e)}(e,t);else if(t.objectMode||r&&r.length>0)if(t.ended&&!i){var a=new Error("stream.push() after EOF");e.emit("error",a)}else if(t.endEmitted&&i){var s=new Error("stream.unshift() after end event");e.emit("error",s)}else{var h;!t.decoder||i||n||(r=t.decoder.write(r),h=!t.objectMode&&0===r.length),i||(t.reading=!1),h||(t.flowing&&0===t.length&&!t.sync?(e.emit("data",r),e.read(0)):(t.length+=t.objectMode?1:r.length,i?t.buffer.unshift(r):t.buffer.push(r),t.needReadable&&lt(e))),function(e,t){t.readingMore||(t.readingMore=!0,de(ct,e,t))}(e,t)}else i||(t.reading=!1);return function(e){return!e.ended&&(e.needReadable||e.length<e.highWaterMark||0===e.length)}(t)}Be(ot,ve),ot.prototype.push=function(e,t){var r=this._readableState;return r.objectMode||"string"!=typeof e||(t=t||r.defaultEncoding)!==r.encoding&&(e=p.from(e,t),t=""),at(this,r,e,t,!1)},ot.prototype.unshift=function(e){return at(this,this._readableState,e,"",!0)},ot.prototype.isPaused=function(){return!1===this._readableState.flowing},ot.prototype.setEncoding=function(e){return this._readableState.decoder=new Qe(e),this._readableState.encoding=e,this};var st=8388608;function ht(e,t){return e<=0||0===t.length&&t.ended?0:t.objectMode?1:e!=e?t.flowing&&t.length?t.buffer.head.data.length:t.length:(e>t.highWaterMark&&(t.highWaterMark=function(e){return e>=st?e=st:(e--,e|=e>>>1,e|=e>>>2,e|=e>>>4,e|=e>>>8,e|=e>>>16,e++),e}(e)),e<=t.length?e:t.ended?t.length:(t.needReadable=!0,0))}function lt(e){var t=e._readableState;t.needReadable=!1,t.emittedReadable||(nt("emitReadable",t.flowing),t.emittedReadable=!0,t.sync?de(ft,e):ft(e))}function ft(e){nt("emit readable"),e.emit("readable"),pt(e)}function ct(e,t){for(var r=t.length;!t.reading&&!t.flowing&&!t.ended&&t.length<t.highWaterMark&&(nt("maybeReadMore read 0"),e.read(0),r!==t.length);)r=t.length;t.readingMore=!1}function ut(e){nt("readable nexttick read 0"),e.read(0)}function dt(e,t){t.reading||(nt("resume read 0"),e.read(0)),t.resumeScheduled=!1,t.awaitDrain=0,e.emit("resume"),pt(e),t.flowing&&!t.reading&&e.read(0)}function pt(e){var t=e._readableState;for(nt("flow",t.flowing);t.flowing&&null!==e.read(););}function _t(e,t){return 0===t.length?null:(t.objectMode?r=t.buffer.shift():!e||e>=t.length?(r=t.decoder?t.buffer.join(""):1===t.buffer.length?t.buffer.head.data:t.buffer.concat(t.length),t.buffer.clear()):r=function(e,t,r){var n;e<t.head.data.length?(n=t.head.data.slice(0,e),t.head.data=t.head.data.slice(e)):n=e===t.head.data.length?t.shift():r?function(e,t){var r=t.head,n=1,i=r.data;e-=i.length;for(;r=r.next;){var o=r.data,a=e>o.length?o.length:e;if(a===o.length?i+=o:i+=o.slice(0,e),0===(e-=a)){a===o.length?(++n,r.next?t.head=r.next:t.head=t.tail=null):(t.head=r,r.data=o.slice(a));break}++n}return t.length-=n,i}(e,t):function(e,t){var r=p.allocUnsafe(e),n=t.head,i=1;n.data.copy(r),e-=n.data.length;for(;n=n.next;){var o=n.data,a=e>o.length?o.length:e;if(o.copy(r,r.length-e,0,a),0===(e-=a)){a===o.length?(++i,n.next?t.head=n.next:t.head=t.tail=null):(t.head=n,n.data=o.slice(a));break}++i}return t.length-=i,r}(e,t);return n}(e,t.buffer,t.decoder),r);var r}function gt(e){var t=e._readableState;if(t.length>0)throw new Error('"endReadable()" called on non-empty stream');t.endEmitted||(t.ended=!0,de(vt,t,e))}function vt(e,t){e.endEmitted||0!==e.length||(e.endEmitted=!0,t.readable=!1,t.emit("end"))}function wt(e,t){for(var r=0,n=e.length;r<n;r++)if(e[r]===t)return r;return-1}function bt(){}function yt(e,t,r){this.chunk=e,this.encoding=t,this.callback=r,this.next=null}function mt(e,t){Object.defineProperty(this,"buffer",{get:Te(function(){return this.getBuffer()},"_writableState.buffer is deprecated. Use _writableState.getBuffer instead.")}),e=e||{},this.objectMode=!!e.objectMode,t instanceof Ct&&(this.objectMode=this.objectMode||!!e.writableObjectMode);var r=e.highWaterMark,n=this.objectMode?16:16384;this.highWaterMark=r||0===r?r:n,this.highWaterMark=~~this.highWaterMark,this.needDrain=!1,this.ending=!1,this.ended=!1,this.finished=!1;var i=!1===e.decodeStrings;this.decodeStrings=!i,this.defaultEncoding=e.defaultEncoding||"utf8",this.length=0,this.writing=!1,this.corked=0,this.sync=!0,this.bufferProcessing=!1,this.onwrite=function(e){!function(e,t){var r=e._writableState,n=r.sync,i=r.writecb;if(function(e){e.writing=!1,e.writecb=null,e.length-=e.writelen,e.writelen=0}(r),t)!function(e,t,r,n,i){--t.pendingcb,r?de(i,n):i(n);e._writableState.errorEmitted=!0,e.emit("error",n)}(e,r,n,t,i);else{var o=Rt(r);o||r.corked||r.bufferProcessing||!r.bufferedRequest||xt(e,r),n?de(St,e,r,o,i):St(e,r,o,i)}}(t,e)},this.writecb=null,this.writelen=0,this.bufferedRequest=null,this.lastBufferedRequest=null,this.pendingcb=0,this.prefinished=!1,this.errorEmitted=!1,this.bufferedRequestCount=0,this.corkedRequestsFree=new zt(this)}function kt(e){if(!(this instanceof kt||this instanceof Ct))return new kt(e);this._writableState=new mt(e,this),this.writable=!0,e&&("function"==typeof e.write&&(this._write=e.write),"function"==typeof e.writev&&(this._writev=e.writev)),ve.call(this)}function Et(e,t,r,n,i,o,a){t.writelen=n,t.writecb=a,t.writing=!0,t.sync=!0,r?e._writev(i,t.onwrite):e._write(i,o,t.onwrite),t.sync=!1}function St(e,t,r,n){r||function(e,t){0===t.length&&t.needDrain&&(t.needDrain=!1,e.emit("drain"))}(e,t),t.pendingcb--,n(),Bt(e,t)}function xt(e,t){t.bufferProcessing=!0;var r=t.bufferedRequest;if(e._writev&&r&&r.next){var n=t.bufferedRequestCount,i=new Array(n),o=t.corkedRequestsFree;o.entry=r;for(var a=0;r;)i[a]=r,r=r.next,a+=1;Et(e,t,!0,t.length,i,"",o.finish),t.pendingcb++,t.lastBufferedRequest=null,o.next?(t.corkedRequestsFree=o.next,o.next=null):t.corkedRequestsFree=new zt(t)}else{for(;r;){var s=r.chunk,h=r.encoding,l=r.callback;if(Et(e,t,!1,t.objectMode?1:s.length,s,h,l),r=r.next,t.writing)break}null===r&&(t.lastBufferedRequest=null)}t.bufferedRequestCount=0,t.bufferedRequest=r,t.bufferProcessing=!1}function Rt(e){return e.ending&&0===e.length&&null===e.bufferedRequest&&!e.finished&&!e.writing}function At(e,t){t.prefinished||(t.prefinished=!0,e.emit("prefinish"))}function Bt(e,t){var r=Rt(t);return r&&(0===t.pendingcb?(At(e,t),t.finished=!0,e.emit("finish")):At(e,t)),r}function zt(e){var t=this;this.next=null,this.entry=null,this.finish=function(r){var n=t.entry;for(t.entry=null;n;){var i=n.callback;e.pendingcb--,i(r),n=n.next}e.corkedRequestsFree?e.corkedRequestsFree.next=t:e.corkedRequestsFree=t}}ot.prototype.read=function(e){nt("read",e),e=parseInt(e,10);var t=this._readableState,r=e;if(0!==e&&(t.emittedReadable=!1),0===e&&t.needReadable&&(t.length>=t.highWaterMark||t.ended))return nt("read: emitReadable",t.length,t.ended),0===t.length&&t.ended?gt(this):lt(this),null;if(0===(e=ht(e,t))&&t.ended)return 0===t.length&&gt(this),null;var n,i=t.needReadable;return nt("need readable",i),(0===t.length||t.length-e<t.highWaterMark)&&nt("length less than watermark",i=!0),t.ended||t.reading?nt("reading or ended",i=!1):i&&(nt("do read"),t.reading=!0,t.sync=!0,0===t.length&&(t.needReadable=!0),this._read(t.highWaterMark),t.sync=!1,t.reading||(e=ht(r,t))),null===(n=e>0?_t(e,t):null)?(t.needReadable=!0,e=0):t.length-=e,0===t.length&&(t.ended||(t.needReadable=!0),r!==e&&t.ended&&gt(this)),null!==n&&this.emit("data",n),n},ot.prototype._read=function(e){this.emit("error",new Error("not implemented"))},ot.prototype.pipe=function(e,t){var r=this,n=this._readableState;switch(n.pipesCount){case 0:n.pipes=e;break;case 1:n.pipes=[n.pipes,e];break;default:n.pipes.push(e)}n.pipesCount+=1,nt("pipe count=%d opts=%j",n.pipesCount,t);var i=!t||!1!==t.end?a:l;function o(e){nt("onunpipe"),e===r&&l()}function a(){nt("onend"),e.end()}n.endEmitted?de(i):r.once("end",i),e.on("unpipe",o);var s=function(e){return function(){var t=e._readableState;nt("pipeOnDrain",t.awaitDrain),t.awaitDrain&&t.awaitDrain--,0===t.awaitDrain&&e.listeners("data").length&&(t.flowing=!0,pt(e))}}(r);e.on("drain",s);var h=!1;function l(){nt("cleanup"),e.removeListener("close",d),e.removeListener("finish",p),e.removeListener("drain",s),e.removeListener("error",u),e.removeListener("unpipe",o),r.removeListener("end",a),r.removeListener("end",l),r.removeListener("data",c),h=!0,!n.awaitDrain||e._writableState&&!e._writableState.needDrain||s()}var f=!1;function c(t){nt("ondata"),f=!1,!1!==e.write(t)||f||((1===n.pipesCount&&n.pipes===e||n.pipesCount>1&&-1!==wt(n.pipes,e))&&!h&&(nt("false write response, pause",r._readableState.awaitDrain),r._readableState.awaitDrain++,f=!0),r.pause())}function u(t){var r;nt("onerror",t),_(),e.removeListener("error",u),0===(r="error",e.listeners(r).length)&&e.emit("error",t)}function d(){e.removeListener("finish",p),_()}function p(){nt("onfinish"),e.removeListener("close",d),_()}function _(){nt("unpipe"),r.unpipe(e)}return r.on("data",c),function(e,t,r){if("function"==typeof e.prependListener)return e.prependListener(t,r);e._events&&e._events[t]?Array.isArray(e._events[t])?e._events[t].unshift(r):e._events[t]=[r,e._events[t]]:e.on(t,r)}(e,"error",u),e.once("close",d),e.once("finish",p),e.emit("pipe",r),n.flowing||(nt("pipe resume"),r.resume()),e},ot.prototype.unpipe=function(e){var t=this._readableState;if(0===t.pipesCount)return this;if(1===t.pipesCount)return e&&e!==t.pipes?this:(e||(e=t.pipes),t.pipes=null,t.pipesCount=0,t.flowing=!1,e&&e.emit("unpipe",this),this);if(!e){var r=t.pipes,n=t.pipesCount;t.pipes=null,t.pipesCount=0,t.flowing=!1;for(var i=0;i<n;i++)r[i].emit("unpipe",this);return this}var o=wt(t.pipes,e);return-1===o?this:(t.pipes.splice(o,1),t.pipesCount-=1,1===t.pipesCount&&(t.pipes=t.pipes[0]),e.emit("unpipe",this),this)},ot.prototype.on=function(e,t){var r=ve.prototype.on.call(this,e,t);if("data"===e)!1!==this._readableState.flowing&&this.resume();else if("readable"===e){var n=this._readableState;n.endEmitted||n.readableListening||(n.readableListening=n.needReadable=!0,n.emittedReadable=!1,n.reading?n.length&&lt(this):de(ut,this))}return r},ot.prototype.addListener=ot.prototype.on,ot.prototype.resume=function(){var e=this._readableState;return e.flowing||(nt("resume"),e.flowing=!0,function(e,t){t.resumeScheduled||(t.resumeScheduled=!0,de(dt,e,t))}(this,e)),this},ot.prototype.pause=function(){return nt("call pause flowing=%j",this._readableState.flowing),!1!==this._readableState.flowing&&(nt("pause"),this._readableState.flowing=!1,this.emit("pause")),this},ot.prototype.wrap=function(e){var t=this._readableState,r=!1,n=this;for(var i in e.on("end",function(){if(nt("wrapped end"),t.decoder&&!t.ended){var e=t.decoder.end();e&&e.length&&n.push(e)}n.push(null)}),e.on("data",function(i){(nt("wrapped data"),t.decoder&&(i=t.decoder.write(i)),t.objectMode&&null==i)||(t.objectMode||i&&i.length)&&(n.push(i)||(r=!0,e.pause()))}),e)void 0===this[i]&&"function"==typeof e[i]&&(this[i]=function(t){return function(){return e[t].apply(e,arguments)}}(i));return function(e,t){for(var r=0,n=e.length;r<n;r++)t(e[r],r)}(["error","close","destroy","pause","resume"],function(t){e.on(t,n.emit.bind(n,t))}),n._read=function(t){nt("wrapped _read",t),r&&(r=!1,e.resume())},n},ot._fromList=_t,kt.WritableState=mt,Be(kt,ve),mt.prototype.getBuffer=function(){for(var e=this.bufferedRequest,t=[];e;)t.push(e),e=e.next;return t},kt.prototype.pipe=function(){this.emit("error",new Error("Cannot pipe, not readable"))},kt.prototype.write=function(e,t,r){var n=this._writableState,i=!1;return"function"==typeof t&&(r=t,t=null),p.isBuffer(e)?t="buffer":t||(t=n.defaultEncoding),"function"!=typeof r&&(r=bt),n.ended?function(e,t){var r=new Error("write after end");e.emit("error",r),de(t,r)}(this,r):function(e,t,r,n){var i=!0,o=!1;return null===r?o=new TypeError("May not write null values to stream"):p.isBuffer(r)||"string"==typeof r||void 0===r||t.objectMode||(o=new TypeError("Invalid non-string/buffer chunk")),o&&(e.emit("error",o),de(n,o),i=!1),i}(this,n,e,r)&&(n.pendingcb++,i=function(e,t,r,n,i){r=function(e,t,r){return e.objectMode||!1===e.decodeStrings||"string"!=typeof t||(t=p.from(t,r)),t}(t,r,n),p.isBuffer(r)&&(n="buffer");var o=t.objectMode?1:r.length;t.length+=o;var a=t.length<t.highWaterMark;a||(t.needDrain=!0);if(t.writing||t.corked){var s=t.lastBufferedRequest;t.lastBufferedRequest=new yt(r,n,i),s?s.next=t.lastBufferedRequest:t.bufferedRequest=t.lastBufferedRequest,t.bufferedRequestCount+=1}else Et(e,t,!1,o,r,n,i);return a}(this,n,e,t,r)),i},kt.prototype.cork=function(){this._writableState.corked++},kt.prototype.uncork=function(){var e=this._writableState;e.corked&&(e.corked--,e.writing||e.corked||e.finished||e.bufferProcessing||!e.bufferedRequest||xt(this,e))},kt.prototype.setDefaultEncoding=function(e){if("string"==typeof e&&(e=e.toLowerCase()),!(["hex","utf8","utf-8","ascii","binary","base64","ucs2","ucs-2","utf16le","utf-16le","raw"].indexOf((e+"").toLowerCase())>-1))throw new TypeError("Unknown encoding: "+e);return this._writableState.defaultEncoding=e,this},kt.prototype._write=function(e,t,r){r(new Error("not implemented"))},kt.prototype._writev=null,kt.prototype.end=function(e,t,r){var n=this._writableState;"function"==typeof e?(r=e,e=null,t=null):"function"==typeof t&&(r=t,t=null),null!=e&&this.write(e,t),n.corked&&(n.corked=1,this.uncork()),n.ending||n.finished||function(e,t,r){t.ending=!0,Bt(e,t),r&&(t.finished?de(r):e.once("finish",r));t.ended=!0,e.writable=!1}(this,n,r)},Be(Ct,ot);for(var Lt=Object.keys(kt.prototype),Tt=0;Tt<Lt.length;Tt++){var Mt=Lt[Tt];Ct.prototype[Mt]||(Ct.prototype[Mt]=kt.prototype[Mt])}function Ct(e){if(!(this instanceof Ct))return new Ct(e);ot.call(this,e),kt.call(this,e),e&&!1===e.readable&&(this.readable=!1),e&&!1===e.writable&&(this.writable=!1),this.allowHalfOpen=!0,e&&!1===e.allowHalfOpen&&(this.allowHalfOpen=!1),this.once("end",Dt)}function Dt(){this.allowHalfOpen||this._writableState.ended||de(It,this)}function It(e){e.end()}function Pt(e){this.afterTransform=function(t,r){return function(e,t,r){var n=e._transformState;n.transforming=!1;var i=n.writecb;if(!i)return e.emit("error",new Error("no writecb in Transform class"));n.writechunk=null,n.writecb=null,null!=r&&e.push(r);i(t);var o=e._readableState;o.reading=!1,(o.needReadable||o.length<o.highWaterMark)&&e._read(o.highWaterMark)}(e,t,r)},this.needTransform=!1,this.transforming=!1,this.writecb=null,this.writechunk=null,this.writeencoding=null}function Ot(e){if(!(this instanceof Ot))return new Ot(e);Ct.call(this,e),this._transformState=new Pt(this);var t=this;this._readableState.needReadable=!0,this._readableState.sync=!1,e&&("function"==typeof e.transform&&(this._transform=e.transform),"function"==typeof e.flush&&(this._flush=e.flush)),this.once("prefinish",function(){"function"==typeof this._flush?this._flush(function(e){Ut(t,e)}):Ut(t)})}function Ut(e,t){if(t)return e.emit("error",t);var r=e._writableState,n=e._transformState;if(r.length)throw new Error("Calling transform done when ws.length != 0");if(n.transforming)throw new Error("Calling transform done when still transforming");return e.push(null)}function Ht(e){if(!(this instanceof Ht))return new Ht(e);Ot.call(this,e)}function Ft(){ve.call(this)}Be(Ot,Ct),Ot.prototype.push=function(e,t){return this._transformState.needTransform=!1,Ct.prototype.push.call(this,e,t)},Ot.prototype._transform=function(e,t,r){throw new Error("Not implemented")},Ot.prototype._write=function(e,t,r){var n=this._transformState;if(n.writecb=r,n.writechunk=e,n.writeencoding=t,!n.transforming){var i=this._readableState;(n.needTransform||i.needReadable||i.length<i.highWaterMark)&&this._read(i.highWaterMark)}},Ot.prototype._read=function(e){var t=this._transformState;null!==t.writechunk&&t.writecb&&!t.transforming?(t.transforming=!0,this._transform(t.writechunk,t.writeencoding,t.afterTransform)):t.needTransform=!0},Be(Ht,Ot),Ht.prototype._transform=function(e,t,r){r(null,e)},Be(Ft,ve),Ft.Readable=ot,Ft.Writable=kt,Ft.Duplex=Ct,Ft.Transform=Ot,Ft.PassThrough=Ht,Ft.Stream=Ft,Ft.prototype.pipe=function(e,t){var r=this;function n(t){e.writable&&!1===e.write(t)&&r.pause&&r.pause()}function i(){r.readable&&r.resume&&r.resume()}r.on("data",n),e.on("drain",i),e._isStdio||t&&!1===t.end||(r.on("end",a),r.on("close",s));var o=!1;function a(){o||(o=!0,e.end())}function s(){o||(o=!0,"function"==typeof e.destroy&&e.destroy())}function h(e){if(l(),0===ve.listenerCount(this,"error"))throw e}function l(){r.removeListener("data",n),e.removeListener("drain",i),r.removeListener("end",a),r.removeListener("close",s),r.removeListener("error",h),e.removeListener("error",h),r.removeListener("end",l),r.removeListener("close",l),e.removeListener("close",l)}return r.on("error",h),e.on("error",h),r.on("end",l),r.on("close",l),e.on("close",l),e.emit("pipe",r),e};var Nt={2:"need dictionary",1:"stream end",0:"","-1":"file error","-2":"stream error","-3":"data error","-4":"insufficient memory","-5":"buffer error","-6":"incompatible version"};function Zt(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg="",this.state=null,this.data_type=2,this.adler=0}function jt(e,t,r,n,i){if(t.subarray&&e.subarray)e.set(t.subarray(r,r+n),i);else for(var o=0;o<n;o++)e[i+o]=t[r+o]}var Wt=Uint8Array,Yt=Uint16Array,Kt=Int32Array,Xt=4,qt=0,Vt=1,Gt=2;function $t(e){for(var t=e.length;--t>=0;)e[t]=0}var Jt=0,Qt=1,er=2,tr=29,rr=256,nr=rr+1+tr,ir=30,or=19,ar=2*nr+1,sr=15,hr=16,lr=7,fr=256,cr=16,ur=17,dr=18,pr=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0],_r=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13],gr=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7],vr=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],wr=new Array(2*(nr+2));$t(wr);var br=new Array(2*ir);$t(br);var yr=new Array(512);$t(yr);var mr=new Array(256);$t(mr);var kr=new Array(tr);$t(kr);var Er,Sr,xr,Rr=new Array(ir);function Ar(e,t,r,n,i){this.static_tree=e,this.extra_bits=t,this.extra_base=r,this.elems=n,this.max_length=i,this.has_stree=e&&e.length}function Br(e,t){this.dyn_tree=e,this.max_code=0,this.stat_desc=t}function zr(e){return e<256?yr[e]:yr[256+(e>>>7)]}function Lr(e,t){e.pending_buf[e.pending++]=255&t,e.pending_buf[e.pending++]=t>>>8&255}function Tr(e,t,r){e.bi_valid>hr-r?(e.bi_buf|=t<<e.bi_valid&65535,Lr(e,e.bi_buf),e.bi_buf=t>>hr-e.bi_valid,e.bi_valid+=r-hr):(e.bi_buf|=t<<e.bi_valid&65535,e.bi_valid+=r)}function Mr(e,t,r){Tr(e,r[2*t],r[2*t+1])}function Cr(e,t){var r=0;do{r|=1&e,e>>>=1,r<<=1}while(--t>0);return r>>>1}function Dr(e,t,r){var n,i,o=new Array(sr+1),a=0;for(n=1;n<=sr;n++)o[n]=a=a+r[n-1]<<1;for(i=0;i<=t;i++){var s=e[2*i+1];0!==s&&(e[2*i]=Cr(o[s]++,s))}}function Ir(e){var t;for(t=0;t<nr;t++)e.dyn_ltree[2*t]=0;for(t=0;t<ir;t++)e.dyn_dtree[2*t]=0;for(t=0;t<or;t++)e.bl_tree[2*t]=0;e.dyn_ltree[2*fr]=1,e.opt_len=e.static_len=0,e.last_lit=e.matches=0}function Pr(e){e.bi_valid>8?Lr(e,e.bi_buf):e.bi_valid>0&&(e.pending_buf[e.pending++]=e.bi_buf),e.bi_buf=0,e.bi_valid=0}function Or(e,t,r,n){var i=2*t,o=2*r;return e[i]<e[o]||e[i]===e[o]&&n[t]<=n[r]}function Ur(e,t,r){for(var n=e.heap[r],i=r<<1;i<=e.heap_len&&(i<e.heap_len&&Or(t,e.heap[i+1],e.heap[i],e.depth)&&i++,!Or(t,n,e.heap[i],e.depth));)e.heap[r]=e.heap[i],r=i,i<<=1;e.heap[r]=n}function Hr(e,t,r){var n,i,o,a,s=0;if(0!==e.last_lit)do{n=e.pending_buf[e.d_buf+2*s]<<8|e.pending_buf[e.d_buf+2*s+1],i=e.pending_buf[e.l_buf+s],s++,0===n?Mr(e,i,t):(Mr(e,(o=mr[i])+rr+1,t),0!==(a=pr[o])&&Tr(e,i-=kr[o],a),Mr(e,o=zr(--n),r),0!==(a=_r[o])&&Tr(e,n-=Rr[o],a))}while(s<e.last_lit);Mr(e,fr,t)}function Fr(e,t){var r,n,i,o=t.dyn_tree,a=t.stat_desc.static_tree,s=t.stat_desc.has_stree,h=t.stat_desc.elems,l=-1;for(e.heap_len=0,e.heap_max=ar,r=0;r<h;r++)0!==o[2*r]?(e.heap[++e.heap_len]=l=r,e.depth[r]=0):o[2*r+1]=0;for(;e.heap_len<2;)o[2*(i=e.heap[++e.heap_len]=l<2?++l:0)]=1,e.depth[i]=0,e.opt_len--,s&&(e.static_len-=a[2*i+1]);for(t.max_code=l,r=e.heap_len>>1;r>=1;r--)Ur(e,o,r);i=h;do{r=e.heap[1],e.heap[1]=e.heap[e.heap_len--],Ur(e,o,1),n=e.heap[1],e.heap[--e.heap_max]=r,e.heap[--e.heap_max]=n,o[2*i]=o[2*r]+o[2*n],e.depth[i]=(e.depth[r]>=e.depth[n]?e.depth[r]:e.depth[n])+1,o[2*r+1]=o[2*n+1]=i,e.heap[1]=i++,Ur(e,o,1)}while(e.heap_len>=2);e.heap[--e.heap_max]=e.heap[1],function(e,t){var r,n,i,o,a,s,h=t.dyn_tree,l=t.max_code,f=t.stat_desc.static_tree,c=t.stat_desc.has_stree,u=t.stat_desc.extra_bits,d=t.stat_desc.extra_base,p=t.stat_desc.max_length,_=0;for(o=0;o<=sr;o++)e.bl_count[o]=0;for(h[2*e.heap[e.heap_max]+1]=0,r=e.heap_max+1;r<ar;r++)(o=h[2*h[2*(n=e.heap[r])+1]+1]+1)>p&&(o=p,_++),h[2*n+1]=o,n>l||(e.bl_count[o]++,a=0,n>=d&&(a=u[n-d]),s=h[2*n],e.opt_len+=s*(o+a),c&&(e.static_len+=s*(f[2*n+1]+a)));if(0!==_){do{for(o=p-1;0===e.bl_count[o];)o--;e.bl_count[o]--,e.bl_count[o+1]+=2,e.bl_count[p]--,_-=2}while(_>0);for(o=p;0!==o;o--)for(n=e.bl_count[o];0!==n;)(i=e.heap[--r])>l||(h[2*i+1]!==o&&(e.opt_len+=(o-h[2*i+1])*h[2*i],h[2*i+1]=o),n--)}}(e,t),Dr(o,l,e.bl_count)}function Nr(e,t,r){var n,i,o=-1,a=t[1],s=0,h=7,l=4;for(0===a&&(h=138,l=3),t[2*(r+1)+1]=65535,n=0;n<=r;n++)i=a,a=t[2*(n+1)+1],++s<h&&i===a||(s<l?e.bl_tree[2*i]+=s:0!==i?(i!==o&&e.bl_tree[2*i]++,e.bl_tree[2*cr]++):s<=10?e.bl_tree[2*ur]++:e.bl_tree[2*dr]++,s=0,o=i,0===a?(h=138,l=3):i===a?(h=6,l=3):(h=7,l=4))}function Zr(e,t,r){var n,i,o=-1,a=t[1],s=0,h=7,l=4;for(0===a&&(h=138,l=3),n=0;n<=r;n++)if(i=a,a=t[2*(n+1)+1],!(++s<h&&i===a)){if(s<l)do{Mr(e,i,e.bl_tree)}while(0!=--s);else 0!==i?(i!==o&&(Mr(e,i,e.bl_tree),s--),Mr(e,cr,e.bl_tree),Tr(e,s-3,2)):s<=10?(Mr(e,ur,e.bl_tree),Tr(e,s-3,3)):(Mr(e,dr,e.bl_tree),Tr(e,s-11,7));s=0,o=i,0===a?(h=138,l=3):i===a?(h=6,l=3):(h=7,l=4)}}$t(Rr);var jr=!1;function Wr(e){jr||(!function(){var e,t,r,n,i,o=new Array(sr+1);for(r=0,n=0;n<tr-1;n++)for(kr[n]=r,e=0;e<1<<pr[n];e++)mr[r++]=n;for(mr[r-1]=n,i=0,n=0;n<16;n++)for(Rr[n]=i,e=0;e<1<<_r[n];e++)yr[i++]=n;for(i>>=7;n<ir;n++)for(Rr[n]=i<<7,e=0;e<1<<_r[n]-7;e++)yr[256+i++]=n;for(t=0;t<=sr;t++)o[t]=0;for(e=0;e<=143;)wr[2*e+1]=8,e++,o[8]++;for(;e<=255;)wr[2*e+1]=9,e++,o[9]++;for(;e<=279;)wr[2*e+1]=7,e++,o[7]++;for(;e<=287;)wr[2*e+1]=8,e++,o[8]++;for(Dr(wr,nr+1,o),e=0;e<ir;e++)br[2*e+1]=5,br[2*e]=Cr(e,5);Er=new Ar(wr,pr,rr+1,nr,sr),Sr=new Ar(br,_r,0,ir,sr),xr=new Ar(new Array(0),gr,0,or,lr)}(),jr=!0),e.l_desc=new Br(e.dyn_ltree,Er),e.d_desc=new Br(e.dyn_dtree,Sr),e.bl_desc=new Br(e.bl_tree,xr),e.bi_buf=0,e.bi_valid=0,Ir(e)}function Yr(e,t,r,n){Tr(e,(Jt<<1)+(n?1:0),3),function(e,t,r,n){Pr(e),n&&(Lr(e,r),Lr(e,~r)),jt(e.pending_buf,e.window,t,r,e.pending),e.pending+=r}(e,t,r,!0)}function Kr(e){Tr(e,Qt<<1,3),Mr(e,fr,wr),function(e){16===e.bi_valid?(Lr(e,e.bi_buf),e.bi_buf=0,e.bi_valid=0):e.bi_valid>=8&&(e.pending_buf[e.pending++]=255&e.bi_buf,e.bi_buf>>=8,e.bi_valid-=8)}(e)}function Xr(e,t,r,n){var i,o,a=0;e.level>0?(e.strm.data_type===Gt&&(e.strm.data_type=function(e){var t,r=4093624447;for(t=0;t<=31;t++,r>>>=1)if(1&r&&0!==e.dyn_ltree[2*t])return qt;if(0!==e.dyn_ltree[18]||0!==e.dyn_ltree[20]||0!==e.dyn_ltree[26])return Vt;for(t=32;t<rr;t++)if(0!==e.dyn_ltree[2*t])return Vt;return qt}(e)),Fr(e,e.l_desc),Fr(e,e.d_desc),a=function(e){var t;for(Nr(e,e.dyn_ltree,e.l_desc.max_code),Nr(e,e.dyn_dtree,e.d_desc.max_code),Fr(e,e.bl_desc),t=or-1;t>=3&&0===e.bl_tree[2*vr[t]+1];t--);return e.opt_len+=3*(t+1)+5+5+4,t}(e),i=e.opt_len+3+7>>>3,(o=e.static_len+3+7>>>3)<=i&&(i=o)):i=o=r+5,r+4<=i&&-1!==t?Yr(e,t,r,n):e.strategy===Xt||o===i?(Tr(e,(Qt<<1)+(n?1:0),3),Hr(e,wr,br)):(Tr(e,(er<<1)+(n?1:0),3),function(e,t,r,n){var i;for(Tr(e,t-257,5),Tr(e,r-1,5),Tr(e,n-4,4),i=0;i<n;i++)Tr(e,e.bl_tree[2*vr[i]+1],3);Zr(e,e.dyn_ltree,t-1),Zr(e,e.dyn_dtree,r-1)}(e,e.l_desc.max_code+1,e.d_desc.max_code+1,a+1),Hr(e,e.dyn_ltree,e.dyn_dtree)),Ir(e),n&&Pr(e)}function qr(e,t,r){return e.pending_buf[e.d_buf+2*e.last_lit]=t>>>8&255,e.pending_buf[e.d_buf+2*e.last_lit+1]=255&t,e.pending_buf[e.l_buf+e.last_lit]=255&r,e.last_lit++,0===t?e.dyn_ltree[2*r]++:(e.matches++,t--,e.dyn_ltree[2*(mr[r]+rr+1)]++,e.dyn_dtree[2*zr(t)]++),e.last_lit===e.lit_bufsize-1}function Vr(e,t,r,n){for(var i=65535&e|0,o=e>>>16&65535|0,a=0;0!==r;){r-=a=r>2e3?2e3:r;do{o=o+(i=i+t[n++]|0)|0}while(--a);i%=65521,o%=65521}return i|o<<16|0}var Gr=function(){for(var e,t=[],r=0;r<256;r++){e=r;for(var n=0;n<8;n++)e=1&e?3988292384^e>>>1:e>>>1;t[r]=e}return t}();function $r(e,t,r,n){var i=Gr,o=n+r;e^=-1;for(var a=n;a<o;a++)e=e>>>8^i[255&(e^t[a])];return-1^e}var Jr,Qr=0,en=1,tn=3,rn=4,nn=5,on=0,an=1,sn=-2,hn=-3,ln=-5,fn=-1,cn=1,un=2,dn=3,pn=4,_n=2,gn=8,vn=9,wn=286,bn=30,yn=19,mn=2*wn+1,kn=15,En=3,Sn=258,xn=Sn+En+1,Rn=32,An=42,Bn=69,zn=73,Ln=91,Tn=103,Mn=113,Cn=666,Dn=1,In=2,Pn=3,On=4,Un=3;function Hn(e,t){return e.msg=Nt[t],t}function Fn(e){return(e<<1)-(e>4?9:0)}function Nn(e){for(var t=e.length;--t>=0;)e[t]=0}function Zn(e){var t=e.state,r=t.pending;r>e.avail_out&&(r=e.avail_out),0!==r&&(jt(e.output,t.pending_buf,t.pending_out,r,e.next_out),e.next_out+=r,t.pending_out+=r,e.total_out+=r,e.avail_out-=r,t.pending-=r,0===t.pending&&(t.pending_out=0))}function jn(e,t){Xr(e,e.block_start>=0?e.block_start:-1,e.strstart-e.block_start,t),e.block_start=e.strstart,Zn(e.strm)}function Wn(e,t){e.pending_buf[e.pending++]=t}function Yn(e,t){e.pending_buf[e.pending++]=t>>>8&255,e.pending_buf[e.pending++]=255&t}function Kn(e,t){var r,n,i=e.max_chain_length,o=e.strstart,a=e.prev_length,s=e.nice_match,h=e.strstart>e.w_size-xn?e.strstart-(e.w_size-xn):0,l=e.window,f=e.w_mask,c=e.prev,u=e.strstart+Sn,d=l[o+a-1],p=l[o+a];e.prev_length>=e.good_match&&(i>>=2),s>e.lookahead&&(s=e.lookahead);do{if(l[(r=t)+a]===p&&l[r+a-1]===d&&l[r]===l[o]&&l[++r]===l[o+1]){o+=2,r++;do{}while(l[++o]===l[++r]&&l[++o]===l[++r]&&l[++o]===l[++r]&&l[++o]===l[++r]&&l[++o]===l[++r]&&l[++o]===l[++r]&&l[++o]===l[++r]&&l[++o]===l[++r]&&o<u);if(n=Sn-(u-o),o=u-Sn,n>a){if(e.match_start=t,a=n,n>=s)break;d=l[o+a-1],p=l[o+a]}}}while((t=c[t&f])>h&&0!=--i);return a<=e.lookahead?a:e.lookahead}function Xn(e){var t,r,n,i,o,a,s,h,l,f,c=e.w_size;do{if(i=e.window_size-e.lookahead-e.strstart,e.strstart>=c+(c-xn)){jt(e.window,e.window,c,c,0),e.match_start-=c,e.strstart-=c,e.block_start-=c,t=r=e.hash_size;do{n=e.head[--t],e.head[t]=n>=c?n-c:0}while(--r);t=r=c;do{n=e.prev[--t],e.prev[t]=n>=c?n-c:0}while(--r);i+=c}if(0===e.strm.avail_in)break;if(a=e.strm,s=e.window,h=e.strstart+e.lookahead,l=i,f=void 0,(f=a.avail_in)>l&&(f=l),r=0===f?0:(a.avail_in-=f,jt(s,a.input,a.next_in,f,h),1===a.state.wrap?a.adler=Vr(a.adler,s,f,h):2===a.state.wrap&&(a.adler=$r(a.adler,s,f,h)),a.next_in+=f,a.total_in+=f,f),e.lookahead+=r,e.lookahead+e.insert>=En)for(o=e.strstart-e.insert,e.ins_h=e.window[o],e.ins_h=(e.ins_h<<e.hash_shift^e.window[o+1])&e.hash_mask;e.insert&&(e.ins_h=(e.ins_h<<e.hash_shift^e.window[o+En-1])&e.hash_mask,e.prev[o&e.w_mask]=e.head[e.ins_h],e.head[e.ins_h]=o,o++,e.insert--,!(e.lookahead+e.insert<En)););}while(e.lookahead<xn&&0!==e.strm.avail_in)}function qn(e,t){for(var r,n;;){if(e.lookahead<xn){if(Xn(e),e.lookahead<xn&&t===Qr)return Dn;if(0===e.lookahead)break}if(r=0,e.lookahead>=En&&(e.ins_h=(e.ins_h<<e.hash_shift^e.window[e.strstart+En-1])&e.hash_mask,r=e.prev[e.strstart&e.w_mask]=e.head[e.ins_h],e.head[e.ins_h]=e.strstart),0!==r&&e.strstart-r<=e.w_size-xn&&(e.match_length=Kn(e,r)),e.match_length>=En)if(n=qr(e,e.strstart-e.match_start,e.match_length-En),e.lookahead-=e.match_length,e.match_length<=e.max_lazy_match&&e.lookahead>=En){e.match_length--;do{e.strstart++,e.ins_h=(e.ins_h<<e.hash_shift^e.window[e.strstart+En-1])&e.hash_mask,r=e.prev[e.strstart&e.w_mask]=e.head[e.ins_h],e.head[e.ins_h]=e.strstart}while(0!=--e.match_length);e.strstart++}else e.strstart+=e.match_length,e.match_length=0,e.ins_h=e.window[e.strstart],e.ins_h=(e.ins_h<<e.hash_shift^e.window[e.strstart+1])&e.hash_mask;else n=qr(e,0,e.window[e.strstart]),e.lookahead--,e.strstart++;if(n&&(jn(e,!1),0===e.strm.avail_out))return Dn}return e.insert=e.strstart<En-1?e.strstart:En-1,t===rn?(jn(e,!0),0===e.strm.avail_out?Pn:On):e.last_lit&&(jn(e,!1),0===e.strm.avail_out)?Dn:In}function Vn(e,t){for(var r,n,i;;){if(e.lookahead<xn){if(Xn(e),e.lookahead<xn&&t===Qr)return Dn;if(0===e.lookahead)break}if(r=0,e.lookahead>=En&&(e.ins_h=(e.ins_h<<e.hash_shift^e.window[e.strstart+En-1])&e.hash_mask,r=e.prev[e.strstart&e.w_mask]=e.head[e.ins_h],e.head[e.ins_h]=e.strstart),e.prev_length=e.match_length,e.prev_match=e.match_start,e.match_length=En-1,0!==r&&e.prev_length<e.max_lazy_match&&e.strstart-r<=e.w_size-xn&&(e.match_length=Kn(e,r),e.match_length<=5&&(e.strategy===cn||e.match_length===En&&e.strstart-e.match_start>4096)&&(e.match_length=En-1)),e.prev_length>=En&&e.match_length<=e.prev_length){i=e.strstart+e.lookahead-En,n=qr(e,e.strstart-1-e.prev_match,e.prev_length-En),e.lookahead-=e.prev_length-1,e.prev_length-=2;do{++e.strstart<=i&&(e.ins_h=(e.ins_h<<e.hash_shift^e.window[e.strstart+En-1])&e.hash_mask,r=e.prev[e.strstart&e.w_mask]=e.head[e.ins_h],e.head[e.ins_h]=e.strstart)}while(0!=--e.prev_length);if(e.match_available=0,e.match_length=En-1,e.strstart++,n&&(jn(e,!1),0===e.strm.avail_out))return Dn}else if(e.match_available){if((n=qr(e,0,e.window[e.strstart-1]))&&jn(e,!1),e.strstart++,e.lookahead--,0===e.strm.avail_out)return Dn}else e.match_available=1,e.strstart++,e.lookahead--}return e.match_available&&(n=qr(e,0,e.window[e.strstart-1]),e.match_available=0),e.insert=e.strstart<En-1?e.strstart:En-1,t===rn?(jn(e,!0),0===e.strm.avail_out?Pn:On):e.last_lit&&(jn(e,!1),0===e.strm.avail_out)?Dn:In}function Gn(e,t,r,n,i){this.good_length=e,this.max_lazy=t,this.nice_length=r,this.max_chain=n,this.func=i}function $n(){this.strm=null,this.status=0,this.pending_buf=null,this.pending_buf_size=0,this.pending_out=0,this.pending=0,this.wrap=0,this.gzhead=null,this.gzindex=0,this.method=gn,this.last_flush=-1,this.w_size=0,this.w_bits=0,this.w_mask=0,this.window=null,this.window_size=0,this.prev=null,this.head=null,this.ins_h=0,this.hash_size=0,this.hash_bits=0,this.hash_mask=0,this.hash_shift=0,this.block_start=0,this.match_length=0,this.prev_match=0,this.match_available=0,this.strstart=0,this.match_start=0,this.lookahead=0,this.prev_length=0,this.max_chain_length=0,this.max_lazy_match=0,this.level=0,this.strategy=0,this.good_match=0,this.nice_match=0,this.dyn_ltree=new Yt(2*mn),this.dyn_dtree=new Yt(2*(2*bn+1)),this.bl_tree=new Yt(2*(2*yn+1)),Nn(this.dyn_ltree),Nn(this.dyn_dtree),Nn(this.bl_tree),this.l_desc=null,this.d_desc=null,this.bl_desc=null,this.bl_count=new Yt(kn+1),this.heap=new Yt(2*wn+1),Nn(this.heap),this.heap_len=0,this.heap_max=0,this.depth=new Yt(2*wn+1),Nn(this.depth),this.l_buf=0,this.lit_bufsize=0,this.last_lit=0,this.d_buf=0,this.opt_len=0,this.static_len=0,this.matches=0,this.insert=0,this.bi_buf=0,this.bi_valid=0}function Jn(e){var t,r=function(e){var t;return e&&e.state?(e.total_in=e.total_out=0,e.data_type=_n,(t=e.state).pending=0,t.pending_out=0,t.wrap<0&&(t.wrap=-t.wrap),t.status=t.wrap?An:Mn,e.adler=2===t.wrap?0:1,t.last_flush=Qr,Wr(t),on):Hn(e,sn)}(e);return r===on&&((t=e.state).window_size=2*t.w_size,Nn(t.head),t.max_lazy_match=Jr[t.level].max_lazy,t.good_match=Jr[t.level].good_length,t.nice_match=Jr[t.level].nice_length,t.max_chain_length=Jr[t.level].max_chain,t.strstart=0,t.block_start=0,t.lookahead=0,t.insert=0,t.match_length=t.prev_length=En-1,t.match_available=0,t.ins_h=0),r}function Qn(e,t){var r,n,i,o;if(!e||!e.state||t>nn||t<0)return e?Hn(e,sn):sn;if(n=e.state,!e.output||!e.input&&0!==e.avail_in||n.status===Cn&&t!==rn)return Hn(e,0===e.avail_out?ln:sn);if(n.strm=e,r=n.last_flush,n.last_flush=t,n.status===An)if(2===n.wrap)e.adler=0,Wn(n,31),Wn(n,139),Wn(n,8),n.gzhead?(Wn(n,(n.gzhead.text?1:0)+(n.gzhead.hcrc?2:0)+(n.gzhead.extra?4:0)+(n.gzhead.name?8:0)+(n.gzhead.comment?16:0)),Wn(n,255&n.gzhead.time),Wn(n,n.gzhead.time>>8&255),Wn(n,n.gzhead.time>>16&255),Wn(n,n.gzhead.time>>24&255),Wn(n,9===n.level?2:n.strategy>=un||n.level<2?4:0),Wn(n,255&n.gzhead.os),n.gzhead.extra&&n.gzhead.extra.length&&(Wn(n,255&n.gzhead.extra.length),Wn(n,n.gzhead.extra.length>>8&255)),n.gzhead.hcrc&&(e.adler=$r(e.adler,n.pending_buf,n.pending,0)),n.gzindex=0,n.status=Bn):(Wn(n,0),Wn(n,0),Wn(n,0),Wn(n,0),Wn(n,0),Wn(n,9===n.level?2:n.strategy>=un||n.level<2?4:0),Wn(n,Un),n.status=Mn);else{var a=gn+(n.w_bits-8<<4)<<8;a|=(n.strategy>=un||n.level<2?0:n.level<6?1:6===n.level?2:3)<<6,0!==n.strstart&&(a|=Rn),a+=31-a%31,n.status=Mn,Yn(n,a),0!==n.strstart&&(Yn(n,e.adler>>>16),Yn(n,65535&e.adler)),e.adler=1}if(n.status===Bn)if(n.gzhead.extra){for(i=n.pending;n.gzindex<(65535&n.gzhead.extra.length)&&(n.pending!==n.pending_buf_size||(n.gzhead.hcrc&&n.pending>i&&(e.adler=$r(e.adler,n.pending_buf,n.pending-i,i)),Zn(e),i=n.pending,n.pending!==n.pending_buf_size));)Wn(n,255&n.gzhead.extra[n.gzindex]),n.gzindex++;n.gzhead.hcrc&&n.pending>i&&(e.adler=$r(e.adler,n.pending_buf,n.pending-i,i)),n.gzindex===n.gzhead.extra.length&&(n.gzindex=0,n.status=zn)}else n.status=zn;if(n.status===zn)if(n.gzhead.name){i=n.pending;do{if(n.pending===n.pending_buf_size&&(n.gzhead.hcrc&&n.pending>i&&(e.adler=$r(e.adler,n.pending_buf,n.pending-i,i)),Zn(e),i=n.pending,n.pending===n.pending_buf_size)){o=1;break}o=n.gzindex<n.gzhead.name.length?255&n.gzhead.name.charCodeAt(n.gzindex++):0,Wn(n,o)}while(0!==o);n.gzhead.hcrc&&n.pending>i&&(e.adler=$r(e.adler,n.pending_buf,n.pending-i,i)),0===o&&(n.gzindex=0,n.status=Ln)}else n.status=Ln;if(n.status===Ln)if(n.gzhead.comment){i=n.pending;do{if(n.pending===n.pending_buf_size&&(n.gzhead.hcrc&&n.pending>i&&(e.adler=$r(e.adler,n.pending_buf,n.pending-i,i)),Zn(e),i=n.pending,n.pending===n.pending_buf_size)){o=1;break}o=n.gzindex<n.gzhead.comment.length?255&n.gzhead.comment.charCodeAt(n.gzindex++):0,Wn(n,o)}while(0!==o);n.gzhead.hcrc&&n.pending>i&&(e.adler=$r(e.adler,n.pending_buf,n.pending-i,i)),0===o&&(n.status=Tn)}else n.status=Tn;if(n.status===Tn&&(n.gzhead.hcrc?(n.pending+2>n.pending_buf_size&&Zn(e),n.pending+2<=n.pending_buf_size&&(Wn(n,255&e.adler),Wn(n,e.adler>>8&255),e.adler=0,n.status=Mn)):n.status=Mn),0!==n.pending){if(Zn(e),0===e.avail_out)return n.last_flush=-1,on}else if(0===e.avail_in&&Fn(t)<=Fn(r)&&t!==rn)return Hn(e,ln);if(n.status===Cn&&0!==e.avail_in)return Hn(e,ln);if(0!==e.avail_in||0!==n.lookahead||t!==Qr&&n.status!==Cn){var s=n.strategy===un?function(e,t){for(var r;;){if(0===e.lookahead&&(Xn(e),0===e.lookahead)){if(t===Qr)return Dn;break}if(e.match_length=0,r=qr(e,0,e.window[e.strstart]),e.lookahead--,e.strstart++,r&&(jn(e,!1),0===e.strm.avail_out))return Dn}return e.insert=0,t===rn?(jn(e,!0),0===e.strm.avail_out?Pn:On):e.last_lit&&(jn(e,!1),0===e.strm.avail_out)?Dn:In}(n,t):n.strategy===dn?function(e,t){for(var r,n,i,o,a=e.window;;){if(e.lookahead<=Sn){if(Xn(e),e.lookahead<=Sn&&t===Qr)return Dn;if(0===e.lookahead)break}if(e.match_length=0,e.lookahead>=En&&e.strstart>0&&(n=a[i=e.strstart-1])===a[++i]&&n===a[++i]&&n===a[++i]){o=e.strstart+Sn;do{}while(n===a[++i]&&n===a[++i]&&n===a[++i]&&n===a[++i]&&n===a[++i]&&n===a[++i]&&n===a[++i]&&n===a[++i]&&i<o);e.match_length=Sn-(o-i),e.match_length>e.lookahead&&(e.match_length=e.lookahead)}if(e.match_length>=En?(r=qr(e,1,e.match_length-En),e.lookahead-=e.match_length,e.strstart+=e.match_length,e.match_length=0):(r=qr(e,0,e.window[e.strstart]),e.lookahead--,e.strstart++),r&&(jn(e,!1),0===e.strm.avail_out))return Dn}return e.insert=0,t===rn?(jn(e,!0),0===e.strm.avail_out?Pn:On):e.last_lit&&(jn(e,!1),0===e.strm.avail_out)?Dn:In}(n,t):Jr[n.level].func(n,t);if(s!==Pn&&s!==On||(n.status=Cn),s===Dn||s===Pn)return 0===e.avail_out&&(n.last_flush=-1),on;if(s===In&&(t===en?Kr(n):t!==nn&&(Yr(n,0,0,!1),t===tn&&(Nn(n.head),0===n.lookahead&&(n.strstart=0,n.block_start=0,n.insert=0))),Zn(e),0===e.avail_out))return n.last_flush=-1,on}return t!==rn?on:n.wrap<=0?an:(2===n.wrap?(Wn(n,255&e.adler),Wn(n,e.adler>>8&255),Wn(n,e.adler>>16&255),Wn(n,e.adler>>24&255),Wn(n,255&e.total_in),Wn(n,e.total_in>>8&255),Wn(n,e.total_in>>16&255),Wn(n,e.total_in>>24&255)):(Yn(n,e.adler>>>16),Yn(n,65535&e.adler)),Zn(e),n.wrap>0&&(n.wrap=-n.wrap),0!==n.pending?on:an)}Jr=[new Gn(0,0,0,0,function(e,t){var r=65535;for(r>e.pending_buf_size-5&&(r=e.pending_buf_size-5);;){if(e.lookahead<=1){if(Xn(e),0===e.lookahead&&t===Qr)return Dn;if(0===e.lookahead)break}e.strstart+=e.lookahead,e.lookahead=0;var n=e.block_start+r;if((0===e.strstart||e.strstart>=n)&&(e.lookahead=e.strstart-n,e.strstart=n,jn(e,!1),0===e.strm.avail_out))return Dn;if(e.strstart-e.block_start>=e.w_size-xn&&(jn(e,!1),0===e.strm.avail_out))return Dn}return e.insert=0,t===rn?(jn(e,!0),0===e.strm.avail_out?Pn:On):(e.strstart>e.block_start&&(jn(e,!1),e.strm.avail_out),Dn)}),new Gn(4,4,8,4,qn),new Gn(4,5,16,8,qn),new Gn(4,6,32,32,qn),new Gn(4,4,16,16,Vn),new Gn(8,16,32,32,Vn),new Gn(8,16,128,128,Vn),new Gn(8,32,128,256,Vn),new Gn(32,128,258,1024,Vn),new Gn(32,258,258,4096,Vn)];var ei=30,ti=12;function ri(e,t){var r,n,i,o,a,s,h,l,f,c,u,d,p,_,g,v,w,b,y,m,k,E,S,x,R;r=e.state,n=e.next_in,x=e.input,i=n+(e.avail_in-5),o=e.next_out,R=e.output,a=o-(t-e.avail_out),s=o+(e.avail_out-257),h=r.dmax,l=r.wsize,f=r.whave,c=r.wnext,u=r.window,d=r.hold,p=r.bits,_=r.lencode,g=r.distcode,v=(1<<r.lenbits)-1,w=(1<<r.distbits)-1;e:do{p<15&&(d+=x[n++]<<p,p+=8,d+=x[n++]<<p,p+=8),b=_[d&v];t:for(;;){if(d>>>=y=b>>>24,p-=y,0===(y=b>>>16&255))R[o++]=65535&b;else{if(!(16&y)){if(0==(64&y)){b=_[(65535&b)+(d&(1<<y)-1)];continue t}if(32&y){r.mode=ti;break e}e.msg="invalid literal/length code",r.mode=ei;break e}m=65535&b,(y&=15)&&(p<y&&(d+=x[n++]<<p,p+=8),m+=d&(1<<y)-1,d>>>=y,p-=y),p<15&&(d+=x[n++]<<p,p+=8,d+=x[n++]<<p,p+=8),b=g[d&w];r:for(;;){if(d>>>=y=b>>>24,p-=y,!(16&(y=b>>>16&255))){if(0==(64&y)){b=g[(65535&b)+(d&(1<<y)-1)];continue r}e.msg="invalid distance code",r.mode=ei;break e}if(k=65535&b,p<(y&=15)&&(d+=x[n++]<<p,(p+=8)<y&&(d+=x[n++]<<p,p+=8)),(k+=d&(1<<y)-1)>h){e.msg="invalid distance too far back",r.mode=ei;break e}if(d>>>=y,p-=y,k>(y=o-a)){if((y=k-y)>f&&r.sane){e.msg="invalid distance too far back",r.mode=ei;break e}if(E=0,S=u,0===c){if(E+=l-y,y<m){m-=y;do{R[o++]=u[E++]}while(--y);E=o-k,S=R}}else if(c<y){if(E+=l+c-y,(y-=c)<m){m-=y;do{R[o++]=u[E++]}while(--y);if(E=0,c<m){m-=y=c;do{R[o++]=u[E++]}while(--y);E=o-k,S=R}}}else if(E+=c-y,y<m){m-=y;do{R[o++]=u[E++]}while(--y);E=o-k,S=R}for(;m>2;)R[o++]=S[E++],R[o++]=S[E++],R[o++]=S[E++],m-=3;m&&(R[o++]=S[E++],m>1&&(R[o++]=S[E++]))}else{E=o-k;do{R[o++]=R[E++],R[o++]=R[E++],R[o++]=R[E++],m-=3}while(m>2);m&&(R[o++]=R[E++],m>1&&(R[o++]=R[E++]))}break}}break}}while(n<i&&o<s);n-=m=p>>3,d&=(1<<(p-=m<<3))-1,e.next_in=n,e.next_out=o,e.avail_in=n<i?i-n+5:5-(n-i),e.avail_out=o<s?s-o+257:257-(o-s),r.hold=d,r.bits=p}var ni=15,ii=852,oi=592,ai=0,si=1,hi=2,li=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0],fi=[16,16,16,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,16,72,78],ci=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0],ui=[16,16,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,64,64];function di(e,t,r,n,i,o,a,s){var h,l,f,c,u,d,p,_,g,v=s.bits,w=0,b=0,y=0,m=0,k=0,E=0,S=0,x=0,R=0,A=0,B=null,z=0,L=new Yt(ni+1),T=new Yt(ni+1),M=null,C=0;for(w=0;w<=ni;w++)L[w]=0;for(b=0;b<n;b++)L[t[r+b]]++;for(k=v,m=ni;m>=1&&0===L[m];m--);if(k>m&&(k=m),0===m)return i[o++]=20971520,i[o++]=20971520,s.bits=1,0;for(y=1;y<m&&0===L[y];y++);for(k<y&&(k=y),x=1,w=1;w<=ni;w++)if(x<<=1,(x-=L[w])<0)return-1;if(x>0&&(e===ai||1!==m))return-1;for(T[1]=0,w=1;w<ni;w++)T[w+1]=T[w]+L[w];for(b=0;b<n;b++)0!==t[r+b]&&(a[T[t[r+b]]++]=b);if(e===ai?(B=M=a,d=19):e===si?(B=li,z-=257,M=fi,C-=257,d=256):(B=ci,M=ui,d=-1),A=0,b=0,w=y,u=o,E=k,S=0,f=-1,c=(R=1<<k)-1,e===si&&R>ii||e===hi&&R>oi)return 1;for(;;){p=w-S,a[b]<d?(_=0,g=a[b]):a[b]>d?(_=M[C+a[b]],g=B[z+a[b]]):(_=96,g=0),h=1<<w-S,y=l=1<<E;do{i[u+(A>>S)+(l-=h)]=p<<24|_<<16|g|0}while(0!==l);for(h=1<<w-1;A&h;)h>>=1;if(0!==h?(A&=h-1,A+=h):A=0,b++,0==--L[w]){if(w===m)break;w=t[r+a[b]]}if(w>k&&(A&c)!==f){for(0===S&&(S=k),u+=y,x=1<<(E=w-S);E+S<m&&!((x-=L[E+S])<=0);)E++,x<<=1;if(R+=1<<E,e===si&&R>ii||e===hi&&R>oi)return 1;i[f=A&c]=k<<24|E<<16|u-o|0}}return 0!==A&&(i[u+A]=w-S<<24|64<<16|0),s.bits=k,0}var pi=0,_i=1,gi=2,vi=4,wi=5,bi=6,yi=0,mi=1,ki=2,Ei=-2,Si=-3,xi=-4,Ri=-5,Ai=8,Bi=1,zi=2,Li=3,Ti=4,Mi=5,Ci=6,Di=7,Ii=8,Pi=9,Oi=10,Ui=11,Hi=12,Fi=13,Ni=14,Zi=15,ji=16,Wi=17,Yi=18,Ki=19,Xi=20,qi=21,Vi=22,Gi=23,$i=24,Ji=25,Qi=26,eo=27,to=28,ro=29,no=30,io=31,oo=32,ao=852,so=592;function ho(e){return(e>>>24&255)+(e>>>8&65280)+((65280&e)<<8)+((255&e)<<24)}function lo(){this.mode=0,this.last=!1,this.wrap=0,this.havedict=!1,this.flags=0,this.dmax=0,this.check=0,this.total=0,this.head=null,this.wbits=0,this.wsize=0,this.whave=0,this.wnext=0,this.window=null,this.hold=0,this.bits=0,this.length=0,this.offset=0,this.extra=0,this.lencode=null,this.distcode=null,this.lenbits=0,this.distbits=0,this.ncode=0,this.nlen=0,this.ndist=0,this.have=0,this.next=null,this.lens=new Yt(320),this.work=new Yt(288),this.lendyn=null,this.distdyn=null,this.sane=0,this.back=0,this.was=0}function fo(e){var t;return e&&e.state?((t=e.state).wsize=0,t.whave=0,t.wnext=0,function(e){var t;return e&&e.state?(t=e.state,e.total_in=e.total_out=t.total=0,e.msg="",t.wrap&&(e.adler=1&t.wrap),t.mode=Bi,t.last=0,t.havedict=0,t.dmax=32768,t.head=null,t.hold=0,t.bits=0,t.lencode=t.lendyn=new Kt(ao),t.distcode=t.distdyn=new Kt(so),t.sane=1,t.back=-1,yi):Ei}(e)):Ei}function co(e,t){var r,n;return e?(n=new lo,e.state=n,n.window=null,(r=function(e,t){var r,n;return e&&e.state?(n=e.state,t<0?(r=0,t=-t):(r=1+(t>>4),t<48&&(t&=15)),t&&(t<8||t>15)?Ei:(null!==n.window&&n.wbits!==t&&(n.window=null),n.wrap=r,n.wbits=t,fo(e))):Ei}(e,t))!==yi&&(e.state=null),r):Ei}var uo,po,_o=!0;function go(e){if(_o){var t;for(uo=new Kt(512),po=new Kt(32),t=0;t<144;)e.lens[t++]=8;for(;t<256;)e.lens[t++]=9;for(;t<280;)e.lens[t++]=7;for(;t<288;)e.lens[t++]=8;for(di(_i,e.lens,0,288,uo,0,e.work,{bits:9}),t=0;t<32;)e.lens[t++]=5;di(gi,e.lens,0,32,po,0,e.work,{bits:5}),_o=!1}e.lencode=uo,e.lenbits=9,e.distcode=po,e.distbits=5}function vo(e,t){var r,n,i,o,a,s,h,l,f,c,u,d,p,_,g,v,w,b,y,m,k,E,S,x,R=0,A=new Wt(4),B=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];if(!e||!e.state||!e.output||!e.input&&0!==e.avail_in)return Ei;(r=e.state).mode===Hi&&(r.mode=Fi),a=e.next_out,i=e.output,h=e.avail_out,o=e.next_in,n=e.input,s=e.avail_in,l=r.hold,f=r.bits,c=s,u=h,E=yi;e:for(;;)switch(r.mode){case Bi:if(0===r.wrap){r.mode=Fi;break}for(;f<16;){if(0===s)break e;s--,l+=n[o++]<<f,f+=8}if(2&r.wrap&&35615===l){r.check=0,A[0]=255&l,A[1]=l>>>8&255,r.check=$r(r.check,A,2,0),l=0,f=0,r.mode=zi;break}if(r.flags=0,r.head&&(r.head.done=!1),!(1&r.wrap)||(((255&l)<<8)+(l>>8))%31){e.msg="incorrect header check",r.mode=no;break}if((15&l)!==Ai){e.msg="unknown compression method",r.mode=no;break}if(f-=4,k=8+(15&(l>>>=4)),0===r.wbits)r.wbits=k;else if(k>r.wbits){e.msg="invalid window size",r.mode=no;break}r.dmax=1<<k,e.adler=r.check=1,r.mode=512&l?Oi:Hi,l=0,f=0;break;case zi:for(;f<16;){if(0===s)break e;s--,l+=n[o++]<<f,f+=8}if(r.flags=l,(255&r.flags)!==Ai){e.msg="unknown compression method",r.mode=no;break}if(57344&r.flags){e.msg="unknown header flags set",r.mode=no;break}r.head&&(r.head.text=l>>8&1),512&r.flags&&(A[0]=255&l,A[1]=l>>>8&255,r.check=$r(r.check,A,2,0)),l=0,f=0,r.mode=Li;case Li:for(;f<32;){if(0===s)break e;s--,l+=n[o++]<<f,f+=8}r.head&&(r.head.time=l),512&r.flags&&(A[0]=255&l,A[1]=l>>>8&255,A[2]=l>>>16&255,A[3]=l>>>24&255,r.check=$r(r.check,A,4,0)),l=0,f=0,r.mode=Ti;case Ti:for(;f<16;){if(0===s)break e;s--,l+=n[o++]<<f,f+=8}r.head&&(r.head.xflags=255&l,r.head.os=l>>8),512&r.flags&&(A[0]=255&l,A[1]=l>>>8&255,r.check=$r(r.check,A,2,0)),l=0,f=0,r.mode=Mi;case Mi:if(1024&r.flags){for(;f<16;){if(0===s)break e;s--,l+=n[o++]<<f,f+=8}r.length=l,r.head&&(r.head.extra_len=l),512&r.flags&&(A[0]=255&l,A[1]=l>>>8&255,r.check=$r(r.check,A,2,0)),l=0,f=0}else r.head&&(r.head.extra=null);r.mode=Ci;case Ci:if(1024&r.flags&&((d=r.length)>s&&(d=s),d&&(r.head&&(k=r.head.extra_len-r.length,r.head.extra||(r.head.extra=new Array(r.head.extra_len)),jt(r.head.extra,n,o,d,k)),512&r.flags&&(r.check=$r(r.check,n,d,o)),s-=d,o+=d,r.length-=d),r.length))break e;r.length=0,r.mode=Di;case Di:if(2048&r.flags){if(0===s)break e;d=0;do{k=n[o+d++],r.head&&k&&r.length<65536&&(r.head.name+=String.fromCharCode(k))}while(k&&d<s);if(512&r.flags&&(r.check=$r(r.check,n,d,o)),s-=d,o+=d,k)break e}else r.head&&(r.head.name=null);r.length=0,r.mode=Ii;case Ii:if(4096&r.flags){if(0===s)break e;d=0;do{k=n[o+d++],r.head&&k&&r.length<65536&&(r.head.comment+=String.fromCharCode(k))}while(k&&d<s);if(512&r.flags&&(r.check=$r(r.check,n,d,o)),s-=d,o+=d,k)break e}else r.head&&(r.head.comment=null);r.mode=Pi;case Pi:if(512&r.flags){for(;f<16;){if(0===s)break e;s--,l+=n[o++]<<f,f+=8}if(l!==(65535&r.check)){e.msg="header crc mismatch",r.mode=no;break}l=0,f=0}r.head&&(r.head.hcrc=r.flags>>9&1,r.head.done=!0),e.adler=r.check=0,r.mode=Hi;break;case Oi:for(;f<32;){if(0===s)break e;s--,l+=n[o++]<<f,f+=8}e.adler=r.check=ho(l),l=0,f=0,r.mode=Ui;case Ui:if(0===r.havedict)return e.next_out=a,e.avail_out=h,e.next_in=o,e.avail_in=s,r.hold=l,r.bits=f,ki;e.adler=r.check=1,r.mode=Hi;case Hi:if(t===wi||t===bi)break e;case Fi:if(r.last){l>>>=7&f,f-=7&f,r.mode=eo;break}for(;f<3;){if(0===s)break e;s--,l+=n[o++]<<f,f+=8}switch(r.last=1&l,f-=1,3&(l>>>=1)){case 0:r.mode=Ni;break;case 1:if(go(r),r.mode=Xi,t===bi){l>>>=2,f-=2;break e}break;case 2:r.mode=Wi;break;case 3:e.msg="invalid block type",r.mode=no}l>>>=2,f-=2;break;case Ni:for(l>>>=7&f,f-=7&f;f<32;){if(0===s)break e;s--,l+=n[o++]<<f,f+=8}if((65535&l)!=(l>>>16^65535)){e.msg="invalid stored block lengths",r.mode=no;break}if(r.length=65535&l,l=0,f=0,r.mode=Zi,t===bi)break e;case Zi:r.mode=ji;case ji:if(d=r.length){if(d>s&&(d=s),d>h&&(d=h),0===d)break e;jt(i,n,o,d,a),s-=d,o+=d,h-=d,a+=d,r.length-=d;break}r.mode=Hi;break;case Wi:for(;f<14;){if(0===s)break e;s--,l+=n[o++]<<f,f+=8}if(r.nlen=257+(31&l),l>>>=5,f-=5,r.ndist=1+(31&l),l>>>=5,f-=5,r.ncode=4+(15&l),l>>>=4,f-=4,r.nlen>286||r.ndist>30){e.msg="too many length or distance symbols",r.mode=no;break}r.have=0,r.mode=Yi;case Yi:for(;r.have<r.ncode;){for(;f<3;){if(0===s)break e;s--,l+=n[o++]<<f,f+=8}r.lens[B[r.have++]]=7&l,l>>>=3,f-=3}for(;r.have<19;)r.lens[B[r.have++]]=0;if(r.lencode=r.lendyn,r.lenbits=7,S={bits:r.lenbits},E=di(pi,r.lens,0,19,r.lencode,0,r.work,S),r.lenbits=S.bits,E){e.msg="invalid code lengths set",r.mode=no;break}r.have=0,r.mode=Ki;case Ki:for(;r.have<r.nlen+r.ndist;){for(;v=(R=r.lencode[l&(1<<r.lenbits)-1])>>>16&255,w=65535&R,!((g=R>>>24)<=f);){if(0===s)break e;s--,l+=n[o++]<<f,f+=8}if(w<16)l>>>=g,f-=g,r.lens[r.have++]=w;else{if(16===w){for(x=g+2;f<x;){if(0===s)break e;s--,l+=n[o++]<<f,f+=8}if(l>>>=g,f-=g,0===r.have){e.msg="invalid bit length repeat",r.mode=no;break}k=r.lens[r.have-1],d=3+(3&l),l>>>=2,f-=2}else if(17===w){for(x=g+3;f<x;){if(0===s)break e;s--,l+=n[o++]<<f,f+=8}f-=g,k=0,d=3+(7&(l>>>=g)),l>>>=3,f-=3}else{for(x=g+7;f<x;){if(0===s)break e;s--,l+=n[o++]<<f,f+=8}f-=g,k=0,d=11+(127&(l>>>=g)),l>>>=7,f-=7}if(r.have+d>r.nlen+r.ndist){e.msg="invalid bit length repeat",r.mode=no;break}for(;d--;)r.lens[r.have++]=k}}if(r.mode===no)break;if(0===r.lens[256]){e.msg="invalid code -- missing end-of-block",r.mode=no;break}if(r.lenbits=9,S={bits:r.lenbits},E=di(_i,r.lens,0,r.nlen,r.lencode,0,r.work,S),r.lenbits=S.bits,E){e.msg="invalid literal/lengths set",r.mode=no;break}if(r.distbits=6,r.distcode=r.distdyn,S={bits:r.distbits},E=di(gi,r.lens,r.nlen,r.ndist,r.distcode,0,r.work,S),r.distbits=S.bits,E){e.msg="invalid distances set",r.mode=no;break}if(r.mode=Xi,t===bi)break e;case Xi:r.mode=qi;case qi:if(s>=6&&h>=258){e.next_out=a,e.avail_out=h,e.next_in=o,e.avail_in=s,r.hold=l,r.bits=f,ri(e,u),a=e.next_out,i=e.output,h=e.avail_out,o=e.next_in,n=e.input,s=e.avail_in,l=r.hold,f=r.bits,r.mode===Hi&&(r.back=-1);break}for(r.back=0;v=(R=r.lencode[l&(1<<r.lenbits)-1])>>>16&255,w=65535&R,!((g=R>>>24)<=f);){if(0===s)break e;s--,l+=n[o++]<<f,f+=8}if(v&&0==(240&v)){for(b=g,y=v,m=w;v=(R=r.lencode[m+((l&(1<<b+y)-1)>>b)])>>>16&255,w=65535&R,!(b+(g=R>>>24)<=f);){if(0===s)break e;s--,l+=n[o++]<<f,f+=8}l>>>=b,f-=b,r.back+=b}if(l>>>=g,f-=g,r.back+=g,r.length=w,0===v){r.mode=Qi;break}if(32&v){r.back=-1,r.mode=Hi;break}if(64&v){e.msg="invalid literal/length code",r.mode=no;break}r.extra=15&v,r.mode=Vi;case Vi:if(r.extra){for(x=r.extra;f<x;){if(0===s)break e;s--,l+=n[o++]<<f,f+=8}r.length+=l&(1<<r.extra)-1,l>>>=r.extra,f-=r.extra,r.back+=r.extra}r.was=r.length,r.mode=Gi;case Gi:for(;v=(R=r.distcode[l&(1<<r.distbits)-1])>>>16&255,w=65535&R,!((g=R>>>24)<=f);){if(0===s)break e;s--,l+=n[o++]<<f,f+=8}if(0==(240&v)){for(b=g,y=v,m=w;v=(R=r.distcode[m+((l&(1<<b+y)-1)>>b)])>>>16&255,w=65535&R,!(b+(g=R>>>24)<=f);){if(0===s)break e;s--,l+=n[o++]<<f,f+=8}l>>>=b,f-=b,r.back+=b}if(l>>>=g,f-=g,r.back+=g,64&v){e.msg="invalid distance code",r.mode=no;break}r.offset=w,r.extra=15&v,r.mode=$i;case $i:if(r.extra){for(x=r.extra;f<x;){if(0===s)break e;s--,l+=n[o++]<<f,f+=8}r.offset+=l&(1<<r.extra)-1,l>>>=r.extra,f-=r.extra,r.back+=r.extra}if(r.offset>r.dmax){e.msg="invalid distance too far back",r.mode=no;break}r.mode=Ji;case Ji:if(0===h)break e;if(d=u-h,r.offset>d){if((d=r.offset-d)>r.whave&&r.sane){e.msg="invalid distance too far back",r.mode=no;break}d>r.wnext?(d-=r.wnext,p=r.wsize-d):p=r.wnext-d,d>r.length&&(d=r.length),_=r.window}else _=i,p=a-r.offset,d=r.length;d>h&&(d=h),h-=d,r.length-=d;do{i[a++]=_[p++]}while(--d);0===r.length&&(r.mode=qi);break;case Qi:if(0===h)break e;i[a++]=r.length,h--,r.mode=qi;break;case eo:if(r.wrap){for(;f<32;){if(0===s)break e;s--,l|=n[o++]<<f,f+=8}if(u-=h,e.total_out+=u,r.total+=u,u&&(e.adler=r.check=r.flags?$r(r.check,i,u,a-u):Vr(r.check,i,u,a-u)),u=h,(r.flags?l:ho(l))!==r.check){e.msg="incorrect data check",r.mode=no;break}l=0,f=0}r.mode=to;case to:if(r.wrap&&r.flags){for(;f<32;){if(0===s)break e;s--,l+=n[o++]<<f,f+=8}if(l!==(4294967295&r.total)){e.msg="incorrect length check",r.mode=no;break}l=0,f=0}r.mode=ro;case ro:E=mi;break e;case no:E=Si;break e;case io:return xi;case oo:default:return Ei}return e.next_out=a,e.avail_out=h,e.next_in=o,e.avail_in=s,r.hold=l,r.bits=f,(r.wsize||u!==e.avail_out&&r.mode<no&&(r.mode<eo||t!==vi))&&function(e,t,r,n){var i,o=e.state;null===o.window&&(o.wsize=1<<o.wbits,o.wnext=0,o.whave=0,o.window=new Wt(o.wsize)),n>=o.wsize?(jt(o.window,t,r-o.wsize,o.wsize,0),o.wnext=0,o.whave=o.wsize):((i=o.wsize-o.wnext)>n&&(i=n),jt(o.window,t,r-n,i,o.wnext),(n-=i)?(jt(o.window,t,r-n,n,0),o.wnext=n,o.whave=o.wsize):(o.wnext+=i,o.wnext===o.wsize&&(o.wnext=0),o.whave<o.wsize&&(o.whave+=i)))}(e,e.output,e.next_out,u-e.avail_out),c-=e.avail_in,u-=e.avail_out,e.total_in+=c,e.total_out+=u,r.total+=u,r.wrap&&u&&(e.adler=r.check=r.flags?$r(r.check,i,u,e.next_out-u):Vr(r.check,i,u,e.next_out-u)),e.data_type=r.bits+(r.last?64:0)+(r.mode===Hi?128:0)+(r.mode===Xi||r.mode===Zi?256:0),(0===c&&0===u||t===vi)&&E===yi&&(E=Ri),E}var wo,bo=1,yo=7;function mo(e){if(e<bo||e>yo)throw new TypeError("Bad argument");this.mode=e,this.init_done=!1,this.write_in_progress=!1,this.pending_close=!1,this.windowBits=0,this.level=0,this.memLevel=0,this.strategy=0,this.dictionary=null}function ko(e,t){for(var r=0;r<e.length;r++)this[t+r]=e[r]}mo.prototype.init=function(e,t,r,n,i){var o;switch(this.windowBits=e,this.level=t,this.memLevel=r,this.strategy=n,3!==this.mode&&4!==this.mode||(this.windowBits+=16),this.mode===yo&&(this.windowBits+=32),5!==this.mode&&6!==this.mode||(this.windowBits=-this.windowBits),this.strm=new Zt,this.mode){case bo:case 3:case 5:o=function(e,t,r,n,i,o){if(!e)return sn;var a=1;if(t===fn&&(t=6),n<0?(a=0,n=-n):n>15&&(a=2,n-=16),i<1||i>vn||r!==gn||n<8||n>15||t<0||t>9||o<0||o>pn)return Hn(e,sn);8===n&&(n=9);var s=new $n;return e.state=s,s.strm=e,s.wrap=a,s.gzhead=null,s.w_bits=n,s.w_size=1<<s.w_bits,s.w_mask=s.w_size-1,s.hash_bits=i+7,s.hash_size=1<<s.hash_bits,s.hash_mask=s.hash_size-1,s.hash_shift=~~((s.hash_bits+En-1)/En),s.window=new Wt(2*s.w_size),s.head=new Yt(s.hash_size),s.prev=new Yt(s.w_size),s.lit_bufsize=1<<i+6,s.pending_buf_size=4*s.lit_bufsize,s.pending_buf=new Wt(s.pending_buf_size),s.d_buf=1*s.lit_bufsize,s.l_buf=3*s.lit_bufsize,s.level=t,s.strategy=o,s.method=r,Jn(e)}(this.strm,this.level,8,this.windowBits,this.memLevel,this.strategy);break;case 2:case 4:case 6:case yo:o=co(this.strm,this.windowBits);break;default:throw new Error("Unknown mode "+this.mode)}0===o?(this.write_in_progress=!1,this.init_done=!0):this._error(o)},mo.prototype.params=function(){throw new Error("deflateParams Not supported")},mo.prototype._writeCheck=function(){if(!this.init_done)throw new Error("write before init");if(0===this.mode)throw new Error("already finalized");if(this.write_in_progress)throw new Error("write already in progress");if(this.pending_close)throw new Error("close is pending")},mo.prototype.write=function(e,t,r,n,i,o,a){this._writeCheck(),this.write_in_progress=!0;var s=this;return de(function(){s.write_in_progress=!1;var h=s._write(e,t,r,n,i,o,a);s.callback(h[0],h[1]),s.pending_close&&s.close()}),this},mo.prototype.writeSync=function(e,t,r,n,i,o,a){return this._writeCheck(),this._write(e,t,r,n,i,o,a)},mo.prototype._write=function(e,t,r,n,i,o,a){if(this.write_in_progress=!0,0!==e&&1!==e&&2!==e&&3!==e&&4!==e&&5!==e)throw new Error("Invalid flush value");null==t&&(t=new p(0),n=0,r=0),i._set?i.set=i._set:i.set=ko;var s,h=this.strm;switch(h.avail_in=n,h.input=t,h.next_in=r,h.avail_out=a,h.output=i,h.next_out=o,this.mode){case bo:case 3:case 5:s=Qn(h,e);break;case yo:case 2:case 4:case 6:s=vo(h,e);break;default:throw new Error("Unknown mode "+this.mode)}return 1!==s&&0!==s&&this._error(s),this.write_in_progress=!1,[h.avail_in,h.avail_out]},mo.prototype.close=function(){this.write_in_progress?this.pending_close=!0:(this.pending_close=!1,this.mode===bo||3===this.mode||5===this.mode?function(e){var t;e&&e.state&&((t=e.state.status)!==An&&t!==Bn&&t!==zn&&t!==Ln&&t!==Tn&&t!==Mn&&t!==Cn?Hn(e,sn):(e.state=null,t===Mn&&Hn(e,hn)))}(this.strm):function(e){if(!e||!e.state)return Ei;var t=e.state;t.window&&(t.window=null),e.state=null}(this.strm),this.mode=0)},mo.prototype.reset=function(){switch(this.mode){case bo:case 5:wo=Jn(this.strm);break;case 2:case 6:wo=fo(this.strm)}0!==wo&&this._error(wo)},mo.prototype._error=function(e){this.onerror(Nt[e]+": "+this.strm.msg,e),this.write_in_progress=!1,this.pending_close&&this.close()};var Eo=Object.freeze({NONE:0,DEFLATE:bo,INFLATE:2,GZIP:3,GUNZIP:4,DEFLATERAW:5,INFLATERAW:6,UNZIP:yo,Z_NO_FLUSH:0,Z_PARTIAL_FLUSH:1,Z_SYNC_FLUSH:2,Z_FULL_FLUSH:3,Z_FINISH:4,Z_BLOCK:5,Z_TREES:6,Z_OK:0,Z_STREAM_END:1,Z_NEED_DICT:2,Z_ERRNO:-1,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_BUF_ERROR:-5,Z_NO_COMPRESSION:0,Z_BEST_SPEED:1,Z_BEST_COMPRESSION:9,Z_DEFAULT_COMPRESSION:-1,Z_FILTERED:1,Z_HUFFMAN_ONLY:2,Z_RLE:3,Z_FIXED:4,Z_DEFAULT_STRATEGY:0,Z_BINARY:0,Z_TEXT:1,Z_UNKNOWN:2,Z_DEFLATED:8,Zlib:mo});var So={};Object.keys(Eo).forEach(function(e){So[e]=Eo[e]}),So.Z_MIN_WINDOWBITS=8,So.Z_MAX_WINDOWBITS=15,So.Z_DEFAULT_WINDOWBITS=15,So.Z_MIN_CHUNK=64,So.Z_MAX_CHUNK=1/0,So.Z_DEFAULT_CHUNK=16384,So.Z_MIN_MEMLEVEL=1,So.Z_MAX_MEMLEVEL=9,So.Z_DEFAULT_MEMLEVEL=8,So.Z_MIN_LEVEL=-1,So.Z_MAX_LEVEL=9,So.Z_DEFAULT_LEVEL=So.Z_DEFAULT_COMPRESSION;var xo={Z_OK:So.Z_OK,Z_STREAM_END:So.Z_STREAM_END,Z_NEED_DICT:So.Z_NEED_DICT,Z_ERRNO:So.Z_ERRNO,Z_STREAM_ERROR:So.Z_STREAM_ERROR,Z_DATA_ERROR:So.Z_DATA_ERROR,Z_MEM_ERROR:So.Z_MEM_ERROR,Z_BUF_ERROR:So.Z_BUF_ERROR,Z_VERSION_ERROR:So.Z_VERSION_ERROR};function Ro(e,t,r){var n=[],i=0;function o(){for(var t;null!==(t=e.read());)n.push(t),i+=t.length;e.once("readable",o)}function a(){var t=p.concat(n,i);n=[],r(null,t),e.close()}e.on("error",function(t){e.removeListener("end",a),e.removeListener("readable",o),r(t)}),e.on("end",a),e.end(t),o()}function Ao(e,t){if("string"==typeof t&&(t=new p(t)),!$(t))throw new TypeError("Not a string or buffer");var r=So.Z_FINISH;return e._processChunk(t,r)}function Bo(e){if(!(this instanceof Bo))return new Bo(e);Io.call(this,e,So.DEFLATE)}function zo(e){if(!(this instanceof zo))return new zo(e);Io.call(this,e,So.INFLATE)}function Lo(e){if(!(this instanceof Lo))return new Lo(e);Io.call(this,e,So.GZIP)}function To(e){if(!(this instanceof To))return new To(e);Io.call(this,e,So.GUNZIP)}function Mo(e){if(!(this instanceof Mo))return new Mo(e);Io.call(this,e,So.DEFLATERAW)}function Co(e){if(!(this instanceof Co))return new Co(e);Io.call(this,e,So.INFLATERAW)}function Do(e){if(!(this instanceof Do))return new Do(e);Io.call(this,e,So.UNZIP)}function Io(e,t){if(this._opts=e=e||{},this._chunkSize=e.chunkSize||So.Z_DEFAULT_CHUNK,Ot.call(this,e),e.flush&&e.flush!==So.Z_NO_FLUSH&&e.flush!==So.Z_PARTIAL_FLUSH&&e.flush!==So.Z_SYNC_FLUSH&&e.flush!==So.Z_FULL_FLUSH&&e.flush!==So.Z_FINISH&&e.flush!==So.Z_BLOCK)throw new Error("Invalid flush flag: "+e.flush);if(this._flushFlag=e.flush||So.Z_NO_FLUSH,e.chunkSize&&(e.chunkSize<So.Z_MIN_CHUNK||e.chunkSize>So.Z_MAX_CHUNK))throw new Error("Invalid chunk size: "+e.chunkSize);if(e.windowBits&&(e.windowBits<So.Z_MIN_WINDOWBITS||e.windowBits>So.Z_MAX_WINDOWBITS))throw new Error("Invalid windowBits: "+e.windowBits);if(e.level&&(e.level<So.Z_MIN_LEVEL||e.level>So.Z_MAX_LEVEL))throw new Error("Invalid compression level: "+e.level);if(e.memLevel&&(e.memLevel<So.Z_MIN_MEMLEVEL||e.memLevel>So.Z_MAX_MEMLEVEL))throw new Error("Invalid memLevel: "+e.memLevel);if(e.strategy&&e.strategy!=So.Z_FILTERED&&e.strategy!=So.Z_HUFFMAN_ONLY&&e.strategy!=So.Z_RLE&&e.strategy!=So.Z_FIXED&&e.strategy!=So.Z_DEFAULT_STRATEGY)throw new Error("Invalid strategy: "+e.strategy);if(e.dictionary&&!$(e.dictionary))throw new Error("Invalid dictionary: it should be a Buffer instance");this._binding=new So.Zlib(t);var r=this;this._hadError=!1,this._binding.onerror=function(e,t){r._binding=null,r._hadError=!0;var n=new Error(e);n.errno=t,n.code=So.codes[t],r.emit("error",n)};var n=So.Z_DEFAULT_COMPRESSION;"number"==typeof e.level&&(n=e.level);var i=So.Z_DEFAULT_STRATEGY;"number"==typeof e.strategy&&(i=e.strategy),this._binding.init(e.windowBits||So.Z_DEFAULT_WINDOWBITS,n,e.memLevel||So.Z_DEFAULT_MEMLEVEL,i,e.dictionary),this._buffer=new p(this._chunkSize),this._offset=0,this._closed=!1,this._level=n,this._strategy=i,this.once("end",this.close)}Object.keys(xo).forEach(function(e){xo[xo[e]]=e}),Be(Io,Ot),Io.prototype.params=function(e,t,r){if(e<So.Z_MIN_LEVEL||e>So.Z_MAX_LEVEL)throw new RangeError("Invalid compression level: "+e);if(t!=So.Z_FILTERED&&t!=So.Z_HUFFMAN_ONLY&&t!=So.Z_RLE&&t!=So.Z_FIXED&&t!=So.Z_DEFAULT_STRATEGY)throw new TypeError("Invalid strategy: "+t);if(this._level!==e||this._strategy!==t){var n=this;this.flush(So.Z_SYNC_FLUSH,function(){n._binding.params(e,t),n._hadError||(n._level=e,n._strategy=t,r&&r())})}else de(r)},Io.prototype.reset=function(){return this._binding.reset()},Io.prototype._flush=function(e){this._transform(new p(0),"",e)},Io.prototype.flush=function(e,t){var r=this._writableState;if(("function"==typeof e||void 0===e&&!t)&&(t=e,e=So.Z_FULL_FLUSH),r.ended)t&&de(t);else if(r.ending)t&&this.once("end",t);else if(r.needDrain){var n=this;this.once("drain",function(){n.flush(t)})}else this._flushFlag=e,this.write(new p(0),"",t)},Io.prototype.close=function(e){if(e&&de(e),!this._closed){this._closed=!0,this._binding.close();var t=this;de(function(){t.emit("close")})}},Io.prototype._transform=function(e,t,r){var n,i=this._writableState,o=(i.ending||i.ended)&&(!e||i.length===e.length);if(null===!e&&!$(e))return r(new Error("invalid input"));o?n=So.Z_FINISH:(n=this._flushFlag,e.length>=i.length&&(this._flushFlag=this._opts.flush||So.Z_NO_FLUSH)),this._processChunk(e,n,r)},Io.prototype._processChunk=function(e,t,r){var n=e&&e.length,i=this._chunkSize-this._offset,o=0,a=this,s="function"==typeof r;if(!s){var h,l=[],f=0;this.on("error",function(e){h=e});do{var c=this._binding.writeSync(t,e,o,n,this._buffer,this._offset,i)}while(!this._hadError&&_(c[0],c[1]));if(this._hadError)throw h;var u=p.concat(l,f);return this.close(),u}var d=this._binding.write(t,e,o,n,this._buffer,this._offset,i);function _(h,c){if(!a._hadError){var u=i-c;if(function(e,t){if(!e)throw new Error(t)}(u>=0,"have should not go down"),u>0){var d=a._buffer.slice(a._offset,a._offset+u);a._offset+=u,s?a.push(d):(l.push(d),f+=d.length)}if((0===c||a._offset>=a._chunkSize)&&(i=a._chunkSize,a._offset=0,a._buffer=new p(a._chunkSize)),0===c){if(o+=n-h,n=h,!s)return!0;var g=a._binding.write(t,e,o,n,a._buffer,a._offset,a._chunkSize);return g.callback=_,void(g.buffer=e)}if(!s)return!1;r()}}d.buffer=e,d.callback=_},Be(Bo,Io),Be(zo,Io),Be(Lo,Io),Be(To,Io),Be(Mo,Io),Be(Co,Io),Be(Do,Io);var Po={codes:xo,createDeflate:function(e){return new Bo(e)},createInflate:function(e){return new zo(e)},createDeflateRaw:function(e){return new Mo(e)},createInflateRaw:function(e){return new Co(e)},createGzip:function(e){return new Lo(e)},createGunzip:function(e){return new To(e)},createUnzip:function(e){return new Do(e)},deflate:function(e,t,r){return"function"==typeof t&&(r=t,t={}),Ro(new Bo(t),e,r)},deflateSync:function(e,t){return Ao(new Bo(t),e)},gzip:function(e,t,r){return"function"==typeof t&&(r=t,t={}),Ro(new Lo(t),e,r)},gzipSync:function(e,t){return Ao(new Lo(t),e)},deflateRaw:function(e,t,r){return"function"==typeof t&&(r=t,t={}),Ro(new Mo(t),e,r)},deflateRawSync:function(e,t){return Ao(new Mo(t),e)},unzip:function(e,t,r){return"function"==typeof t&&(r=t,t={}),Ro(new Do(t),e,r)},unzipSync:function(e,t){return Ao(new Do(t),e)},inflate:function(e,t,r){return"function"==typeof t&&(r=t,t={}),Ro(new zo(t),e,r)},inflateSync:function(e,t){return Ao(new zo(t),e)},gunzip:function(e,t,r){return"function"==typeof t&&(r=t,t={}),Ro(new To(t),e,r)},gunzipSync:function(e,t){return Ao(new To(t),e)},inflateRaw:function(e,t,r){return"function"==typeof t&&(r=t,t={}),Ro(new Co(t),e,r)},inflateRawSync:function(e,t){return Ao(new Co(t),e)},Deflate:Bo,Inflate:zo,Gzip:Lo,Gunzip:To,DeflateRaw:Mo,InflateRaw:Co,Unzip:Do,Zlib:Io};/* harmony default export */ __webpack_exports__["a"] = (class{constructor(e,t,r){this.SDKAPPID=e,this.EXPIRETIME=r,this.PRIVATEKEY=t}genTestUserSig(e){return this._isNumber(this.SDKAPPID)?this._isString(this.PRIVATEKEY)?this._isString(e)?this._isNumber(this.EXPIRETIME)?(console.log("SDKAppID="+this.SDKAPPID+" key="+this.PRIVATEKEY+" userID="+e+" expire="+this.EXPIRETIME),this.genSigWithUserbuf(e,this.EXPIRETIME,null)):(console.error("expireTime must be a number"),""):(console.error("userID must be a string"),""):(console.error("privateKey must be a string"),""):(console.error("SDKAppID must be a number"),"")}newBuffer(e,t){return p.from?p.from(e,t):new p(e,t)}unescape(e){return e.replace(/_/g,"=").replace(/\-/g,"/").replace(/\*/g,"+")}escape(e){return e.replace(/\+/g,"*").replace(/\//g,"-").replace(/=/g,"_")}encode(e){return this.escape(this.newBuffer(e).toString("base64"))}decode(e){return this.newBuffer(this.unescape(e),"base64")}base64encode(e){return this.newBuffer(e).toString("base64")}base64decode(e){return this.newBuffer(e,"base64").toString()}_hmacsha256(e,t,r,n){let i="TLS.identifier:"+e+"\n";i+="TLS.sdkappid:"+this.SDKAPPID+"\n",i+="TLS.time:"+t+"\n",i+="TLS.expire:"+r+"\n",null!=n&&(i+="TLS.userbuf:"+n+"\n");let o=te.HmacSHA256(i,this.PRIVATEKEY);return te.enc.Base64.stringify(o)}_utc(){return Math.round(Date.now()/1e3)}_isNumber(e){return null!==e&&("number"==typeof e&&!isNaN(e-0)||"object"==typeof e&&e.constructor===Number)}_isString(e){return"string"==typeof e}genSigWithUserbuf(e,t,r){let n=this._utc(),i={"TLS.ver":"2.0","TLS.identifier":e,"TLS.sdkappid":this.SDKAPPID,"TLS.time":n,"TLS.expire":t},o="";if(null!=r){let a=this.base64encode(r);i["TLS.userbuf"]=a,o=this._hmacsha256(e,n,t,a)}else o=this._hmacsha256(e,n,t,null);i["TLS.sig"]=o;let a=JSON.stringify(i),s=Po.deflateSync(this.newBuffer(a)).toString("base64"),h=this.escape(s);return console.log("ret="+h),h}validate(e){let t=this.decode(e),r=Po.inflateSync(t);console.log("validate ret="+r)}});

/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__("DuR2")))

/***/ }),

/***/ "qio6":
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__("evD5");
var anObject = __webpack_require__("77Pl");
var getKeys = __webpack_require__("lktj");

module.exports = __webpack_require__("+E39") ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = getKeys(Properties);
  var length = keys.length;
  var i = 0;
  var P;
  while (length > i) dP.f(O, P = keys[i++], Properties[P]);
  return O;
};


/***/ }),

/***/ "qyJz":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ctx = __webpack_require__("+ZMJ");
var $export = __webpack_require__("kM2E");
var toObject = __webpack_require__("sB3e");
var call = __webpack_require__("msXi");
var isArrayIter = __webpack_require__("Mhyx");
var toLength = __webpack_require__("QRG4");
var createProperty = __webpack_require__("fBQ2");
var getIterFn = __webpack_require__("3fs2");

$export($export.S + $export.F * !__webpack_require__("dY0y")(function (iter) { Array.from(iter); }), 'Array', {
  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
  from: function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
    var O = toObject(arrayLike);
    var C = typeof this == 'function' ? this : Array;
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var index = 0;
    var iterFn = getIterFn(O);
    var length, result, step, iterator;
    if (mapping) mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
    // if object isn't iterable or it's array with default iterator - use simple case
    if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {
      for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
      }
    } else {
      length = toLength(O.length);
      for (result = new C(length); length > index; index++) {
        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
      }
    }
    result.length = index;
    return result;
  }
});


/***/ }),

/***/ "rjj0":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["default"] = addStylesClient;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__listToStyles__ = __webpack_require__("tTVk");
/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
  Modified by Evan You @yyx990803
*/



var hasDocument = typeof document !== 'undefined'

if (typeof DEBUG !== 'undefined' && DEBUG) {
  if (!hasDocument) {
    throw new Error(
    'vue-style-loader cannot be used in a non-browser environment. ' +
    "Use { target: 'node' } in your Webpack config to indicate a server-rendering environment."
  ) }
}

/*
type StyleObject = {
  id: number;
  parts: Array<StyleObjectPart>
}

type StyleObjectPart = {
  css: string;
  media: string;
  sourceMap: ?string
}
*/

var stylesInDom = {/*
  [id: number]: {
    id: number,
    refs: number,
    parts: Array<(obj?: StyleObjectPart) => void>
  }
*/}

var head = hasDocument && (document.head || document.getElementsByTagName('head')[0])
var singletonElement = null
var singletonCounter = 0
var isProduction = false
var noop = function () {}
var options = null
var ssrIdKey = 'data-vue-ssr-id'

// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
// tags it will allow on a page
var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\b/.test(navigator.userAgent.toLowerCase())

function addStylesClient (parentId, list, _isProduction, _options) {
  isProduction = _isProduction

  options = _options || {}

  var styles = Object(__WEBPACK_IMPORTED_MODULE_0__listToStyles__["a" /* default */])(parentId, list)
  addStylesToDom(styles)

  return function update (newList) {
    var mayRemove = []
    for (var i = 0; i < styles.length; i++) {
      var item = styles[i]
      var domStyle = stylesInDom[item.id]
      domStyle.refs--
      mayRemove.push(domStyle)
    }
    if (newList) {
      styles = Object(__WEBPACK_IMPORTED_MODULE_0__listToStyles__["a" /* default */])(parentId, newList)
      addStylesToDom(styles)
    } else {
      styles = []
    }
    for (var i = 0; i < mayRemove.length; i++) {
      var domStyle = mayRemove[i]
      if (domStyle.refs === 0) {
        for (var j = 0; j < domStyle.parts.length; j++) {
          domStyle.parts[j]()
        }
        delete stylesInDom[domStyle.id]
      }
    }
  }
}

function addStylesToDom (styles /* Array<StyleObject> */) {
  for (var i = 0; i < styles.length; i++) {
    var item = styles[i]
    var domStyle = stylesInDom[item.id]
    if (domStyle) {
      domStyle.refs++
      for (var j = 0; j < domStyle.parts.length; j++) {
        domStyle.parts[j](item.parts[j])
      }
      for (; j < item.parts.length; j++) {
        domStyle.parts.push(addStyle(item.parts[j]))
      }
      if (domStyle.parts.length > item.parts.length) {
        domStyle.parts.length = item.parts.length
      }
    } else {
      var parts = []
      for (var j = 0; j < item.parts.length; j++) {
        parts.push(addStyle(item.parts[j]))
      }
      stylesInDom[item.id] = { id: item.id, refs: 1, parts: parts }
    }
  }
}

function createStyleElement () {
  var styleElement = document.createElement('style')
  styleElement.type = 'text/css'
  head.appendChild(styleElement)
  return styleElement
}

function addStyle (obj /* StyleObjectPart */) {
  var update, remove
  var styleElement = document.querySelector('style[' + ssrIdKey + '~="' + obj.id + '"]')

  if (styleElement) {
    if (isProduction) {
      // has SSR styles and in production mode.
      // simply do nothing.
      return noop
    } else {
      // has SSR styles but in dev mode.
      // for some reason Chrome can't handle source map in server-rendered
      // style tags - source maps in <style> only works if the style tag is
      // created and inserted dynamically. So we remove the server rendered
      // styles and inject new ones.
      styleElement.parentNode.removeChild(styleElement)
    }
  }

  if (isOldIE) {
    // use singleton mode for IE9.
    var styleIndex = singletonCounter++
    styleElement = singletonElement || (singletonElement = createStyleElement())
    update = applyToSingletonTag.bind(null, styleElement, styleIndex, false)
    remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true)
  } else {
    // use multi-style-tag mode in all other cases
    styleElement = createStyleElement()
    update = applyToTag.bind(null, styleElement)
    remove = function () {
      styleElement.parentNode.removeChild(styleElement)
    }
  }

  update(obj)

  return function updateStyle (newObj /* StyleObjectPart */) {
    if (newObj) {
      if (newObj.css === obj.css &&
          newObj.media === obj.media &&
          newObj.sourceMap === obj.sourceMap) {
        return
      }
      update(obj = newObj)
    } else {
      remove()
    }
  }
}

var replaceText = (function () {
  var textStore = []

  return function (index, replacement) {
    textStore[index] = replacement
    return textStore.filter(Boolean).join('\n')
  }
})()

function applyToSingletonTag (styleElement, index, remove, obj) {
  var css = remove ? '' : obj.css

  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = replaceText(index, css)
  } else {
    var cssNode = document.createTextNode(css)
    var childNodes = styleElement.childNodes
    if (childNodes[index]) styleElement.removeChild(childNodes[index])
    if (childNodes.length) {
      styleElement.insertBefore(cssNode, childNodes[index])
    } else {
      styleElement.appendChild(cssNode)
    }
  }
}

function applyToTag (styleElement, obj) {
  var css = obj.css
  var media = obj.media
  var sourceMap = obj.sourceMap

  if (media) {
    styleElement.setAttribute('media', media)
  }
  if (options.ssrId) {
    styleElement.setAttribute(ssrIdKey, obj.id)
  }

  if (sourceMap) {
    // https://developer.chrome.com/devtools/docs/javascript-debugging
    // this makes source maps inside style tags work properly in Chrome
    css += '\n/*# sourceURL=' + sourceMap.sources[0] + ' */'
    // http://stackoverflow.com/a/26603875
    css += '\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + ' */'
  }

  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = css
  } else {
    while (styleElement.firstChild) {
      styleElement.removeChild(styleElement.firstChild)
    }
    styleElement.appendChild(document.createTextNode(css))
  }
}


/***/ }),

/***/ "sB3e":
/***/ (function(module, exports, __webpack_require__) {

// 7.1.13 ToObject(argument)
var defined = __webpack_require__("52gC");
module.exports = function (it) {
  return Object(defined(it));
};


/***/ }),

/***/ "tTVk":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = listToStyles;
/**
 * Translates the list format produced by css-loader into something
 * easier to manipulate.
 */
function listToStyles (parentId, list) {
  var styles = []
  var newStyles = {}
  for (var i = 0; i < list.length; i++) {
    var item = list[i]
    var id = item[0]
    var css = item[1]
    var media = item[2]
    var sourceMap = item[3]
    var part = {
      id: parentId + ':' + i,
      css: css,
      media: media,
      sourceMap: sourceMap
    }
    if (!newStyles[id]) {
      styles.push(newStyles[id] = { id: id, parts: [part] })
    } else {
      newStyles[id].parts.push(part)
    }
  }
  return styles
}


/***/ }),

/***/ "vFc/":
/***/ (function(module, exports, __webpack_require__) {

// false -> Array#indexOf
// true  -> Array#includes
var toIObject = __webpack_require__("TcQ7");
var toLength = __webpack_require__("QRG4");
var toAbsoluteIndex = __webpack_require__("fkB2");
module.exports = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
      if (O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};


/***/ }),

/***/ "vIB/":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var LIBRARY = __webpack_require__("O4g8");
var $export = __webpack_require__("kM2E");
var redefine = __webpack_require__("880/");
var hide = __webpack_require__("hJx8");
var Iterators = __webpack_require__("/bQp");
var $iterCreate = __webpack_require__("94VQ");
var setToStringTag = __webpack_require__("e6n0");
var getPrototypeOf = __webpack_require__("PzxK");
var ITERATOR = __webpack_require__("dSzd")('iterator');
var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function () { return this; };

module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  $iterCreate(Constructor, NAME, next);
  var getMethod = function (kind) {
    if (!BUGGY && kind in proto) return proto[kind];
    switch (kind) {
      case KEYS: return function keys() { return new Constructor(this, kind); };
      case VALUES: return function values() { return new Constructor(this, kind); };
    } return function entries() { return new Constructor(this, kind); };
  };
  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = $native || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype;
  // Fix native
  if ($anyNative) {
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != 'function') hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEF_VALUES && $native && $native.name !== VALUES) {
    VALUES_BUG = true;
    $default = function values() { return $native.call(this); };
  }
  // Define iterator
  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG] = returnThis;
  if (DEFAULT) {
    methods = {
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries
    };
    if (FORCED) for (key in methods) {
      if (!(key in proto)) redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};


/***/ }),

/***/ "woOf":
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__("V3tA"), __esModule: true };

/***/ }),

/***/ "xnc9":
/***/ (function(module, exports) {

// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');


/***/ }),

/***/ "yGwj":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
// eslint-disable-next-line func-names
module.exports = function (useSourceMap) {
  var list = []; // return the list of modules as css string

  list.toString = function toString() {
    return this.map(function (item) {
      var content = cssWithMappingToString(item, useSourceMap);

      if (item[2]) {
        return "@media ".concat(item[2], "{").concat(content, "}");
      }

      return content;
    }).join('');
  }; // import a list of modules into the list
  // eslint-disable-next-line func-names


  list.i = function (modules, mediaQuery) {
    if (typeof modules === 'string') {
      // eslint-disable-next-line no-param-reassign
      modules = [[null, modules, '']];
    }

    var alreadyImportedModules = {};

    for (var i = 0; i < this.length; i++) {
      // eslint-disable-next-line prefer-destructuring
      var id = this[i][0];

      if (id != null) {
        alreadyImportedModules[id] = true;
      }
    }

    for (var _i = 0; _i < modules.length; _i++) {
      var item = modules[_i]; // skip already imported module
      // this implementation is not 100% perfect for weird media query combinations
      // when a module is imported multiple times with different media queries.
      // I hope this will never occur (Hey this way we have smaller bundles)

      if (item[0] == null || !alreadyImportedModules[item[0]]) {
        if (mediaQuery && !item[2]) {
          item[2] = mediaQuery;
        } else if (mediaQuery) {
          item[2] = "(".concat(item[2], ") and (").concat(mediaQuery, ")");
        }

        list.push(item);
      }
    }
  };

  return list;
};

function cssWithMappingToString(item, useSourceMap) {
  var content = item[1] || ''; // eslint-disable-next-line prefer-destructuring

  var cssMapping = item[3];

  if (!cssMapping) {
    return content;
  }

  if (useSourceMap && typeof btoa === 'function') {
    var sourceMapping = toComment(cssMapping);
    var sourceURLs = cssMapping.sources.map(function (source) {
      return "/*# sourceURL=".concat(cssMapping.sourceRoot).concat(source, " */");
    });
    return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
  }

  return [content].join('\n');
} // Adapted from convert-source-map (MIT)


function toComment(sourceMap) {
  // eslint-disable-next-line no-undef
  var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
  var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
  return "/*# ".concat(data, " */");
}

/***/ }),

/***/ "ybqe":
/***/ (function(module, exports) {

/* globals __VUE_SSR_CONTEXT__ */

// this module is a runtime utility for cleaner component module output and will
// be included in the final webpack user bundle

module.exports = function normalizeComponent (
  rawScriptExports,
  compiledTemplate,
  injectStyles,
  scopeId,
  moduleIdentifier /* server only */
) {
  var esModule
  var scriptExports = rawScriptExports = rawScriptExports || {}

  // ES6 modules interop
  var type = typeof rawScriptExports.default
  if (type === 'object' || type === 'function') {
    esModule = rawScriptExports
    scriptExports = rawScriptExports.default
  }

  // Vue.extend constructor export interop
  var options = typeof scriptExports === 'function'
    ? scriptExports.options
    : scriptExports

  // render functions
  if (compiledTemplate) {
    options.render = compiledTemplate.render
    options.staticRenderFns = compiledTemplate.staticRenderFns
  }

  // scopedId
  if (scopeId) {
    options._scopeId = scopeId
  }

  var hook
  if (moduleIdentifier) { // server build
    hook = function (context) {
      // 2.3 injection
      context =
        context || // cached call
        (this.$vnode && this.$vnode.ssrContext) || // stateful
        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional
      // 2.2 with runInNewContext: true
      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
        context = __VUE_SSR_CONTEXT__
      }
      // inject component styles
      if (injectStyles) {
        injectStyles.call(this, context)
      }
      // register component module identifier for async chunk inferrence
      if (context && context._registeredComponents) {
        context._registeredComponents.add(moduleIdentifier)
      }
    }
    // used by ssr in case component is cached and beforeCreate
    // never gets called
    options._ssrRegister = hook
  } else if (injectStyles) {
    hook = injectStyles
  }

  if (hook) {
    var functional = options.functional
    var existing = functional
      ? options.render
      : options.beforeCreate
    if (!functional) {
      // inject component registration as beforeCreate hook
      options.beforeCreate = existing
        ? [].concat(existing, hook)
        : [hook]
    } else {
      // register for functioal component in vue file
      options.render = function renderWithStyleInjection (h, context) {
        hook.call(context)
        return existing(h, context)
      }
    }
  }

  return {
    esModule: esModule,
    exports: scriptExports,
    options: options
  }
}


/***/ }),

/***/ "zQR9":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $at = __webpack_require__("h65t")(true);

// 21.1.3.27 String.prototype[@@iterator]()
__webpack_require__("vIB/")(String, 'String', function (iterated) {
  this._t = String(iterated); // target
  this._i = 0;                // next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var index = this._i;
  var point;
  if (index >= O.length) return { value: undefined, done: true };
  point = $at(O, index);
  this._i += point.length;
  return { value: point, done: false };
});


/***/ })

});